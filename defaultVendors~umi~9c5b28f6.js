(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[13],{"16Al":function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar ReactPropTypesSecret = __webpack_require__(\"WbBG\");\n\nfunction emptyFunction() {}\n\nfunction emptyFunctionWithReset() {}\n\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function () {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n\n    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');\n    err.name = 'Invariant Violation';\n    throw err;\n  }\n\n  ;\n  shim.isRequired = shim;\n\n  function getShim() {\n    return shim;\n  }\n\n  ; // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n\n  var ReactPropTypes = {\n    array: shim,\n    bigint: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n  ReactPropTypes.PropTypes = ReactPropTypes;\n  return ReactPropTypes;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanM/ZDdhMCJdLCJuYW1lcyI6WyJSZWFjdFByb3BUeXBlc1NlY3JldCIsInJlcXVpcmUiLCJlbXB0eUZ1bmN0aW9uIiwiZW1wdHlGdW5jdGlvbldpdGhSZXNldCIsInJlc2V0V2FybmluZ0NhY2hlIiwibW9kdWxlIiwiZXhwb3J0cyIsInNoaW0iLCJwcm9wcyIsInByb3BOYW1lIiwiY29tcG9uZW50TmFtZSIsImxvY2F0aW9uIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiZXJyIiwiRXJyb3IiLCJuYW1lIiwiaXNSZXF1aXJlZCIsImdldFNoaW0iLCJSZWFjdFByb3BUeXBlcyIsImFycmF5IiwiYmlnaW50IiwiYm9vbCIsImZ1bmMiLCJudW1iZXIiLCJvYmplY3QiLCJzdHJpbmciLCJzeW1ib2wiLCJhbnkiLCJhcnJheU9mIiwiZWxlbWVudCIsImVsZW1lbnRUeXBlIiwiaW5zdGFuY2VPZiIsIm5vZGUiLCJvYmplY3RPZiIsIm9uZU9mIiwib25lT2ZUeXBlIiwic2hhcGUiLCJleGFjdCIsImNoZWNrUHJvcFR5cGVzIiwiUHJvcFR5cGVzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFYTs7QUFFYixJQUFJQSxvQkFBb0IsR0FBR0MsbUJBQU8sQ0FBQyxNQUFELENBQWxDOztBQUVBLFNBQVNDLGFBQVQsR0FBeUIsQ0FBRTs7QUFDM0IsU0FBU0Msc0JBQVQsR0FBa0MsQ0FBRTs7QUFDcENBLHNCQUFzQixDQUFDQyxpQkFBdkIsR0FBMkNGLGFBQTNDOztBQUVBRyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBVztBQUMxQixXQUFTQyxJQUFULENBQWNDLEtBQWQsRUFBcUJDLFFBQXJCLEVBQStCQyxhQUEvQixFQUE4Q0MsUUFBOUMsRUFBd0RDLFlBQXhELEVBQXNFQyxNQUF0RSxFQUE4RTtBQUM1RSxRQUFJQSxNQUFNLEtBQUtiLG9CQUFmLEVBQXFDO0FBQ25DO0FBQ0E7QUFDRDs7QUFDRCxRQUFJYyxHQUFHLEdBQUcsSUFBSUMsS0FBSixDQUNSLHlGQUNBLCtDQURBLEdBRUEsZ0RBSFEsQ0FBVjtBQUtBRCxPQUFHLENBQUNFLElBQUosR0FBVyxxQkFBWDtBQUNBLFVBQU1GLEdBQU47QUFDRDs7QUFBQTtBQUNEUCxNQUFJLENBQUNVLFVBQUwsR0FBa0JWLElBQWxCOztBQUNBLFdBQVNXLE9BQVQsR0FBbUI7QUFDakIsV0FBT1gsSUFBUDtBQUNEOztBQUFBLEdBakJ5QixDQWtCMUI7QUFDQTs7QUFDQSxNQUFJWSxjQUFjLEdBQUc7QUFDbkJDLFNBQUssRUFBRWIsSUFEWTtBQUVuQmMsVUFBTSxFQUFFZCxJQUZXO0FBR25CZSxRQUFJLEVBQUVmLElBSGE7QUFJbkJnQixRQUFJLEVBQUVoQixJQUphO0FBS25CaUIsVUFBTSxFQUFFakIsSUFMVztBQU1uQmtCLFVBQU0sRUFBRWxCLElBTlc7QUFPbkJtQixVQUFNLEVBQUVuQixJQVBXO0FBUW5Cb0IsVUFBTSxFQUFFcEIsSUFSVztBQVVuQnFCLE9BQUcsRUFBRXJCLElBVmM7QUFXbkJzQixXQUFPLEVBQUVYLE9BWFU7QUFZbkJZLFdBQU8sRUFBRXZCLElBWlU7QUFhbkJ3QixlQUFXLEVBQUV4QixJQWJNO0FBY25CeUIsY0FBVSxFQUFFZCxPQWRPO0FBZW5CZSxRQUFJLEVBQUUxQixJQWZhO0FBZ0JuQjJCLFlBQVEsRUFBRWhCLE9BaEJTO0FBaUJuQmlCLFNBQUssRUFBRWpCLE9BakJZO0FBa0JuQmtCLGFBQVMsRUFBRWxCLE9BbEJRO0FBbUJuQm1CLFNBQUssRUFBRW5CLE9BbkJZO0FBb0JuQm9CLFNBQUssRUFBRXBCLE9BcEJZO0FBc0JuQnFCLGtCQUFjLEVBQUVwQyxzQkF0Qkc7QUF1Qm5CQyxxQkFBaUIsRUFBRUY7QUF2QkEsR0FBckI7QUEwQkFpQixnQkFBYyxDQUFDcUIsU0FBZixHQUEyQnJCLGNBQTNCO0FBRUEsU0FBT0EsY0FBUDtBQUNELENBakREIiwiZmlsZSI6IjE2QWwuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0KCkge31cbmVtcHR5RnVuY3Rpb25XaXRoUmVzZXQucmVzZXRXYXJuaW5nQ2FjaGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYmlnaW50OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGVsZW1lbnRUeXBlOiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW0sXG5cbiAgICBjaGVja1Byb3BUeXBlczogZW1wdHlGdW5jdGlvbldpdGhSZXNldCxcbiAgICByZXNldFdhcm5pbmdDYWNoZTogZW1wdHlGdW5jdGlvblxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16Al\n")},"17x9":function(module,exports,__webpack_require__){eval('/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__("16Al")();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz9kN2JjIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBSUEsS0FBSixFQUEyQyxxQ0FBM0MsTUFPTztBQUNMO0FBQ0E7QUFDQUMsUUFBTSxDQUFDQyxPQUFQLEdBQWlCQyxtQkFBTyxDQUFDLE1BQUQsQ0FBUCxFQUFqQjtBQUNEIiwiZmlsZSI6IjE3eDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17x9\n')},"33yf":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  } // if the path is allowed to go above the root, restore leading ..s\n\n\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n} // path.resolve([from ...], to)\n// posix version\n\n\nexports.resolve = function () {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries\n\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  } // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n  // Normalize the path\n\n\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n}; // path.normalize(path)\n// posix version\n\n\nexports.normalize = function (path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/'; // Normalize the path\n\n  path = normalizeArray(filter(path.split('/'), function (p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n}; // posix version\n\n\nexports.isAbsolute = function (path) {\n  return path.charAt(0) === '/';\n}; // posix version\n\n\nexports.join = function () {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function (p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n\n    return p;\n  }).join('/'));\n}; // path.relative(from, to)\n// posix version\n\n\nexports.relative = function (from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47\n  /*/*/\n  ;\n  var end = -1;\n  var matchedSlash = true;\n\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n\n    if (code === 47\n    /*/*/\n    ) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47\n    /*/*/\n    ) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n} // Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\n\n\nexports.basename = function (path, ext) {\n  var f = basename(path);\n\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n\n  var preDotState = 0;\n\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n\n    if (code === 47\n    /*/*/\n    ) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n\n        continue;\n      }\n\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n\n    if (code === 46\n    /*.*/\n    ) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n      } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n\n  return path.slice(startDot, end);\n};\n\nfunction filter(xs, f) {\n  if (xs.filter) return xs.filter(f);\n  var res = [];\n\n  for (var i = 0; i < xs.length; i++) {\n    if (f(xs[i], i, xs)) res.push(xs[i]);\n  }\n\n  return res;\n} // String.prototype.substr - negative index don't work in IE8\n\n\nvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n  return str.substr(start, len);\n} : function (str, start, len) {\n  if (start < 0) start = str.length + start;\n  return str.substr(start, len);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"Q2Ig\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzP2RmN2MiXSwibmFtZXMiOlsibm9ybWFsaXplQXJyYXkiLCJwYXJ0cyIsImFsbG93QWJvdmVSb290IiwidXAiLCJpIiwibGVuZ3RoIiwibGFzdCIsInNwbGljZSIsInVuc2hpZnQiLCJleHBvcnRzIiwicmVzb2x2ZSIsInJlc29sdmVkUGF0aCIsInJlc29sdmVkQWJzb2x1dGUiLCJhcmd1bWVudHMiLCJwYXRoIiwicHJvY2VzcyIsImN3ZCIsIlR5cGVFcnJvciIsImNoYXJBdCIsImZpbHRlciIsInNwbGl0IiwicCIsImpvaW4iLCJub3JtYWxpemUiLCJpc0Fic29sdXRlIiwidHJhaWxpbmdTbGFzaCIsInN1YnN0ciIsInBhdGhzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJpbmRleCIsInJlbGF0aXZlIiwiZnJvbSIsInRvIiwidHJpbSIsImFyciIsInN0YXJ0IiwiZW5kIiwiZnJvbVBhcnRzIiwidG9QYXJ0cyIsIk1hdGgiLCJtaW4iLCJzYW1lUGFydHNMZW5ndGgiLCJvdXRwdXRQYXJ0cyIsInB1c2giLCJjb25jYXQiLCJzZXAiLCJkZWxpbWl0ZXIiLCJkaXJuYW1lIiwiY29kZSIsImNoYXJDb2RlQXQiLCJoYXNSb290IiwibWF0Y2hlZFNsYXNoIiwiYmFzZW5hbWUiLCJleHQiLCJmIiwiZXh0bmFtZSIsInN0YXJ0RG90Iiwic3RhcnRQYXJ0IiwicHJlRG90U3RhdGUiLCJ4cyIsInJlcyIsInN0ciIsImxlbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLGNBQVQsQ0FBd0JDLEtBQXhCLEVBQStCQyxjQUEvQixFQUErQztBQUM3QztBQUNBLE1BQUlDLEVBQUUsR0FBRyxDQUFUOztBQUNBLE9BQUssSUFBSUMsQ0FBQyxHQUFHSCxLQUFLLENBQUNJLE1BQU4sR0FBZSxDQUE1QixFQUErQkQsQ0FBQyxJQUFJLENBQXBDLEVBQXVDQSxDQUFDLEVBQXhDLEVBQTRDO0FBQzFDLFFBQUlFLElBQUksR0FBR0wsS0FBSyxDQUFDRyxDQUFELENBQWhCOztBQUNBLFFBQUlFLElBQUksS0FBSyxHQUFiLEVBQWtCO0FBQ2hCTCxXQUFLLENBQUNNLE1BQU4sQ0FBYUgsQ0FBYixFQUFnQixDQUFoQjtBQUNELEtBRkQsTUFFTyxJQUFJRSxJQUFJLEtBQUssSUFBYixFQUFtQjtBQUN4QkwsV0FBSyxDQUFDTSxNQUFOLENBQWFILENBQWIsRUFBZ0IsQ0FBaEI7QUFDQUQsUUFBRTtBQUNILEtBSE0sTUFHQSxJQUFJQSxFQUFKLEVBQVE7QUFDYkYsV0FBSyxDQUFDTSxNQUFOLENBQWFILENBQWIsRUFBZ0IsQ0FBaEI7QUFDQUQsUUFBRTtBQUNIO0FBQ0YsR0FkNEMsQ0FnQjdDOzs7QUFDQSxNQUFJRCxjQUFKLEVBQW9CO0FBQ2xCLFdBQU9DLEVBQUUsRUFBVCxFQUFhQSxFQUFiLEVBQWlCO0FBQ2ZGLFdBQUssQ0FBQ08sT0FBTixDQUFjLElBQWQ7QUFDRDtBQUNGOztBQUVELFNBQU9QLEtBQVA7QUFDRCxDLENBRUQ7QUFDQTs7O0FBQ0FRLE9BQU8sQ0FBQ0MsT0FBUixHQUFrQixZQUFXO0FBQzNCLE1BQUlDLFlBQVksR0FBRyxFQUFuQjtBQUFBLE1BQ0lDLGdCQUFnQixHQUFHLEtBRHZCOztBQUdBLE9BQUssSUFBSVIsQ0FBQyxHQUFHUyxTQUFTLENBQUNSLE1BQVYsR0FBbUIsQ0FBaEMsRUFBbUNELENBQUMsSUFBSSxDQUFDLENBQU4sSUFBVyxDQUFDUSxnQkFBL0MsRUFBaUVSLENBQUMsRUFBbEUsRUFBc0U7QUFDcEUsUUFBSVUsSUFBSSxHQUFJVixDQUFDLElBQUksQ0FBTixHQUFXUyxTQUFTLENBQUNULENBQUQsQ0FBcEIsR0FBMEJXLE9BQU8sQ0FBQ0MsR0FBUixFQUFyQyxDQURvRSxDQUdwRTs7QUFDQSxRQUFJLE9BQU9GLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFDNUIsWUFBTSxJQUFJRyxTQUFKLENBQWMsMkNBQWQsQ0FBTjtBQUNELEtBRkQsTUFFTyxJQUFJLENBQUNILElBQUwsRUFBVztBQUNoQjtBQUNEOztBQUVESCxnQkFBWSxHQUFHRyxJQUFJLEdBQUcsR0FBUCxHQUFhSCxZQUE1QjtBQUNBQyxvQkFBZ0IsR0FBR0UsSUFBSSxDQUFDSSxNQUFMLENBQVksQ0FBWixNQUFtQixHQUF0QztBQUNELEdBaEIwQixDQWtCM0I7QUFDQTtBQUVBOzs7QUFDQVAsY0FBWSxHQUFHWCxjQUFjLENBQUNtQixNQUFNLENBQUNSLFlBQVksQ0FBQ1MsS0FBYixDQUFtQixHQUFuQixDQUFELEVBQTBCLFVBQVNDLENBQVQsRUFBWTtBQUN4RSxXQUFPLENBQUMsQ0FBQ0EsQ0FBVDtBQUNELEdBRm1DLENBQVAsRUFFekIsQ0FBQ1QsZ0JBRndCLENBQWQsQ0FFUVUsSUFGUixDQUVhLEdBRmIsQ0FBZjtBQUlBLFNBQVEsQ0FBQ1YsZ0JBQWdCLEdBQUcsR0FBSCxHQUFTLEVBQTFCLElBQWdDRCxZQUFqQyxJQUFrRCxHQUF6RDtBQUNELENBM0JELEMsQ0E2QkE7QUFDQTs7O0FBQ0FGLE9BQU8sQ0FBQ2MsU0FBUixHQUFvQixVQUFTVCxJQUFULEVBQWU7QUFDakMsTUFBSVUsVUFBVSxHQUFHZixPQUFPLENBQUNlLFVBQVIsQ0FBbUJWLElBQW5CLENBQWpCO0FBQUEsTUFDSVcsYUFBYSxHQUFHQyxNQUFNLENBQUNaLElBQUQsRUFBTyxDQUFDLENBQVIsQ0FBTixLQUFxQixHQUR6QyxDQURpQyxDQUlqQzs7QUFDQUEsTUFBSSxHQUFHZCxjQUFjLENBQUNtQixNQUFNLENBQUNMLElBQUksQ0FBQ00sS0FBTCxDQUFXLEdBQVgsQ0FBRCxFQUFrQixVQUFTQyxDQUFULEVBQVk7QUFDeEQsV0FBTyxDQUFDLENBQUNBLENBQVQ7QUFDRCxHQUYyQixDQUFQLEVBRWpCLENBQUNHLFVBRmdCLENBQWQsQ0FFVUYsSUFGVixDQUVlLEdBRmYsQ0FBUDs7QUFJQSxNQUFJLENBQUNSLElBQUQsSUFBUyxDQUFDVSxVQUFkLEVBQTBCO0FBQ3hCVixRQUFJLEdBQUcsR0FBUDtBQUNEOztBQUNELE1BQUlBLElBQUksSUFBSVcsYUFBWixFQUEyQjtBQUN6QlgsUUFBSSxJQUFJLEdBQVI7QUFDRDs7QUFFRCxTQUFPLENBQUNVLFVBQVUsR0FBRyxHQUFILEdBQVMsRUFBcEIsSUFBMEJWLElBQWpDO0FBQ0QsQ0FqQkQsQyxDQW1CQTs7O0FBQ0FMLE9BQU8sQ0FBQ2UsVUFBUixHQUFxQixVQUFTVixJQUFULEVBQWU7QUFDbEMsU0FBT0EsSUFBSSxDQUFDSSxNQUFMLENBQVksQ0FBWixNQUFtQixHQUExQjtBQUNELENBRkQsQyxDQUlBOzs7QUFDQVQsT0FBTyxDQUFDYSxJQUFSLEdBQWUsWUFBVztBQUN4QixNQUFJSyxLQUFLLEdBQUdDLEtBQUssQ0FBQ0MsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0JDLElBQXRCLENBQTJCbEIsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBWjtBQUNBLFNBQU9KLE9BQU8sQ0FBQ2MsU0FBUixDQUFrQkosTUFBTSxDQUFDUSxLQUFELEVBQVEsVUFBU04sQ0FBVCxFQUFZVyxLQUFaLEVBQW1CO0FBQ3hELFFBQUksT0FBT1gsQ0FBUCxLQUFhLFFBQWpCLEVBQTJCO0FBQ3pCLFlBQU0sSUFBSUosU0FBSixDQUFjLHdDQUFkLENBQU47QUFDRDs7QUFDRCxXQUFPSSxDQUFQO0FBQ0QsR0FMOEIsQ0FBTixDQUt0QkMsSUFMc0IsQ0FLakIsR0FMaUIsQ0FBbEIsQ0FBUDtBQU1ELENBUkQsQyxDQVdBO0FBQ0E7OztBQUNBYixPQUFPLENBQUN3QixRQUFSLEdBQW1CLFVBQVNDLElBQVQsRUFBZUMsRUFBZixFQUFtQjtBQUNwQ0QsTUFBSSxHQUFHekIsT0FBTyxDQUFDQyxPQUFSLENBQWdCd0IsSUFBaEIsRUFBc0JSLE1BQXRCLENBQTZCLENBQTdCLENBQVA7QUFDQVMsSUFBRSxHQUFHMUIsT0FBTyxDQUFDQyxPQUFSLENBQWdCeUIsRUFBaEIsRUFBb0JULE1BQXBCLENBQTJCLENBQTNCLENBQUw7O0FBRUEsV0FBU1UsSUFBVCxDQUFjQyxHQUFkLEVBQW1CO0FBQ2pCLFFBQUlDLEtBQUssR0FBRyxDQUFaOztBQUNBLFdBQU9BLEtBQUssR0FBR0QsR0FBRyxDQUFDaEMsTUFBbkIsRUFBMkJpQyxLQUFLLEVBQWhDLEVBQW9DO0FBQ2xDLFVBQUlELEdBQUcsQ0FBQ0MsS0FBRCxDQUFILEtBQWUsRUFBbkIsRUFBdUI7QUFDeEI7O0FBRUQsUUFBSUMsR0FBRyxHQUFHRixHQUFHLENBQUNoQyxNQUFKLEdBQWEsQ0FBdkI7O0FBQ0EsV0FBT2tDLEdBQUcsSUFBSSxDQUFkLEVBQWlCQSxHQUFHLEVBQXBCLEVBQXdCO0FBQ3RCLFVBQUlGLEdBQUcsQ0FBQ0UsR0FBRCxDQUFILEtBQWEsRUFBakIsRUFBcUI7QUFDdEI7O0FBRUQsUUFBSUQsS0FBSyxHQUFHQyxHQUFaLEVBQWlCLE9BQU8sRUFBUDtBQUNqQixXQUFPRixHQUFHLENBQUNQLEtBQUosQ0FBVVEsS0FBVixFQUFpQkMsR0FBRyxHQUFHRCxLQUFOLEdBQWMsQ0FBL0IsQ0FBUDtBQUNEOztBQUVELE1BQUlFLFNBQVMsR0FBR0osSUFBSSxDQUFDRixJQUFJLENBQUNkLEtBQUwsQ0FBVyxHQUFYLENBQUQsQ0FBcEI7QUFDQSxNQUFJcUIsT0FBTyxHQUFHTCxJQUFJLENBQUNELEVBQUUsQ0FBQ2YsS0FBSCxDQUFTLEdBQVQsQ0FBRCxDQUFsQjtBQUVBLE1BQUlmLE1BQU0sR0FBR3FDLElBQUksQ0FBQ0MsR0FBTCxDQUFTSCxTQUFTLENBQUNuQyxNQUFuQixFQUEyQm9DLE9BQU8sQ0FBQ3BDLE1BQW5DLENBQWI7QUFDQSxNQUFJdUMsZUFBZSxHQUFHdkMsTUFBdEI7O0FBQ0EsT0FBSyxJQUFJRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHQyxNQUFwQixFQUE0QkQsQ0FBQyxFQUE3QixFQUFpQztBQUMvQixRQUFJb0MsU0FBUyxDQUFDcEMsQ0FBRCxDQUFULEtBQWlCcUMsT0FBTyxDQUFDckMsQ0FBRCxDQUE1QixFQUFpQztBQUMvQndDLHFCQUFlLEdBQUd4QyxDQUFsQjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJeUMsV0FBVyxHQUFHLEVBQWxCOztBQUNBLE9BQUssSUFBSXpDLENBQUMsR0FBR3dDLGVBQWIsRUFBOEJ4QyxDQUFDLEdBQUdvQyxTQUFTLENBQUNuQyxNQUE1QyxFQUFvREQsQ0FBQyxFQUFyRCxFQUF5RDtBQUN2RHlDLGVBQVcsQ0FBQ0MsSUFBWixDQUFpQixJQUFqQjtBQUNEOztBQUVERCxhQUFXLEdBQUdBLFdBQVcsQ0FBQ0UsTUFBWixDQUFtQk4sT0FBTyxDQUFDWCxLQUFSLENBQWNjLGVBQWQsQ0FBbkIsQ0FBZDtBQUVBLFNBQU9DLFdBQVcsQ0FBQ3ZCLElBQVosQ0FBaUIsR0FBakIsQ0FBUDtBQUNELENBdkNEOztBQXlDQWIsT0FBTyxDQUFDdUMsR0FBUixHQUFjLEdBQWQ7QUFDQXZDLE9BQU8sQ0FBQ3dDLFNBQVIsR0FBb0IsR0FBcEI7O0FBRUF4QyxPQUFPLENBQUN5QyxPQUFSLEdBQWtCLFVBQVVwQyxJQUFWLEVBQWdCO0FBQ2hDLE1BQUksT0FBT0EsSUFBUCxLQUFnQixRQUFwQixFQUE4QkEsSUFBSSxHQUFHQSxJQUFJLEdBQUcsRUFBZDtBQUM5QixNQUFJQSxJQUFJLENBQUNULE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUIsT0FBTyxHQUFQO0FBQ3ZCLE1BQUk4QyxJQUFJLEdBQUdyQyxJQUFJLENBQUNzQyxVQUFMLENBQWdCLENBQWhCLENBQVg7QUFDQSxNQUFJQyxPQUFPLEdBQUdGLElBQUksS0FBSztBQUFHO0FBQTFCO0FBQ0EsTUFBSVosR0FBRyxHQUFHLENBQUMsQ0FBWDtBQUNBLE1BQUllLFlBQVksR0FBRyxJQUFuQjs7QUFDQSxPQUFLLElBQUlsRCxDQUFDLEdBQUdVLElBQUksQ0FBQ1QsTUFBTCxHQUFjLENBQTNCLEVBQThCRCxDQUFDLElBQUksQ0FBbkMsRUFBc0MsRUFBRUEsQ0FBeEMsRUFBMkM7QUFDekMrQyxRQUFJLEdBQUdyQyxJQUFJLENBQUNzQyxVQUFMLENBQWdCaEQsQ0FBaEIsQ0FBUDs7QUFDQSxRQUFJK0MsSUFBSSxLQUFLO0FBQUc7QUFBaEIsTUFBdUI7QUFDbkIsWUFBSSxDQUFDRyxZQUFMLEVBQW1CO0FBQ2pCZixhQUFHLEdBQUduQyxDQUFOO0FBQ0E7QUFDRDtBQUNGLE9BTEgsTUFLUztBQUNQO0FBQ0FrRCxrQkFBWSxHQUFHLEtBQWY7QUFDRDtBQUNGOztBQUVELE1BQUlmLEdBQUcsS0FBSyxDQUFDLENBQWIsRUFBZ0IsT0FBT2MsT0FBTyxHQUFHLEdBQUgsR0FBUyxHQUF2Qjs7QUFDaEIsTUFBSUEsT0FBTyxJQUFJZCxHQUFHLEtBQUssQ0FBdkIsRUFBMEI7QUFDeEI7QUFDQTtBQUNBLFdBQU8sR0FBUDtBQUNEOztBQUNELFNBQU96QixJQUFJLENBQUNnQixLQUFMLENBQVcsQ0FBWCxFQUFjUyxHQUFkLENBQVA7QUFDRCxDQTNCRDs7QUE2QkEsU0FBU2dCLFFBQVQsQ0FBa0J6QyxJQUFsQixFQUF3QjtBQUN0QixNQUFJLE9BQU9BLElBQVAsS0FBZ0IsUUFBcEIsRUFBOEJBLElBQUksR0FBR0EsSUFBSSxHQUFHLEVBQWQ7QUFFOUIsTUFBSXdCLEtBQUssR0FBRyxDQUFaO0FBQ0EsTUFBSUMsR0FBRyxHQUFHLENBQUMsQ0FBWDtBQUNBLE1BQUllLFlBQVksR0FBRyxJQUFuQjtBQUNBLE1BQUlsRCxDQUFKOztBQUVBLE9BQUtBLENBQUMsR0FBR1UsSUFBSSxDQUFDVCxNQUFMLEdBQWMsQ0FBdkIsRUFBMEJELENBQUMsSUFBSSxDQUEvQixFQUFrQyxFQUFFQSxDQUFwQyxFQUF1QztBQUNyQyxRQUFJVSxJQUFJLENBQUNzQyxVQUFMLENBQWdCaEQsQ0FBaEIsTUFBdUI7QUFBRztBQUE5QixNQUFxQztBQUNqQztBQUNBO0FBQ0EsWUFBSSxDQUFDa0QsWUFBTCxFQUFtQjtBQUNqQmhCLGVBQUssR0FBR2xDLENBQUMsR0FBRyxDQUFaO0FBQ0E7QUFDRDtBQUNGLE9BUEgsTUFPUyxJQUFJbUMsR0FBRyxLQUFLLENBQUMsQ0FBYixFQUFnQjtBQUN2QjtBQUNBO0FBQ0FlLGtCQUFZLEdBQUcsS0FBZjtBQUNBZixTQUFHLEdBQUduQyxDQUFDLEdBQUcsQ0FBVjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSW1DLEdBQUcsS0FBSyxDQUFDLENBQWIsRUFBZ0IsT0FBTyxFQUFQO0FBQ2hCLFNBQU96QixJQUFJLENBQUNnQixLQUFMLENBQVdRLEtBQVgsRUFBa0JDLEdBQWxCLENBQVA7QUFDRCxDLENBRUQ7QUFDQTs7O0FBQ0E5QixPQUFPLENBQUM4QyxRQUFSLEdBQW1CLFVBQVV6QyxJQUFWLEVBQWdCMEMsR0FBaEIsRUFBcUI7QUFDdEMsTUFBSUMsQ0FBQyxHQUFHRixRQUFRLENBQUN6QyxJQUFELENBQWhCOztBQUNBLE1BQUkwQyxHQUFHLElBQUlDLENBQUMsQ0FBQy9CLE1BQUYsQ0FBUyxDQUFDLENBQUQsR0FBSzhCLEdBQUcsQ0FBQ25ELE1BQWxCLE1BQThCbUQsR0FBekMsRUFBOEM7QUFDNUNDLEtBQUMsR0FBR0EsQ0FBQyxDQUFDL0IsTUFBRixDQUFTLENBQVQsRUFBWStCLENBQUMsQ0FBQ3BELE1BQUYsR0FBV21ELEdBQUcsQ0FBQ25ELE1BQTNCLENBQUo7QUFDRDs7QUFDRCxTQUFPb0QsQ0FBUDtBQUNELENBTkQ7O0FBUUFoRCxPQUFPLENBQUNpRCxPQUFSLEdBQWtCLFVBQVU1QyxJQUFWLEVBQWdCO0FBQ2hDLE1BQUksT0FBT0EsSUFBUCxLQUFnQixRQUFwQixFQUE4QkEsSUFBSSxHQUFHQSxJQUFJLEdBQUcsRUFBZDtBQUM5QixNQUFJNkMsUUFBUSxHQUFHLENBQUMsQ0FBaEI7QUFDQSxNQUFJQyxTQUFTLEdBQUcsQ0FBaEI7QUFDQSxNQUFJckIsR0FBRyxHQUFHLENBQUMsQ0FBWDtBQUNBLE1BQUllLFlBQVksR0FBRyxJQUFuQixDQUxnQyxDQU1oQztBQUNBOztBQUNBLE1BQUlPLFdBQVcsR0FBRyxDQUFsQjs7QUFDQSxPQUFLLElBQUl6RCxDQUFDLEdBQUdVLElBQUksQ0FBQ1QsTUFBTCxHQUFjLENBQTNCLEVBQThCRCxDQUFDLElBQUksQ0FBbkMsRUFBc0MsRUFBRUEsQ0FBeEMsRUFBMkM7QUFDekMsUUFBSStDLElBQUksR0FBR3JDLElBQUksQ0FBQ3NDLFVBQUwsQ0FBZ0JoRCxDQUFoQixDQUFYOztBQUNBLFFBQUkrQyxJQUFJLEtBQUs7QUFBRztBQUFoQixNQUF1QjtBQUNuQjtBQUNBO0FBQ0EsWUFBSSxDQUFDRyxZQUFMLEVBQW1CO0FBQ2pCTSxtQkFBUyxHQUFHeEQsQ0FBQyxHQUFHLENBQWhCO0FBQ0E7QUFDRDs7QUFDRDtBQUNEOztBQUNILFFBQUltQyxHQUFHLEtBQUssQ0FBQyxDQUFiLEVBQWdCO0FBQ2Q7QUFDQTtBQUNBZSxrQkFBWSxHQUFHLEtBQWY7QUFDQWYsU0FBRyxHQUFHbkMsQ0FBQyxHQUFHLENBQVY7QUFDRDs7QUFDRCxRQUFJK0MsSUFBSSxLQUFLO0FBQUc7QUFBaEIsTUFBdUI7QUFDbkI7QUFDQSxZQUFJUSxRQUFRLEtBQUssQ0FBQyxDQUFsQixFQUNFQSxRQUFRLEdBQUd2RCxDQUFYLENBREYsS0FFSyxJQUFJeUQsV0FBVyxLQUFLLENBQXBCLEVBQ0hBLFdBQVcsR0FBRyxDQUFkO0FBQ0wsT0FORCxNQU1PLElBQUlGLFFBQVEsS0FBSyxDQUFDLENBQWxCLEVBQXFCO0FBQzFCO0FBQ0E7QUFDQUUsaUJBQVcsR0FBRyxDQUFDLENBQWY7QUFDRDtBQUNGOztBQUVELE1BQUlGLFFBQVEsS0FBSyxDQUFDLENBQWQsSUFBbUJwQixHQUFHLEtBQUssQ0FBQyxDQUE1QixJQUNBO0FBQ0FzQixhQUFXLEtBQUssQ0FGaEIsSUFHQTtBQUNBQSxhQUFXLEtBQUssQ0FBaEIsSUFBcUJGLFFBQVEsS0FBS3BCLEdBQUcsR0FBRyxDQUF4QyxJQUE2Q29CLFFBQVEsS0FBS0MsU0FBUyxHQUFHLENBSjFFLEVBSTZFO0FBQzNFLFdBQU8sRUFBUDtBQUNEOztBQUNELFNBQU85QyxJQUFJLENBQUNnQixLQUFMLENBQVc2QixRQUFYLEVBQXFCcEIsR0FBckIsQ0FBUDtBQUNELENBL0NEOztBQWlEQSxTQUFTcEIsTUFBVCxDQUFpQjJDLEVBQWpCLEVBQXFCTCxDQUFyQixFQUF3QjtBQUNwQixNQUFJSyxFQUFFLENBQUMzQyxNQUFQLEVBQWUsT0FBTzJDLEVBQUUsQ0FBQzNDLE1BQUgsQ0FBVXNDLENBQVYsQ0FBUDtBQUNmLE1BQUlNLEdBQUcsR0FBRyxFQUFWOztBQUNBLE9BQUssSUFBSTNELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwRCxFQUFFLENBQUN6RCxNQUF2QixFQUErQkQsQ0FBQyxFQUFoQyxFQUFvQztBQUNoQyxRQUFJcUQsQ0FBQyxDQUFDSyxFQUFFLENBQUMxRCxDQUFELENBQUgsRUFBUUEsQ0FBUixFQUFXMEQsRUFBWCxDQUFMLEVBQXFCQyxHQUFHLENBQUNqQixJQUFKLENBQVNnQixFQUFFLENBQUMxRCxDQUFELENBQVg7QUFDeEI7O0FBQ0QsU0FBTzJELEdBQVA7QUFDSCxDLENBRUQ7OztBQUNBLElBQUlyQyxNQUFNLEdBQUcsS0FBS0EsTUFBTCxDQUFZLENBQUMsQ0FBYixNQUFvQixHQUFwQixHQUNQLFVBQVVzQyxHQUFWLEVBQWUxQixLQUFmLEVBQXNCMkIsR0FBdEIsRUFBMkI7QUFBRSxTQUFPRCxHQUFHLENBQUN0QyxNQUFKLENBQVdZLEtBQVgsRUFBa0IyQixHQUFsQixDQUFQO0FBQStCLENBRHJELEdBRVAsVUFBVUQsR0FBVixFQUFlMUIsS0FBZixFQUFzQjJCLEdBQXRCLEVBQTJCO0FBQ3pCLE1BQUkzQixLQUFLLEdBQUcsQ0FBWixFQUFlQSxLQUFLLEdBQUcwQixHQUFHLENBQUMzRCxNQUFKLEdBQWFpQyxLQUFyQjtBQUNmLFNBQU8wQixHQUFHLENBQUN0QyxNQUFKLENBQVdZLEtBQVgsRUFBa0IyQixHQUFsQixDQUFQO0FBQ0gsQ0FMTCxDIiwiZmlsZSI6IjMzeWYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAuZGlybmFtZSwgLmJhc2VuYW1lLCBhbmQgLmV4dG5hbWUgbWV0aG9kcyBhcmUgZXh0cmFjdGVkIGZyb20gTm9kZS5qcyB2OC4xMS4xLFxuLy8gYmFja3BvcnRlZCBhbmQgdHJhbnNwbGl0ZWQgd2l0aCBCYWJlbCwgd2l0aCBiYWNrd2FyZHMtY29tcGF0IGZpeGVzXG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzb2x2ZWRQYXRoID0gJycsXG4gICAgICByZXNvbHZlZEFic29sdXRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICB2YXIgcGF0aCA9IChpID49IDApID8gYXJndW1lbnRzW2ldIDogcHJvY2Vzcy5jd2QoKTtcblxuICAgIC8vIFNraXAgZW1wdHkgYW5kIGludmFsaWQgZW50cmllc1xuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihyZXNvbHZlZFBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIHJldHVybiAoKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGgpIHx8ICcuJztcbn07XG5cbi8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICB0cmFpbGluZ1NsYXNoID0gc3Vic3RyKHBhdGgsIC0xKSA9PT0gJy8nO1xuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICBwYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHBhdGguc3BsaXQoJy8nKSwgZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhIXA7XG4gIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHBhdGggPSAnLic7XG4gIH1cbiAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgIHBhdGggKz0gJy8nO1xuICB9XG5cbiAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmpvaW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgcmV0dXJuIGV4cG9ydHMubm9ybWFsaXplKGZpbHRlcihwYXRocywgZnVuY3Rpb24ocCwgaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHAgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSkuam9pbignLycpKTtcbn07XG5cblxuLy8gcGF0aC5yZWxhdGl2ZShmcm9tLCB0bylcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICBmcm9tID0gZXhwb3J0cy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTtcbiAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICBmdW5jdGlvbiB0cmltKGFycikge1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKGFycltzdGFydF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGVuZCA+PSAwOyBlbmQtLSkge1xuICAgICAgaWYgKGFycltlbmRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKTtcbiAgfVxuXG4gIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcblxuICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgfVxuXG4gIG91dHB1dFBhcnRzID0gb3V0cHV0UGFydHMuY29uY2F0KHRvUGFydHMuc2xpY2Uoc2FtZVBhcnRzTGVuZ3RoKSk7XG5cbiAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbmV4cG9ydHMuc2VwID0gJy8nO1xuZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gIHZhciBoYXNSb290ID0gY29kZSA9PT0gNDcgLyovKi87XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMTsgLS1pKSB7XG4gICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3JcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gaGFzUm9vdCA/ICcvJyA6ICcuJztcbiAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSB7XG4gICAgLy8gcmV0dXJuICcvLyc7XG4gICAgLy8gQmFja3dhcmRzLWNvbXBhdCBmaXg6XG4gICAgcmV0dXJuICcvJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xufTtcblxuZnVuY3Rpb24gYmFzZW5hbWUocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuXG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmQgPT09IC0xKSByZXR1cm4gJyc7XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuXG4vLyBVc2VzIGEgbWl4ZWQgYXBwcm9hY2ggZm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCBhcyBleHQgYmVoYXZpb3IgY2hhbmdlZFxuLy8gaW4gbmV3IE5vZGUuanMgdmVyc2lvbnMsIHNvIG9ubHkgYmFzZW5hbWUoKSBhYm92ZSBpcyBiYWNrcG9ydGVkIGhlcmVcbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbiAocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gYmFzZW5hbWUocGF0aCk7XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICB2YXIgc3RhcnREb3QgPSAtMTtcbiAgdmFyIHN0YXJ0UGFydCA9IDA7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgdmFyIHByZURvdFN0YXRlID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICBpZiAoY29kZSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnRQYXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDQ2IC8qLiovKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpXG4gICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGFuZCBub24tcGF0aCBzZXBhcmF0b3IgYmVmb3JlIG91ciBkb3QsIHNvIHdlIHNob3VsZFxuICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fCBlbmQgPT09IC0xIHx8XG4gICAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///33yf\n")},"3Mpw":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ defaultProps; });\n\n// UNUSED EXPORTS: Prism\n\n// CONCATENATED MODULE: ./node_modules/prism-react-renderer/prism/index.js\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\n\n/**\n * prism-react-renderer:\n * This file has been modified to remove:\n * - globals and window dependency\n * - worker support\n * - highlightAll and other element dependent methods\n * - _.hooks helpers\n * - UMD/node-specific hacks\n * It has also been run through prettier\n */\nvar Prism = function () {\n  // Private helper vars\n  var lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n  var uniqueId = 0; // The grammar object for plaintext\n\n  var plainTextGrammar = {};\n  var _ = {\n    /**\n     * A namespace for utility methods.\n     *\n     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n     * change or disappear at any time.\n     *\n     * @namespace\n     * @memberof Prism\n     */\n    util: {\n      encode: function encode(tokens) {\n        if (tokens instanceof Token) {\n          return new Token(tokens.type, encode(tokens.content), tokens.alias);\n        } else if (Array.isArray(tokens)) {\n          return tokens.map(encode);\n        } else {\n          return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n        }\n      },\n\n      /**\n       * Returns the name of the type of the given value.\n       *\n       * @param {any} o\n       * @returns {string}\n       * @example\n       * type(null)      === 'Null'\n       * type(undefined) === 'Undefined'\n       * type(123)       === 'Number'\n       * type('foo')     === 'String'\n       * type(true)      === 'Boolean'\n       * type([1, 2])    === 'Array'\n       * type({})        === 'Object'\n       * type(String)    === 'Function'\n       * type(/abc+/)    === 'RegExp'\n       */\n      type: function type(o) {\n        return Object.prototype.toString.call(o).slice(8, -1);\n      },\n\n      /**\n       * Returns a unique number for the given object. Later calls will still return the same number.\n       *\n       * @param {Object} obj\n       * @returns {number}\n       */\n      objId: function objId(obj) {\n        if (!obj['__id']) {\n          Object.defineProperty(obj, '__id', {\n            value: ++uniqueId\n          });\n        }\n\n        return obj['__id'];\n      },\n\n      /**\n       * Creates a deep clone of the given object.\n       *\n       * The main intended use of this function is to clone language definitions.\n       *\n       * @param {T} o\n       * @param {Record<number, any>} [visited]\n       * @returns {T}\n       * @template T\n       */\n      clone: function deepClone(o, visited) {\n        visited = visited || {};\n        var clone;\n        var id;\n\n        switch (_.util.type(o)) {\n          case 'Object':\n            id = _.util.objId(o);\n\n            if (visited[id]) {\n              return visited[id];\n            }\n\n            clone =\n            /** @type {Record<string, any>} */\n            {};\n            visited[id] = clone;\n\n            for (var key in o) {\n              if (o.hasOwnProperty(key)) {\n                clone[key] = deepClone(o[key], visited);\n              }\n            }\n\n            return (\n              /** @type {any} */\n              clone\n            );\n\n          case 'Array':\n            id = _.util.objId(o);\n\n            if (visited[id]) {\n              return visited[id];\n            }\n\n            clone = [];\n            visited[id] = clone;\n\n            /** @type {Array} */\n\n            /** @type {any} */\n            o.forEach(function (v, i) {\n              clone[i] = deepClone(v, visited);\n            });\n            return (\n              /** @type {any} */\n              clone\n            );\n\n          default:\n            return o;\n        }\n      },\n\n      /**\n       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n       *\n       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n       *\n       * @param {Element} element\n       * @returns {string}\n       */\n      getLanguage: function getLanguage(element) {\n        while (element) {\n          var m = lang.exec(element.className);\n\n          if (m) {\n            return m[1].toLowerCase();\n          }\n\n          element = element.parentElement;\n        }\n\n        return 'none';\n      },\n\n      /**\n       * Sets the Prism `language-xxxx` class of the given element.\n       *\n       * @param {Element} element\n       * @param {string} language\n       * @returns {void}\n       */\n      setLanguage: function setLanguage(element, language) {\n        // remove all `language-xxxx` classes\n        // (this might leave behind a leading space)\n        element.className = element.className.replace(RegExp(lang, 'gi'), ''); // add the new `language-xxxx` class\n        // (using `classList` will automatically clean up spaces for us)\n\n        element.classList.add('language-' + language);\n      },\n\n      /**\n       * Returns whether a given class is active for `element`.\n       *\n       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n       * given class is just the given class with a `no-` prefix.\n       *\n       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n       * ancestors have the given class or the negated version of it, then the default activation will be returned.\n       *\n       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n       * version of it, the class is considered active.\n       *\n       * @param {Element} element\n       * @param {string} className\n       * @param {boolean} [defaultActivation=false]\n       * @returns {boolean}\n       */\n      isActive: function isActive(element, className, defaultActivation) {\n        var no = 'no-' + className;\n\n        while (element) {\n          var classList = element.classList;\n\n          if (classList.contains(className)) {\n            return true;\n          }\n\n          if (classList.contains(no)) {\n            return false;\n          }\n\n          element = element.parentElement;\n        }\n\n        return !!defaultActivation;\n      }\n    },\n\n    /**\n     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n     *\n     * @namespace\n     * @memberof Prism\n     * @public\n     */\n    languages: {\n      /**\n       * The grammar for plain, unformatted text.\n       */\n      plain: plainTextGrammar,\n      plaintext: plainTextGrammar,\n      text: plainTextGrammar,\n      txt: plainTextGrammar,\n\n      /**\n       * Creates a deep copy of the language with the given id and appends the given tokens.\n       *\n       * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n       * will be overwritten at its original position.\n       *\n       * ## Best practices\n       *\n       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n       * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n       *\n       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n       *\n       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n       * @param {Grammar} redef The new tokens to append.\n       * @returns {Grammar} The new language created.\n       * @public\n       * @example\n       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n       *     // at its original position\n       *     'comment': { ... },\n       *     // CSS doesn't have a 'color' token, so this token will be appended\n       *     'color': /\\b(?:red|green|blue)\\b/\n       * });\n       */\n      extend: function extend(id, redef) {\n        var lang = _.util.clone(_.languages[id]);\n\n        for (var key in redef) {\n          lang[key] = redef[key];\n        }\n\n        return lang;\n      },\n\n      /**\n       * Inserts tokens _before_ another token in a language definition or any other grammar.\n       *\n       * ## Usage\n       *\n       * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n       * this:\n       *\n       * ```js\n       * Prism.languages.markup.style = {\n       *     // token\n       * };\n       * ```\n       *\n       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n       * before existing tokens. For the CSS example above, you would use it like this:\n       *\n       * ```js\n       * Prism.languages.insertBefore('markup', 'cdata', {\n       *     'style': {\n       *         // token\n       *     }\n       * });\n       * ```\n       *\n       * ## Special cases\n       *\n       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n       * will be ignored.\n       *\n       * This behavior can be used to insert tokens after `before`:\n       *\n       * ```js\n       * Prism.languages.insertBefore('markup', 'comment', {\n       *     'comment': Prism.languages.markup.comment,\n       *     // tokens after 'comment'\n       * });\n       * ```\n       *\n       * ## Limitations\n       *\n       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n       * deleting properties which is necessary to insert at arbitrary positions.\n       *\n       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n       * Instead, it will create a new object and replace all references to the target object with the new one. This\n       * can be done without temporarily deleting properties, so the iteration order is well-defined.\n       *\n       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n       * you hold the target object in a variable, then the value of the variable will not change.\n       *\n       * ```js\n       * var oldMarkup = Prism.languages.markup;\n       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n       *\n       * assert(oldMarkup !== Prism.languages.markup);\n       * assert(newMarkup === Prism.languages.markup);\n       * ```\n       *\n       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n       * object to be modified.\n       * @param {string} before The key to insert before.\n       * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n       * object to be modified.\n       *\n       * Defaults to `Prism.languages`.\n       * @returns {Grammar} The new grammar object.\n       * @public\n       */\n      insertBefore: function insertBefore(inside, before, insert, root) {\n        root = root ||\n        /** @type {any} */\n        _.languages;\n        var grammar = root[inside];\n        /** @type {Grammar} */\n\n        var ret = {};\n\n        for (var token in grammar) {\n          if (grammar.hasOwnProperty(token)) {\n            if (token == before) {\n              for (var newToken in insert) {\n                if (insert.hasOwnProperty(newToken)) {\n                  ret[newToken] = insert[newToken];\n                }\n              }\n            } // Do not insert token which also occur in insert. See #1525\n\n\n            if (!insert.hasOwnProperty(token)) {\n              ret[token] = grammar[token];\n            }\n          }\n        }\n\n        var old = root[inside];\n        root[inside] = ret; // Update references in other language definitions\n\n        _.languages.DFS(_.languages, function (key, value) {\n          if (value === old && key != inside) {\n            this[key] = ret;\n          }\n        });\n\n        return ret;\n      },\n      // Traverse a language definition with Depth First Search\n      DFS: function DFS(o, callback, type, visited) {\n        visited = visited || {};\n        var objId = _.util.objId;\n\n        for (var i in o) {\n          if (o.hasOwnProperty(i)) {\n            callback.call(o, i, o[i], type || i);\n            var property = o[i];\n\n            var propertyType = _.util.type(property);\n\n            if (propertyType === 'Object' && !visited[objId(property)]) {\n              visited[objId(property)] = true;\n              DFS(property, callback, null, visited);\n            } else if (propertyType === 'Array' && !visited[objId(property)]) {\n              visited[objId(property)] = true;\n              DFS(property, callback, i, visited);\n            }\n          }\n        }\n      }\n    },\n    plugins: {},\n\n    /**\n     * Low-level function, only use if you know what you\u2019re doing. It accepts a string of text as input\n     * and the language definitions to use, and returns a string with the HTML produced.\n     *\n     * The following hooks will be run:\n     * 1. `before-tokenize`\n     * 2. `after-tokenize`\n     * 3. `wrap`: On each {@link Token}.\n     *\n     * @param {string} text A string with the code to be highlighted.\n     * @param {Grammar} grammar An object containing the tokens to use.\n     *\n     * Usually a language definition like `Prism.languages.markup`.\n     * @param {string} language The name of the language definition passed to `grammar`.\n     * @returns {string} The highlighted HTML.\n     * @memberof Prism\n     * @public\n     * @example\n     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n     */\n    highlight: function highlight(text, grammar, language) {\n      var env = {\n        code: text,\n        grammar: grammar,\n        language: language\n      };\n\n      _.hooks.run('before-tokenize', env);\n\n      env.tokens = _.tokenize(env.code, env.grammar);\n\n      _.hooks.run('after-tokenize', env);\n\n      return Token.stringify(_.util.encode(env.tokens), env.language);\n    },\n\n    /**\n     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n     * and the language definitions to use, and returns an array with the tokenized code.\n     *\n     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n     *\n     * This method could be useful in other contexts as well, as a very crude parser.\n     *\n     * @param {string} text A string with the code to be highlighted.\n     * @param {Grammar} grammar An object containing the tokens to use.\n     *\n     * Usually a language definition like `Prism.languages.markup`.\n     * @returns {TokenStream} An array of strings and tokens, a token stream.\n     * @memberof Prism\n     * @public\n     * @example\n     * let code = `var foo = 0;`;\n     * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n     * tokens.forEach(token => {\n     *     if (token instanceof Prism.Token && token.type === 'number') {\n     *         console.log(`Found numeric literal: ${token.content}`);\n     *     }\n     * });\n     */\n    tokenize: function tokenize(text, grammar) {\n      var rest = grammar.rest;\n\n      if (rest) {\n        for (var token in rest) {\n          grammar[token] = rest[token];\n        }\n\n        delete grammar.rest;\n      }\n\n      var tokenList = new LinkedList();\n      addAfter(tokenList, tokenList.head, text);\n      matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n      return toArray(tokenList);\n    },\n\n    /**\n     * @namespace\n     * @memberof Prism\n     * @public\n     */\n    hooks: {\n      all: {},\n\n      /**\n       * Adds the given callback to the list of callbacks for the given hook.\n       *\n       * The callback will be invoked when the hook it is registered for is run.\n       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n       *\n       * One callback function can be registered to multiple hooks and the same hook multiple times.\n       *\n       * @param {string} name The name of the hook.\n       * @param {HookCallback} callback The callback function which is given environment variables.\n       * @public\n       */\n      add: function add(name, callback) {\n        var hooks = _.hooks.all;\n        hooks[name] = hooks[name] || [];\n        hooks[name].push(callback);\n      },\n\n      /**\n       * Runs a hook invoking all registered callbacks with the given environment variables.\n       *\n       * Callbacks will be invoked synchronously and in the order in which they were registered.\n       *\n       * @param {string} name The name of the hook.\n       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n       * @public\n       */\n      run: function run(name, env) {\n        var callbacks = _.hooks.all[name];\n\n        if (!callbacks || !callbacks.length) {\n          return;\n        }\n\n        for (var i = 0, callback; callback = callbacks[i++];) {\n          callback(env);\n        }\n      }\n    },\n    Token: Token\n  }; // Typescript note:\n  // The following can be used to import the Token type in JSDoc:\n  //\n  //   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n  /**\n   * Creates a new token.\n   *\n   * @param {string} type See {@link Token#type type}\n   * @param {string | TokenStream} content See {@link Token#content content}\n   * @param {string|string[]} [alias] The alias(es) of the token.\n   * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n   * @class\n   * @global\n   * @public\n   */\n\n  function Token(type, content, alias, matchedStr) {\n    /**\n     * The type of the token.\n     *\n     * This is usually the key of a pattern in a {@link Grammar}.\n     *\n     * @type {string}\n     * @see GrammarToken\n     * @public\n     */\n    this.type = type;\n    /**\n     * The strings or tokens contained by this token.\n     *\n     * This will be a token stream if the pattern matched also defined an `inside` grammar.\n     *\n     * @type {string | TokenStream}\n     * @public\n     */\n\n    this.content = content;\n    /**\n     * The alias(es) of the token.\n     *\n     * @type {string|string[]}\n     * @see GrammarToken\n     * @public\n     */\n\n    this.alias = alias; // Copy of the full string this token was created from\n\n    this.length = (matchedStr || '').length | 0;\n  }\n  /**\n   * A token stream is an array of strings and {@link Token Token} objects.\n   *\n   * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n   * them.\n   *\n   * 1. No adjacent strings.\n   * 2. No empty strings.\n   *\n   *    The only exception here is the token stream that only contains the empty string and nothing else.\n   *\n   * @typedef {Array<string | Token>} TokenStream\n   * @global\n   * @public\n   */\n\n  /**\n   * Converts the given token or token stream to an HTML representation.\n   *\n   * The following hooks will be run:\n   * 1. `wrap`: On each {@link Token}.\n   *\n   * @param {string | Token | TokenStream} o The token or token stream to be converted.\n   * @param {string} language The name of current language.\n   * @returns {string} The HTML representation of the token or token stream.\n   * @memberof Token\n   * @static\n   */\n\n\n  Token.stringify = function stringify(o, language) {\n    if (typeof o == 'string') {\n      return o;\n    }\n\n    if (Array.isArray(o)) {\n      var s = '';\n      o.forEach(function (e) {\n        s += stringify(e, language);\n      });\n      return s;\n    }\n\n    var env = {\n      type: o.type,\n      content: stringify(o.content, language),\n      tag: 'span',\n      classes: ['token', o.type],\n      attributes: {},\n      language: language\n    };\n    var aliases = o.alias;\n\n    if (aliases) {\n      if (Array.isArray(aliases)) {\n        Array.prototype.push.apply(env.classes, aliases);\n      } else {\n        env.classes.push(aliases);\n      }\n    }\n\n    _.hooks.run('wrap', env);\n\n    var attributes = '';\n\n    for (var name in env.attributes) {\n      attributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n    }\n\n    return '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n  };\n  /**\n   * @param {RegExp} pattern\n   * @param {number} pos\n   * @param {string} text\n   * @param {boolean} lookbehind\n   * @returns {RegExpExecArray | null}\n   */\n\n\n  function matchPattern(pattern, pos, text, lookbehind) {\n    pattern.lastIndex = pos;\n    var match = pattern.exec(text);\n\n    if (match && lookbehind && match[1]) {\n      // change the match to remove the text matched by the Prism lookbehind group\n      var lookbehindLength = match[1].length;\n      match.index += lookbehindLength;\n      match[0] = match[0].slice(lookbehindLength);\n    }\n\n    return match;\n  }\n  /**\n   * @param {string} text\n   * @param {LinkedList<string | Token>} tokenList\n   * @param {any} grammar\n   * @param {LinkedListNode<string | Token>} startNode\n   * @param {number} startPos\n   * @param {RematchOptions} [rematch]\n   * @returns {void}\n   * @private\n   *\n   * @typedef RematchOptions\n   * @property {string} cause\n   * @property {number} reach\n   */\n\n\n  function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n    for (var token in grammar) {\n      if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n        continue;\n      }\n\n      var patterns = grammar[token];\n      patterns = Array.isArray(patterns) ? patterns : [patterns];\n\n      for (var j = 0; j < patterns.length; ++j) {\n        if (rematch && rematch.cause == token + ',' + j) {\n          return;\n        }\n\n        var patternObj = patterns[j];\n        var inside = patternObj.inside;\n        var lookbehind = !!patternObj.lookbehind;\n        var greedy = !!patternObj.greedy;\n        var alias = patternObj.alias;\n\n        if (greedy && !patternObj.pattern.global) {\n          // Without the global flag, lastIndex won't work\n          var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n          patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n        }\n        /** @type {RegExp} */\n\n\n        var pattern = patternObj.pattern || patternObj;\n\n        for ( // iterate the token list and keep track of the current token/string position\n        var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {\n          if (rematch && pos >= rematch.reach) {\n            break;\n          }\n\n          var str = currentNode.value;\n\n          if (tokenList.length > text.length) {\n            // Something went terribly wrong, ABORT, ABORT!\n            return;\n          }\n\n          if (str instanceof Token) {\n            continue;\n          }\n\n          var removeCount = 1; // this is the to parameter of removeBetween\n\n          var match;\n\n          if (greedy) {\n            match = matchPattern(pattern, pos, text, lookbehind);\n\n            if (!match || match.index >= text.length) {\n              break;\n            }\n\n            var from = match.index;\n            var to = match.index + match[0].length;\n            var p = pos; // find the node that contains the match\n\n            p += currentNode.value.length;\n\n            while (from >= p) {\n              currentNode = currentNode.next;\n              p += currentNode.value.length;\n            } // adjust pos (and p)\n\n\n            p -= currentNode.value.length;\n            pos = p; // the current node is a Token, then the match starts inside another Token, which is invalid\n\n            if (currentNode.value instanceof Token) {\n              continue;\n            } // find the last node which is affected by this match\n\n\n            for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {\n              removeCount++;\n              p += k.value.length;\n            }\n\n            removeCount--; // replace with the new match\n\n            str = text.slice(pos, p);\n            match.index -= pos;\n          } else {\n            match = matchPattern(pattern, 0, str, lookbehind);\n\n            if (!match) {\n              continue;\n            }\n          } // eslint-disable-next-line no-redeclare\n\n\n          var from = match.index;\n          var matchStr = match[0];\n          var before = str.slice(0, from);\n          var after = str.slice(from + matchStr.length);\n          var reach = pos + str.length;\n\n          if (rematch && reach > rematch.reach) {\n            rematch.reach = reach;\n          }\n\n          var removeFrom = currentNode.prev;\n\n          if (before) {\n            removeFrom = addAfter(tokenList, removeFrom, before);\n            pos += before.length;\n          }\n\n          removeRange(tokenList, removeFrom, removeCount);\n          var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n          currentNode = addAfter(tokenList, removeFrom, wrapped);\n\n          if (after) {\n            addAfter(tokenList, currentNode, after);\n          }\n\n          if (removeCount > 1) {\n            // at least one Token object was removed, so we have to do some rematching\n            // this can only happen if the current pattern is greedy\n\n            /** @type {RematchOptions} */\n            var nestedRematch = {\n              cause: token + ',' + j,\n              reach: reach\n            };\n            matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch); // the reach might have been extended because of the rematching\n\n            if (rematch && nestedRematch.reach > rematch.reach) {\n              rematch.reach = nestedRematch.reach;\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @typedef LinkedListNode\n   * @property {T} value\n   * @property {LinkedListNode<T> | null} prev The previous node.\n   * @property {LinkedListNode<T> | null} next The next node.\n   * @template T\n   * @private\n   */\n\n  /**\n   * @template T\n   * @private\n   */\n\n\n  function LinkedList() {\n    /** @type {LinkedListNode<T>} */\n    var head = {\n      value: null,\n      prev: null,\n      next: null\n    };\n    /** @type {LinkedListNode<T>} */\n\n    var tail = {\n      value: null,\n      prev: head,\n      next: null\n    };\n    head.next = tail;\n    /** @type {LinkedListNode<T>} */\n\n    this.head = head;\n    /** @type {LinkedListNode<T>} */\n\n    this.tail = tail;\n    this.length = 0;\n  }\n  /**\n   * Adds a new node with the given value to the list.\n   *\n   * @param {LinkedList<T>} list\n   * @param {LinkedListNode<T>} node\n   * @param {T} value\n   * @returns {LinkedListNode<T>} The added node.\n   * @template T\n   */\n\n\n  function addAfter(list, node, value) {\n    // assumes that node != list.tail && values.length >= 0\n    var next = node.next;\n    var newNode = {\n      value: value,\n      prev: node,\n      next: next\n    };\n    node.next = newNode;\n    next.prev = newNode;\n    list.length++;\n    return newNode;\n  }\n  /**\n   * Removes `count` nodes after the given node. The given node will not be removed.\n   *\n   * @param {LinkedList<T>} list\n   * @param {LinkedListNode<T>} node\n   * @param {number} count\n   * @template T\n   */\n\n\n  function removeRange(list, node, count) {\n    var next = node.next;\n\n    for (var i = 0; i < count && next !== list.tail; i++) {\n      next = next.next;\n    }\n\n    node.next = next;\n    next.prev = node;\n    list.length -= i;\n  }\n  /**\n   * @param {LinkedList<T>} list\n   * @returns {T[]}\n   * @template T\n   */\n\n\n  function toArray(list) {\n    var array = [];\n    var node = list.head.next;\n\n    while (node !== list.tail) {\n      array.push(node.value);\n      node = node.next;\n    }\n\n    return array;\n  }\n\n  return _;\n}();\n\nvar prism = Prism;\nPrism[\"default\"] = Prism;\n/* This content is auto-generated to include some prismjs language components: */\n\n/* \"prismjs/components/prism-markup\" */\n\nprism.languages.markup = {\n  'comment': {\n    pattern: /\x3c!--(?:(?!\x3c!--)[\\s\\S])*?--\x3e/,\n    greedy: true\n  },\n  'prolog': {\n    pattern: /<\\?[\\s\\S]+?\\?>/,\n    greedy: true\n  },\n  'doctype': {\n    // https://www.w3.org/TR/xml/#NT-doctypedecl\n    pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|\x3c!--(?:[^-]|-(?!->))*--\x3e)*\\]\\s*)?>/i,\n    greedy: true,\n    inside: {\n      'internal-subset': {\n        pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n        lookbehind: true,\n        greedy: true,\n        inside: null // see below\n\n      },\n      'string': {\n        pattern: /\"[^\"]*\"|'[^']*'/,\n        greedy: true\n      },\n      'punctuation': /^<!|>$|[[\\]]/,\n      'doctype-tag': /^DOCTYPE/i,\n      'name': /[^\\s<>'\"]+/\n    }\n  },\n  'cdata': {\n    pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n    greedy: true\n  },\n  'tag': {\n    pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n    greedy: true,\n    inside: {\n      'tag': {\n        pattern: /^<\\/?[^\\s>\\/]+/,\n        inside: {\n          'punctuation': /^<\\/?/,\n          'namespace': /^[^\\s>\\/:]+:/\n        }\n      },\n      'special-attr': [],\n      'attr-value': {\n        pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n        inside: {\n          'punctuation': [{\n            pattern: /^=/,\n            alias: 'attr-equals'\n          }, /\"|'/]\n        }\n      },\n      'punctuation': /\\/?>/,\n      'attr-name': {\n        pattern: /[^\\s>\\/]+/,\n        inside: {\n          'namespace': /^[^\\s>\\/:]+:/\n        }\n      }\n    }\n  },\n  'entity': [{\n    pattern: /&[\\da-z]{1,8};/i,\n    alias: 'named-entity'\n  }, /&#x?[\\da-f]{1,8};/i]\n};\nprism.languages.markup['tag'].inside['attr-value'].inside['entity'] = prism.languages.markup['entity'];\nprism.languages.markup['doctype'].inside['internal-subset'].inside = prism.languages.markup; // Plugin to make entity title show the real entity, idea by Roman Komarov\n\nprism.hooks.add('wrap', function (env) {\n  if (env.type === 'entity') {\n    env.attributes['title'] = env.content.replace(/&amp;/, '&');\n  }\n});\nObject.defineProperty(prism.languages.markup.tag, 'addInlined', {\n  /**\n   * Adds an inlined language to markup.\n   *\n   * An example of an inlined language is CSS with `<style>` tags.\n   *\n   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addInlined('style', 'css');\n   */\n  value: function addInlined(tagName, lang) {\n    var includedCdataInside = {};\n    includedCdataInside['language-' + lang] = {\n      pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n      lookbehind: true,\n      inside: prism.languages[lang]\n    };\n    includedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n    var inside = {\n      'included-cdata': {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        inside: includedCdataInside\n      }\n    };\n    inside['language-' + lang] = {\n      pattern: /[\\s\\S]+/,\n      inside: prism.languages[lang]\n    };\n    var def = {};\n    def[tagName] = {\n      pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () {\n        return tagName;\n      }), 'i'),\n      lookbehind: true,\n      greedy: true,\n      inside: inside\n    };\n    prism.languages.insertBefore('markup', 'cdata', def);\n  }\n});\nObject.defineProperty(prism.languages.markup.tag, 'addAttribute', {\n  /**\n   * Adds an pattern to highlight languages embedded in HTML attributes.\n   *\n   * An example of an inlined language is CSS with `style` attributes.\n   *\n   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addAttribute('style', 'css');\n   */\n  value: function value(attrName, lang) {\n    prism.languages.markup.tag.inside['special-attr'].push({\n      pattern: RegExp(/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source, 'i'),\n      lookbehind: true,\n      inside: {\n        'attr-name': /^[^\\s=]+/,\n        'attr-value': {\n          pattern: /=[\\s\\S]+/,\n          inside: {\n            'value': {\n              pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n              lookbehind: true,\n              alias: [lang, 'language-' + lang],\n              inside: prism.languages[lang]\n            },\n            'punctuation': [{\n              pattern: /^=/,\n              alias: 'attr-equals'\n            }, /\"|'/]\n          }\n        }\n      }\n    });\n  }\n});\nprism.languages.html = prism.languages.markup;\nprism.languages.mathml = prism.languages.markup;\nprism.languages.svg = prism.languages.markup;\nprism.languages.xml = prism.languages.extend('markup', {});\nprism.languages.ssml = prism.languages.xml;\nprism.languages.atom = prism.languages.xml;\nprism.languages.rss = prism.languages.xml;\n/* \"prismjs/components/prism-bash\" */\n\n(function (Prism) {\n  // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\\n' '|'\n  // + LC_ALL, RANDOM, REPLY, SECONDS.\n  // + make sure PS1..4 are here as they are not always set,\n  // - some useless things.\n  var envVars = '\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b';\n  var commandAfterHeredoc = {\n    pattern: /(^([\"']?)\\w+\\2)[ \\t]+\\S.*/,\n    lookbehind: true,\n    alias: 'punctuation',\n    // this looks reasonably well in all themes\n    inside: null // see below\n\n  };\n  var insideString = {\n    'bash': commandAfterHeredoc,\n    'environment': {\n      pattern: RegExp('\\\\$' + envVars),\n      alias: 'constant'\n    },\n    'variable': [// [0]: Arithmetic Environment\n    {\n      pattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,\n      greedy: true,\n      inside: {\n        // If there is a $ sign at the beginning highlight $(( and )) as variable\n        'variable': [{\n          pattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/,\n          lookbehind: true\n        }, /^\\$\\(\\(/],\n        'number': /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,\n        // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic\n        'operator': /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,\n        // If there is no $ sign at the beginning highlight (( and )) as punctuation\n        'punctuation': /\\(\\(?|\\)\\)?|,|;/\n      }\n    }, // [1]: Command Substitution\n    {\n      pattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|`[^`]+`/,\n      greedy: true,\n      inside: {\n        'variable': /^\\$\\(|^`|\\)$|`$/\n      }\n    }, // [2]: Brace expansion\n    {\n      pattern: /\\$\\{[^}]+\\}/,\n      greedy: true,\n      inside: {\n        'operator': /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,\n        'punctuation': /[\\[\\]]/,\n        'environment': {\n          pattern: RegExp('(\\\\{)' + envVars),\n          lookbehind: true,\n          alias: 'constant'\n        }\n      }\n    }, /\\$(?:\\w+|[#?*!@$])/],\n    // Escape sequences from echo and printf's manuals, and escaped quotes.\n    'entity': /\\\\(?:[abceEfnrtv\\\\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/\n  };\n  Prism.languages.bash = {\n    'shebang': {\n      pattern: /^#!\\s*\\/.*/,\n      alias: 'important'\n    },\n    'comment': {\n      pattern: /(^|[^\"{\\\\$])#.*/,\n      lookbehind: true\n    },\n    'function-name': [// a) function foo {\n    // b) foo() {\n    // c) function foo() {\n    // but not \u201cfoo {\u201d\n    {\n      // a) and c)\n      pattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,\n      lookbehind: true,\n      alias: 'function'\n    }, {\n      // b)\n      pattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/,\n      alias: 'function'\n    }],\n    // Highlight variable names as variables in for and select beginnings.\n    'for-or-select': {\n      pattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,\n      alias: 'variable',\n      lookbehind: true\n    },\n    // Highlight variable names as variables in the left-hand part\n    // of assignments (\u201c=\u201d and \u201c+=\u201d).\n    'assign-left': {\n      pattern: /(^|[\\s;|&]|[<>]\\()\\w+(?=\\+?=)/,\n      inside: {\n        'environment': {\n          pattern: RegExp('(^|[\\\\s;|&]|[<>]\\\\()' + envVars),\n          lookbehind: true,\n          alias: 'constant'\n        }\n      },\n      alias: 'variable',\n      lookbehind: true\n    },\n    'string': [// Support for Here-documents https://en.wikipedia.org/wiki/Here_document\n    {\n      pattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,\n      lookbehind: true,\n      greedy: true,\n      inside: insideString\n    }, // Here-document with quotes around the tag\n    // \u2192 No expansion (so no \u201cinside\u201d).\n    {\n      pattern: /((?:^|[^<])<<-?\\s*)([\"'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'bash': commandAfterHeredoc\n      }\n    }, // \u201cNormal\u201d string\n    {\n      // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n      pattern: /(^|[^\\\\](?:\\\\\\\\)*)\"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|`[^`]+`|[^\"\\\\`$])*\"/,\n      lookbehind: true,\n      greedy: true,\n      inside: insideString\n    }, {\n      // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html\n      pattern: /(^|[^$\\\\])'[^']*'/,\n      lookbehind: true,\n      greedy: true\n    }, {\n      // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html\n      pattern: /\\$'(?:[^'\\\\]|\\\\[\\s\\S])*'/,\n      greedy: true,\n      inside: {\n        'entity': insideString.entity\n      }\n    }],\n    'environment': {\n      pattern: RegExp('\\\\$?' + envVars),\n      alias: 'constant'\n    },\n    'variable': insideString.variable,\n    'function': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,\n      lookbehind: true\n    },\n    'keyword': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\\s;|&])/,\n      lookbehind: true\n    },\n    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n    'builtin': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:\\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\\s;|&])/,\n      lookbehind: true,\n      // Alias added to make those easier to distinguish from strings.\n      alias: 'class-name'\n    },\n    'boolean': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:false|true)(?=$|[)\\s;|&])/,\n      lookbehind: true\n    },\n    'file-descriptor': {\n      pattern: /\\B&\\d\\b/,\n      alias: 'important'\n    },\n    'operator': {\n      // Lots of redirections here, but not just that.\n      pattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,\n      inside: {\n        'file-descriptor': {\n          pattern: /^\\d/,\n          alias: 'important'\n        }\n      }\n    },\n    'punctuation': /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,\n    'number': {\n      pattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/,\n      lookbehind: true\n    }\n  };\n  commandAfterHeredoc.inside = Prism.languages.bash;\n  /* Patterns in command substitution. */\n\n  var toBeCopied = ['comment', 'function-name', 'for-or-select', 'assign-left', 'string', 'environment', 'function', 'keyword', 'builtin', 'boolean', 'file-descriptor', 'operator', 'punctuation', 'number'];\n  var inside = insideString.variable[1].inside;\n\n  for (var i = 0; i < toBeCopied.length; i++) {\n    inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];\n  }\n\n  Prism.languages.shell = Prism.languages.bash;\n})(prism);\n/* \"prismjs/components/prism-clike\" */\n\n\nprism.languages.clike = {\n  'comment': [{\n    pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    lookbehind: true,\n    greedy: true\n  }, {\n    pattern: /(^|[^\\\\:])\\/\\/.*/,\n    lookbehind: true,\n    greedy: true\n  }],\n  'string': {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true\n  },\n  'class-name': {\n    pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n    lookbehind: true,\n    inside: {\n      'punctuation': /[.\\\\]/\n    }\n  },\n  'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n  'boolean': /\\b(?:false|true)\\b/,\n  'function': /\\b\\w+(?=\\()/,\n  'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n  'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n  'punctuation': /[{}[\\];(),.:]/\n};\n/* \"prismjs/components/prism-c\" */\n\nprism.languages.c = prism.languages.extend('clike', {\n  'comment': {\n    pattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    greedy: true\n  },\n  'string': {\n    // https://en.cppreference.com/w/c/language/string_literal\n    pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n    greedy: true\n  },\n  'class-name': {\n    pattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n    lookbehind: true\n  },\n  'keyword': /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n  'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n  'number': /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n  'operator': />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n});\nprism.languages.insertBefore('c', 'string', {\n  'char': {\n    // https://en.cppreference.com/w/c/language/character_constant\n    pattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n    greedy: true\n  }\n});\nprism.languages.insertBefore('c', 'string', {\n  'macro': {\n    // allow for multiline macro definitions\n    // spaces after the # character compile fine with gcc\n    pattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n    lookbehind: true,\n    greedy: true,\n    alias: 'property',\n    inside: {\n      'string': [{\n        // highlight the path of the include statement as a string\n        pattern: /^(#\\s*include\\s*)<[^>]+>/,\n        lookbehind: true\n      }, prism.languages.c['string']],\n      'char': prism.languages.c['char'],\n      'comment': prism.languages.c['comment'],\n      'macro-name': [{\n        pattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n        lookbehind: true\n      }, {\n        pattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n        lookbehind: true,\n        alias: 'function'\n      }],\n      // highlight macro directives as keywords\n      'directive': {\n        pattern: /^(#\\s*)[a-z]+/,\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      'directive-hash': /^#/,\n      'punctuation': /##|\\\\(?=[\\r\\n])/,\n      'expression': {\n        pattern: /\\S[\\s\\S]*/,\n        inside: prism.languages.c\n      }\n    }\n  }\n});\nprism.languages.insertBefore('c', 'function', {\n  // highlight predefined macros as constants\n  'constant': /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n});\ndelete prism.languages.c['boolean'];\n/* \"prismjs/components/prism-cpp\" */\n\n(function (Prism) {\n  var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n  var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () {\n    return keyword.source;\n  });\n  Prism.languages.cpp = Prism.languages.extend('c', {\n    'class-name': [{\n      pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function () {\n        return keyword.source;\n      })),\n      lookbehind: true\n    }, // This is intended to capture the class name of method implementations like:\n    //   void foo::bar() const {}\n    // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n    // it starts with an uppercase letter. This approximation should give decent results.\n    /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/, // This will capture the class name before destructors like:\n    //   Foo::~Foo() {}\n    /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i, // This also intends to capture the class name of method implementations but here the class has template\n    // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n    /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],\n    'keyword': keyword,\n    'number': {\n      pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n      greedy: true\n    },\n    'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n    'boolean': /\\b(?:false|true)\\b/\n  });\n  Prism.languages.insertBefore('cpp', 'string', {\n    'module': {\n      // https://en.cppreference.com/w/cpp/language/modules\n      pattern: RegExp(/(\\b(?:import|module)\\s+)/.source + '(?:' + // header-name\n      /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + '|' + // module name or partition or both\n      /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () {\n        return modName;\n      }) + ')'),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'string': /^[<\"][\\s\\S]+/,\n        'operator': /:/,\n        'punctuation': /\\./\n      }\n    },\n    'raw-string': {\n      pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n      alias: 'string',\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'keyword', {\n    'generic-function': {\n      pattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n      inside: {\n        'function': /^\\w+/,\n        'generic': {\n          pattern: /<[\\s\\S]+/,\n          alias: 'class-name',\n          inside: Prism.languages.cpp\n        }\n      }\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'operator', {\n    'double-colon': {\n      pattern: /::/,\n      alias: 'punctuation'\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'class-name', {\n    // the base clause is an optional list of parent classes\n    // https://en.cppreference.com/w/cpp/language/class\n    'base-clause': {\n      pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n      lookbehind: true,\n      greedy: true,\n      inside: Prism.languages.extend('cpp', {})\n    }\n  });\n  Prism.languages.insertBefore('inside', 'double-colon', {\n    // All untokenized words that are not namespaces should be class names\n    'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n  }, Prism.languages.cpp['base-clause']);\n})(prism);\n/* \"prismjs/components/prism-css\" */\n\n\n(function (Prism) {\n  var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n  Prism.languages.css = {\n    'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n    'atrule': {\n      pattern: /@[\\w-](?:[^;{\\s]|\\s+(?![\\s{]))*(?:;|(?=\\s*\\{))/,\n      inside: {\n        'rule': /^@[\\w-]+/,\n        'selector-function-argument': {\n          pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n          lookbehind: true,\n          alias: 'selector'\n        },\n        'keyword': {\n          pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n          lookbehind: true\n        } // See rest below\n\n      }\n    },\n    'url': {\n      // https://drafts.csswg.org/css-values-3/#urls\n      pattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n      greedy: true,\n      inside: {\n        'function': /^url/i,\n        'punctuation': /^\\(|\\)$/,\n        'string': {\n          pattern: RegExp('^' + string.source + '$'),\n          alias: 'url'\n        }\n      }\n    },\n    'selector': {\n      pattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n      lookbehind: true\n    },\n    'string': {\n      pattern: string,\n      greedy: true\n    },\n    'property': {\n      pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n      lookbehind: true\n    },\n    'important': /!important\\b/i,\n    'function': {\n      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n      lookbehind: true\n    },\n    'punctuation': /[(){};:,]/\n  };\n  Prism.languages.css['atrule'].inside.rest = Prism.languages.css;\n  var markup = Prism.languages.markup;\n\n  if (markup) {\n    markup.tag.addInlined('style', 'css');\n    markup.tag.addAttribute('style', 'css');\n  }\n})(prism);\n/* \"prismjs/components/prism-css-extras\" */\n\n\n(function (Prism) {\n  var string = /(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/;\n  var selectorInside;\n  Prism.languages.css.selector = {\n    pattern: Prism.languages.css.selector.pattern,\n    lookbehind: true,\n    inside: selectorInside = {\n      'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/,\n      'pseudo-class': /:[-\\w]+/,\n      'class': /\\.[-\\w]+/,\n      'id': /#[-\\w]+/,\n      'attribute': {\n        pattern: RegExp('\\\\[(?:[^[\\\\]\"\\']|' + string.source + ')*\\\\]'),\n        greedy: true,\n        inside: {\n          'punctuation': /^\\[|\\]$/,\n          'case-sensitivity': {\n            pattern: /(\\s)[si]$/i,\n            lookbehind: true,\n            alias: 'keyword'\n          },\n          'namespace': {\n            pattern: /^(\\s*)(?:(?!\\s)[-*\\w\\xA0-\\uFFFF])*\\|(?!=)/,\n            lookbehind: true,\n            inside: {\n              'punctuation': /\\|$/\n            }\n          },\n          'attr-name': {\n            pattern: /^(\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+/,\n            lookbehind: true\n          },\n          'attr-value': [string, {\n            pattern: /(=\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+(?=\\s*$)/,\n            lookbehind: true\n          }],\n          'operator': /[|~*^$]?=/\n        }\n      },\n      'n-th': [{\n        pattern: /(\\(\\s*)[+-]?\\d*[\\dn](?:\\s*[+-]\\s*\\d+)?(?=\\s*\\))/,\n        lookbehind: true,\n        inside: {\n          'number': /[\\dn]+/,\n          'operator': /[+-]/\n        }\n      }, {\n        pattern: /(\\(\\s*)(?:even|odd)(?=\\s*\\))/i,\n        lookbehind: true\n      }],\n      'combinator': />|\\+|~|\\|\\|/,\n      // the `tag` token has been existed and removed.\n      // because we can't find a perfect tokenize to match it.\n      // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.\n      'punctuation': /[(),]/\n    }\n  };\n  Prism.languages.css['atrule'].inside['selector-function-argument'].inside = selectorInside;\n  Prism.languages.insertBefore('css', 'property', {\n    'variable': {\n      pattern: /(^|[^-\\w\\xA0-\\uFFFF])--(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*/i,\n      lookbehind: true\n    }\n  });\n  var unit = {\n    pattern: /(\\b\\d+)(?:%|[a-z]+(?![\\w-]))/,\n    lookbehind: true\n  }; // 123 -123 .123 -.123 12.3 -12.3\n\n  var number = {\n    pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n    lookbehind: true\n  };\n  Prism.languages.insertBefore('css', 'function', {\n    'operator': {\n      pattern: /(\\s)[+\\-*\\/](?=\\s)/,\n      lookbehind: true\n    },\n    // CAREFUL!\n    // Previewers and Inline color use hexcode and color.\n    'hexcode': {\n      pattern: /\\B#[\\da-f]{3,8}\\b/i,\n      alias: 'color'\n    },\n    'color': [{\n      pattern: /(^|[^\\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\\w-])/i,\n      lookbehind: true\n    }, {\n      pattern: /\\b(?:hsl|rgb)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:hsl|rgb)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n      inside: {\n        'unit': unit,\n        'number': number,\n        'function': /[\\w-]+(?=\\()/,\n        'punctuation': /[(),]/\n      }\n    }],\n    // it's important that there is no boundary assertion after the hex digits\n    'entity': /\\\\[\\da-f]{1,8}/i,\n    'unit': unit,\n    'number': number\n  });\n})(prism);\n/* \"prismjs/components/prism-javascript\" */\n\n\nprism.languages.javascript = prism.languages.extend('clike', {\n  'class-name': [prism.languages.clike['class-name'], {\n    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n    lookbehind: true\n  }],\n  'keyword': [{\n    pattern: /((?:^|\\})\\s*)catch\\b/,\n    lookbehind: true\n  }, {\n    pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n    lookbehind: true\n  }],\n  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n  'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n  'number': {\n    pattern: RegExp(/(^|[^\\w$])/.source + '(?:' + ( // constant\n    /NaN|Infinity/.source + '|' + // binary integer\n    /0[bB][01]+(?:_[01]+)*n?/.source + '|' + // octal integer\n    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + '|' + // hexadecimal integer\n    /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + '|' + // decimal bigint\n    /\\d+(?:_\\d+)*n/.source + '|' + // decimal number (integer or float) but no bigint\n    /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + ')' + /(?![\\w$])/.source),\n    lookbehind: true\n  },\n  'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\nprism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\nprism.languages.insertBefore('javascript', 'keyword', {\n  'regex': {\n    // eslint-disable-next-line regexp/no-dupe-characters-character-class\n    pattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)\\/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/,\n    lookbehind: true,\n    greedy: true,\n    inside: {\n      'regex-source': {\n        pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n        lookbehind: true,\n        alias: 'language-regex',\n        inside: prism.languages.regex\n      },\n      'regex-delimiter': /^\\/|\\/$/,\n      'regex-flags': /^[a-z]+$/\n    }\n  },\n  // This must be declared before keyword because we use \"function\" inside the look-forward\n  'function-variable': {\n    pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n    alias: 'function'\n  },\n  'parameter': [{\n    pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }, {\n    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }, {\n    pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }, {\n    pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }],\n  'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nprism.languages.insertBefore('javascript', 'string', {\n  'hashbang': {\n    pattern: /^#!.*/,\n    greedy: true,\n    alias: 'comment'\n  },\n  'template-string': {\n    pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n    greedy: true,\n    inside: {\n      'template-punctuation': {\n        pattern: /^`|`$/,\n        alias: 'string'\n      },\n      'interpolation': {\n        pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n        lookbehind: true,\n        inside: {\n          'interpolation-punctuation': {\n            pattern: /^\\$\\{|\\}$/,\n            alias: 'punctuation'\n          },\n          rest: prism.languages.javascript\n        }\n      },\n      'string': /[\\s\\S]+/\n    }\n  },\n  'string-property': {\n    pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n    lookbehind: true,\n    greedy: true,\n    alias: 'property'\n  }\n});\nprism.languages.insertBefore('javascript', 'operator', {\n  'literal-property': {\n    pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n    lookbehind: true,\n    alias: 'property'\n  }\n});\n\nif (prism.languages.markup) {\n  prism.languages.markup.tag.addInlined('script', 'javascript'); // add attribute support for all DOM events.\n  // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\n  prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, 'javascript');\n}\n\nprism.languages.js = prism.languages.javascript;\n/* \"prismjs/components/prism-coffeescript\" */\n\n(function (Prism) {\n  // Ignore comments starting with { to privilege string interpolation highlighting\n  var comment = /#(?!\\{).+/;\n  var interpolation = {\n    pattern: /#\\{[^}]+\\}/,\n    alias: 'variable'\n  };\n  Prism.languages.coffeescript = Prism.languages.extend('javascript', {\n    'comment': comment,\n    'string': [// Strings are multiline\n    {\n      pattern: /'(?:\\\\[\\s\\S]|[^\\\\'])*'/,\n      greedy: true\n    }, {\n      // Strings are multiline\n      pattern: /\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"/,\n      greedy: true,\n      inside: {\n        'interpolation': interpolation\n      }\n    }],\n    'keyword': /\\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\\b/,\n    'class-member': {\n      pattern: /@(?!\\d)\\w+/,\n      alias: 'variable'\n    }\n  });\n  Prism.languages.insertBefore('coffeescript', 'comment', {\n    'multiline-comment': {\n      pattern: /###[\\s\\S]+?###/,\n      alias: 'comment'\n    },\n    // Block regexp can contain comments and interpolation\n    'block-regex': {\n      pattern: /\\/{3}[\\s\\S]*?\\/{3}/,\n      alias: 'regex',\n      inside: {\n        'comment': comment,\n        'interpolation': interpolation\n      }\n    }\n  });\n  Prism.languages.insertBefore('coffeescript', 'string', {\n    'inline-javascript': {\n      pattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\n      inside: {\n        'delimiter': {\n          pattern: /^`|`$/,\n          alias: 'punctuation'\n        },\n        'script': {\n          pattern: /[\\s\\S]+/,\n          alias: 'language-javascript',\n          inside: Prism.languages.javascript\n        }\n      }\n    },\n    // Block strings\n    'multiline-string': [{\n      pattern: /'''[\\s\\S]*?'''/,\n      greedy: true,\n      alias: 'string'\n    }, {\n      pattern: /\"\"\"[\\s\\S]*?\"\"\"/,\n      greedy: true,\n      alias: 'string',\n      inside: {\n        interpolation: interpolation\n      }\n    }]\n  });\n  Prism.languages.insertBefore('coffeescript', 'keyword', {\n    // Object property\n    'property': /(?!\\d)\\w+(?=\\s*:(?!:))/\n  });\n  delete Prism.languages.coffeescript['template-string'];\n  Prism.languages.coffee = Prism.languages.coffeescript;\n})(prism);\n/* \"prismjs/components/prism-yaml\" */\n\n\n(function (Prism) {\n  // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property\n  // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node\n  var anchorOrAlias = /[*&][^\\s[\\]{},]+/; // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property\n\n  var tag = /!(?:<[\\w\\-%#;/?:@&=+$,.!~*'()[\\]]+>|(?:[a-zA-Z\\d-]*!)?[\\w\\-%#;/?:@&=+$.~*'()]+)?/; // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)\n\n  var properties = '(?:' + tag.source + '(?:[ \\t]+' + anchorOrAlias.source + ')?|' + anchorOrAlias.source + '(?:[ \\t]+' + tag.source + ')?)'; // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)\n  // This is a simplified version that doesn't support \"#\" and multiline keys\n  // All these long scarry character classes are simplified versions of YAML's characters\n\n  var plainKey = /(?:[^\\s\\x00-\\x08\\x0e-\\x1f!\"#%&'*,\\-:>?@[\\]`{|}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]|[?:-]<PLAIN>)(?:[ \\t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function () {\n    return /[^\\s\\x00-\\x08\\x0e-\\x1f,[\\]{}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]/.source;\n  });\n  var string = /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"|'(?:[^'\\\\\\r\\n]|\\\\.)*'/.source;\n  /**\n   *\n   * @param {string} value\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */\n\n  function createValuePattern(value, flags) {\n    flags = (flags || '').replace(/m/g, '') + 'm'; // add m flag\n\n    var pattern = /([:\\-,[{]\\s*(?:\\s<<prop>>[ \\t]+)?)(?:<<value>>)(?=[ \\t]*(?:$|,|\\]|\\}|(?:[\\r\\n]\\s*)?#))/.source.replace(/<<prop>>/g, function () {\n      return properties;\n    }).replace(/<<value>>/g, function () {\n      return value;\n    });\n    return RegExp(pattern, flags);\n  }\n\n  Prism.languages.yaml = {\n    'scalar': {\n      pattern: RegExp(/([\\-:]\\s*(?:\\s<<prop>>[ \\t]+)?[|>])[ \\t]*(?:((?:\\r?\\n|\\r)[ \\t]+)\\S[^\\r\\n]*(?:\\2[^\\r\\n]+)*)/.source.replace(/<<prop>>/g, function () {\n        return properties;\n      })),\n      lookbehind: true,\n      alias: 'string'\n    },\n    'comment': /#.*/,\n    'key': {\n      pattern: RegExp(/((?:^|[:\\-,[{\\r\\n?])[ \\t]*(?:<<prop>>[ \\t]+)?)<<key>>(?=\\s*:\\s)/.source.replace(/<<prop>>/g, function () {\n        return properties;\n      }).replace(/<<key>>/g, function () {\n        return '(?:' + plainKey + '|' + string + ')';\n      })),\n      lookbehind: true,\n      greedy: true,\n      alias: 'atrule'\n    },\n    'directive': {\n      pattern: /(^[ \\t]*)%.+/m,\n      lookbehind: true,\n      alias: 'important'\n    },\n    'datetime': {\n      pattern: createValuePattern(/\\d{4}-\\d\\d?-\\d\\d?(?:[tT]|[ \\t]+)\\d\\d?:\\d{2}:\\d{2}(?:\\.\\d*)?(?:[ \\t]*(?:Z|[-+]\\d\\d?(?::\\d{2})?))?|\\d{4}-\\d{2}-\\d{2}|\\d\\d?:\\d{2}(?::\\d{2}(?:\\.\\d*)?)?/.source),\n      lookbehind: true,\n      alias: 'number'\n    },\n    'boolean': {\n      pattern: createValuePattern(/false|true/.source, 'i'),\n      lookbehind: true,\n      alias: 'important'\n    },\n    'null': {\n      pattern: createValuePattern(/null|~/.source, 'i'),\n      lookbehind: true,\n      alias: 'important'\n    },\n    'string': {\n      pattern: createValuePattern(string),\n      lookbehind: true,\n      greedy: true\n    },\n    'number': {\n      pattern: createValuePattern(/[+-]?(?:0x[\\da-f]+|0o[0-7]+|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?|\\.inf|\\.nan)/.source, 'i'),\n      lookbehind: true\n    },\n    'tag': tag,\n    'important': anchorOrAlias,\n    'punctuation': /---|[:[\\]{}\\-,|>?]|\\.\\.\\./\n  };\n  Prism.languages.yml = Prism.languages.yaml;\n})(prism);\n/* \"prismjs/components/prism-markdown\" */\n\n\n(function (Prism) {\n  // Allow only one line break\n  var inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n  /**\n   * This function is intended for the creation of the bold or italic pattern.\n   *\n   * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n   *\n   * _Note:_ Keep in mind that this adds a capturing group.\n   *\n   * @param {string} pattern\n   * @returns {RegExp}\n   */\n\n  function createInline(pattern) {\n    pattern = pattern.replace(/<inner>/g, function () {\n      return inner;\n    });\n    return RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + '(?:' + pattern + ')');\n  }\n\n  var tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n  var tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function () {\n    return tableCell;\n  });\n  var tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n  Prism.languages.markdown = Prism.languages.extend('markup', {});\n  Prism.languages.insertBefore('markdown', 'prolog', {\n    'front-matter-block': {\n      pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'punctuation': /^---|---$/,\n        'front-matter': {\n          pattern: /\\S+(?:\\s+\\S+)*/,\n          alias: ['yaml', 'language-yaml'],\n          inside: Prism.languages.yaml\n        }\n      }\n    },\n    'blockquote': {\n      // > ...\n      pattern: /^>(?:[\\t ]*>)*/m,\n      alias: 'punctuation'\n    },\n    'table': {\n      pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),\n      inside: {\n        'table-data-rows': {\n          pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),\n          lookbehind: true,\n          inside: {\n            'table-data': {\n              pattern: RegExp(tableCell),\n              inside: Prism.languages.markdown\n            },\n            'punctuation': /\\|/\n          }\n        },\n        'table-line': {\n          pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),\n          lookbehind: true,\n          inside: {\n            'punctuation': /\\||:?-{3,}:?/\n          }\n        },\n        'table-header-row': {\n          pattern: RegExp('^' + tableRow + '$'),\n          inside: {\n            'table-header': {\n              pattern: RegExp(tableCell),\n              alias: 'important',\n              inside: Prism.languages.markdown\n            },\n            'punctuation': /\\|/\n          }\n        }\n      }\n    },\n    'code': [{\n      // Prefixed by 4 spaces or 1 tab and preceded by an empty line\n      pattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n      lookbehind: true,\n      alias: 'keyword'\n    }, {\n      // ```optional language\n      // code block\n      // ```\n      pattern: /^```[\\s\\S]*?^```$/m,\n      greedy: true,\n      inside: {\n        'code-block': {\n          pattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n          lookbehind: true\n        },\n        'code-language': {\n          pattern: /^(```).+/,\n          lookbehind: true\n        },\n        'punctuation': /```/\n      }\n    }],\n    'title': [{\n      // title 1\n      // =======\n      // title 2\n      // -------\n      pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n      alias: 'important',\n      inside: {\n        punctuation: /==+$|--+$/\n      }\n    }, {\n      // # title 1\n      // ###### title 6\n      pattern: /(^\\s*)#.+/m,\n      lookbehind: true,\n      alias: 'important',\n      inside: {\n        punctuation: /^#+|#+$/\n      }\n    }],\n    'hr': {\n      // ***\n      // ---\n      // * * *\n      // -----------\n      pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n      lookbehind: true,\n      alias: 'punctuation'\n    },\n    'list': {\n      // * item\n      // + item\n      // - item\n      // 1. item\n      pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n      lookbehind: true,\n      alias: 'punctuation'\n    },\n    'url-reference': {\n      // [id]: http://example.com \"Optional title\"\n      // [id]: http://example.com 'Optional title'\n      // [id]: http://example.com (Optional title)\n      // [id]: <http://example.com> \"Optional title\"\n      pattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n      inside: {\n        'variable': {\n          pattern: /^(!?\\[)[^\\]]+/,\n          lookbehind: true\n        },\n        'string': /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n        'punctuation': /^[\\[\\]!:]|[<>]/\n      },\n      alias: 'url'\n    },\n    'bold': {\n      // **strong**\n      // __strong__\n      // allow one nested instance of italic text using the same delimiter\n      pattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'content': {\n          pattern: /(^..)[\\s\\S]+(?=..$)/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'punctuation': /\\*\\*|__/\n      }\n    },\n    'italic': {\n      // *em*\n      // _em_\n      // allow one nested instance of bold text using the same delimiter\n      pattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'content': {\n          pattern: /(^.)[\\s\\S]+(?=.$)/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'punctuation': /[*_]/\n      }\n    },\n    'strike': {\n      // ~~strike through~~\n      // ~strike~\n      // eslint-disable-next-line regexp/strict\n      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'content': {\n          pattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'punctuation': /~~?/\n      }\n    },\n    'code-snippet': {\n      // `code`\n      // ``code``\n      pattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n      lookbehind: true,\n      greedy: true,\n      alias: ['code', 'keyword']\n    },\n    'url': {\n      // [example](http://example.com \"Optional title\")\n      // [example][id]\n      // [example] [id]\n      pattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'operator': /^!/,\n        'content': {\n          pattern: /(^\\[)[^\\]]+(?=\\])/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'variable': {\n          pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n          lookbehind: true\n        },\n        'url': {\n          pattern: /(^\\]\\()[^\\s)]+/,\n          lookbehind: true\n        },\n        'string': {\n          pattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n          lookbehind: true\n        }\n      }\n    }\n  });\n  ['url', 'bold', 'italic', 'strike'].forEach(function (token) {\n    ['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {\n      if (token !== inside) {\n        Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];\n      }\n    });\n  });\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'markdown' && env.language !== 'md') {\n      return;\n    }\n\n    function walkTokens(tokens) {\n      if (!tokens || typeof tokens === 'string') {\n        return;\n      }\n\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (token.type !== 'code') {\n          walkTokens(token.content);\n          continue;\n        }\n        /*\n         * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n         * is optional. But the grammar is defined so that there is only one case we have to handle:\n         *\n         * token.content = [\n         *     <span class=\"punctuation\">```</span>,\n         *     <span class=\"code-language\">xxxx</span>,\n         *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n         *     <span class=\"code-block\">...</span>,\n         *     '\\n', // exactly one new lines again\n         *     <span class=\"punctuation\">```</span>\n         * ];\n         */\n\n\n        var codeLang = token.content[1];\n        var codeBlock = token.content[3];\n\n        if (codeLang && codeBlock && codeLang.type === 'code-language' && codeBlock.type === 'code-block' && typeof codeLang.content === 'string') {\n          // this might be a language that Prism does not support\n          // do some replacements to support C++, C#, and F#\n          var lang = codeLang.content.replace(/\\b#/g, 'sharp').replace(/\\b\\+\\+/g, 'pp'); // only use the first word\n\n          lang = (/[a-z][\\w-]*/i.exec(lang) || [''])[0].toLowerCase();\n          var alias = 'language-' + lang; // add alias\n\n          if (!codeBlock.alias) {\n            codeBlock.alias = [alias];\n          } else if (typeof codeBlock.alias === 'string') {\n            codeBlock.alias = [codeBlock.alias, alias];\n          } else {\n            codeBlock.alias.push(alias);\n          }\n        }\n      }\n    }\n\n    walkTokens(env.tokens);\n  });\n  Prism.hooks.add('wrap', function (env) {\n    if (env.type !== 'code-block') {\n      return;\n    }\n\n    var codeLang = '';\n\n    for (var i = 0, l = env.classes.length; i < l; i++) {\n      var cls = env.classes[i];\n      var match = /language-(.+)/.exec(cls);\n\n      if (match) {\n        codeLang = match[1];\n        break;\n      }\n    }\n\n    var grammar = Prism.languages[codeLang];\n\n    if (!grammar) {\n      if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {\n        var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);\n        env.attributes['id'] = id;\n        Prism.plugins.autoloader.loadLanguages(codeLang, function () {\n          var ele = document.getElementById(id);\n\n          if (ele) {\n            ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);\n          }\n        });\n      }\n    } else {\n      env.content = Prism.highlight(textContent(env.content), grammar, codeLang);\n    }\n  });\n  var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');\n  /**\n   * A list of known entity names.\n   *\n   * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n   *\n   * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n   */\n\n  var KNOWN_ENTITY_NAMES = {\n    'amp': '&',\n    'lt': '<',\n    'gt': '>',\n    'quot': '\"'\n  }; // IE 11 doesn't support `String.fromCodePoint`\n\n  var fromCodePoint = String.fromCodePoint || String.fromCharCode;\n  /**\n   * Returns the text content of a given HTML source code string.\n   *\n   * @param {string} html\n   * @returns {string}\n   */\n\n  function textContent(html) {\n    // remove all tags\n    var text = html.replace(tagPattern, ''); // decode known entities\n\n    text = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (m, code) {\n      code = code.toLowerCase();\n\n      if (code[0] === '#') {\n        var value;\n\n        if (code[1] === 'x') {\n          value = parseInt(code.slice(2), 16);\n        } else {\n          value = Number(code.slice(1));\n        }\n\n        return fromCodePoint(value);\n      } else {\n        var known = KNOWN_ENTITY_NAMES[code];\n\n        if (known) {\n          return known;\n        } // unable to decode\n\n\n        return m;\n      }\n    });\n    return text;\n  }\n\n  Prism.languages.md = Prism.languages.markdown;\n})(prism);\n/* \"prismjs/components/prism-graphql\" */\n\n\nprism.languages.graphql = {\n  'comment': /#.*/,\n  'description': {\n    pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n    greedy: true,\n    alias: 'string',\n    inside: {\n      'language-markdown': {\n        pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n        lookbehind: true,\n        inside: prism.languages.markdown\n      }\n    }\n  },\n  'string': {\n    pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n    greedy: true\n  },\n  'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'boolean': /\\b(?:false|true)\\b/,\n  'variable': /\\$[a-z_]\\w*/i,\n  'directive': {\n    pattern: /@[a-z_]\\w*/i,\n    alias: 'function'\n  },\n  'attr-name': {\n    pattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n    greedy: true\n  },\n  'atom-input': {\n    pattern: /\\b[A-Z]\\w*Input\\b/,\n    alias: 'class-name'\n  },\n  'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n  'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n  'class-name': {\n    pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n    lookbehind: true\n  },\n  'fragment': {\n    pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-mutation': {\n    pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-query': {\n    pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n  'operator': /[!=|&]|\\.{3}/,\n  'property-query': /\\w+(?=\\s*\\()/,\n  'object': /\\w+(?=\\s*\\{)/,\n  'punctuation': /[!(){}\\[\\]:=,]/,\n  'property': /\\w+/\n};\nprism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n  if (env.language !== 'graphql') {\n    return;\n  }\n  /**\n   * get the graphql token stream that we want to customize\n   *\n   * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n   * @type {Token[]}\n   */\n\n\n  var validTokens = env.tokens.filter(function (token) {\n    return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n  });\n  var currentIndex = 0;\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {number} offset\n   * @returns {Token | undefined}\n   */\n\n  function getToken(offset) {\n    return validTokens[currentIndex + offset];\n  }\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {readonly string[]} types\n   * @param {number} [offset=0]\n   * @returns {boolean}\n   */\n\n\n  function isTokenType(types, offset) {\n    offset = offset || 0;\n\n    for (var i = 0; i < types.length; i++) {\n      var token = getToken(i + offset);\n\n      if (!token || token.type !== types[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns the index of the closing bracket to an opening bracket.\n   *\n   * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n   *\n   * If no closing bracket could be found, `-1` will be returned.\n   *\n   * @param {RegExp} open\n   * @param {RegExp} close\n   * @returns {number}\n   */\n\n\n  function findClosingBracket(open, close) {\n    var stackHeight = 1;\n\n    for (var i = currentIndex; i < validTokens.length; i++) {\n      var token = validTokens[i];\n      var content = token.content;\n\n      if (token.type === 'punctuation' && typeof content === 'string') {\n        if (open.test(content)) {\n          stackHeight++;\n        } else if (close.test(content)) {\n          stackHeight--;\n\n          if (stackHeight === 0) {\n            return i;\n          }\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Adds an alias to the given token.\n   *\n   * @param {Token} token\n   * @param {string} alias\n   * @returns {void}\n   */\n\n\n  function addAlias(token, alias) {\n    var aliases = token.alias;\n\n    if (!aliases) {\n      token.alias = aliases = [];\n    } else if (!Array.isArray(aliases)) {\n      token.alias = aliases = [aliases];\n    }\n\n    aliases.push(alias);\n  }\n\n  for (; currentIndex < validTokens.length;) {\n    var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens\n\n    if (startToken.type === 'keyword' && startToken.content === 'mutation') {\n      // any array of the names of all input variables (if any)\n      var inputVariables = [];\n\n      if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n        // definition\n        currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n        var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\n        if (definitionEnd === -1) {\n          continue;\n        } // find all input variables\n\n\n        for (; currentIndex < definitionEnd; currentIndex++) {\n          var t = getToken(0);\n\n          if (t.type === 'variable') {\n            addAlias(t, 'variable-input');\n            inputVariables.push(t.content);\n          }\n        }\n\n        currentIndex = definitionEnd + 1;\n      }\n\n      if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n        currentIndex++; // skip opening bracket\n\n        addAlias(getToken(0), 'property-mutation');\n\n        if (inputVariables.length > 0) {\n          var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\n          if (mutationEnd === -1) {\n            continue;\n          } // give references to input variables a special alias\n\n\n          for (var i = currentIndex; i < mutationEnd; i++) {\n            var varToken = validTokens[i];\n\n            if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n              addAlias(varToken, 'variable-input');\n            }\n          }\n        }\n      }\n    }\n  }\n});\n/* \"prismjs/components/prism-sql\" */\n\nprism.languages.sql = {\n  'comment': {\n    pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n    lookbehind: true\n  },\n  'variable': [{\n    pattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n    greedy: true\n  }, /@[\\w.$]+/],\n  'string': {\n    pattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n    greedy: true,\n    lookbehind: true\n  },\n  'identifier': {\n    pattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n    greedy: true,\n    lookbehind: true,\n    inside: {\n      'punctuation': /^`|`$/\n    }\n  },\n  'function': /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i,\n  // Should we highlight user defined functions too?\n  'keyword': /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n  'boolean': /\\b(?:FALSE|NULL|TRUE)\\b/i,\n  'number': /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n  'operator': /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n  'punctuation': /[;[\\]()`,.]/\n};\n/* \"prismjs/components/prism-js-templates\" */\n\n(function (Prism) {\n  var templateString = Prism.languages.javascript['template-string']; // see the pattern in prism-javascript.js\n\n  var templateLiteralPattern = templateString.pattern.source;\n  var interpolationObject = templateString.inside['interpolation'];\n  var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n  var interpolationPattern = interpolationObject.pattern.source;\n  /**\n   * Creates a new pattern to match a template string with a special tag.\n   *\n   * This will return `undefined` if there is no grammar with the given language id.\n   *\n   * @param {string} language The language id of the embedded language. E.g. `markdown`.\n   * @param {string} tag The regex pattern to match the tag.\n   * @returns {object | undefined}\n   * @example\n   * createTemplate('css', /\\bcss/.source);\n   */\n\n  function createTemplate(language, tag) {\n    if (!Prism.languages[language]) {\n      return undefined;\n    }\n\n    return {\n      pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'template-punctuation': {\n          pattern: /^`|`$/,\n          alias: 'string'\n        },\n        'embedded-code': {\n          pattern: /[\\s\\S]+/,\n          alias: language\n        }\n      }\n    };\n  }\n\n  Prism.languages.javascript['template-string'] = [// styled-jsx:\n  //   css`a { color: #25F; }`\n  // styled-components:\n  //   styled.h1`color: red;`\n  createTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), // html`<p></p>`\n  // div.innerHTML = `<p></p>`\n  createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source), // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n  createTemplate('svg', /\\bsvg/.source), // md`# h1`, markdown`## h2`\n  createTemplate('markdown', /\\b(?:markdown|md)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\n  createTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source), // sql`...`\n  createTemplate('sql', /\\bsql/.source), // vanilla template string\n  templateString].filter(Boolean);\n  /**\n   * Returns a specific placeholder literal for the given language.\n   *\n   * @param {number} counter\n   * @param {string} language\n   * @returns {string}\n   */\n\n  function getPlaceholder(counter, language) {\n    return '___' + language.toUpperCase() + '_' + counter + '___';\n  }\n  /**\n   * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n   *\n   * @param {string} code\n   * @param {any} grammar\n   * @param {string} language\n   * @returns {(string|Token)[]}\n   */\n\n\n  function tokenizeWithHooks(code, grammar, language) {\n    var env = {\n      code: code,\n      grammar: grammar,\n      language: language\n    };\n    Prism.hooks.run('before-tokenize', env);\n    env.tokens = Prism.tokenize(env.code, env.grammar);\n    Prism.hooks.run('after-tokenize', env);\n    return env.tokens;\n  }\n  /**\n   * Returns the token of the given JavaScript interpolation expression.\n   *\n   * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n   * @returns {Token}\n   */\n\n\n  function tokenizeInterpolationExpression(expression) {\n    var tempGrammar = {};\n    tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n    /** @type {Array} */\n\n    var tokens = Prism.tokenize(expression, tempGrammar);\n\n    if (tokens.length === 3) {\n      /**\n       * The token array will look like this\n       * [\n       *     [\"interpolation-punctuation\", \"${\"]\n       *     \"...\" // JavaScript expression of the interpolation\n       *     [\"interpolation-punctuation\", \"}\"]\n       * ]\n       */\n      var args = [1, 1];\n      args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n      tokens.splice.apply(tokens, args);\n    }\n\n    return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n  }\n  /**\n   * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n   *\n   * This function has 3 phases:\n   *\n   * 1. Replace all JavaScript interpolation expression with a placeholder.\n   *    The placeholder will have the syntax of a identify of the target language.\n   * 2. Tokenize the code with placeholders.\n   * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n   *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n   *    tokenized as two tokens by the grammar of the embedded language.\n   *\n   * @param {string} code\n   * @param {object} grammar\n   * @param {string} language\n   * @returns {Token}\n   */\n\n\n  function tokenizeEmbedded(code, grammar, language) {\n    // 1. First filter out all interpolations\n    // because they might be escaped, we need a lookbehind, so we use Prism\n\n    /** @type {(Token|string)[]} */\n    var _tokens = Prism.tokenize(code, {\n      'interpolation': {\n        pattern: RegExp(interpolationPattern),\n        lookbehind: true\n      }\n    }); // replace all interpolations with a placeholder which is not in the code already\n\n\n    var placeholderCounter = 0;\n    /** @type {Object<string, string>} */\n\n    var placeholderMap = {};\n\n    var embeddedCode = _tokens.map(function (token) {\n      if (typeof token === 'string') {\n        return token;\n      } else {\n        var interpolationExpression = token.content;\n        var placeholder;\n\n        while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {\n          /* noop */\n        }\n\n        placeholderMap[placeholder] = interpolationExpression;\n        return placeholder;\n      }\n    }).join(''); // 2. Tokenize the embedded code\n\n\n    var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation\n\n    var placeholders = Object.keys(placeholderMap);\n    placeholderCounter = 0;\n    /**\n     *\n     * @param {(Token|string)[]} tokens\n     * @returns {void}\n     */\n\n    function walkTokens(tokens) {\n      for (var i = 0; i < tokens.length; i++) {\n        if (placeholderCounter >= placeholders.length) {\n          return;\n        }\n\n        var token = tokens[i];\n\n        if (typeof token === 'string' || typeof token.content === 'string') {\n          var placeholder = placeholders[placeholderCounter];\n          var s = typeof token === 'string' ? token :\n          /** @type {string} */\n          token.content;\n          var index = s.indexOf(placeholder);\n\n          if (index !== -1) {\n            ++placeholderCounter;\n            var before = s.substring(0, index);\n            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n            var after = s.substring(index + placeholder.length);\n            var replacement = [];\n\n            if (before) {\n              replacement.push(before);\n            }\n\n            replacement.push(middle);\n\n            if (after) {\n              var afterTokens = [after];\n              walkTokens(afterTokens);\n              replacement.push.apply(replacement, afterTokens);\n            }\n\n            if (typeof token === 'string') {\n              tokens.splice.apply(tokens, [i, 1].concat(replacement));\n              i += replacement.length - 1;\n            } else {\n              token.content = replacement;\n            }\n          }\n        } else {\n          var content = token.content;\n\n          if (Array.isArray(content)) {\n            walkTokens(content);\n          } else {\n            walkTokens([content]);\n          }\n        }\n      }\n    }\n\n    walkTokens(embeddedTokens);\n    return new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n  }\n  /**\n   * The languages for which JS templating will handle tagged template literals.\n   *\n   * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n   */\n\n\n  var supportedLanguages = {\n    'javascript': true,\n    'js': true,\n    'typescript': true,\n    'ts': true,\n    'jsx': true,\n    'tsx': true\n  };\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (!(env.language in supportedLanguages)) {\n      return;\n    }\n    /**\n     * Finds and tokenizes all template strings with an embedded languages.\n     *\n     * @param {(Token | string)[]} tokens\n     * @returns {void}\n     */\n\n\n    function findTemplateStrings(tokens) {\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (typeof token === 'string') {\n          continue;\n        }\n\n        var content = token.content;\n\n        if (!Array.isArray(content)) {\n          if (typeof content !== 'string') {\n            findTemplateStrings([content]);\n          }\n\n          continue;\n        }\n\n        if (token.type === 'template-string') {\n          /**\n           * A JavaScript template-string token will look like this:\n           *\n           * [\"template-string\", [\n           *     [\"template-punctuation\", \"`\"],\n           *     (\n           *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n           *         or\n           *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n           *                                  It also has an alias which is the language of the embedded code.\n           *     ),\n           *     [\"template-punctuation\", \"`\"]\n           * ]]\n           */\n          var embedded = content[1];\n\n          if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n            // get string content\n            var code = stringContent(embedded);\n            var alias = embedded.alias;\n            var language = Array.isArray(alias) ? alias[0] : alias;\n            var grammar = Prism.languages[language];\n\n            if (!grammar) {\n              // the embedded language isn't registered.\n              continue;\n            }\n\n            content[1] = tokenizeEmbedded(code, grammar, language);\n          }\n        } else {\n          findTemplateStrings(content);\n        }\n      }\n    }\n\n    findTemplateStrings(env.tokens);\n  });\n  /**\n   * Returns the string content of a token or token stream.\n   *\n   * @param {string | Token | (string | Token)[]} value\n   * @returns {string}\n   */\n\n  function stringContent(value) {\n    if (typeof value === 'string') {\n      return value;\n    } else if (Array.isArray(value)) {\n      return value.map(stringContent).join('');\n    } else {\n      return stringContent(value.content);\n    }\n  }\n})(prism);\n/* \"prismjs/components/prism-typescript\" */\n\n\n(function (Prism) {\n  Prism.languages.typescript = Prism.languages.extend('javascript', {\n    'class-name': {\n      pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n      lookbehind: true,\n      greedy: true,\n      inside: null // see below\n\n    },\n    'builtin': /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/\n  }); // The keywords TypeScript adds to JavaScript\n\n  Prism.languages.typescript.keyword.push(/\\b(?:abstract|declare|is|keyof|readonly|require)\\b/, // keywords that have to be followed by an identifier\n  /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/, // This is for `import type *, {}`\n  /\\btype\\b(?=\\s*(?:[\\{*]|$))/); // doesn't work with TS because TS is too complex\n\n  delete Prism.languages.typescript['parameter'];\n  delete Prism.languages.typescript['literal-property']; // a version of typescript specifically for highlighting types\n\n  var typeInside = Prism.languages.extend('typescript', {});\n  delete typeInside['class-name'];\n  Prism.languages.typescript['class-name'].inside = typeInside;\n  Prism.languages.insertBefore('typescript', 'function', {\n    'decorator': {\n      pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n      inside: {\n        'at': {\n          pattern: /^@/,\n          alias: 'operator'\n        },\n        'function': /^[\\s\\S]+/\n      }\n    },\n    'generic-function': {\n      // e.g. foo<T extends \"bar\" | \"baz\">( ...\n      pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n      greedy: true,\n      inside: {\n        'function': /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n        'generic': {\n          pattern: /<[\\s\\S]+/,\n          // everything after the first <\n          alias: 'class-name',\n          inside: typeInside\n        }\n      }\n    }\n  });\n  Prism.languages.ts = Prism.languages.typescript;\n})(prism);\n/* \"prismjs/components/prism-js-extras\" */\n\n\n(function (Prism) {\n  Prism.languages.insertBefore('javascript', 'function-variable', {\n    'method-variable': {\n      pattern: RegExp('(\\\\.\\\\s*)' + Prism.languages.javascript['function-variable'].pattern.source),\n      lookbehind: true,\n      alias: ['function-variable', 'method', 'function', 'property-access']\n    }\n  });\n  Prism.languages.insertBefore('javascript', 'function', {\n    'method': {\n      pattern: RegExp('(\\\\.\\\\s*)' + Prism.languages.javascript['function'].source),\n      lookbehind: true,\n      alias: ['function', 'property-access']\n    }\n  });\n  Prism.languages.insertBefore('javascript', 'constant', {\n    'known-class-name': [{\n      // standard built-ins\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n      pattern: /\\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\\b/,\n      alias: 'class-name'\n    }, {\n      // errors\n      pattern: /\\b(?:[A-Z]\\w*)Error\\b/,\n      alias: 'class-name'\n    }]\n  });\n  /**\n   * Replaces the `<ID>` placeholder in the given pattern with a pattern for general JS identifiers.\n   *\n   * @param {string} source\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */\n\n  function withId(source, flags) {\n    return RegExp(source.replace(/<ID>/g, function () {\n      return /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/.source;\n    }), flags);\n  }\n\n  Prism.languages.insertBefore('javascript', 'keyword', {\n    'imports': {\n      // https://tc39.es/ecma262/#sec-imports\n      pattern: withId(/(\\bimport\\b\\s*)(?:<ID>(?:\\s*,\\s*(?:\\*\\s*as\\s+<ID>|\\{[^{}]*\\}))?|\\*\\s*as\\s+<ID>|\\{[^{}]*\\})(?=\\s*\\bfrom\\b)/.source),\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    },\n    'exports': {\n      // https://tc39.es/ecma262/#sec-exports\n      pattern: withId(/(\\bexport\\b\\s*)(?:\\*(?:\\s*as\\s+<ID>)?(?=\\s*\\bfrom\\b)|\\{[^{}]*\\})/.source),\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    }\n  });\n  Prism.languages.javascript['keyword'].unshift({\n    pattern: /\\b(?:as|default|export|from|import)\\b/,\n    alias: 'module'\n  }, {\n    pattern: /\\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\\b/,\n    alias: 'control-flow'\n  }, {\n    pattern: /\\bnull\\b/,\n    alias: ['null', 'nil']\n  }, {\n    pattern: /\\bundefined\\b/,\n    alias: 'nil'\n  });\n  Prism.languages.insertBefore('javascript', 'operator', {\n    'spread': {\n      pattern: /\\.{3}/,\n      alias: 'operator'\n    },\n    'arrow': {\n      pattern: /=>/,\n      alias: 'operator'\n    }\n  });\n  Prism.languages.insertBefore('javascript', 'punctuation', {\n    'property-access': {\n      pattern: withId(/(\\.\\s*)#?<ID>/.source),\n      lookbehind: true\n    },\n    'maybe-class-name': {\n      pattern: /(^|[^$\\w\\xA0-\\uFFFF])[A-Z][$\\w\\xA0-\\uFFFF]+/,\n      lookbehind: true\n    },\n    'dom': {\n      // this contains only a few commonly used DOM variables\n      pattern: /\\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\\b/,\n      alias: 'variable'\n    },\n    'console': {\n      pattern: /\\bconsole(?=\\s*\\.)/,\n      alias: 'class-name'\n    }\n  }); // add 'maybe-class-name' to tokens which might be a class name\n\n  var maybeClassNameTokens = ['function', 'function-variable', 'method', 'method-variable', 'property-access'];\n\n  for (var i = 0; i < maybeClassNameTokens.length; i++) {\n    var token = maybeClassNameTokens[i];\n    var value = Prism.languages.javascript[token]; // convert regex to object\n\n    if (Prism.util.type(value) === 'RegExp') {\n      value = Prism.languages.javascript[token] = {\n        pattern: value\n      };\n    } // keep in mind that we don't support arrays\n\n\n    var inside = value.inside || {};\n    value.inside = inside;\n    inside['maybe-class-name'] = /^[A-Z][\\s\\S]*/;\n  }\n})(prism);\n/* \"prismjs/components/prism-jsx\" */\n\n\n(function (Prism) {\n  var javascript = Prism.util.clone(Prism.languages.javascript);\n  var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n  var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n  var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n  /**\n   * @param {string} source\n   * @param {string} [flags]\n   */\n\n  function re(source, flags) {\n    source = source.replace(/<S>/g, function () {\n      return space;\n    }).replace(/<BRACES>/g, function () {\n      return braces;\n    }).replace(/<SPREAD>/g, function () {\n      return spread;\n    });\n    return RegExp(source, flags);\n  }\n\n  spread = re(spread).source;\n  Prism.languages.jsx = Prism.languages.extend('markup', javascript);\n  Prism.languages.jsx.tag.pattern = re(/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/.source);\n  Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/;\n  Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/;\n  Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n  Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];\n  Prism.languages.insertBefore('inside', 'attr-name', {\n    'spread': {\n      pattern: re(/<SPREAD>/.source),\n      inside: Prism.languages.jsx\n    }\n  }, Prism.languages.jsx.tag);\n  Prism.languages.insertBefore('inside', 'special-attr', {\n    'script': {\n      // Allow for two levels of nesting\n      pattern: re(/=<BRACES>/.source),\n      alias: 'language-javascript',\n      inside: {\n        'script-punctuation': {\n          pattern: /^=(?=\\{)/,\n          alias: 'punctuation'\n        },\n        rest: Prism.languages.jsx\n      }\n    }\n  }, Prism.languages.jsx.tag); // The following will handle plain text inside tags\n\n  var stringifyToken = function stringifyToken(token) {\n    if (!token) {\n      return '';\n    }\n\n    if (typeof token === 'string') {\n      return token;\n    }\n\n    if (typeof token.content === 'string') {\n      return token.content;\n    }\n\n    return token.content.map(stringifyToken).join('');\n  };\n\n  var walkTokens = function walkTokens(tokens) {\n    var openedTags = [];\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      var notTagNorBrace = false;\n\n      if (typeof token !== 'string') {\n        if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n          // We found a tag, now find its kind\n          if (token.content[0].content[0].content === '</') {\n            // Closing tag\n            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n              // Pop matching opening tag\n              openedTags.pop();\n            }\n          } else {\n            if (token.content[token.content.length - 1].content === '/>') ;else {\n              // Opening tag\n              openedTags.push({\n                tagName: stringifyToken(token.content[0].content[1]),\n                openedBraces: 0\n              });\n            }\n          }\n        } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {\n          // Here we might have entered a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces++;\n        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n          // Here we might have left a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces--;\n        } else {\n          notTagNorBrace = true;\n        }\n      }\n\n      if (notTagNorBrace || typeof token === 'string') {\n        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n          // Here we are inside a tag, and not inside a JSX context.\n          // That's plain text: drop any tokens matched.\n          var plainText = stringifyToken(token); // And merge text with adjacent text\n\n          if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n            plainText += stringifyToken(tokens[i + 1]);\n            tokens.splice(i + 1, 1);\n          }\n\n          if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n            plainText = stringifyToken(tokens[i - 1]) + plainText;\n            tokens.splice(i - 1, 1);\n            i--;\n          }\n\n          tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n        }\n      }\n\n      if (token.content && typeof token.content !== 'string') {\n        walkTokens(token.content);\n      }\n    }\n  };\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'jsx' && env.language !== 'tsx') {\n      return;\n    }\n\n    walkTokens(env.tokens);\n  });\n})(prism);\n/* \"prismjs/components/prism-diff\" */\n\n\n(function (Prism) {\n  Prism.languages.diff = {\n    'coord': [// Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n    /^(?:\\*{3}|-{3}|\\+{3}).*$/m, // Match \"@@ ... @@\" coord lines in unified diff.\n    /^@@.*@@$/m, // Match coord lines in normal diff (starts with a number).\n    /^\\d.*$/m] // deleted, inserted, unchanged, diff\n\n  };\n  /**\n   * A map from the name of a block to its line prefix.\n   *\n   * @type {Object<string, string>}\n   */\n\n  var PREFIXES = {\n    'deleted-sign': '-',\n    'deleted-arrow': '<',\n    'inserted-sign': '+',\n    'inserted-arrow': '>',\n    'unchanged': ' ',\n    'diff': '!'\n  }; // add a token for each prefix\n\n  Object.keys(PREFIXES).forEach(function (name) {\n    var prefix = PREFIXES[name];\n    var alias = [];\n\n    if (!/^\\w+$/.test(name)) {\n      // \"deleted-sign\" -> \"deleted\"\n      alias.push(/\\w+/.exec(name)[0]);\n    }\n\n    if (name === 'diff') {\n      alias.push('bold');\n    }\n\n    Prism.languages.diff[name] = {\n      pattern: RegExp('^(?:[' + prefix + '].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+', 'm'),\n      alias: alias,\n      inside: {\n        'line': {\n          pattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n          lookbehind: true\n        },\n        'prefix': {\n          pattern: /[\\s\\S]/,\n          alias: /\\w+/.exec(name)[0]\n        }\n      }\n    };\n  }); // make prefixes available to Diff plugin\n\n  Object.defineProperty(Prism.languages.diff, 'PREFIXES', {\n    value: PREFIXES\n  });\n})(prism);\n/* \"prismjs/components/prism-git\" */\n\n\nprism.languages.git = {\n  /*\n   * A simple one line comment like in a git status command\n   * For instance:\n   * $ git status\n   * # On branch infinite-scroll\n   * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,\n   * # and have 1 and 2 different commits each, respectively.\n   * nothing to commit (working directory clean)\n   */\n  'comment': /^#.*/m,\n\n  /*\n   * Regexp to match the changed lines in a git diff output. Check the example below.\n   */\n  'deleted': /^[-\u2013].*/m,\n  'inserted': /^\\+.*/m,\n\n  /*\n   * a string (double and simple quote)\n   */\n  'string': /(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\n  /*\n   * a git command. It starts with a random prompt finishing by a $, then \"git\" then some other parameters\n   * For instance:\n   * $ git add file.txt\n   */\n  'command': {\n    pattern: /^.*\\$ git .*$/m,\n    inside: {\n      /*\n       * A git command can contain a parameter starting by a single or a double dash followed by a string\n       * For instance:\n       * $ git diff --cached\n       * $ git log -p\n       */\n      'parameter': /\\s--?\\w+/\n    }\n  },\n\n  /*\n   * Coordinates displayed in a git diff command\n   * For instance:\n   * $ git diff\n   * diff --git file.txt file.txt\n   * index 6214953..1d54a52 100644\n   * --- file.txt\n   * +++ file.txt\n   * @@ -1 +1,2 @@\n   * -Here's my tetx file\n   * +Here's my text file\n   * +And this is the second line\n   */\n  'coord': /^@@.*@@$/m,\n\n  /*\n   * Match a \"commit [SHA1]\" line in a git log output.\n   * For instance:\n   * $ git log\n   * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09\n   * Author: lgiraudel\n   * Date:   Mon Feb 17 11:18:34 2014 +0100\n   *\n   *     Add of a new line\n   */\n  'commit-sha1': /^commit \\w{40}$/m\n};\n/* \"prismjs/components/prism-go\" */\n\nprism.languages.go = prism.languages.extend('clike', {\n  'string': {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"|`[^`]*`/,\n    lookbehind: true,\n    greedy: true\n  },\n  'keyword': /\\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\\b/,\n  'boolean': /\\b(?:_|false|iota|nil|true)\\b/,\n  'number': [// binary and octal integers\n  /\\b0(?:b[01_]+|o[0-7_]+)i?\\b/i, // hexadecimal integers and floats\n  /\\b0x(?:[a-f\\d_]+(?:\\.[a-f\\d_]*)?|\\.[a-f\\d_]+)(?:p[+-]?\\d+(?:_\\d+)*)?i?(?!\\w)/i, // decimal integers and floats\n  /(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?[\\d_]+)?i?(?!\\w)/i],\n  'operator': /[*\\/%^!=]=?|\\+[=+]?|-[=-]?|\\|[=|]?|&(?:=|&|\\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\\.\\.\\./,\n  'builtin': /\\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\\b/\n});\nprism.languages.insertBefore('go', 'string', {\n  'char': {\n    pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){0,10}'/,\n    greedy: true\n  }\n});\ndelete prism.languages.go['class-name'];\n/* \"prismjs/components/prism-markup-templating\" */\n\n(function (Prism) {\n  /**\n   * Returns the placeholder for the given language id and index.\n   *\n   * @param {string} language\n   * @param {string|number} index\n   * @returns {string}\n   */\n  function getPlaceholder(language, index) {\n    return '___' + language.toUpperCase() + index + '___';\n  }\n\n  Object.defineProperties(Prism.languages['markup-templating'] = {}, {\n    buildPlaceholders: {\n      /**\n       * Tokenize all inline templating expressions matching `placeholderPattern`.\n       *\n       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n       * `true` will be replaced.\n       *\n       * @param {object} env The environment of the `before-tokenize` hook.\n       * @param {string} language The language id.\n       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n       * @param {(match: string) => boolean} [replaceFilter]\n       */\n      value: function value(env, language, placeholderPattern, replaceFilter) {\n        if (env.language !== language) {\n          return;\n        }\n\n        var tokenStack = env.tokenStack = [];\n        env.code = env.code.replace(placeholderPattern, function (match) {\n          if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n            return match;\n          }\n\n          var i = tokenStack.length;\n          var placeholder; // Check for existing strings\n\n          while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n            ++i;\n          } // Create a sparse array\n\n\n          tokenStack[i] = match;\n          return placeholder;\n        }); // Switch the grammar to markup\n\n        env.grammar = Prism.languages.markup;\n      }\n    },\n    tokenizePlaceholders: {\n      /**\n       * Replace placeholders with proper tokens after tokenizing.\n       *\n       * @param {object} env The environment of the `after-tokenize` hook.\n       * @param {string} language The language id.\n       */\n      value: function value(env, language) {\n        if (env.language !== language || !env.tokenStack) {\n          return;\n        } // Switch the grammar back\n\n\n        env.grammar = Prism.languages[language];\n        var j = 0;\n        var keys = Object.keys(env.tokenStack);\n\n        function walkTokens(tokens) {\n          for (var i = 0; i < tokens.length; i++) {\n            // all placeholders are replaced already\n            if (j >= keys.length) {\n              break;\n            }\n\n            var token = tokens[i];\n\n            if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n              var k = keys[j];\n              var t = env.tokenStack[k];\n              var s = typeof token === 'string' ? token : token.content;\n              var placeholder = getPlaceholder(language, k);\n              var index = s.indexOf(placeholder);\n\n              if (index > -1) {\n                ++j;\n                var before = s.substring(0, index);\n                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n                var after = s.substring(index + placeholder.length);\n                var replacement = [];\n\n                if (before) {\n                  replacement.push.apply(replacement, walkTokens([before]));\n                }\n\n                replacement.push(middle);\n\n                if (after) {\n                  replacement.push.apply(replacement, walkTokens([after]));\n                }\n\n                if (typeof token === 'string') {\n                  tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                } else {\n                  token.content = replacement;\n                }\n              }\n            } else if (token.content\n            /* && typeof token.content !== 'string' */\n            ) {\n                walkTokens(token.content);\n              }\n          }\n\n          return tokens;\n        }\n\n        walkTokens(env.tokens);\n      }\n    }\n  });\n})(prism);\n/* \"prismjs/components/prism-handlebars\" */\n\n\n(function (Prism) {\n  Prism.languages.handlebars = {\n    'comment': /\\{\\{![\\s\\S]*?\\}\\}/,\n    'delimiter': {\n      pattern: /^\\{\\{\\{?|\\}\\}\\}?$/,\n      alias: 'punctuation'\n    },\n    'string': /([\"'])(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    'number': /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee][+-]?\\d+)?/,\n    'boolean': /\\b(?:false|true)\\b/,\n    'block': {\n      pattern: /^(\\s*(?:~\\s*)?)[#\\/]\\S+?(?=\\s*(?:~\\s*)?$|\\s)/,\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    'brackets': {\n      pattern: /\\[[^\\]]+\\]/,\n      inside: {\n        punctuation: /\\[|\\]/,\n        variable: /[\\s\\S]+/\n      }\n    },\n    'punctuation': /[!\"#%&':()*+,.\\/;<=>@\\[\\\\\\]^`{|}~]/,\n    'variable': /[^!\"#%&'()*+,\\/;<=>@\\[\\\\\\]^`{|}~\\s]+/\n  };\n  Prism.hooks.add('before-tokenize', function (env) {\n    var handlebarsPattern = /\\{\\{\\{[\\s\\S]+?\\}\\}\\}|\\{\\{[\\s\\S]+?\\}\\}/g;\n    Prism.languages['markup-templating'].buildPlaceholders(env, 'handlebars', handlebarsPattern);\n  });\n  Prism.hooks.add('after-tokenize', function (env) {\n    Prism.languages['markup-templating'].tokenizePlaceholders(env, 'handlebars');\n  });\n  Prism.languages.hbs = Prism.languages.handlebars;\n})(prism);\n/* \"prismjs/components/prism-json\" */\n// https://www.json.org/json-en.html\n\n\nprism.languages.json = {\n  'property': {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n    lookbehind: true,\n    greedy: true\n  },\n  'string': {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?!\\s*:)/,\n    lookbehind: true,\n    greedy: true\n  },\n  'comment': {\n    pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    greedy: true\n  },\n  'number': /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'punctuation': /[{}[\\],]/,\n  'operator': /:/,\n  'boolean': /\\b(?:false|true)\\b/,\n  'null': {\n    pattern: /\\bnull\\b/,\n    alias: 'keyword'\n  }\n};\nprism.languages.webmanifest = prism.languages.json;\n/* \"prismjs/components/prism-less\" */\n\n/* FIXME :\n :extend() is not handled specifically : its highlighting is buggy.\n Mixin usage must be inside a ruleset to be highlighted.\n At-rules (e.g. import) containing interpolations are buggy.\n Detached rulesets are highlighted as at-rules.\n A comment before a mixin usage prevents the latter to be properly highlighted.\n */\n\nprism.languages.less = prism.languages.extend('css', {\n  'comment': [/\\/\\*[\\s\\S]*?\\*\\//, {\n    pattern: /(^|[^\\\\])\\/\\/.*/,\n    lookbehind: true\n  }],\n  'atrule': {\n    pattern: /@[\\w-](?:\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n    inside: {\n      'punctuation': /[:()]/\n    }\n  },\n  // selectors and mixins are considered the same\n  'selector': {\n    pattern: /(?:@\\{[\\w-]+\\}|[^{};\\s@])(?:@\\{[\\w-]+\\}|\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};@\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n    inside: {\n      // mixin parameters\n      'variable': /@+[\\w-]+/\n    }\n  },\n  'property': /(?:@\\{[\\w-]+\\}|[\\w-])+(?:\\+_?)?(?=\\s*:)/,\n  'operator': /[+\\-*\\/]/\n});\nprism.languages.insertBefore('less', 'property', {\n  'variable': [// Variable declaration (the colon must be consumed!)\n  {\n    pattern: /@[\\w-]+\\s*:/,\n    inside: {\n      'punctuation': /:/\n    }\n  }, // Variable usage\n  /@@?[\\w-]+/],\n  'mixin-usage': {\n    pattern: /([{;]\\s*)[.#](?!\\d)[\\w-].*?(?=[(;])/,\n    lookbehind: true,\n    alias: 'function'\n  }\n});\n/* \"prismjs/components/prism-makefile\" */\n\nprism.languages.makefile = {\n  'comment': {\n    pattern: /(^|[^\\\\])#(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n])*/,\n    lookbehind: true\n  },\n  'string': {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true\n  },\n  'builtin-target': {\n    pattern: /\\.[A-Z][^:#=\\s]+(?=\\s*:(?!=))/,\n    alias: 'builtin'\n  },\n  'target': {\n    pattern: /^(?:[^:=\\s]|[ \\t]+(?![\\s:]))+(?=\\s*:(?!=))/m,\n    alias: 'symbol',\n    inside: {\n      'variable': /\\$+(?:(?!\\$)[^(){}:#=\\s]+|(?=[({]))/\n    }\n  },\n  'variable': /\\$+(?:(?!\\$)[^(){}:#=\\s]+|\\([@*%<^+?][DF]\\)|(?=[({]))/,\n  // Directives\n  'keyword': /-include\\b|\\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\\b/,\n  'function': {\n    pattern: /(\\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \\t])/,\n    lookbehind: true\n  },\n  'operator': /(?:::|[?:+!])?=|[|@]/,\n  'punctuation': /[:;(){}]/\n};\n/* \"prismjs/components/prism-objectivec\" */\n\nprism.languages.objectivec = prism.languages.extend('c', {\n  'string': {\n    pattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n    greedy: true\n  },\n  'keyword': /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n  'operator': /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n});\ndelete prism.languages.objectivec['class-name'];\nprism.languages.objc = prism.languages.objectivec;\n/* \"prismjs/components/prism-ocaml\" */\n// https://ocaml.org/manual/lex.html\n\nprism.languages.ocaml = {\n  'comment': {\n    pattern: /\\(\\*[\\s\\S]*?\\*\\)/,\n    greedy: true\n  },\n  'char': {\n    pattern: /'(?:[^\\\\\\r\\n']|\\\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,\n    greedy: true\n  },\n  'string': [{\n    pattern: /\"(?:\\\\(?:[\\s\\S]|\\r\\n)|[^\\\\\\r\\n\"])*\"/,\n    greedy: true\n  }, {\n    pattern: /\\{([a-z_]*)\\|[\\s\\S]*?\\|\\1\\}/,\n    greedy: true\n  }],\n  'number': [// binary and octal\n  /\\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\\b/i, // hexadecimal\n  /\\b0x[a-f0-9][a-f0-9_]*(?:\\.[a-f0-9_]*)?(?:p[+-]?\\d[\\d_]*)?(?!\\w)/i, // decimal\n  /\\b\\d[\\d_]*(?:\\.[\\d_]*)?(?:e[+-]?\\d[\\d_]*)?(?!\\w)/i],\n  'directive': {\n    pattern: /\\B#\\w+/,\n    alias: 'property'\n  },\n  'label': {\n    pattern: /\\B~\\w+/,\n    alias: 'property'\n  },\n  'type-variable': {\n    pattern: /\\B'\\w+/,\n    alias: 'function'\n  },\n  'variant': {\n    pattern: /`\\w+/,\n    alias: 'symbol'\n  },\n  // For the list of keywords and operators,\n  // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84\n  'keyword': /\\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\\b/,\n  'boolean': /\\b(?:false|true)\\b/,\n  'operator-like-punctuation': {\n    pattern: /\\[[<>|]|[>|]\\]|\\{<|>\\}/,\n    alias: 'punctuation'\n  },\n  // Custom operators are allowed\n  'operator': /\\.[.~]|:[=>]|[=<>@^|&+\\-*\\/$%!?~][!$%&*+\\-.\\/:<=>?@^|~]*|\\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\\b/,\n  'punctuation': /;;|::|[(){}\\[\\].,:;#]|\\b_\\b/\n};\n/* \"prismjs/components/prism-python\" */\n\nprism.languages.python = {\n  'comment': {\n    pattern: /(^|[^\\\\])#.*/,\n    lookbehind: true,\n    greedy: true\n  },\n  'string-interpolation': {\n    pattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n    greedy: true,\n    inside: {\n      'interpolation': {\n        // \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n        pattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n        lookbehind: true,\n        inside: {\n          'format-spec': {\n            pattern: /(:)[^:(){}]+(?=\\}$)/,\n            lookbehind: true\n          },\n          'conversion-option': {\n            pattern: /![sra](?=[:}]$)/,\n            alias: 'punctuation'\n          },\n          rest: null\n        }\n      },\n      'string': /[\\s\\S]+/\n    }\n  },\n  'triple-quoted-string': {\n    pattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n    greedy: true,\n    alias: 'string'\n  },\n  'string': {\n    pattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n    greedy: true\n  },\n  'function': {\n    pattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n    lookbehind: true\n  },\n  'class-name': {\n    pattern: /(\\bclass\\s+)\\w+/i,\n    lookbehind: true\n  },\n  'decorator': {\n    pattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n    lookbehind: true,\n    alias: ['annotation', 'punctuation'],\n    inside: {\n      'punctuation': /\\./\n    }\n  },\n  'keyword': /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n  'builtin': /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n  'boolean': /\\b(?:False|None|True)\\b/,\n  'number': /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n  'operator': /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n  'punctuation': /[{}[\\];(),.:]/\n};\nprism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = prism.languages.python;\nprism.languages.py = prism.languages.python;\n/* \"prismjs/components/prism-reason\" */\n\nprism.languages.reason = prism.languages.extend('clike', {\n  'string': {\n    pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n\"])*\"/,\n    greedy: true\n  },\n  // 'class-name' must be matched *after* 'constructor' defined below\n  'class-name': /\\b[A-Z]\\w*/,\n  'keyword': /\\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\\b/,\n  'operator': /\\.{3}|:[:=]|\\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\\-*\\/]\\.?|\\b(?:asr|land|lor|lsl|lsr|lxor|mod)\\b/\n});\nprism.languages.insertBefore('reason', 'class-name', {\n  'char': {\n    pattern: /'(?:\\\\x[\\da-f]{2}|\\\\o[0-3][0-7][0-7]|\\\\\\d{3}|\\\\.|[^'\\\\\\r\\n])'/,\n    greedy: true\n  },\n  // Negative look-ahead prevents from matching things like String.capitalize\n  'constructor': /\\b[A-Z]\\w*\\b(?!\\s*\\.)/,\n  'label': {\n    pattern: /\\b[a-z]\\w*(?=::)/,\n    alias: 'symbol'\n  }\n}); // We can't match functions property, so let's not even try.\n\ndelete prism.languages.reason[\"function\"];\n/* \"prismjs/components/prism-sass\" */\n\n(function (Prism) {\n  Prism.languages.sass = Prism.languages.extend('css', {\n    // Sass comments don't need to be closed, only indented\n    'comment': {\n      pattern: /^([ \\t]*)\\/[\\/*].*(?:(?:\\r?\\n|\\r)\\1[ \\t].+)*/m,\n      lookbehind: true,\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore('sass', 'atrule', {\n    // We want to consume the whole line\n    'atrule-line': {\n      // Includes support for = and + shortcuts\n      pattern: /^(?:[ \\t]*)[@+=].+/m,\n      greedy: true,\n      inside: {\n        'atrule': /(?:@[\\w-]+|[+=])/\n      }\n    }\n  });\n  delete Prism.languages.sass.atrule;\n  var variable = /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/;\n  var operator = [/[+*\\/%]|[=!]=|<=?|>=?|\\b(?:and|not|or)\\b/, {\n    pattern: /(\\s)-(?=\\s)/,\n    lookbehind: true\n  }];\n  Prism.languages.insertBefore('sass', 'property', {\n    // We want to consume the whole line\n    'variable-line': {\n      pattern: /^[ \\t]*\\$.+/m,\n      greedy: true,\n      inside: {\n        'punctuation': /:/,\n        'variable': variable,\n        'operator': operator\n      }\n    },\n    // We want to consume the whole line\n    'property-line': {\n      pattern: /^[ \\t]*(?:[^:\\s]+ *:.*|:[^:\\s].*)/m,\n      greedy: true,\n      inside: {\n        'property': [/[^:\\s]+(?=\\s*:)/, {\n          pattern: /(:)[^:\\s]+/,\n          lookbehind: true\n        }],\n        'punctuation': /:/,\n        'variable': variable,\n        'operator': operator,\n        'important': Prism.languages.sass.important\n      }\n    }\n  });\n  delete Prism.languages.sass.property;\n  delete Prism.languages.sass.important; // Now that whole lines for other patterns are consumed,\n  // what's left should be selectors\n\n  Prism.languages.insertBefore('sass', 'punctuation', {\n    'selector': {\n      pattern: /^([ \\t]*)\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*(?:,(?:\\r?\\n|\\r)\\1[ \\t]+\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*)*/m,\n      lookbehind: true,\n      greedy: true\n    }\n  });\n})(prism);\n/* \"prismjs/components/prism-scss\" */\n\n\nprism.languages.scss = prism.languages.extend('css', {\n  'comment': {\n    pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n    lookbehind: true\n  },\n  'atrule': {\n    pattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n    inside: {\n      'rule': /@[\\w-]+/ // See rest below\n\n    }\n  },\n  // url, compassified\n  'url': /(?:[-a-z]+-)?url(?=\\()/i,\n  // CSS selector regex is not appropriate for Sass\n  // since there can be lot more things (var, @ directive, nesting..)\n  // a selector must start at the end of a property or after a brace (end of other rules or nesting)\n  // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n  // the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n  // can \"pass\" as a selector- e.g: proper#{$erty})\n  // this one was hard to do, so please be careful if you edit this one :)\n  'selector': {\n    // Initial look-ahead is used to prevent matching of blank selectors\n    pattern: /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\n    inside: {\n      'parent': {\n        pattern: /&/,\n        alias: 'important'\n      },\n      'placeholder': /%[-\\w]+/,\n      'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n    }\n  },\n  'property': {\n    pattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n    inside: {\n      'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n    }\n  }\n});\nprism.languages.insertBefore('scss', 'atrule', {\n  'keyword': [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i, {\n    pattern: /( )(?:from|through)(?= )/,\n    lookbehind: true\n  }]\n});\nprism.languages.insertBefore('scss', 'important', {\n  // var and interpolated vars\n  'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n});\nprism.languages.insertBefore('scss', 'function', {\n  'module-modifier': {\n    pattern: /\\b(?:as|hide|show|with)\\b/i,\n    alias: 'keyword'\n  },\n  'placeholder': {\n    pattern: /%[-\\w]+/,\n    alias: 'selector'\n  },\n  'statement': {\n    pattern: /\\B!(?:default|optional)\\b/i,\n    alias: 'keyword'\n  },\n  'boolean': /\\b(?:false|true)\\b/,\n  'null': {\n    pattern: /\\bnull\\b/,\n    alias: 'keyword'\n  },\n  'operator': {\n    pattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|not|or)(?=\\s)/,\n    lookbehind: true\n  }\n});\nprism.languages.scss['atrule'].inside.rest = prism.languages.scss;\n/* \"prismjs/components/prism-stylus\" */\n\n(function (Prism) {\n  var unit = {\n    pattern: /(\\b\\d+)(?:%|[a-z]+)/,\n    lookbehind: true\n  }; // 123 -123 .123 -.123 12.3 -12.3\n\n  var number = {\n    pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n    lookbehind: true\n  };\n  var inside = {\n    'comment': {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n      lookbehind: true\n    },\n    'url': {\n      pattern: /\\burl\\(([\"']?).*?\\1\\)/i,\n      greedy: true\n    },\n    'string': {\n      pattern: /(\"|')(?:(?!\\1)[^\\\\\\r\\n]|\\\\(?:\\r\\n|[\\s\\S]))*\\1/,\n      greedy: true\n    },\n    'interpolation': null,\n    // See below\n    'func': null,\n    // See below\n    'important': /\\B!(?:important|optional)\\b/i,\n    'keyword': {\n      pattern: /(^|\\s+)(?:(?:else|for|if|return|unless)(?=\\s|$)|@[\\w-]+)/,\n      lookbehind: true\n    },\n    'hexcode': /#[\\da-f]{3,6}/i,\n    'color': [/\\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\\b/i, {\n      pattern: /\\b(?:hsl|rgb)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:hsl|rgb)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n      inside: {\n        'unit': unit,\n        'number': number,\n        'function': /[\\w-]+(?=\\()/,\n        'punctuation': /[(),]/\n      }\n    }],\n    'entity': /\\\\[\\da-f]{1,8}/i,\n    'unit': unit,\n    'boolean': /\\b(?:false|true)\\b/,\n    'operator': [// We want non-word chars around \"-\" because it is\n    // accepted in property names.\n    /~|[+!\\/%<>?=]=?|[-:]=|\\*[*=]?|\\.{2,3}|&&|\\|\\||\\B-\\B|\\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\\b/],\n    'number': number,\n    'punctuation': /[{}()\\[\\];:,]/\n  };\n  inside['interpolation'] = {\n    pattern: /\\{[^\\r\\n}:]+\\}/,\n    alias: 'variable',\n    inside: {\n      'delimiter': {\n        pattern: /^\\{|\\}$/,\n        alias: 'punctuation'\n      },\n      rest: inside\n    }\n  };\n  inside['func'] = {\n    pattern: /[\\w-]+\\([^)]*\\).*/,\n    inside: {\n      'function': /^[^(]+/,\n      rest: inside\n    }\n  };\n  Prism.languages.stylus = {\n    'atrule-declaration': {\n      pattern: /(^[ \\t]*)@.+/m,\n      lookbehind: true,\n      inside: {\n        'atrule': /^@[\\w-]+/,\n        rest: inside\n      }\n    },\n    'variable-declaration': {\n      pattern: /(^[ \\t]*)[\\w$-]+\\s*.?=[ \\t]*(?:\\{[^{}]*\\}|\\S.*|$)/m,\n      lookbehind: true,\n      inside: {\n        'variable': /^\\S+/,\n        rest: inside\n      }\n    },\n    'statement': {\n      pattern: /(^[ \\t]*)(?:else|for|if|return|unless)[ \\t].+/m,\n      lookbehind: true,\n      inside: {\n        'keyword': /^\\S+/,\n        rest: inside\n      }\n    },\n    // A property/value pair cannot end with a comma or a brace\n    // It cannot have indented content unless it ended with a semicolon\n    'property-declaration': {\n      pattern: /((?:^|\\{)([ \\t]*))(?:[\\w-]|\\{[^}\\r\\n]+\\})+(?:\\s*:\\s*|[ \\t]+)(?!\\s)[^{\\r\\n]*(?:;|[^{\\r\\n,]$(?!(?:\\r?\\n|\\r)(?:\\{|\\2[ \\t])))/m,\n      lookbehind: true,\n      inside: {\n        'property': {\n          pattern: /^[^\\s:]+/,\n          inside: {\n            'interpolation': inside.interpolation\n          }\n        },\n        rest: inside\n      }\n    },\n    // A selector can contain parentheses only as part of a pseudo-element\n    // It can span multiple lines.\n    // It must end with a comma or an accolade or have indented content.\n    'selector': {\n      pattern: /(^[ \\t]*)(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\)|(?![\\w-]))|\\{[^}\\r\\n]+\\})+)(?:(?:\\r?\\n|\\r)(?:\\1(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\)|(?![\\w-]))|\\{[^}\\r\\n]+\\})+)))*(?:,$|\\{|(?=(?:\\r?\\n|\\r)(?:\\{|\\1[ \\t])))/m,\n      lookbehind: true,\n      inside: {\n        'interpolation': inside.interpolation,\n        'comment': inside.comment,\n        'punctuation': /[{},]/\n      }\n    },\n    'func': inside.func,\n    'string': inside.string,\n    'comment': {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n      lookbehind: true,\n      greedy: true\n    },\n    'interpolation': inside.interpolation,\n    'punctuation': /[{}()\\[\\];:.]/\n  };\n})(prism);\n/* \"prismjs/components/prism-tsx\" */\n\n\n(function (Prism) {\n  var typescript = Prism.util.clone(Prism.languages.typescript);\n  Prism.languages.tsx = Prism.languages.extend('jsx', typescript); // doesn't work with TS because TS is too complex\n\n  delete Prism.languages.tsx['parameter'];\n  delete Prism.languages.tsx['literal-property']; // This will prevent collisions between TSX tags and TS generic types.\n  // Idea by https://github.com/karlhorky\n  // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n\n  var tag = Prism.languages.tsx.tag;\n  tag.pattern = RegExp(/(^|[^\\w$]|(?=<\\/))/.source + '(?:' + tag.pattern.source + ')', tag.pattern.flags);\n  tag.lookbehind = true;\n})(prism);\n/* \"prismjs/components/prism-wasm\" */\n\n\nprism.languages.wasm = {\n  'comment': [/\\(;[\\s\\S]*?;\\)/, {\n    pattern: /;;.*/,\n    greedy: true\n  }],\n  'string': {\n    pattern: /\"(?:\\\\[\\s\\S]|[^\"\\\\])*\"/,\n    greedy: true\n  },\n  'keyword': [{\n    pattern: /\\b(?:align|offset)=/,\n    inside: {\n      'operator': /=/\n    }\n  }, {\n    pattern: /\\b(?:(?:f32|f64|i32|i64)(?:\\.(?:abs|add|and|ceil|clz|const|convert_[su]\\/i(?:32|64)|copysign|ctz|demote\\/f64|div(?:_[su])?|eqz?|extend_[su]\\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\\/f32|reinterpret\\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\\/f(?:32|64))?|wrap\\/i64|xor))?|memory\\.(?:grow|size))\\b/,\n    inside: {\n      'punctuation': /\\./\n    }\n  }, /\\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\\b/],\n  'variable': /\\$[\\w!#$%&'*+\\-./:<=>?@\\\\^`|~]+/,\n  'number': /[+-]?\\b(?:\\d(?:_?\\d)*(?:\\.\\d(?:_?\\d)*)?(?:[eE][+-]?\\d(?:_?\\d)*)?|0x[\\da-fA-F](?:_?[\\da-fA-F])*(?:\\.[\\da-fA-F](?:_?[\\da-fA-D])*)?(?:[pP][+-]?\\d(?:_?\\d)*)?)\\b|\\binf\\b|\\bnan(?::0x[\\da-fA-F](?:_?[\\da-fA-D])*)?\\b/,\n  'punctuation': /[()]/\n};\n/* harmony default export */ var prism_react_renderer_prism = (prism);\n// CONCATENATED MODULE: ./node_modules/prism-react-renderer/themes/duotoneDark/index.js\n// Duotone Dark\n// Author: Simurai, adapted from DuoTone themes for Atom (http://simurai.com/projects/2016/01/01/duotone-themes)\n// Conversion: Bram de Haan (http://atelierbram.github.io/Base2Tone-prism/output/prism/prism-base2tone-evening-dark.css)\n// Generated with Base16 Builder (https://github.com/base16-builder/base16-builder)\nvar theme = {\n  plain: {\n    backgroundColor: \"#2a2734\",\n    color: \"#9a86fd\"\n  },\n  styles: [{\n    types: [\"comment\", \"prolog\", \"doctype\", \"cdata\", \"punctuation\"],\n    style: {\n      color: \"#6c6783\"\n    }\n  }, {\n    types: [\"namespace\"],\n    style: {\n      opacity: 0.7\n    }\n  }, {\n    types: [\"tag\", \"operator\", \"number\"],\n    style: {\n      color: \"#e09142\"\n    }\n  }, {\n    types: [\"property\", \"function\"],\n    style: {\n      color: \"#9a86fd\"\n    }\n  }, {\n    types: [\"tag-id\", \"selector\", \"atrule-id\"],\n    style: {\n      color: \"#eeebff\"\n    }\n  }, {\n    types: [\"attr-name\"],\n    style: {\n      color: \"#c4b9fe\"\n    }\n  }, {\n    types: [\"boolean\", \"string\", \"entity\", \"url\", \"attr-value\", \"keyword\", \"control\", \"directive\", \"unit\", \"statement\", \"regex\", \"at-rule\", \"placeholder\", \"variable\"],\n    style: {\n      color: \"#ffcc99\"\n    }\n  }, {\n    types: [\"deleted\"],\n    style: {\n      textDecorationLine: \"line-through\"\n    }\n  }, {\n    types: [\"inserted\"],\n    style: {\n      textDecorationLine: \"underline\"\n    }\n  }, {\n    types: [\"italic\"],\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, {\n    types: [\"important\", \"bold\"],\n    style: {\n      fontWeight: \"bold\"\n    }\n  }, {\n    types: [\"important\"],\n    style: {\n      color: \"#c4b9fe\"\n    }\n  }]\n};\n/* harmony default export */ var duotoneDark = (theme);\n// EXTERNAL MODULE: ./node_modules/umi/node_modules/react/index.js\nvar react = __webpack_require__(\"kM82\");\n\n// CONCATENATED MODULE: ./node_modules/prism-react-renderer/dist/index.js\n\n\n\n\nvar defaultProps = {\n  // $FlowFixMe\n  Prism: prism_react_renderer_prism,\n  theme: duotoneDark\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function normalizeEmptyLines(line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\\n\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].content = \"\\n\";\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function appendTypes(types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\n\nvar normalizeTokens = function normalizeTokens(tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var i$1 = 1; i$1 < newlineCount; i$1++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[i$1]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nvar themeToDict = function themeToDict(theme, language) {\n  var plain = theme.plain; // $FlowFixMe\n\n  var base = Object.create(null);\n  var themeDict = theme.styles.reduce(function (acc, themeEntry) {\n    var languages = themeEntry.languages;\n    var style = themeEntry.style;\n\n    if (languages && !languages.includes(language)) {\n      return acc;\n    }\n\n    themeEntry.types.forEach(function (type) {\n      // $FlowFixMe\n      var accStyle = _extends({}, acc[type], style);\n\n      acc[type] = accStyle;\n    });\n    return acc;\n  }, base); // $FlowFixMe\n\n  themeDict.root = plain; // $FlowFixMe\n\n  themeDict.plain = _extends({}, plain, {\n    backgroundColor: null\n  });\n  return themeDict;\n};\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nvar Highlight = /*@__PURE__*/function (Component) {\n  function Highlight() {\n    var this$1 = this;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    Component.apply(this, args);\n\n    _defineProperty(this, \"getThemeDict\", function (props) {\n      if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n        return this$1.themeDict;\n      }\n\n      this$1.prevTheme = props.theme;\n      this$1.prevLanguage = props.language;\n      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n      return this$1.themeDict = themeDict;\n    });\n\n    _defineProperty(this, \"getLineProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"line\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token-line\",\n        style: undefined,\n        key: undefined\n      });\n\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict !== undefined) {\n        output.style = themeDict.plain;\n      }\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"getStyleForToken\", function (ref) {\n      var types = ref.types;\n      var empty = ref.empty;\n      var typesSize = types.length;\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict === undefined) {\n        return undefined;\n      } else if (typesSize === 1 && types[0] === \"plain\") {\n        return empty ? {\n          display: \"inline-block\"\n        } : undefined;\n      } else if (typesSize === 1 && !empty) {\n        return themeDict[types[0]];\n      }\n\n      var baseStyle = empty ? {\n        display: \"inline-block\"\n      } : {}; // $FlowFixMe\n\n      var typeStyles = types.map(function (type) {\n        return themeDict[type];\n      });\n      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));\n    });\n\n    _defineProperty(this, \"getTokenProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var token = ref.token;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"token\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token \" + token.types.join(\" \"),\n        children: token.content,\n        style: this$1.getStyleForToken(token),\n        key: undefined\n      });\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"tokenize\", function (Prism, code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language,\n        tokens: []\n      };\n      Prism.hooks.run(\"before-tokenize\", env);\n      var tokens = env.tokens = Prism.tokenize(env.code, env.grammar, env.language);\n      Prism.hooks.run(\"after-tokenize\", env);\n      return tokens;\n    });\n  }\n\n  if (Component) Highlight.__proto__ = Component;\n  Highlight.prototype = Object.create(Component && Component.prototype);\n  Highlight.prototype.constructor = Highlight;\n\n  Highlight.prototype.render = function render() {\n    var ref = this.props;\n    var Prism = ref.Prism;\n    var language = ref.language;\n    var code = ref.code;\n    var children = ref.children;\n    var themeDict = this.getThemeDict(this.props);\n    var grammar = Prism.languages[language];\n    var mixedTokens = grammar !== undefined ? this.tokenize(Prism, code, grammar, language) : [code];\n    var tokens = normalizeTokens(mixedTokens);\n    return children({\n      tokens: tokens,\n      className: \"prism-code language-\" + language,\n      style: themeDict !== undefined ? themeDict.root : {},\n      getLineProps: this.getLineProps,\n      getTokenProps: this.getTokenProps\n    });\n  };\n\n  return Highlight;\n}(react[\"Component\"]);\n\n/* harmony default export */ var dist = __webpack_exports__[\"a\"] = (Highlight);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvcHJpc20vaW5kZXguanM/NDk1MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvdGhlbWVzL2R1b3RvbmVEYXJrL2luZGV4LmpzP2Q2MGYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ByaXNtLXJlYWN0LXJlbmRlcmVyL2Rpc3QvaW5kZXguanM/ZGNjYSJdLCJuYW1lcyI6WyJQcmlzbSIsImxhbmciLCJ1bmlxdWVJZCIsInBsYWluVGV4dEdyYW1tYXIiLCJfIiwidXRpbCIsImVuY29kZSIsInRva2VucyIsIlRva2VuIiwidHlwZSIsImNvbnRlbnQiLCJhbGlhcyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInJlcGxhY2UiLCJvIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJvYmpJZCIsIm9iaiIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJjbG9uZSIsImRlZXBDbG9uZSIsInZpc2l0ZWQiLCJpZCIsImtleSIsImhhc093blByb3BlcnR5IiwiZm9yRWFjaCIsInYiLCJpIiwiZ2V0TGFuZ3VhZ2UiLCJlbGVtZW50IiwibSIsImV4ZWMiLCJjbGFzc05hbWUiLCJ0b0xvd2VyQ2FzZSIsInBhcmVudEVsZW1lbnQiLCJzZXRMYW5ndWFnZSIsImxhbmd1YWdlIiwiUmVnRXhwIiwiY2xhc3NMaXN0IiwiYWRkIiwiaXNBY3RpdmUiLCJkZWZhdWx0QWN0aXZhdGlvbiIsIm5vIiwiY29udGFpbnMiLCJsYW5ndWFnZXMiLCJwbGFpbiIsInBsYWludGV4dCIsInRleHQiLCJ0eHQiLCJleHRlbmQiLCJyZWRlZiIsImluc2VydEJlZm9yZSIsImluc2lkZSIsImJlZm9yZSIsImluc2VydCIsInJvb3QiLCJncmFtbWFyIiwicmV0IiwidG9rZW4iLCJuZXdUb2tlbiIsIm9sZCIsIkRGUyIsImNhbGxiYWNrIiwicHJvcGVydHkiLCJwcm9wZXJ0eVR5cGUiLCJwbHVnaW5zIiwiaGlnaGxpZ2h0IiwiZW52IiwiY29kZSIsImhvb2tzIiwicnVuIiwidG9rZW5pemUiLCJzdHJpbmdpZnkiLCJyZXN0IiwidG9rZW5MaXN0IiwiTGlua2VkTGlzdCIsImFkZEFmdGVyIiwiaGVhZCIsIm1hdGNoR3JhbW1hciIsInRvQXJyYXkiLCJhbGwiLCJuYW1lIiwicHVzaCIsImNhbGxiYWNrcyIsImxlbmd0aCIsIm1hdGNoZWRTdHIiLCJzIiwiZSIsInRhZyIsImNsYXNzZXMiLCJhdHRyaWJ1dGVzIiwiYWxpYXNlcyIsImFwcGx5Iiwiam9pbiIsIm1hdGNoUGF0dGVybiIsInBhdHRlcm4iLCJwb3MiLCJsb29rYmVoaW5kIiwibGFzdEluZGV4IiwibWF0Y2giLCJsb29rYmVoaW5kTGVuZ3RoIiwiaW5kZXgiLCJzdGFydE5vZGUiLCJzdGFydFBvcyIsInJlbWF0Y2giLCJwYXR0ZXJucyIsImoiLCJjYXVzZSIsInBhdHRlcm5PYmoiLCJncmVlZHkiLCJnbG9iYWwiLCJmbGFncyIsInNvdXJjZSIsImN1cnJlbnROb2RlIiwibmV4dCIsInRhaWwiLCJyZWFjaCIsInN0ciIsInJlbW92ZUNvdW50IiwiZnJvbSIsInRvIiwicCIsImsiLCJtYXRjaFN0ciIsImFmdGVyIiwicmVtb3ZlRnJvbSIsInByZXYiLCJyZW1vdmVSYW5nZSIsIndyYXBwZWQiLCJuZXN0ZWRSZW1hdGNoIiwibGlzdCIsIm5vZGUiLCJuZXdOb2RlIiwiY291bnQiLCJhcnJheSIsInByaXNtIiwibWFya3VwIiwiYWRkSW5saW5lZCIsInRhZ05hbWUiLCJpbmNsdWRlZENkYXRhSW5zaWRlIiwiZGVmIiwiYXR0ck5hbWUiLCJodG1sIiwibWF0aG1sIiwic3ZnIiwieG1sIiwic3NtbCIsImF0b20iLCJyc3MiLCJlbnZWYXJzIiwiY29tbWFuZEFmdGVySGVyZWRvYyIsImluc2lkZVN0cmluZyIsImJhc2giLCJlbnRpdHkiLCJ2YXJpYWJsZSIsInRvQmVDb3BpZWQiLCJzaGVsbCIsImNsaWtlIiwiYyIsImtleXdvcmQiLCJtb2ROYW1lIiwiY3BwIiwic3RyaW5nIiwiY3NzIiwiYWRkQXR0cmlidXRlIiwic2VsZWN0b3JJbnNpZGUiLCJzZWxlY3RvciIsInVuaXQiLCJudW1iZXIiLCJqYXZhc2NyaXB0IiwicmVnZXgiLCJqcyIsImNvbW1lbnQiLCJpbnRlcnBvbGF0aW9uIiwiY29mZmVlc2NyaXB0IiwiY29mZmVlIiwiYW5jaG9yT3JBbGlhcyIsInByb3BlcnRpZXMiLCJwbGFpbktleSIsImNyZWF0ZVZhbHVlUGF0dGVybiIsInlhbWwiLCJ5bWwiLCJpbm5lciIsImNyZWF0ZUlubGluZSIsInRhYmxlQ2VsbCIsInRhYmxlUm93IiwidGFibGVMaW5lIiwibWFya2Rvd24iLCJwdW5jdHVhdGlvbiIsIndhbGtUb2tlbnMiLCJsIiwiY29kZUxhbmciLCJjb2RlQmxvY2siLCJjbHMiLCJhdXRvbG9hZGVyIiwiRGF0ZSIsInZhbHVlT2YiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsb2FkTGFuZ3VhZ2VzIiwiZWxlIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwidGFnUGF0dGVybiIsIktOT1dOX0VOVElUWV9OQU1FUyIsImZyb21Db2RlUG9pbnQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJwYXJzZUludCIsIk51bWJlciIsImtub3duIiwibWQiLCJncmFwaHFsIiwiYWZ0ZXJUb2tlbml6ZUdyYXBocWwiLCJ2YWxpZFRva2VucyIsImZpbHRlciIsImN1cnJlbnRJbmRleCIsImdldFRva2VuIiwib2Zmc2V0IiwiaXNUb2tlblR5cGUiLCJ0eXBlcyIsImZpbmRDbG9zaW5nQnJhY2tldCIsIm9wZW4iLCJjbG9zZSIsInN0YWNrSGVpZ2h0IiwidGVzdCIsImFkZEFsaWFzIiwic3RhcnRUb2tlbiIsImlucHV0VmFyaWFibGVzIiwiZGVmaW5pdGlvbkVuZCIsInQiLCJtdXRhdGlvbkVuZCIsInZhclRva2VuIiwiaW5kZXhPZiIsInNxbCIsInRlbXBsYXRlU3RyaW5nIiwidGVtcGxhdGVMaXRlcmFsUGF0dGVybiIsImludGVycG9sYXRpb25PYmplY3QiLCJpbnRlcnBvbGF0aW9uUHVuY3R1YXRpb25PYmplY3QiLCJpbnRlcnBvbGF0aW9uUGF0dGVybiIsImNyZWF0ZVRlbXBsYXRlIiwidW5kZWZpbmVkIiwiQm9vbGVhbiIsImdldFBsYWNlaG9sZGVyIiwiY291bnRlciIsInRvVXBwZXJDYXNlIiwidG9rZW5pemVXaXRoSG9va3MiLCJ0b2tlbml6ZUludGVycG9sYXRpb25FeHByZXNzaW9uIiwiZXhwcmVzc2lvbiIsInRlbXBHcmFtbWFyIiwiYXJncyIsInNwbGljZSIsInRva2VuaXplRW1iZWRkZWQiLCJfdG9rZW5zIiwicGxhY2Vob2xkZXJDb3VudGVyIiwicGxhY2Vob2xkZXJNYXAiLCJlbWJlZGRlZENvZGUiLCJpbnRlcnBvbGF0aW9uRXhwcmVzc2lvbiIsInBsYWNlaG9sZGVyIiwiZW1iZWRkZWRUb2tlbnMiLCJwbGFjZWhvbGRlcnMiLCJrZXlzIiwic3Vic3RyaW5nIiwibWlkZGxlIiwicmVwbGFjZW1lbnQiLCJhZnRlclRva2VucyIsImNvbmNhdCIsInN1cHBvcnRlZExhbmd1YWdlcyIsImZpbmRUZW1wbGF0ZVN0cmluZ3MiLCJlbWJlZGRlZCIsInN0cmluZ0NvbnRlbnQiLCJ0eXBlc2NyaXB0IiwidHlwZUluc2lkZSIsInRzIiwid2l0aElkIiwidW5zaGlmdCIsIm1heWJlQ2xhc3NOYW1lVG9rZW5zIiwic3BhY2UiLCJicmFjZXMiLCJzcHJlYWQiLCJyZSIsImpzeCIsInN0cmluZ2lmeVRva2VuIiwib3BlbmVkVGFncyIsIm5vdFRhZ05vckJyYWNlIiwicG9wIiwib3BlbmVkQnJhY2VzIiwicGxhaW5UZXh0IiwiZGlmZiIsIlBSRUZJWEVTIiwicHJlZml4IiwiZ2l0IiwiZ28iLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYnVpbGRQbGFjZWhvbGRlcnMiLCJwbGFjZWhvbGRlclBhdHRlcm4iLCJyZXBsYWNlRmlsdGVyIiwidG9rZW5TdGFjayIsInRva2VuaXplUGxhY2Vob2xkZXJzIiwiaGFuZGxlYmFycyIsImhhbmRsZWJhcnNQYXR0ZXJuIiwiaGJzIiwianNvbiIsIndlYm1hbmlmZXN0IiwibGVzcyIsIm1ha2VmaWxlIiwib2JqZWN0aXZlYyIsIm9iamMiLCJvY2FtbCIsInB5dGhvbiIsInB5IiwicmVhc29uIiwic2FzcyIsImF0cnVsZSIsIm9wZXJhdG9yIiwiaW1wb3J0YW50Iiwic2NzcyIsInN0eWx1cyIsImZ1bmMiLCJ0c3giLCJ3YXNtIiwidGhlbWUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsInN0eWxlcyIsInN0eWxlIiwib3BhY2l0eSIsInRleHREZWNvcmF0aW9uTGluZSIsImZvbnRTdHlsZSIsImZvbnRXZWlnaHQiLCJkZWZhdWx0UHJvcHMiLCJfZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInRhcmdldCIsImFyZ3VtZW50cyIsIm5ld2xpbmVSZSIsIm5vcm1hbGl6ZUVtcHR5TGluZXMiLCJsaW5lIiwiZW1wdHkiLCJhcHBlbmRUeXBlcyIsInR5cGVzU2l6ZSIsIm5vcm1hbGl6ZVRva2VucyIsInR5cGVBcnJTdGFjayIsInRva2VuQXJyU3RhY2siLCJ0b2tlbkFyckluZGV4U3RhY2siLCJ0b2tlbkFyclNpemVTdGFjayIsInN0YWNrSW5kZXgiLCJjdXJyZW50TGluZSIsImFjYyIsInRva2VuQXJyIiwic3BsaXRCeU5ld2xpbmVzIiwic3BsaXQiLCJuZXdsaW5lQ291bnQiLCJpJDEiLCJ0aGVtZVRvRGljdCIsImJhc2UiLCJjcmVhdGUiLCJ0aGVtZURpY3QiLCJyZWR1Y2UiLCJ0aGVtZUVudHJ5IiwiaW5jbHVkZXMiLCJhY2NTdHlsZSIsIm9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZSIsIkhpZ2hsaWdodCIsIkNvbXBvbmVudCIsInRoaXMkMSIsImxlbiIsInByb3BzIiwicHJldlRoZW1lIiwicHJldkxhbmd1YWdlIiwicmVmIiwicmVzdCQxIiwib3V0cHV0IiwiZ2V0VGhlbWVEaWN0IiwiZGlzcGxheSIsImJhc2VTdHlsZSIsInR5cGVTdHlsZXMiLCJjaGlsZHJlbiIsImdldFN0eWxlRm9yVG9rZW4iLCJfX3Byb3RvX18iLCJjb25zdHJ1Y3RvciIsInJlbmRlciIsIm1peGVkVG9rZW5zIiwiZ2V0TGluZVByb3BzIiwiZ2V0VG9rZW5Qcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQyxJQUFJQSxLQUFLLEdBQUksWUFBWTtBQUV6QjtBQUNBLE1BQUlDLElBQUksR0FBRyx5Q0FBWDtBQUNBLE1BQUlDLFFBQVEsR0FBRyxDQUFmLENBSnlCLENBTXpCOztBQUNBLE1BQUlDLGdCQUFnQixHQUFHLEVBQXZCO0FBR0EsTUFBSUMsQ0FBQyxHQUFHO0FBQ1A7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0VDLFFBQUksRUFBRTtBQUNMQyxZQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFnQkMsTUFBaEIsRUFBd0I7QUFDL0IsWUFBSUEsTUFBTSxZQUFZQyxLQUF0QixFQUE2QjtBQUM1QixpQkFBTyxJQUFJQSxLQUFKLENBQVVELE1BQU0sQ0FBQ0UsSUFBakIsRUFBdUJILE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRyxPQUFSLENBQTdCLEVBQStDSCxNQUFNLENBQUNJLEtBQXRELENBQVA7QUFDQSxTQUZELE1BRU8sSUFBSUMsS0FBSyxDQUFDQyxPQUFOLENBQWNOLE1BQWQsQ0FBSixFQUEyQjtBQUNqQyxpQkFBT0EsTUFBTSxDQUFDTyxHQUFQLENBQVdSLE1BQVgsQ0FBUDtBQUNBLFNBRk0sTUFFQTtBQUNOLGlCQUFPQyxNQUFNLENBQUNRLE9BQVAsQ0FBZSxJQUFmLEVBQXFCLE9BQXJCLEVBQThCQSxPQUE5QixDQUFzQyxJQUF0QyxFQUE0QyxNQUE1QyxFQUFvREEsT0FBcEQsQ0FBNEQsU0FBNUQsRUFBdUUsR0FBdkUsQ0FBUDtBQUNBO0FBQ0QsT0FUSTs7QUFXTDtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHTixVQUFJLEVBQUUsY0FBVU8sQ0FBVixFQUFhO0FBQ2xCLGVBQU9DLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCSixDQUEvQixFQUFrQ0ssS0FBbEMsQ0FBd0MsQ0FBeEMsRUFBMkMsQ0FBQyxDQUE1QyxDQUFQO0FBQ0EsT0E3Qkk7O0FBK0JMO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHQyxXQUFLLEVBQUUsZUFBVUMsR0FBVixFQUFlO0FBQ3JCLFlBQUksQ0FBQ0EsR0FBRyxDQUFDLE1BQUQsQ0FBUixFQUFrQjtBQUNqQk4sZ0JBQU0sQ0FBQ08sY0FBUCxDQUFzQkQsR0FBdEIsRUFBMkIsTUFBM0IsRUFBbUM7QUFBRUUsaUJBQUssRUFBRSxFQUFFdkI7QUFBWCxXQUFuQztBQUNBOztBQUNELGVBQU9xQixHQUFHLENBQUMsTUFBRCxDQUFWO0FBQ0EsT0ExQ0k7O0FBNENMO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0dHLFdBQUssRUFBRSxTQUFTQyxTQUFULENBQW1CWCxDQUFuQixFQUFzQlksT0FBdEIsRUFBK0I7QUFDckNBLGVBQU8sR0FBR0EsT0FBTyxJQUFJLEVBQXJCO0FBRUEsWUFBSUYsS0FBSjtBQUFXLFlBQUlHLEVBQUo7O0FBQ1gsZ0JBQVF6QixDQUFDLENBQUNDLElBQUYsQ0FBT0ksSUFBUCxDQUFZTyxDQUFaLENBQVI7QUFDQyxlQUFLLFFBQUw7QUFDQ2EsY0FBRSxHQUFHekIsQ0FBQyxDQUFDQyxJQUFGLENBQU9pQixLQUFQLENBQWFOLENBQWIsQ0FBTDs7QUFDQSxnQkFBSVksT0FBTyxDQUFDQyxFQUFELENBQVgsRUFBaUI7QUFDaEIscUJBQU9ELE9BQU8sQ0FBQ0MsRUFBRCxDQUFkO0FBQ0E7O0FBQ0RILGlCQUFLO0FBQUc7QUFBb0MsY0FBNUM7QUFDQUUsbUJBQU8sQ0FBQ0MsRUFBRCxDQUFQLEdBQWNILEtBQWQ7O0FBRUEsaUJBQUssSUFBSUksR0FBVCxJQUFnQmQsQ0FBaEIsRUFBbUI7QUFDbEIsa0JBQUlBLENBQUMsQ0FBQ2UsY0FBRixDQUFpQkQsR0FBakIsQ0FBSixFQUEyQjtBQUMxQkoscUJBQUssQ0FBQ0ksR0FBRCxDQUFMLEdBQWFILFNBQVMsQ0FBQ1gsQ0FBQyxDQUFDYyxHQUFELENBQUYsRUFBU0YsT0FBVCxDQUF0QjtBQUNBO0FBQ0Q7O0FBRUQ7QUFBTztBQUFvQkY7QUFBM0I7O0FBRUQsZUFBSyxPQUFMO0FBQ0NHLGNBQUUsR0FBR3pCLENBQUMsQ0FBQ0MsSUFBRixDQUFPaUIsS0FBUCxDQUFhTixDQUFiLENBQUw7O0FBQ0EsZ0JBQUlZLE9BQU8sQ0FBQ0MsRUFBRCxDQUFYLEVBQWlCO0FBQ2hCLHFCQUFPRCxPQUFPLENBQUNDLEVBQUQsQ0FBZDtBQUNBOztBQUNESCxpQkFBSyxHQUFHLEVBQVI7QUFDQUUsbUJBQU8sQ0FBQ0MsRUFBRCxDQUFQLEdBQWNILEtBQWQ7O0FBRUM7O0FBQXFCO0FBQW1CVixhQUF6QyxDQUE4Q2dCLE9BQTlDLENBQXNELFVBQVVDLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUNyRVIsbUJBQUssQ0FBQ1EsQ0FBRCxDQUFMLEdBQVdQLFNBQVMsQ0FBQ00sQ0FBRCxFQUFJTCxPQUFKLENBQXBCO0FBQ0EsYUFGRDtBQUlBO0FBQU87QUFBb0JGO0FBQTNCOztBQUVEO0FBQ0MsbUJBQU9WLENBQVA7QUFoQ0Y7QUFrQ0EsT0E1Rkk7O0FBOEZMO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDR21CLGlCQUFXLEVBQUUscUJBQVVDLE9BQVYsRUFBbUI7QUFDL0IsZUFBT0EsT0FBUCxFQUFnQjtBQUNmLGNBQUlDLENBQUMsR0FBR3BDLElBQUksQ0FBQ3FDLElBQUwsQ0FBVUYsT0FBTyxDQUFDRyxTQUFsQixDQUFSOztBQUNBLGNBQUlGLENBQUosRUFBTztBQUNOLG1CQUFPQSxDQUFDLENBQUMsQ0FBRCxDQUFELENBQUtHLFdBQUwsRUFBUDtBQUNBOztBQUNESixpQkFBTyxHQUFHQSxPQUFPLENBQUNLLGFBQWxCO0FBQ0E7O0FBQ0QsZUFBTyxNQUFQO0FBQ0EsT0EvR0k7O0FBaUhMO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0dDLGlCQUFXLEVBQUUscUJBQVVOLE9BQVYsRUFBbUJPLFFBQW5CLEVBQTZCO0FBQ3pDO0FBQ0E7QUFDQVAsZUFBTyxDQUFDRyxTQUFSLEdBQW9CSCxPQUFPLENBQUNHLFNBQVIsQ0FBa0J4QixPQUFsQixDQUEwQjZCLE1BQU0sQ0FBQzNDLElBQUQsRUFBTyxJQUFQLENBQWhDLEVBQThDLEVBQTlDLENBQXBCLENBSHlDLENBS3pDO0FBQ0E7O0FBQ0FtQyxlQUFPLENBQUNTLFNBQVIsQ0FBa0JDLEdBQWxCLENBQXNCLGNBQWNILFFBQXBDO0FBQ0EsT0FoSUk7O0FBa0lMO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0dJLGNBQVEsRUFBRSxrQkFBVVgsT0FBVixFQUFtQkcsU0FBbkIsRUFBOEJTLGlCQUE5QixFQUFpRDtBQUMxRCxZQUFJQyxFQUFFLEdBQUcsUUFBUVYsU0FBakI7O0FBRUEsZUFBT0gsT0FBUCxFQUFnQjtBQUNmLGNBQUlTLFNBQVMsR0FBR1QsT0FBTyxDQUFDUyxTQUF4Qjs7QUFDQSxjQUFJQSxTQUFTLENBQUNLLFFBQVYsQ0FBbUJYLFNBQW5CLENBQUosRUFBbUM7QUFDbEMsbUJBQU8sSUFBUDtBQUNBOztBQUNELGNBQUlNLFNBQVMsQ0FBQ0ssUUFBVixDQUFtQkQsRUFBbkIsQ0FBSixFQUE0QjtBQUMzQixtQkFBTyxLQUFQO0FBQ0E7O0FBQ0RiLGlCQUFPLEdBQUdBLE9BQU8sQ0FBQ0ssYUFBbEI7QUFDQTs7QUFDRCxlQUFPLENBQUMsQ0FBQ08saUJBQVQ7QUFDQTtBQW5LSSxLQVZDOztBQWdMUDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFRyxhQUFTLEVBQUU7QUFDVjtBQUNIO0FBQ0E7QUFDR0MsV0FBSyxFQUFFakQsZ0JBSkc7QUFLVmtELGVBQVMsRUFBRWxELGdCQUxEO0FBTVZtRCxVQUFJLEVBQUVuRCxnQkFOSTtBQU9Wb0QsU0FBRyxFQUFFcEQsZ0JBUEs7O0FBU1Y7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDR3FELFlBQU0sRUFBRSxnQkFBVTNCLEVBQVYsRUFBYzRCLEtBQWQsRUFBcUI7QUFDNUIsWUFBSXhELElBQUksR0FBR0csQ0FBQyxDQUFDQyxJQUFGLENBQU9xQixLQUFQLENBQWF0QixDQUFDLENBQUMrQyxTQUFGLENBQVl0QixFQUFaLENBQWIsQ0FBWDs7QUFFQSxhQUFLLElBQUlDLEdBQVQsSUFBZ0IyQixLQUFoQixFQUF1QjtBQUN0QnhELGNBQUksQ0FBQzZCLEdBQUQsQ0FBSixHQUFZMkIsS0FBSyxDQUFDM0IsR0FBRCxDQUFqQjtBQUNBOztBQUVELGVBQU83QixJQUFQO0FBQ0EsT0E3Q1M7O0FBK0NWO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHeUQsa0JBQVksRUFBRSxzQkFBVUMsTUFBVixFQUFrQkMsTUFBbEIsRUFBMEJDLE1BQTFCLEVBQWtDQyxJQUFsQyxFQUF3QztBQUNyREEsWUFBSSxHQUFHQSxJQUFJO0FBQUk7QUFBb0IxRCxTQUFDLENBQUMrQyxTQUFyQztBQUNBLFlBQUlZLE9BQU8sR0FBR0QsSUFBSSxDQUFDSCxNQUFELENBQWxCO0FBQ0E7O0FBQ0EsWUFBSUssR0FBRyxHQUFHLEVBQVY7O0FBRUEsYUFBSyxJQUFJQyxLQUFULElBQWtCRixPQUFsQixFQUEyQjtBQUMxQixjQUFJQSxPQUFPLENBQUNoQyxjQUFSLENBQXVCa0MsS0FBdkIsQ0FBSixFQUFtQztBQUVsQyxnQkFBSUEsS0FBSyxJQUFJTCxNQUFiLEVBQXFCO0FBQ3BCLG1CQUFLLElBQUlNLFFBQVQsSUFBcUJMLE1BQXJCLEVBQTZCO0FBQzVCLG9CQUFJQSxNQUFNLENBQUM5QixjQUFQLENBQXNCbUMsUUFBdEIsQ0FBSixFQUFxQztBQUNwQ0YscUJBQUcsQ0FBQ0UsUUFBRCxDQUFILEdBQWdCTCxNQUFNLENBQUNLLFFBQUQsQ0FBdEI7QUFDQTtBQUNEO0FBQ0QsYUFSaUMsQ0FVbEM7OztBQUNBLGdCQUFJLENBQUNMLE1BQU0sQ0FBQzlCLGNBQVAsQ0FBc0JrQyxLQUF0QixDQUFMLEVBQW1DO0FBQ2xDRCxpQkFBRyxDQUFDQyxLQUFELENBQUgsR0FBYUYsT0FBTyxDQUFDRSxLQUFELENBQXBCO0FBQ0E7QUFDRDtBQUNEOztBQUVELFlBQUlFLEdBQUcsR0FBR0wsSUFBSSxDQUFDSCxNQUFELENBQWQ7QUFDQUcsWUFBSSxDQUFDSCxNQUFELENBQUosR0FBZUssR0FBZixDQXpCcUQsQ0EyQnJEOztBQUNBNUQsU0FBQyxDQUFDK0MsU0FBRixDQUFZaUIsR0FBWixDQUFnQmhFLENBQUMsQ0FBQytDLFNBQWxCLEVBQTZCLFVBQVVyQixHQUFWLEVBQWVMLEtBQWYsRUFBc0I7QUFDbEQsY0FBSUEsS0FBSyxLQUFLMEMsR0FBVixJQUFpQnJDLEdBQUcsSUFBSTZCLE1BQTVCLEVBQW9DO0FBQ25DLGlCQUFLN0IsR0FBTCxJQUFZa0MsR0FBWjtBQUNBO0FBQ0QsU0FKRDs7QUFNQSxlQUFPQSxHQUFQO0FBQ0EsT0E3SlM7QUErSlY7QUFDQUksU0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYXBELENBQWIsRUFBZ0JxRCxRQUFoQixFQUEwQjVELElBQTFCLEVBQWdDbUIsT0FBaEMsRUFBeUM7QUFDN0NBLGVBQU8sR0FBR0EsT0FBTyxJQUFJLEVBQXJCO0FBRUEsWUFBSU4sS0FBSyxHQUFHbEIsQ0FBQyxDQUFDQyxJQUFGLENBQU9pQixLQUFuQjs7QUFFQSxhQUFLLElBQUlZLENBQVQsSUFBY2xCLENBQWQsRUFBaUI7QUFDaEIsY0FBSUEsQ0FBQyxDQUFDZSxjQUFGLENBQWlCRyxDQUFqQixDQUFKLEVBQXlCO0FBQ3hCbUMsb0JBQVEsQ0FBQ2pELElBQVQsQ0FBY0osQ0FBZCxFQUFpQmtCLENBQWpCLEVBQW9CbEIsQ0FBQyxDQUFDa0IsQ0FBRCxDQUFyQixFQUEwQnpCLElBQUksSUFBSXlCLENBQWxDO0FBRUEsZ0JBQUlvQyxRQUFRLEdBQUd0RCxDQUFDLENBQUNrQixDQUFELENBQWhCOztBQUNBLGdCQUFJcUMsWUFBWSxHQUFHbkUsQ0FBQyxDQUFDQyxJQUFGLENBQU9JLElBQVAsQ0FBWTZELFFBQVosQ0FBbkI7O0FBRUEsZ0JBQUlDLFlBQVksS0FBSyxRQUFqQixJQUE2QixDQUFDM0MsT0FBTyxDQUFDTixLQUFLLENBQUNnRCxRQUFELENBQU4sQ0FBekMsRUFBNEQ7QUFDM0QxQyxxQkFBTyxDQUFDTixLQUFLLENBQUNnRCxRQUFELENBQU4sQ0FBUCxHQUEyQixJQUEzQjtBQUNBRixpQkFBRyxDQUFDRSxRQUFELEVBQVdELFFBQVgsRUFBcUIsSUFBckIsRUFBMkJ6QyxPQUEzQixDQUFIO0FBQ0EsYUFIRCxNQUdPLElBQUkyQyxZQUFZLEtBQUssT0FBakIsSUFBNEIsQ0FBQzNDLE9BQU8sQ0FBQ04sS0FBSyxDQUFDZ0QsUUFBRCxDQUFOLENBQXhDLEVBQTJEO0FBQ2pFMUMscUJBQU8sQ0FBQ04sS0FBSyxDQUFDZ0QsUUFBRCxDQUFOLENBQVAsR0FBMkIsSUFBM0I7QUFDQUYsaUJBQUcsQ0FBQ0UsUUFBRCxFQUFXRCxRQUFYLEVBQXFCbkMsQ0FBckIsRUFBd0JOLE9BQXhCLENBQUg7QUFDQTtBQUNEO0FBQ0Q7QUFDRDtBQXJMUyxLQXZMSjtBQStXUDRDLFdBQU8sRUFBRSxFQS9XRjs7QUFrWFA7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFQyxhQUFTLEVBQUUsbUJBQVVuQixJQUFWLEVBQWdCUyxPQUFoQixFQUF5QnBCLFFBQXpCLEVBQW1DO0FBQzdDLFVBQUkrQixHQUFHLEdBQUc7QUFDVEMsWUFBSSxFQUFFckIsSUFERztBQUVUUyxlQUFPLEVBQUVBLE9BRkE7QUFHVHBCLGdCQUFRLEVBQUVBO0FBSEQsT0FBVjs7QUFLQXZDLE9BQUMsQ0FBQ3dFLEtBQUYsQ0FBUUMsR0FBUixDQUFZLGlCQUFaLEVBQStCSCxHQUEvQjs7QUFDQUEsU0FBRyxDQUFDbkUsTUFBSixHQUFhSCxDQUFDLENBQUMwRSxRQUFGLENBQVdKLEdBQUcsQ0FBQ0MsSUFBZixFQUFxQkQsR0FBRyxDQUFDWCxPQUF6QixDQUFiOztBQUNBM0QsT0FBQyxDQUFDd0UsS0FBRixDQUFRQyxHQUFSLENBQVksZ0JBQVosRUFBOEJILEdBQTlCOztBQUNBLGFBQU9sRSxLQUFLLENBQUN1RSxTQUFOLENBQWdCM0UsQ0FBQyxDQUFDQyxJQUFGLENBQU9DLE1BQVAsQ0FBY29FLEdBQUcsQ0FBQ25FLE1BQWxCLENBQWhCLEVBQTJDbUUsR0FBRyxDQUFDL0IsUUFBL0MsQ0FBUDtBQUNBLEtBaFpNOztBQWtaUDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRW1DLFlBQVEsRUFBRSxrQkFBVXhCLElBQVYsRUFBZ0JTLE9BQWhCLEVBQXlCO0FBQ2xDLFVBQUlpQixJQUFJLEdBQUdqQixPQUFPLENBQUNpQixJQUFuQjs7QUFDQSxVQUFJQSxJQUFKLEVBQVU7QUFDVCxhQUFLLElBQUlmLEtBQVQsSUFBa0JlLElBQWxCLEVBQXdCO0FBQ3ZCakIsaUJBQU8sQ0FBQ0UsS0FBRCxDQUFQLEdBQWlCZSxJQUFJLENBQUNmLEtBQUQsQ0FBckI7QUFDQTs7QUFFRCxlQUFPRixPQUFPLENBQUNpQixJQUFmO0FBQ0E7O0FBRUQsVUFBSUMsU0FBUyxHQUFHLElBQUlDLFVBQUosRUFBaEI7QUFDQUMsY0FBUSxDQUFDRixTQUFELEVBQVlBLFNBQVMsQ0FBQ0csSUFBdEIsRUFBNEI5QixJQUE1QixDQUFSO0FBRUErQixrQkFBWSxDQUFDL0IsSUFBRCxFQUFPMkIsU0FBUCxFQUFrQmxCLE9BQWxCLEVBQTJCa0IsU0FBUyxDQUFDRyxJQUFyQyxFQUEyQyxDQUEzQyxDQUFaO0FBRUEsYUFBT0UsT0FBTyxDQUFDTCxTQUFELENBQWQ7QUFDQSxLQTFiTTs7QUE0YlA7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNFTCxTQUFLLEVBQUU7QUFDTlcsU0FBRyxFQUFFLEVBREM7O0FBR047QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0d6QyxTQUFHLEVBQUUsYUFBVTBDLElBQVYsRUFBZ0JuQixRQUFoQixFQUEwQjtBQUM5QixZQUFJTyxLQUFLLEdBQUd4RSxDQUFDLENBQUN3RSxLQUFGLENBQVFXLEdBQXBCO0FBRUFYLGFBQUssQ0FBQ1ksSUFBRCxDQUFMLEdBQWNaLEtBQUssQ0FBQ1ksSUFBRCxDQUFMLElBQWUsRUFBN0I7QUFFQVosYUFBSyxDQUFDWSxJQUFELENBQUwsQ0FBWUMsSUFBWixDQUFpQnBCLFFBQWpCO0FBQ0EsT0FyQks7O0FBdUJOO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNHUSxTQUFHLEVBQUUsYUFBVVcsSUFBVixFQUFnQmQsR0FBaEIsRUFBcUI7QUFDekIsWUFBSWdCLFNBQVMsR0FBR3RGLENBQUMsQ0FBQ3dFLEtBQUYsQ0FBUVcsR0FBUixDQUFZQyxJQUFaLENBQWhCOztBQUVBLFlBQUksQ0FBQ0UsU0FBRCxJQUFjLENBQUNBLFNBQVMsQ0FBQ0MsTUFBN0IsRUFBcUM7QUFDcEM7QUFDQTs7QUFFRCxhQUFLLElBQUl6RCxDQUFDLEdBQUcsQ0FBUixFQUFXbUMsUUFBaEIsRUFBMkJBLFFBQVEsR0FBR3FCLFNBQVMsQ0FBQ3hELENBQUMsRUFBRixDQUEvQyxHQUF3RDtBQUN2RG1DLGtCQUFRLENBQUNLLEdBQUQsQ0FBUjtBQUNBO0FBQ0Q7QUExQ0ssS0FqY0E7QUE4ZVBsRSxTQUFLLEVBQUVBO0FBOWVBLEdBQVIsQ0FWeUIsQ0E0ZnpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0MsV0FBU0EsS0FBVCxDQUFlQyxJQUFmLEVBQXFCQyxPQUFyQixFQUE4QkMsS0FBOUIsRUFBcUNpRixVQUFyQyxFQUFpRDtBQUNoRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxTQUFLbkYsSUFBTCxHQUFZQSxJQUFaO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDRSxTQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDRSxTQUFLQyxLQUFMLEdBQWFBLEtBQWIsQ0EzQmdELENBNEJoRDs7QUFDQSxTQUFLZ0YsTUFBTCxHQUFjLENBQUNDLFVBQVUsSUFBSSxFQUFmLEVBQW1CRCxNQUFuQixHQUE0QixDQUExQztBQUNBO0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0NuRixPQUFLLENBQUN1RSxTQUFOLEdBQWtCLFNBQVNBLFNBQVQsQ0FBbUIvRCxDQUFuQixFQUFzQjJCLFFBQXRCLEVBQWdDO0FBQ2pELFFBQUksT0FBTzNCLENBQVAsSUFBWSxRQUFoQixFQUEwQjtBQUN6QixhQUFPQSxDQUFQO0FBQ0E7O0FBQ0QsUUFBSUosS0FBSyxDQUFDQyxPQUFOLENBQWNHLENBQWQsQ0FBSixFQUFzQjtBQUNyQixVQUFJNkUsQ0FBQyxHQUFHLEVBQVI7QUFDQTdFLE9BQUMsQ0FBQ2dCLE9BQUYsQ0FBVSxVQUFVOEQsQ0FBVixFQUFhO0FBQ3RCRCxTQUFDLElBQUlkLFNBQVMsQ0FBQ2UsQ0FBRCxFQUFJbkQsUUFBSixDQUFkO0FBQ0EsT0FGRDtBQUdBLGFBQU9rRCxDQUFQO0FBQ0E7O0FBRUQsUUFBSW5CLEdBQUcsR0FBRztBQUNUakUsVUFBSSxFQUFFTyxDQUFDLENBQUNQLElBREM7QUFFVEMsYUFBTyxFQUFFcUUsU0FBUyxDQUFDL0QsQ0FBQyxDQUFDTixPQUFILEVBQVlpQyxRQUFaLENBRlQ7QUFHVG9ELFNBQUcsRUFBRSxNQUhJO0FBSVRDLGFBQU8sRUFBRSxDQUFDLE9BQUQsRUFBVWhGLENBQUMsQ0FBQ1AsSUFBWixDQUpBO0FBS1R3RixnQkFBVSxFQUFFLEVBTEg7QUFNVHRELGNBQVEsRUFBRUE7QUFORCxLQUFWO0FBU0EsUUFBSXVELE9BQU8sR0FBR2xGLENBQUMsQ0FBQ0wsS0FBaEI7O0FBQ0EsUUFBSXVGLE9BQUosRUFBYTtBQUNaLFVBQUl0RixLQUFLLENBQUNDLE9BQU4sQ0FBY3FGLE9BQWQsQ0FBSixFQUE0QjtBQUMzQnRGLGFBQUssQ0FBQ00sU0FBTixDQUFnQnVFLElBQWhCLENBQXFCVSxLQUFyQixDQUEyQnpCLEdBQUcsQ0FBQ3NCLE9BQS9CLEVBQXdDRSxPQUF4QztBQUNBLE9BRkQsTUFFTztBQUNOeEIsV0FBRyxDQUFDc0IsT0FBSixDQUFZUCxJQUFaLENBQWlCUyxPQUFqQjtBQUNBO0FBQ0Q7O0FBRUQ5RixLQUFDLENBQUN3RSxLQUFGLENBQVFDLEdBQVIsQ0FBWSxNQUFaLEVBQW9CSCxHQUFwQjs7QUFFQSxRQUFJdUIsVUFBVSxHQUFHLEVBQWpCOztBQUNBLFNBQUssSUFBSVQsSUFBVCxJQUFpQmQsR0FBRyxDQUFDdUIsVUFBckIsRUFBaUM7QUFDaENBLGdCQUFVLElBQUksTUFBTVQsSUFBTixHQUFhLElBQWIsR0FBb0IsQ0FBQ2QsR0FBRyxDQUFDdUIsVUFBSixDQUFlVCxJQUFmLEtBQXdCLEVBQXpCLEVBQTZCekUsT0FBN0IsQ0FBcUMsSUFBckMsRUFBMkMsUUFBM0MsQ0FBcEIsR0FBMkUsR0FBekY7QUFDQTs7QUFFRCxXQUFPLE1BQU0yRCxHQUFHLENBQUNxQixHQUFWLEdBQWdCLFVBQWhCLEdBQTZCckIsR0FBRyxDQUFDc0IsT0FBSixDQUFZSSxJQUFaLENBQWlCLEdBQWpCLENBQTdCLEdBQXFELEdBQXJELEdBQTJESCxVQUEzRCxHQUF3RSxHQUF4RSxHQUE4RXZCLEdBQUcsQ0FBQ2hFLE9BQWxGLEdBQTRGLElBQTVGLEdBQW1HZ0UsR0FBRyxDQUFDcUIsR0FBdkcsR0FBNkcsR0FBcEg7QUFDQSxHQXRDRDtBQXdDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU00sWUFBVCxDQUFzQkMsT0FBdEIsRUFBK0JDLEdBQS9CLEVBQW9DakQsSUFBcEMsRUFBMENrRCxVQUExQyxFQUFzRDtBQUNyREYsV0FBTyxDQUFDRyxTQUFSLEdBQW9CRixHQUFwQjtBQUNBLFFBQUlHLEtBQUssR0FBR0osT0FBTyxDQUFDaEUsSUFBUixDQUFhZ0IsSUFBYixDQUFaOztBQUNBLFFBQUlvRCxLQUFLLElBQUlGLFVBQVQsSUFBdUJFLEtBQUssQ0FBQyxDQUFELENBQWhDLEVBQXFDO0FBQ3BDO0FBQ0EsVUFBSUMsZ0JBQWdCLEdBQUdELEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2YsTUFBaEM7QUFDQWUsV0FBSyxDQUFDRSxLQUFOLElBQWVELGdCQUFmO0FBQ0FELFdBQUssQ0FBQyxDQUFELENBQUwsR0FBV0EsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTckYsS0FBVCxDQUFlc0YsZ0JBQWYsQ0FBWDtBQUNBOztBQUNELFdBQU9ELEtBQVA7QUFDQTtBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNDLFdBQVNyQixZQUFULENBQXNCL0IsSUFBdEIsRUFBNEIyQixTQUE1QixFQUF1Q2xCLE9BQXZDLEVBQWdEOEMsU0FBaEQsRUFBMkRDLFFBQTNELEVBQXFFQyxPQUFyRSxFQUE4RTtBQUM3RSxTQUFLLElBQUk5QyxLQUFULElBQWtCRixPQUFsQixFQUEyQjtBQUMxQixVQUFJLENBQUNBLE9BQU8sQ0FBQ2hDLGNBQVIsQ0FBdUJrQyxLQUF2QixDQUFELElBQWtDLENBQUNGLE9BQU8sQ0FBQ0UsS0FBRCxDQUE5QyxFQUF1RDtBQUN0RDtBQUNBOztBQUVELFVBQUkrQyxRQUFRLEdBQUdqRCxPQUFPLENBQUNFLEtBQUQsQ0FBdEI7QUFDQStDLGNBQVEsR0FBR3BHLEtBQUssQ0FBQ0MsT0FBTixDQUFjbUcsUUFBZCxJQUEwQkEsUUFBMUIsR0FBcUMsQ0FBQ0EsUUFBRCxDQUFoRDs7QUFFQSxXQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdELFFBQVEsQ0FBQ3JCLE1BQTdCLEVBQXFDLEVBQUVzQixDQUF2QyxFQUEwQztBQUN6QyxZQUFJRixPQUFPLElBQUlBLE9BQU8sQ0FBQ0csS0FBUixJQUFpQmpELEtBQUssR0FBRyxHQUFSLEdBQWNnRCxDQUE5QyxFQUFpRDtBQUNoRDtBQUNBOztBQUVELFlBQUlFLFVBQVUsR0FBR0gsUUFBUSxDQUFDQyxDQUFELENBQXpCO0FBQ0EsWUFBSXRELE1BQU0sR0FBR3dELFVBQVUsQ0FBQ3hELE1BQXhCO0FBQ0EsWUFBSTZDLFVBQVUsR0FBRyxDQUFDLENBQUNXLFVBQVUsQ0FBQ1gsVUFBOUI7QUFDQSxZQUFJWSxNQUFNLEdBQUcsQ0FBQyxDQUFDRCxVQUFVLENBQUNDLE1BQTFCO0FBQ0EsWUFBSXpHLEtBQUssR0FBR3dHLFVBQVUsQ0FBQ3hHLEtBQXZCOztBQUVBLFlBQUl5RyxNQUFNLElBQUksQ0FBQ0QsVUFBVSxDQUFDYixPQUFYLENBQW1CZSxNQUFsQyxFQUEwQztBQUN6QztBQUNBLGNBQUlDLEtBQUssR0FBR0gsVUFBVSxDQUFDYixPQUFYLENBQW1CbkYsUUFBbkIsR0FBOEJ1RixLQUE5QixDQUFvQyxXQUFwQyxFQUFpRCxDQUFqRCxDQUFaO0FBQ0FTLG9CQUFVLENBQUNiLE9BQVgsR0FBcUIxRCxNQUFNLENBQUN1RSxVQUFVLENBQUNiLE9BQVgsQ0FBbUJpQixNQUFwQixFQUE0QkQsS0FBSyxHQUFHLEdBQXBDLENBQTNCO0FBQ0E7QUFFRDs7O0FBQ0EsWUFBSWhCLE9BQU8sR0FBR2EsVUFBVSxDQUFDYixPQUFYLElBQXNCYSxVQUFwQzs7QUFFQSxjQUFNO0FBQ0wsWUFBSUssV0FBVyxHQUFHWCxTQUFTLENBQUNZLElBQTVCLEVBQWtDbEIsR0FBRyxHQUFHTyxRQUR6QyxFQUVDVSxXQUFXLEtBQUt2QyxTQUFTLENBQUN5QyxJQUYzQixFQUdDbkIsR0FBRyxJQUFJaUIsV0FBVyxDQUFDL0YsS0FBWixDQUFrQmtFLE1BQXpCLEVBQWlDNkIsV0FBVyxHQUFHQSxXQUFXLENBQUNDLElBSDVELEVBSUU7QUFFRCxjQUFJVixPQUFPLElBQUlSLEdBQUcsSUFBSVEsT0FBTyxDQUFDWSxLQUE5QixFQUFxQztBQUNwQztBQUNBOztBQUVELGNBQUlDLEdBQUcsR0FBR0osV0FBVyxDQUFDL0YsS0FBdEI7O0FBRUEsY0FBSXdELFNBQVMsQ0FBQ1UsTUFBVixHQUFtQnJDLElBQUksQ0FBQ3FDLE1BQTVCLEVBQW9DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFRCxjQUFJaUMsR0FBRyxZQUFZcEgsS0FBbkIsRUFBMEI7QUFDekI7QUFDQTs7QUFFRCxjQUFJcUgsV0FBVyxHQUFHLENBQWxCLENBakJDLENBaUJvQjs7QUFDckIsY0FBSW5CLEtBQUo7O0FBRUEsY0FBSVUsTUFBSixFQUFZO0FBQ1hWLGlCQUFLLEdBQUdMLFlBQVksQ0FBQ0MsT0FBRCxFQUFVQyxHQUFWLEVBQWVqRCxJQUFmLEVBQXFCa0QsVUFBckIsQ0FBcEI7O0FBQ0EsZ0JBQUksQ0FBQ0UsS0FBRCxJQUFVQSxLQUFLLENBQUNFLEtBQU4sSUFBZXRELElBQUksQ0FBQ3FDLE1BQWxDLEVBQTBDO0FBQ3pDO0FBQ0E7O0FBRUQsZ0JBQUltQyxJQUFJLEdBQUdwQixLQUFLLENBQUNFLEtBQWpCO0FBQ0EsZ0JBQUltQixFQUFFLEdBQUdyQixLQUFLLENBQUNFLEtBQU4sR0FBY0YsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTZixNQUFoQztBQUNBLGdCQUFJcUMsQ0FBQyxHQUFHekIsR0FBUixDQVJXLENBVVg7O0FBQ0F5QixhQUFDLElBQUlSLFdBQVcsQ0FBQy9GLEtBQVosQ0FBa0JrRSxNQUF2Qjs7QUFDQSxtQkFBT21DLElBQUksSUFBSUUsQ0FBZixFQUFrQjtBQUNqQlIseUJBQVcsR0FBR0EsV0FBVyxDQUFDQyxJQUExQjtBQUNBTyxlQUFDLElBQUlSLFdBQVcsQ0FBQy9GLEtBQVosQ0FBa0JrRSxNQUF2QjtBQUNBLGFBZlUsQ0FnQlg7OztBQUNBcUMsYUFBQyxJQUFJUixXQUFXLENBQUMvRixLQUFaLENBQWtCa0UsTUFBdkI7QUFDQVksZUFBRyxHQUFHeUIsQ0FBTixDQWxCVyxDQW9CWDs7QUFDQSxnQkFBSVIsV0FBVyxDQUFDL0YsS0FBWixZQUE2QmpCLEtBQWpDLEVBQXdDO0FBQ3ZDO0FBQ0EsYUF2QlUsQ0F5Qlg7OztBQUNBLGlCQUNDLElBQUl5SCxDQUFDLEdBQUdULFdBRFQsRUFFQ1MsQ0FBQyxLQUFLaEQsU0FBUyxDQUFDeUMsSUFBaEIsS0FBeUJNLENBQUMsR0FBR0QsRUFBSixJQUFVLE9BQU9FLENBQUMsQ0FBQ3hHLEtBQVQsS0FBbUIsUUFBdEQsQ0FGRCxFQUdDd0csQ0FBQyxHQUFHQSxDQUFDLENBQUNSLElBSFAsRUFJRTtBQUNESSx5QkFBVztBQUNYRyxlQUFDLElBQUlDLENBQUMsQ0FBQ3hHLEtBQUYsQ0FBUWtFLE1BQWI7QUFDQTs7QUFDRGtDLHVCQUFXLEdBbENBLENBb0NYOztBQUNBRCxlQUFHLEdBQUd0RSxJQUFJLENBQUNqQyxLQUFMLENBQVdrRixHQUFYLEVBQWdCeUIsQ0FBaEIsQ0FBTjtBQUNBdEIsaUJBQUssQ0FBQ0UsS0FBTixJQUFlTCxHQUFmO0FBQ0EsV0F2Q0QsTUF1Q087QUFDTkcsaUJBQUssR0FBR0wsWUFBWSxDQUFDQyxPQUFELEVBQVUsQ0FBVixFQUFhc0IsR0FBYixFQUFrQnBCLFVBQWxCLENBQXBCOztBQUNBLGdCQUFJLENBQUNFLEtBQUwsRUFBWTtBQUNYO0FBQ0E7QUFDRCxXQWhFQSxDQWtFRDs7O0FBQ0EsY0FBSW9CLElBQUksR0FBR3BCLEtBQUssQ0FBQ0UsS0FBakI7QUFDQSxjQUFJc0IsUUFBUSxHQUFHeEIsS0FBSyxDQUFDLENBQUQsQ0FBcEI7QUFDQSxjQUFJOUMsTUFBTSxHQUFHZ0UsR0FBRyxDQUFDdkcsS0FBSixDQUFVLENBQVYsRUFBYXlHLElBQWIsQ0FBYjtBQUNBLGNBQUlLLEtBQUssR0FBR1AsR0FBRyxDQUFDdkcsS0FBSixDQUFVeUcsSUFBSSxHQUFHSSxRQUFRLENBQUN2QyxNQUExQixDQUFaO0FBRUEsY0FBSWdDLEtBQUssR0FBR3BCLEdBQUcsR0FBR3FCLEdBQUcsQ0FBQ2pDLE1BQXRCOztBQUNBLGNBQUlvQixPQUFPLElBQUlZLEtBQUssR0FBR1osT0FBTyxDQUFDWSxLQUEvQixFQUFzQztBQUNyQ1osbUJBQU8sQ0FBQ1ksS0FBUixHQUFnQkEsS0FBaEI7QUFDQTs7QUFFRCxjQUFJUyxVQUFVLEdBQUdaLFdBQVcsQ0FBQ2EsSUFBN0I7O0FBRUEsY0FBSXpFLE1BQUosRUFBWTtBQUNYd0Usc0JBQVUsR0FBR2pELFFBQVEsQ0FBQ0YsU0FBRCxFQUFZbUQsVUFBWixFQUF3QnhFLE1BQXhCLENBQXJCO0FBQ0EyQyxlQUFHLElBQUkzQyxNQUFNLENBQUMrQixNQUFkO0FBQ0E7O0FBRUQyQyxxQkFBVyxDQUFDckQsU0FBRCxFQUFZbUQsVUFBWixFQUF3QlAsV0FBeEIsQ0FBWDtBQUVBLGNBQUlVLE9BQU8sR0FBRyxJQUFJL0gsS0FBSixDQUFVeUQsS0FBVixFQUFpQk4sTUFBTSxHQUFHdkQsQ0FBQyxDQUFDMEUsUUFBRixDQUFXb0QsUUFBWCxFQUFxQnZFLE1BQXJCLENBQUgsR0FBa0N1RSxRQUF6RCxFQUFtRXZILEtBQW5FLEVBQTBFdUgsUUFBMUUsQ0FBZDtBQUNBVixxQkFBVyxHQUFHckMsUUFBUSxDQUFDRixTQUFELEVBQVltRCxVQUFaLEVBQXdCRyxPQUF4QixDQUF0Qjs7QUFFQSxjQUFJSixLQUFKLEVBQVc7QUFDVmhELG9CQUFRLENBQUNGLFNBQUQsRUFBWXVDLFdBQVosRUFBeUJXLEtBQXpCLENBQVI7QUFDQTs7QUFFRCxjQUFJTixXQUFXLEdBQUcsQ0FBbEIsRUFBcUI7QUFDcEI7QUFDQTs7QUFFQTtBQUNBLGdCQUFJVyxhQUFhLEdBQUc7QUFDbkJ0QixtQkFBSyxFQUFFakQsS0FBSyxHQUFHLEdBQVIsR0FBY2dELENBREY7QUFFbkJVLG1CQUFLLEVBQUVBO0FBRlksYUFBcEI7QUFJQXRDLHdCQUFZLENBQUMvQixJQUFELEVBQU8yQixTQUFQLEVBQWtCbEIsT0FBbEIsRUFBMkJ5RCxXQUFXLENBQUNhLElBQXZDLEVBQTZDOUIsR0FBN0MsRUFBa0RpQyxhQUFsRCxDQUFaLENBVG9CLENBV3BCOztBQUNBLGdCQUFJekIsT0FBTyxJQUFJeUIsYUFBYSxDQUFDYixLQUFkLEdBQXNCWixPQUFPLENBQUNZLEtBQTdDLEVBQW9EO0FBQ25EWixxQkFBTyxDQUFDWSxLQUFSLEdBQWdCYSxhQUFhLENBQUNiLEtBQTlCO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7QUFDRDtBQUNEO0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQztBQUNEO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU3pDLFVBQVQsR0FBc0I7QUFDckI7QUFDQSxRQUFJRSxJQUFJLEdBQUc7QUFBRTNELFdBQUssRUFBRSxJQUFUO0FBQWU0RyxVQUFJLEVBQUUsSUFBckI7QUFBMkJaLFVBQUksRUFBRTtBQUFqQyxLQUFYO0FBQ0E7O0FBQ0EsUUFBSUMsSUFBSSxHQUFHO0FBQUVqRyxXQUFLLEVBQUUsSUFBVDtBQUFlNEcsVUFBSSxFQUFFakQsSUFBckI7QUFBMkJxQyxVQUFJLEVBQUU7QUFBakMsS0FBWDtBQUNBckMsUUFBSSxDQUFDcUMsSUFBTCxHQUFZQyxJQUFaO0FBRUE7O0FBQ0EsU0FBS3RDLElBQUwsR0FBWUEsSUFBWjtBQUNBOztBQUNBLFNBQUtzQyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLL0IsTUFBTCxHQUFjLENBQWQ7QUFDQTtBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU1IsUUFBVCxDQUFrQnNELElBQWxCLEVBQXdCQyxJQUF4QixFQUE4QmpILEtBQTlCLEVBQXFDO0FBQ3BDO0FBQ0EsUUFBSWdHLElBQUksR0FBR2lCLElBQUksQ0FBQ2pCLElBQWhCO0FBRUEsUUFBSWtCLE9BQU8sR0FBRztBQUFFbEgsV0FBSyxFQUFFQSxLQUFUO0FBQWdCNEcsVUFBSSxFQUFFSyxJQUF0QjtBQUE0QmpCLFVBQUksRUFBRUE7QUFBbEMsS0FBZDtBQUNBaUIsUUFBSSxDQUFDakIsSUFBTCxHQUFZa0IsT0FBWjtBQUNBbEIsUUFBSSxDQUFDWSxJQUFMLEdBQVlNLE9BQVo7QUFDQUYsUUFBSSxDQUFDOUMsTUFBTDtBQUVBLFdBQU9nRCxPQUFQO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQyxXQUFTTCxXQUFULENBQXFCRyxJQUFyQixFQUEyQkMsSUFBM0IsRUFBaUNFLEtBQWpDLEVBQXdDO0FBQ3ZDLFFBQUluQixJQUFJLEdBQUdpQixJQUFJLENBQUNqQixJQUFoQjs7QUFDQSxTQUFLLElBQUl2RixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMEcsS0FBSixJQUFhbkIsSUFBSSxLQUFLZ0IsSUFBSSxDQUFDZixJQUEzQyxFQUFpRHhGLENBQUMsRUFBbEQsRUFBc0Q7QUFDckR1RixVQUFJLEdBQUdBLElBQUksQ0FBQ0EsSUFBWjtBQUNBOztBQUNEaUIsUUFBSSxDQUFDakIsSUFBTCxHQUFZQSxJQUFaO0FBQ0FBLFFBQUksQ0FBQ1ksSUFBTCxHQUFZSyxJQUFaO0FBQ0FELFFBQUksQ0FBQzlDLE1BQUwsSUFBZXpELENBQWY7QUFDQTtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUNDLFdBQVNvRCxPQUFULENBQWlCbUQsSUFBakIsRUFBdUI7QUFDdEIsUUFBSUksS0FBSyxHQUFHLEVBQVo7QUFDQSxRQUFJSCxJQUFJLEdBQUdELElBQUksQ0FBQ3JELElBQUwsQ0FBVXFDLElBQXJCOztBQUNBLFdBQU9pQixJQUFJLEtBQUtELElBQUksQ0FBQ2YsSUFBckIsRUFBMkI7QUFDMUJtQixXQUFLLENBQUNwRCxJQUFOLENBQVdpRCxJQUFJLENBQUNqSCxLQUFoQjtBQUNBaUgsVUFBSSxHQUFHQSxJQUFJLENBQUNqQixJQUFaO0FBQ0E7O0FBQ0QsV0FBT29CLEtBQVA7QUFDQTs7QUFFRCxTQUFPekksQ0FBUDtBQUVBLENBcjNCYSxFQUFiOztBQXUzQkQsSUFBSTBJLEtBQUssR0FBRzlJLEtBQVo7QUFDQUEsS0FBSyxXQUFMLEdBQWdCQSxLQUFoQjtBQUVBOztBQUVBOztBQUVBOEksS0FBSyxDQUFDM0YsU0FBTixDQUFnQjRGLE1BQWhCLEdBQXlCO0FBQ3ZCLGFBQVc7QUFDVHpDLFdBQU8sRUFBRSw2QkFEQTtBQUVUYyxVQUFNLEVBQUU7QUFGQyxHQURZO0FBS3ZCLFlBQVU7QUFDUmQsV0FBTyxFQUFFLGdCQUREO0FBRVJjLFVBQU0sRUFBRTtBQUZBLEdBTGE7QUFTdkIsYUFBVztBQUNUO0FBQ0FkLFdBQU8sRUFBRSxzSEFGQTtBQUdUYyxVQUFNLEVBQUUsSUFIQztBQUlUekQsVUFBTSxFQUFFO0FBQ04seUJBQW1CO0FBQ2pCMkMsZUFBTyxFQUFFLDRCQURRO0FBRWpCRSxrQkFBVSxFQUFFLElBRks7QUFHakJZLGNBQU0sRUFBRSxJQUhTO0FBSWpCekQsY0FBTSxFQUFFLElBSlMsQ0FJSjs7QUFKSSxPQURiO0FBUU4sZ0JBQVU7QUFDUjJDLGVBQU8sRUFBRSxpQkFERDtBQUVSYyxjQUFNLEVBQUU7QUFGQSxPQVJKO0FBWU4scUJBQWUsY0FaVDtBQWFOLHFCQUFlLFdBYlQ7QUFjTixjQUFRO0FBZEY7QUFKQyxHQVRZO0FBOEJ2QixXQUFTO0FBQ1BkLFdBQU8sRUFBRSwyQkFERjtBQUVQYyxVQUFNLEVBQUU7QUFGRCxHQTlCYztBQWtDdkIsU0FBTztBQUNMZCxXQUFPLEVBQUUsc0hBREo7QUFFTGMsVUFBTSxFQUFFLElBRkg7QUFHTHpELFVBQU0sRUFBRTtBQUNOLGFBQU87QUFDTDJDLGVBQU8sRUFBRSxnQkFESjtBQUVMM0MsY0FBTSxFQUFFO0FBQ04seUJBQWUsT0FEVDtBQUVOLHVCQUFhO0FBRlA7QUFGSCxPQUREO0FBUU4sc0JBQWdCLEVBUlY7QUFTTixvQkFBYztBQUNaMkMsZUFBTyxFQUFFLG9DQURHO0FBRVozQyxjQUFNLEVBQUU7QUFDTix5QkFBZSxDQUFDO0FBQ2QyQyxtQkFBTyxFQUFFLElBREs7QUFFZDNGLGlCQUFLLEVBQUU7QUFGTyxXQUFELEVBR1osS0FIWTtBQURUO0FBRkksT0FUUjtBQWtCTixxQkFBZSxNQWxCVDtBQW1CTixtQkFBYTtBQUNYMkYsZUFBTyxFQUFFLFdBREU7QUFFWDNDLGNBQU0sRUFBRTtBQUNOLHVCQUFhO0FBRFA7QUFGRztBQW5CUDtBQUhILEdBbENnQjtBQWdFdkIsWUFBVSxDQUFDO0FBQ1QyQyxXQUFPLEVBQUUsaUJBREE7QUFFVDNGLFNBQUssRUFBRTtBQUZFLEdBQUQsRUFHUCxvQkFITztBQWhFYSxDQUF6QjtBQXFFQW1JLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0I0RixNQUFoQixDQUF1QixLQUF2QixFQUE4QnBGLE1BQTlCLENBQXFDLFlBQXJDLEVBQW1EQSxNQUFuRCxDQUEwRCxRQUExRCxJQUFzRW1GLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0I0RixNQUFoQixDQUF1QixRQUF2QixDQUF0RTtBQUNBRCxLQUFLLENBQUMzRixTQUFOLENBQWdCNEYsTUFBaEIsQ0FBdUIsU0FBdkIsRUFBa0NwRixNQUFsQyxDQUF5QyxpQkFBekMsRUFBNERBLE1BQTVELEdBQXFFbUYsS0FBSyxDQUFDM0YsU0FBTixDQUFnQjRGLE1BQXJGLEMsQ0FBNkY7O0FBRTdGRCxLQUFLLENBQUNsRSxLQUFOLENBQVk5QixHQUFaLENBQWdCLE1BQWhCLEVBQXdCLFVBQVU0QixHQUFWLEVBQWU7QUFDckMsTUFBSUEsR0FBRyxDQUFDakUsSUFBSixLQUFhLFFBQWpCLEVBQTJCO0FBQ3pCaUUsT0FBRyxDQUFDdUIsVUFBSixDQUFlLE9BQWYsSUFBMEJ2QixHQUFHLENBQUNoRSxPQUFKLENBQVlLLE9BQVosQ0FBb0IsT0FBcEIsRUFBNkIsR0FBN0IsQ0FBMUI7QUFDRDtBQUNGLENBSkQ7QUFLQUUsTUFBTSxDQUFDTyxjQUFQLENBQXNCc0gsS0FBSyxDQUFDM0YsU0FBTixDQUFnQjRGLE1BQWhCLENBQXVCaEQsR0FBN0MsRUFBa0QsWUFBbEQsRUFBZ0U7QUFDOUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFdEUsT0FBSyxFQUFFLFNBQVN1SCxVQUFULENBQW9CQyxPQUFwQixFQUE2QmhKLElBQTdCLEVBQW1DO0FBQ3hDLFFBQUlpSixtQkFBbUIsR0FBRyxFQUExQjtBQUNBQSx1QkFBbUIsQ0FBQyxjQUFjakosSUFBZixDQUFuQixHQUEwQztBQUN4Q3FHLGFBQU8sRUFBRSxtQ0FEK0I7QUFFeENFLGdCQUFVLEVBQUUsSUFGNEI7QUFHeEM3QyxZQUFNLEVBQUVtRixLQUFLLENBQUMzRixTQUFOLENBQWdCbEQsSUFBaEI7QUFIZ0MsS0FBMUM7QUFLQWlKLHVCQUFtQixDQUFDLE9BQUQsQ0FBbkIsR0FBK0Isc0JBQS9CO0FBQ0EsUUFBSXZGLE1BQU0sR0FBRztBQUNYLHdCQUFrQjtBQUNoQjJDLGVBQU8sRUFBRSwyQkFETztBQUVoQjNDLGNBQU0sRUFBRXVGO0FBRlE7QUFEUCxLQUFiO0FBTUF2RixVQUFNLENBQUMsY0FBYzFELElBQWYsQ0FBTixHQUE2QjtBQUMzQnFHLGFBQU8sRUFBRSxTQURrQjtBQUUzQjNDLFlBQU0sRUFBRW1GLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JsRCxJQUFoQjtBQUZtQixLQUE3QjtBQUlBLFFBQUlrSixHQUFHLEdBQUcsRUFBVjtBQUNBQSxPQUFHLENBQUNGLE9BQUQsQ0FBSCxHQUFlO0FBQ2IzQyxhQUFPLEVBQUUxRCxNQUFNLENBQUMsd0ZBQXdGMkUsTUFBeEYsQ0FBK0Z4RyxPQUEvRixDQUF1RyxLQUF2RyxFQUE4RyxZQUFZO0FBQ3hJLGVBQU9rSSxPQUFQO0FBQ0QsT0FGZSxDQUFELEVBRVgsR0FGVyxDQURGO0FBSWJ6QyxnQkFBVSxFQUFFLElBSkM7QUFLYlksWUFBTSxFQUFFLElBTEs7QUFNYnpELFlBQU0sRUFBRUE7QUFOSyxLQUFmO0FBUUFtRixTQUFLLENBQUMzRixTQUFOLENBQWdCTyxZQUFoQixDQUE2QixRQUE3QixFQUF1QyxPQUF2QyxFQUFnRHlGLEdBQWhEO0FBQ0Q7QUF4QzZELENBQWhFO0FBMENBbEksTUFBTSxDQUFDTyxjQUFQLENBQXNCc0gsS0FBSyxDQUFDM0YsU0FBTixDQUFnQjRGLE1BQWhCLENBQXVCaEQsR0FBN0MsRUFBa0QsY0FBbEQsRUFBa0U7QUFDaEU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFdEUsT0FBSyxFQUFFLGVBQVUySCxRQUFWLEVBQW9CbkosSUFBcEIsRUFBMEI7QUFDL0I2SSxTQUFLLENBQUMzRixTQUFOLENBQWdCNEYsTUFBaEIsQ0FBdUJoRCxHQUF2QixDQUEyQnBDLE1BQTNCLENBQWtDLGNBQWxDLEVBQWtEOEIsSUFBbEQsQ0FBdUQ7QUFDckRhLGFBQU8sRUFBRTFELE1BQU0sQ0FBQyxhQUFhMkUsTUFBYixHQUFzQixLQUF0QixHQUE4QjZCLFFBQTlCLEdBQXlDLEdBQXpDLEdBQStDLGlEQUFpRDdCLE1BQWpHLEVBQXlHLEdBQXpHLENBRHNDO0FBRXJEZixnQkFBVSxFQUFFLElBRnlDO0FBR3JEN0MsWUFBTSxFQUFFO0FBQ04scUJBQWEsVUFEUDtBQUVOLHNCQUFjO0FBQ1oyQyxpQkFBTyxFQUFFLFVBREc7QUFFWjNDLGdCQUFNLEVBQUU7QUFDTixxQkFBUztBQUNQMkMscUJBQU8sRUFBRSx3Q0FERjtBQUVQRSx3QkFBVSxFQUFFLElBRkw7QUFHUDdGLG1CQUFLLEVBQUUsQ0FBQ1YsSUFBRCxFQUFPLGNBQWNBLElBQXJCLENBSEE7QUFJUDBELG9CQUFNLEVBQUVtRixLQUFLLENBQUMzRixTQUFOLENBQWdCbEQsSUFBaEI7QUFKRCxhQURIO0FBT04sMkJBQWUsQ0FBQztBQUNkcUcscUJBQU8sRUFBRSxJQURLO0FBRWQzRixtQkFBSyxFQUFFO0FBRk8sYUFBRCxFQUdaLEtBSFk7QUFQVDtBQUZJO0FBRlI7QUFINkMsS0FBdkQ7QUFzQkQ7QUFuQytELENBQWxFO0FBcUNBbUksS0FBSyxDQUFDM0YsU0FBTixDQUFnQmtHLElBQWhCLEdBQXVCUCxLQUFLLENBQUMzRixTQUFOLENBQWdCNEYsTUFBdkM7QUFDQUQsS0FBSyxDQUFDM0YsU0FBTixDQUFnQm1HLE1BQWhCLEdBQXlCUixLQUFLLENBQUMzRixTQUFOLENBQWdCNEYsTUFBekM7QUFDQUQsS0FBSyxDQUFDM0YsU0FBTixDQUFnQm9HLEdBQWhCLEdBQXNCVCxLQUFLLENBQUMzRixTQUFOLENBQWdCNEYsTUFBdEM7QUFDQUQsS0FBSyxDQUFDM0YsU0FBTixDQUFnQnFHLEdBQWhCLEdBQXNCVixLQUFLLENBQUMzRixTQUFOLENBQWdCSyxNQUFoQixDQUF1QixRQUF2QixFQUFpQyxFQUFqQyxDQUF0QjtBQUNBc0YsS0FBSyxDQUFDM0YsU0FBTixDQUFnQnNHLElBQWhCLEdBQXVCWCxLQUFLLENBQUMzRixTQUFOLENBQWdCcUcsR0FBdkM7QUFDQVYsS0FBSyxDQUFDM0YsU0FBTixDQUFnQnVHLElBQWhCLEdBQXVCWixLQUFLLENBQUMzRixTQUFOLENBQWdCcUcsR0FBdkM7QUFDQVYsS0FBSyxDQUFDM0YsU0FBTixDQUFnQndHLEdBQWhCLEdBQXNCYixLQUFLLENBQUMzRixTQUFOLENBQWdCcUcsR0FBdEM7QUFDQTs7QUFFQSxDQUFDLFVBQVV4SixLQUFWLEVBQWlCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSTRKLE9BQU8sR0FBRyx5b0NBQWQ7QUFDQSxNQUFJQyxtQkFBbUIsR0FBRztBQUN4QnZELFdBQU8sRUFBRSwyQkFEZTtBQUV4QkUsY0FBVSxFQUFFLElBRlk7QUFHeEI3RixTQUFLLEVBQUUsYUFIaUI7QUFJeEI7QUFDQWdELFVBQU0sRUFBRSxJQUxnQixDQUtYOztBQUxXLEdBQTFCO0FBUUEsTUFBSW1HLFlBQVksR0FBRztBQUNqQixZQUFRRCxtQkFEUztBQUVqQixtQkFBZTtBQUNidkQsYUFBTyxFQUFFMUQsTUFBTSxDQUFDLFFBQVFnSCxPQUFULENBREY7QUFFYmpKLFdBQUssRUFBRTtBQUZNLEtBRkU7QUFNakIsZ0JBQVksQ0FBQztBQUNiO0FBQ0UyRixhQUFPLEVBQUUscUJBRFg7QUFFRWMsWUFBTSxFQUFFLElBRlY7QUFHRXpELFlBQU0sRUFBRTtBQUNOO0FBQ0Esb0JBQVksQ0FBQztBQUNYMkMsaUJBQU8sRUFBRSxzQkFERTtBQUVYRSxvQkFBVSxFQUFFO0FBRkQsU0FBRCxFQUdULFNBSFMsQ0FGTjtBQU1OLGtCQUFVLDZEQU5KO0FBT047QUFDQSxvQkFBWSwwREFSTjtBQVNOO0FBQ0EsdUJBQWU7QUFWVDtBQUhWLEtBRFksRUFnQlQ7QUFDSDtBQUNFRixhQUFPLEVBQUUsb0NBRFg7QUFFRWMsWUFBTSxFQUFFLElBRlY7QUFHRXpELFlBQU0sRUFBRTtBQUNOLG9CQUFZO0FBRE47QUFIVixLQWpCWSxFQXVCVDtBQUNIO0FBQ0UyQyxhQUFPLEVBQUUsYUFEWDtBQUVFYyxZQUFNLEVBQUUsSUFGVjtBQUdFekQsWUFBTSxFQUFFO0FBQ04sb0JBQVksa0NBRE47QUFFTix1QkFBZSxRQUZUO0FBR04sdUJBQWU7QUFDYjJDLGlCQUFPLEVBQUUxRCxNQUFNLENBQUMsVUFBVWdILE9BQVgsQ0FERjtBQUVicEQsb0JBQVUsRUFBRSxJQUZDO0FBR2I3RixlQUFLLEVBQUU7QUFITTtBQUhUO0FBSFYsS0F4QlksRUFvQ1Qsb0JBcENTLENBTks7QUEyQ2pCO0FBQ0EsY0FBVTtBQTVDTyxHQUFuQjtBQThDQVgsT0FBSyxDQUFDbUQsU0FBTixDQUFnQjRHLElBQWhCLEdBQXVCO0FBQ3JCLGVBQVc7QUFDVHpELGFBQU8sRUFBRSxZQURBO0FBRVQzRixXQUFLLEVBQUU7QUFGRSxLQURVO0FBS3JCLGVBQVc7QUFDVDJGLGFBQU8sRUFBRSxpQkFEQTtBQUVURSxnQkFBVSxFQUFFO0FBRkgsS0FMVTtBQVNyQixxQkFBaUIsQ0FBQztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0FGLGFBQU8sRUFBRSxpREFGWDtBQUdFRSxnQkFBVSxFQUFFLElBSGQ7QUFJRTdGLFdBQUssRUFBRTtBQUpULEtBSmlCLEVBU2Q7QUFDRDtBQUNBMkYsYUFBTyxFQUFFLDZCQUZSO0FBR0QzRixXQUFLLEVBQUU7QUFITixLQVRjLENBVEk7QUF1QnJCO0FBQ0EscUJBQWlCO0FBQ2YyRixhQUFPLEVBQUUscUNBRE07QUFFZjNGLFdBQUssRUFBRSxVQUZRO0FBR2Y2RixnQkFBVSxFQUFFO0FBSEcsS0F4Qkk7QUE2QnJCO0FBQ0E7QUFDQSxtQkFBZTtBQUNiRixhQUFPLEVBQUUsK0JBREk7QUFFYjNDLFlBQU0sRUFBRTtBQUNOLHVCQUFlO0FBQ2IyQyxpQkFBTyxFQUFFMUQsTUFBTSxDQUFDLHlCQUF5QmdILE9BQTFCLENBREY7QUFFYnBELG9CQUFVLEVBQUUsSUFGQztBQUdiN0YsZUFBSyxFQUFFO0FBSE07QUFEVCxPQUZLO0FBU2JBLFdBQUssRUFBRSxVQVRNO0FBVWI2RixnQkFBVSxFQUFFO0FBVkMsS0EvQk07QUEyQ3JCLGNBQVUsQ0FBQztBQUNYO0FBQ0VGLGFBQU8sRUFBRSxrREFEWDtBQUVFRSxnQkFBVSxFQUFFLElBRmQ7QUFHRVksWUFBTSxFQUFFLElBSFY7QUFJRXpELFlBQU0sRUFBRW1HO0FBSlYsS0FEVSxFQU1QO0FBQ0g7QUFDQTtBQUNFeEQsYUFBTyxFQUFFLDBEQURYO0FBRUVFLGdCQUFVLEVBQUUsSUFGZDtBQUdFWSxZQUFNLEVBQUUsSUFIVjtBQUlFekQsWUFBTSxFQUFFO0FBQ04sZ0JBQVFrRztBQURGO0FBSlYsS0FSVSxFQWVQO0FBQ0g7QUFDRTtBQUNBdkQsYUFBTyxFQUFFLHlFQUZYO0FBR0VFLGdCQUFVLEVBQUUsSUFIZDtBQUlFWSxZQUFNLEVBQUUsSUFKVjtBQUtFekQsWUFBTSxFQUFFbUc7QUFMVixLQWhCVSxFQXNCUDtBQUNEO0FBQ0F4RCxhQUFPLEVBQUUsbUJBRlI7QUFHREUsZ0JBQVUsRUFBRSxJQUhYO0FBSURZLFlBQU0sRUFBRTtBQUpQLEtBdEJPLEVBMkJQO0FBQ0Q7QUFDQWQsYUFBTyxFQUFFLDBCQUZSO0FBR0RjLFlBQU0sRUFBRSxJQUhQO0FBSUR6RCxZQUFNLEVBQUU7QUFDTixrQkFBVW1HLFlBQVksQ0FBQ0U7QUFEakI7QUFKUCxLQTNCTyxDQTNDVztBQThFckIsbUJBQWU7QUFDYjFELGFBQU8sRUFBRTFELE1BQU0sQ0FBQyxTQUFTZ0gsT0FBVixDQURGO0FBRWJqSixXQUFLLEVBQUU7QUFGTSxLQTlFTTtBQWtGckIsZ0JBQVltSixZQUFZLENBQUNHLFFBbEZKO0FBbUZyQixnQkFBWTtBQUNWM0QsYUFBTyxFQUFFLDBqREFEQztBQUVWRSxnQkFBVSxFQUFFO0FBRkYsS0FuRlM7QUF1RnJCLGVBQVc7QUFDVEYsYUFBTyxFQUFFLCtHQURBO0FBRVRFLGdCQUFVLEVBQUU7QUFGSCxLQXZGVTtBQTJGckI7QUFDQSxlQUFXO0FBQ1RGLGFBQU8sRUFBRSw0U0FEQTtBQUVURSxnQkFBVSxFQUFFLElBRkg7QUFHVDtBQUNBN0YsV0FBSyxFQUFFO0FBSkUsS0E1RlU7QUFrR3JCLGVBQVc7QUFDVDJGLGFBQU8sRUFBRSxnREFEQTtBQUVURSxnQkFBVSxFQUFFO0FBRkgsS0FsR1U7QUFzR3JCLHVCQUFtQjtBQUNqQkYsYUFBTyxFQUFFLFNBRFE7QUFFakIzRixXQUFLLEVBQUU7QUFGVSxLQXRHRTtBQTBHckIsZ0JBQVk7QUFDVjtBQUNBMkYsYUFBTyxFQUFFLDZFQUZDO0FBR1YzQyxZQUFNLEVBQUU7QUFDTiwyQkFBbUI7QUFDakIyQyxpQkFBTyxFQUFFLEtBRFE7QUFFakIzRixlQUFLLEVBQUU7QUFGVTtBQURiO0FBSEUsS0ExR1M7QUFvSHJCLG1CQUFlLGdDQXBITTtBQXFIckIsY0FBVTtBQUNSMkYsYUFBTyxFQUFFLG9DQUREO0FBRVJFLGdCQUFVLEVBQUU7QUFGSjtBQXJIVyxHQUF2QjtBQTBIQXFELHFCQUFtQixDQUFDbEcsTUFBcEIsR0FBNkIzRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCNEcsSUFBN0M7QUFDQTs7QUFFQSxNQUFJRyxVQUFVLEdBQUcsQ0FBQyxTQUFELEVBQVksZUFBWixFQUE2QixlQUE3QixFQUE4QyxhQUE5QyxFQUE2RCxRQUE3RCxFQUF1RSxhQUF2RSxFQUFzRixVQUF0RixFQUFrRyxTQUFsRyxFQUE2RyxTQUE3RyxFQUF3SCxTQUF4SCxFQUFtSSxpQkFBbkksRUFBc0osVUFBdEosRUFBa0ssYUFBbEssRUFBaUwsUUFBakwsQ0FBakI7QUFDQSxNQUFJdkcsTUFBTSxHQUFHbUcsWUFBWSxDQUFDRyxRQUFiLENBQXNCLENBQXRCLEVBQXlCdEcsTUFBdEM7O0FBRUEsT0FBSyxJQUFJekIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2dJLFVBQVUsQ0FBQ3ZFLE1BQS9CLEVBQXVDekQsQ0FBQyxFQUF4QyxFQUE0QztBQUMxQ3lCLFVBQU0sQ0FBQ3VHLFVBQVUsQ0FBQ2hJLENBQUQsQ0FBWCxDQUFOLEdBQXdCbEMsS0FBSyxDQUFDbUQsU0FBTixDQUFnQjRHLElBQWhCLENBQXFCRyxVQUFVLENBQUNoSSxDQUFELENBQS9CLENBQXhCO0FBQ0Q7O0FBRURsQyxPQUFLLENBQUNtRCxTQUFOLENBQWdCZ0gsS0FBaEIsR0FBd0JuSyxLQUFLLENBQUNtRCxTQUFOLENBQWdCNEcsSUFBeEM7QUFDRCxDQWpNRCxFQWlNR2pCLEtBak1IO0FBa01BOzs7QUFHQUEsS0FBSyxDQUFDM0YsU0FBTixDQUFnQmlILEtBQWhCLEdBQXdCO0FBQ3RCLGFBQVcsQ0FBQztBQUNWOUQsV0FBTyxFQUFFLGlDQURDO0FBRVZFLGNBQVUsRUFBRSxJQUZGO0FBR1ZZLFVBQU0sRUFBRTtBQUhFLEdBQUQsRUFJUjtBQUNEZCxXQUFPLEVBQUUsa0JBRFI7QUFFREUsY0FBVSxFQUFFLElBRlg7QUFHRFksVUFBTSxFQUFFO0FBSFAsR0FKUSxDQURXO0FBVXRCLFlBQVU7QUFDUmQsV0FBTyxFQUFFLGdEQUREO0FBRVJjLFVBQU0sRUFBRTtBQUZBLEdBVlk7QUFjdEIsZ0JBQWM7QUFDWmQsV0FBTyxFQUFFLDBGQURHO0FBRVpFLGNBQVUsRUFBRSxJQUZBO0FBR1o3QyxVQUFNLEVBQUU7QUFDTixxQkFBZTtBQURUO0FBSEksR0FkUTtBQXFCdEIsYUFBVyw0R0FyQlc7QUFzQnRCLGFBQVcsb0JBdEJXO0FBdUJ0QixjQUFZLGFBdkJVO0FBd0J0QixZQUFVLDJEQXhCWTtBQXlCdEIsY0FBWSw4Q0F6QlU7QUEwQnRCLGlCQUFlO0FBMUJPLENBQXhCO0FBNEJBOztBQUVBbUYsS0FBSyxDQUFDM0YsU0FBTixDQUFnQmtILENBQWhCLEdBQW9CdkIsS0FBSyxDQUFDM0YsU0FBTixDQUFnQkssTUFBaEIsQ0FBdUIsT0FBdkIsRUFBZ0M7QUFDbEQsYUFBVztBQUNUOEMsV0FBTyxFQUFFLHFFQURBO0FBRVRjLFVBQU0sRUFBRTtBQUZDLEdBRHVDO0FBS2xELFlBQVU7QUFDUjtBQUNBZCxXQUFPLEVBQUUscUNBRkQ7QUFHUmMsVUFBTSxFQUFFO0FBSEEsR0FMd0M7QUFVbEQsZ0JBQWM7QUFDWmQsV0FBTyxFQUFFLGtGQURHO0FBRVpFLGNBQVUsRUFBRTtBQUZBLEdBVm9DO0FBY2xELGFBQVcsbVZBZHVDO0FBZWxELGNBQVksdUJBZnNDO0FBZ0JsRCxZQUFVLG1IQWhCd0M7QUFpQmxELGNBQVk7QUFqQnNDLENBQWhDLENBQXBCO0FBbUJBc0MsS0FBSyxDQUFDM0YsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsR0FBN0IsRUFBa0MsUUFBbEMsRUFBNEM7QUFDMUMsVUFBUTtBQUNOO0FBQ0E0QyxXQUFPLEVBQUUsMENBRkg7QUFHTmMsVUFBTSxFQUFFO0FBSEY7QUFEa0MsQ0FBNUM7QUFPQTBCLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLEdBQTdCLEVBQWtDLFFBQWxDLEVBQTRDO0FBQzFDLFdBQVM7QUFDUDtBQUNBO0FBQ0E0QyxXQUFPLEVBQUUsMkZBSEY7QUFJUEUsY0FBVSxFQUFFLElBSkw7QUFLUFksVUFBTSxFQUFFLElBTEQ7QUFNUHpHLFNBQUssRUFBRSxVQU5BO0FBT1BnRCxVQUFNLEVBQUU7QUFDTixnQkFBVSxDQUFDO0FBQ1Q7QUFDQTJDLGVBQU8sRUFBRSwwQkFGQTtBQUdURSxrQkFBVSxFQUFFO0FBSEgsT0FBRCxFQUlQc0MsS0FBSyxDQUFDM0YsU0FBTixDQUFnQmtILENBQWhCLENBQWtCLFFBQWxCLENBSk8sQ0FESjtBQU1OLGNBQVF2QixLQUFLLENBQUMzRixTQUFOLENBQWdCa0gsQ0FBaEIsQ0FBa0IsTUFBbEIsQ0FORjtBQU9OLGlCQUFXdkIsS0FBSyxDQUFDM0YsU0FBTixDQUFnQmtILENBQWhCLENBQWtCLFNBQWxCLENBUEw7QUFRTixvQkFBYyxDQUFDO0FBQ2IvRCxlQUFPLEVBQUUsOEJBREk7QUFFYkUsa0JBQVUsRUFBRTtBQUZDLE9BQUQsRUFHWDtBQUNERixlQUFPLEVBQUUsOEJBRFI7QUFFREUsa0JBQVUsRUFBRSxJQUZYO0FBR0Q3RixhQUFLLEVBQUU7QUFITixPQUhXLENBUlI7QUFnQk47QUFDQSxtQkFBYTtBQUNYMkYsZUFBTyxFQUFFLGVBREU7QUFFWEUsa0JBQVUsRUFBRSxJQUZEO0FBR1g3RixhQUFLLEVBQUU7QUFISSxPQWpCUDtBQXNCTix3QkFBa0IsSUF0Qlo7QUF1Qk4scUJBQWUsaUJBdkJUO0FBd0JOLG9CQUFjO0FBQ1oyRixlQUFPLEVBQUUsV0FERztBQUVaM0MsY0FBTSxFQUFFbUYsS0FBSyxDQUFDM0YsU0FBTixDQUFnQmtIO0FBRlo7QUF4QlI7QUFQRDtBQURpQyxDQUE1QztBQXVDQXZCLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLEdBQTdCLEVBQWtDLFVBQWxDLEVBQThDO0FBQzVDO0FBQ0EsY0FBWTtBQUZnQyxDQUE5QztBQUlBLE9BQU9vRixLQUFLLENBQUMzRixTQUFOLENBQWdCa0gsQ0FBaEIsQ0FBa0IsU0FBbEIsQ0FBUDtBQUNBOztBQUVBLENBQUMsVUFBVXJLLEtBQVYsRUFBaUI7QUFDaEIsTUFBSXNLLE9BQU8sR0FBRyxtc0JBQWQ7QUFDQSxNQUFJQyxPQUFPLEdBQUcsdUNBQXVDaEQsTUFBdkMsQ0FBOEN4RyxPQUE5QyxDQUFzRCxZQUF0RCxFQUFvRSxZQUFZO0FBQzVGLFdBQU91SixPQUFPLENBQUMvQyxNQUFmO0FBQ0QsR0FGYSxDQUFkO0FBR0F2SCxPQUFLLENBQUNtRCxTQUFOLENBQWdCcUgsR0FBaEIsR0FBc0J4SyxLQUFLLENBQUNtRCxTQUFOLENBQWdCSyxNQUFoQixDQUF1QixHQUF2QixFQUE0QjtBQUNoRCxrQkFBYyxDQUFDO0FBQ2I4QyxhQUFPLEVBQUUxRCxNQUFNLENBQUMsZ0VBQWdFMkUsTUFBaEUsQ0FBdUV4RyxPQUF2RSxDQUErRSxZQUEvRSxFQUE2RixZQUFZO0FBQ3ZILGVBQU91SixPQUFPLENBQUMvQyxNQUFmO0FBQ0QsT0FGZSxDQUFELENBREY7QUFJYmYsZ0JBQVUsRUFBRTtBQUpDLEtBQUQsRUFLWDtBQUNIO0FBQ0E7QUFDQTtBQUNBLG9DQVRjLEVBU29CO0FBQ2xDO0FBQ0EsdUNBWGMsRUFXdUI7QUFDckM7QUFDQSxvRUFiYyxDQURrQztBQWVoRCxlQUFXOEQsT0FmcUM7QUFnQmhELGNBQVU7QUFDUmhFLGFBQU8sRUFBRSxnSkFERDtBQUVSYyxZQUFNLEVBQUU7QUFGQSxLQWhCc0M7QUFvQmhELGdCQUFZLHdIQXBCb0M7QUFxQmhELGVBQVc7QUFyQnFDLEdBQTVCLENBQXRCO0FBdUJBcEgsT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsS0FBN0IsRUFBb0MsUUFBcEMsRUFBOEM7QUFDNUMsY0FBVTtBQUNSO0FBQ0E0QyxhQUFPLEVBQUUxRCxNQUFNLENBQUMsMkJBQTJCMkUsTUFBM0IsR0FBb0MsS0FBcEMsR0FBNEM7QUFDNUQseURBQW1EQSxNQURuQyxHQUM0QyxHQUQ1QyxHQUNrRDtBQUNsRSx3REFBa0RBLE1BQWxELENBQXlEeEcsT0FBekQsQ0FBaUUsYUFBakUsRUFBZ0YsWUFBWTtBQUMxRixlQUFPd0osT0FBUDtBQUNELE9BRkQsQ0FGZ0IsR0FJWCxHQUpVLENBRlA7QUFPUi9ELGdCQUFVLEVBQUUsSUFQSjtBQVFSWSxZQUFNLEVBQUUsSUFSQTtBQVNSekQsWUFBTSxFQUFFO0FBQ04sa0JBQVUsY0FESjtBQUVOLG9CQUFZLEdBRk47QUFHTix1QkFBZTtBQUhUO0FBVEEsS0FEa0M7QUFnQjVDLGtCQUFjO0FBQ1oyQyxhQUFPLEVBQUUsbUNBREc7QUFFWjNGLFdBQUssRUFBRSxRQUZLO0FBR1p5RyxZQUFNLEVBQUU7QUFISTtBQWhCOEIsR0FBOUM7QUFzQkFwSCxPQUFLLENBQUNtRCxTQUFOLENBQWdCTyxZQUFoQixDQUE2QixLQUE3QixFQUFvQyxTQUFwQyxFQUErQztBQUM3Qyx3QkFBb0I7QUFDbEI0QyxhQUFPLEVBQUUsNkRBRFM7QUFFbEIzQyxZQUFNLEVBQUU7QUFDTixvQkFBWSxNQUROO0FBRU4sbUJBQVc7QUFDVDJDLGlCQUFPLEVBQUUsVUFEQTtBQUVUM0YsZUFBSyxFQUFFLFlBRkU7QUFHVGdELGdCQUFNLEVBQUUzRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCcUg7QUFIZjtBQUZMO0FBRlU7QUFEeUIsR0FBL0M7QUFhQXhLLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLEtBQTdCLEVBQW9DLFVBQXBDLEVBQWdEO0FBQzlDLG9CQUFnQjtBQUNkNEMsYUFBTyxFQUFFLElBREs7QUFFZDNGLFdBQUssRUFBRTtBQUZPO0FBRDhCLEdBQWhEO0FBTUFYLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLEtBQTdCLEVBQW9DLFlBQXBDLEVBQWtEO0FBQ2hEO0FBQ0E7QUFDQSxtQkFBZTtBQUNiNEMsYUFBTyxFQUFFLDRFQURJO0FBRWJFLGdCQUFVLEVBQUUsSUFGQztBQUdiWSxZQUFNLEVBQUUsSUFISztBQUliekQsWUFBTSxFQUFFM0QsS0FBSyxDQUFDbUQsU0FBTixDQUFnQkssTUFBaEIsQ0FBdUIsS0FBdkIsRUFBOEIsRUFBOUI7QUFKSztBQUhpQyxHQUFsRDtBQVVBeEQsT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsUUFBN0IsRUFBdUMsY0FBdkMsRUFBdUQ7QUFDckQ7QUFDQSxrQkFBYztBQUZ1QyxHQUF2RCxFQUdHMUQsS0FBSyxDQUFDbUQsU0FBTixDQUFnQnFILEdBQWhCLENBQW9CLGFBQXBCLENBSEg7QUFJRCxDQW5GRCxFQW1GRzFCLEtBbkZIO0FBb0ZBOzs7QUFHQSxDQUFDLFVBQVU5SSxLQUFWLEVBQWlCO0FBQ2hCLE1BQUl5SyxNQUFNLEdBQUcsNkVBQWI7QUFDQXpLLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0J1SCxHQUFoQixHQUFzQjtBQUNwQixlQUFXLGtCQURTO0FBRXBCLGNBQVU7QUFDUnBFLGFBQU8sRUFBRSxnREFERDtBQUVSM0MsWUFBTSxFQUFFO0FBQ04sZ0JBQVEsVUFERjtBQUVOLHNDQUE4QjtBQUM1QjJDLGlCQUFPLEVBQUUsMkZBRG1CO0FBRTVCRSxvQkFBVSxFQUFFLElBRmdCO0FBRzVCN0YsZUFBSyxFQUFFO0FBSHFCLFNBRnhCO0FBT04sbUJBQVc7QUFDVDJGLGlCQUFPLEVBQUUsd0NBREE7QUFFVEUsb0JBQVUsRUFBRTtBQUZILFNBUEwsQ0FVSjs7QUFWSTtBQUZBLEtBRlU7QUFrQnBCLFdBQU87QUFDTDtBQUNBRixhQUFPLEVBQUUxRCxNQUFNLENBQUMsaUJBQWlCNkgsTUFBTSxDQUFDbEQsTUFBeEIsR0FBaUMsR0FBakMsR0FBdUMsOEJBQThCQSxNQUFyRSxHQUE4RSxNQUEvRSxFQUF1RixHQUF2RixDQUZWO0FBR0xILFlBQU0sRUFBRSxJQUhIO0FBSUx6RCxZQUFNLEVBQUU7QUFDTixvQkFBWSxPQUROO0FBRU4sdUJBQWUsU0FGVDtBQUdOLGtCQUFVO0FBQ1IyQyxpQkFBTyxFQUFFMUQsTUFBTSxDQUFDLE1BQU02SCxNQUFNLENBQUNsRCxNQUFiLEdBQXNCLEdBQXZCLENBRFA7QUFFUjVHLGVBQUssRUFBRTtBQUZDO0FBSEo7QUFKSCxLQWxCYTtBQStCcEIsZ0JBQVk7QUFDVjJGLGFBQU8sRUFBRTFELE1BQU0sQ0FBQyx1REFBdUQ2SCxNQUFNLENBQUNsRCxNQUE5RCxHQUF1RSxlQUF4RSxDQURMO0FBRVZmLGdCQUFVLEVBQUU7QUFGRixLQS9CUTtBQW1DcEIsY0FBVTtBQUNSRixhQUFPLEVBQUVtRSxNQUREO0FBRVJyRCxZQUFNLEVBQUU7QUFGQSxLQW5DVTtBQXVDcEIsZ0JBQVk7QUFDVmQsYUFBTyxFQUFFLG1GQURDO0FBRVZFLGdCQUFVLEVBQUU7QUFGRixLQXZDUTtBQTJDcEIsaUJBQWEsZUEzQ087QUE0Q3BCLGdCQUFZO0FBQ1ZGLGFBQU8sRUFBRSxpQ0FEQztBQUVWRSxnQkFBVSxFQUFFO0FBRkYsS0E1Q1E7QUFnRHBCLG1CQUFlO0FBaERLLEdBQXRCO0FBa0RBeEcsT0FBSyxDQUFDbUQsU0FBTixDQUFnQnVILEdBQWhCLENBQW9CLFFBQXBCLEVBQThCL0csTUFBOUIsQ0FBcUNxQixJQUFyQyxHQUE0Q2hGLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0J1SCxHQUE1RDtBQUNBLE1BQUkzQixNQUFNLEdBQUcvSSxLQUFLLENBQUNtRCxTQUFOLENBQWdCNEYsTUFBN0I7O0FBRUEsTUFBSUEsTUFBSixFQUFZO0FBQ1ZBLFVBQU0sQ0FBQ2hELEdBQVAsQ0FBV2lELFVBQVgsQ0FBc0IsT0FBdEIsRUFBK0IsS0FBL0I7QUFDQUQsVUFBTSxDQUFDaEQsR0FBUCxDQUFXNEUsWUFBWCxDQUF3QixPQUF4QixFQUFpQyxLQUFqQztBQUNEO0FBQ0YsQ0EzREQsRUEyREc3QixLQTNESDtBQTREQTs7O0FBR0EsQ0FBQyxVQUFVOUksS0FBVixFQUFpQjtBQUNoQixNQUFJeUssTUFBTSxHQUFHLCtDQUFiO0FBQ0EsTUFBSUcsY0FBSjtBQUNBNUssT0FBSyxDQUFDbUQsU0FBTixDQUFnQnVILEdBQWhCLENBQW9CRyxRQUFwQixHQUErQjtBQUM3QnZFLFdBQU8sRUFBRXRHLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0J1SCxHQUFoQixDQUFvQkcsUUFBcEIsQ0FBNkJ2RSxPQURUO0FBRTdCRSxjQUFVLEVBQUUsSUFGaUI7QUFHN0I3QyxVQUFNLEVBQUVpSCxjQUFjLEdBQUc7QUFDdkIsd0JBQWtCLDhEQURLO0FBRXZCLHNCQUFnQixTQUZPO0FBR3ZCLGVBQVMsVUFIYztBQUl2QixZQUFNLFNBSmlCO0FBS3ZCLG1CQUFhO0FBQ1h0RSxlQUFPLEVBQUUxRCxNQUFNLENBQUMsc0JBQXNCNkgsTUFBTSxDQUFDbEQsTUFBN0IsR0FBc0MsT0FBdkMsQ0FESjtBQUVYSCxjQUFNLEVBQUUsSUFGRztBQUdYekQsY0FBTSxFQUFFO0FBQ04seUJBQWUsU0FEVDtBQUVOLDhCQUFvQjtBQUNsQjJDLG1CQUFPLEVBQUUsWUFEUztBQUVsQkUsc0JBQVUsRUFBRSxJQUZNO0FBR2xCN0YsaUJBQUssRUFBRTtBQUhXLFdBRmQ7QUFPTix1QkFBYTtBQUNYMkYsbUJBQU8sRUFBRSwyQ0FERTtBQUVYRSxzQkFBVSxFQUFFLElBRkQ7QUFHWDdDLGtCQUFNLEVBQUU7QUFDTiw2QkFBZTtBQURUO0FBSEcsV0FQUDtBQWNOLHVCQUFhO0FBQ1gyQyxtQkFBTyxFQUFFLG1DQURFO0FBRVhFLHNCQUFVLEVBQUU7QUFGRCxXQWRQO0FBa0JOLHdCQUFjLENBQUNpRSxNQUFELEVBQVM7QUFDckJuRSxtQkFBTyxFQUFFLDJDQURZO0FBRXJCRSxzQkFBVSxFQUFFO0FBRlMsV0FBVCxDQWxCUjtBQXNCTixzQkFBWTtBQXRCTjtBQUhHLE9BTFU7QUFpQ3ZCLGNBQVEsQ0FBQztBQUNQRixlQUFPLEVBQUUsaURBREY7QUFFUEUsa0JBQVUsRUFBRSxJQUZMO0FBR1A3QyxjQUFNLEVBQUU7QUFDTixvQkFBVSxRQURKO0FBRU4sc0JBQVk7QUFGTjtBQUhELE9BQUQsRUFPTDtBQUNEMkMsZUFBTyxFQUFFLCtCQURSO0FBRURFLGtCQUFVLEVBQUU7QUFGWCxPQVBLLENBakNlO0FBNEN2QixvQkFBYyxhQTVDUztBQTZDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQWU7QUFoRFE7QUFISSxHQUEvQjtBQXNEQXhHLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0J1SCxHQUFoQixDQUFvQixRQUFwQixFQUE4Qi9HLE1BQTlCLENBQXFDLDRCQUFyQyxFQUFtRUEsTUFBbkUsR0FBNEVpSCxjQUE1RTtBQUNBNUssT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsS0FBN0IsRUFBb0MsVUFBcEMsRUFBZ0Q7QUFDOUMsZ0JBQVk7QUFDVjRDLGFBQU8sRUFBRSw2RUFEQztBQUVWRSxnQkFBVSxFQUFFO0FBRkY7QUFEa0MsR0FBaEQ7QUFNQSxNQUFJc0UsSUFBSSxHQUFHO0FBQ1R4RSxXQUFPLEVBQUUsOEJBREE7QUFFVEUsY0FBVSxFQUFFO0FBRkgsR0FBWCxDQWhFZ0IsQ0FtRWI7O0FBRUgsTUFBSXVFLE1BQU0sR0FBRztBQUNYekUsV0FBTyxFQUFFLHNDQURFO0FBRVhFLGNBQVUsRUFBRTtBQUZELEdBQWI7QUFJQXhHLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLEtBQTdCLEVBQW9DLFVBQXBDLEVBQWdEO0FBQzlDLGdCQUFZO0FBQ1Y0QyxhQUFPLEVBQUUsb0JBREM7QUFFVkUsZ0JBQVUsRUFBRTtBQUZGLEtBRGtDO0FBSzlDO0FBQ0E7QUFDQSxlQUFXO0FBQ1RGLGFBQU8sRUFBRSxvQkFEQTtBQUVUM0YsV0FBSyxFQUFFO0FBRkUsS0FQbUM7QUFXOUMsYUFBUyxDQUFDO0FBQ1IyRixhQUFPLEVBQUUsbTZDQUREO0FBRVJFLGdCQUFVLEVBQUU7QUFGSixLQUFELEVBR047QUFDREYsYUFBTyxFQUFFLDJKQURSO0FBRUQzQyxZQUFNLEVBQUU7QUFDTixnQkFBUW1ILElBREY7QUFFTixrQkFBVUMsTUFGSjtBQUdOLG9CQUFZLGNBSE47QUFJTix1QkFBZTtBQUpUO0FBRlAsS0FITSxDQVhxQztBQXVCOUM7QUFDQSxjQUFVLGlCQXhCb0M7QUF5QjlDLFlBQVFELElBekJzQztBQTBCOUMsY0FBVUM7QUExQm9DLEdBQWhEO0FBNEJELENBckdELEVBcUdHakMsS0FyR0g7QUFzR0E7OztBQUdBQSxLQUFLLENBQUMzRixTQUFOLENBQWdCNkgsVUFBaEIsR0FBNkJsQyxLQUFLLENBQUMzRixTQUFOLENBQWdCSyxNQUFoQixDQUF1QixPQUF2QixFQUFnQztBQUMzRCxnQkFBYyxDQUFDc0YsS0FBSyxDQUFDM0YsU0FBTixDQUFnQmlILEtBQWhCLENBQXNCLFlBQXRCLENBQUQsRUFBc0M7QUFDbEQ5RCxXQUFPLEVBQUUseUdBRHlDO0FBRWxERSxjQUFVLEVBQUU7QUFGc0MsR0FBdEMsQ0FENkM7QUFLM0QsYUFBVyxDQUFDO0FBQ1ZGLFdBQU8sRUFBRSxzQkFEQztBQUVWRSxjQUFVLEVBQUU7QUFGRixHQUFELEVBR1I7QUFDREYsV0FBTyxFQUFFLGtkQURSO0FBRURFLGNBQVUsRUFBRTtBQUZYLEdBSFEsQ0FMZ0Q7QUFZM0Q7QUFDQSxjQUFZLG1HQWIrQztBQWMzRCxZQUFVO0FBQ1JGLFdBQU8sRUFBRTFELE1BQU0sQ0FBQyxhQUFhMkUsTUFBYixHQUFzQixLQUF0QixLQUFnQztBQUNoRCxtQkFBZUEsTUFBZixHQUF3QixHQUF4QixHQUE4QjtBQUM5Qiw4QkFBMEJBLE1BRDFCLEdBQ21DLEdBRG5DLEdBQ3lDO0FBQ3pDLGdDQUE0QkEsTUFGNUIsR0FFcUMsR0FGckMsR0FFMkM7QUFDM0MsMENBQXNDQSxNQUh0QyxHQUcrQyxHQUgvQyxHQUdxRDtBQUNyRCxvQkFBZ0JBLE1BSmhCLEdBSXlCLEdBSnpCLEdBSStCO0FBQy9CLHdGQUFvRkEsTUFOcEUsSUFNOEUsR0FOOUUsR0FNb0YsWUFBWUEsTUFOakcsQ0FEUDtBQVFSZixjQUFVLEVBQUU7QUFSSixHQWRpRDtBQXdCM0QsY0FBWTtBQXhCK0MsQ0FBaEMsQ0FBN0I7QUEwQkFzQyxLQUFLLENBQUMzRixTQUFOLENBQWdCNkgsVUFBaEIsQ0FBMkIsWUFBM0IsRUFBeUMsQ0FBekMsRUFBNEMxRSxPQUE1QyxHQUFzRCxzRUFBdEQ7QUFDQXdDLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLFlBQTdCLEVBQTJDLFNBQTNDLEVBQXNEO0FBQ3BELFdBQVM7QUFDUDtBQUNBNEMsV0FBTyxFQUFFLHdMQUZGO0FBR1BFLGNBQVUsRUFBRSxJQUhMO0FBSVBZLFVBQU0sRUFBRSxJQUpEO0FBS1B6RCxVQUFNLEVBQUU7QUFDTixzQkFBZ0I7QUFDZDJDLGVBQU8sRUFBRSwyQkFESztBQUVkRSxrQkFBVSxFQUFFLElBRkU7QUFHZDdGLGFBQUssRUFBRSxnQkFITztBQUlkZ0QsY0FBTSxFQUFFbUYsS0FBSyxDQUFDM0YsU0FBTixDQUFnQjhIO0FBSlYsT0FEVjtBQU9OLHlCQUFtQixTQVBiO0FBUU4scUJBQWU7QUFSVDtBQUxELEdBRDJDO0FBaUJwRDtBQUNBLHVCQUFxQjtBQUNuQjNFLFdBQU8sRUFBRSwrTEFEVTtBQUVuQjNGLFNBQUssRUFBRTtBQUZZLEdBbEIrQjtBQXNCcEQsZUFBYSxDQUFDO0FBQ1oyRixXQUFPLEVBQUUscUlBREc7QUFFWkUsY0FBVSxFQUFFLElBRkE7QUFHWjdDLFVBQU0sRUFBRW1GLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0I2SDtBQUhaLEdBQUQsRUFJVjtBQUNEMUUsV0FBTyxFQUFFLG9GQURSO0FBRURFLGNBQVUsRUFBRSxJQUZYO0FBR0Q3QyxVQUFNLEVBQUVtRixLQUFLLENBQUMzRixTQUFOLENBQWdCNkg7QUFIdkIsR0FKVSxFQVFWO0FBQ0QxRSxXQUFPLEVBQUUsaUVBRFI7QUFFREUsY0FBVSxFQUFFLElBRlg7QUFHRDdDLFVBQU0sRUFBRW1GLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0I2SDtBQUh2QixHQVJVLEVBWVY7QUFDRDFFLFdBQU8sRUFBRSw2ZUFEUjtBQUVERSxjQUFVLEVBQUUsSUFGWDtBQUdEN0MsVUFBTSxFQUFFbUYsS0FBSyxDQUFDM0YsU0FBTixDQUFnQjZIO0FBSHZCLEdBWlUsQ0F0QnVDO0FBdUNwRCxjQUFZO0FBdkN3QyxDQUF0RDtBQXlDQWxDLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLFlBQTdCLEVBQTJDLFFBQTNDLEVBQXFEO0FBQ25ELGNBQVk7QUFDVjRDLFdBQU8sRUFBRSxPQURDO0FBRVZjLFVBQU0sRUFBRSxJQUZFO0FBR1Z6RyxTQUFLLEVBQUU7QUFIRyxHQUR1QztBQU1uRCxxQkFBbUI7QUFDakIyRixXQUFPLEVBQUUsMEVBRFE7QUFFakJjLFVBQU0sRUFBRSxJQUZTO0FBR2pCekQsVUFBTSxFQUFFO0FBQ04sOEJBQXdCO0FBQ3RCMkMsZUFBTyxFQUFFLE9BRGE7QUFFdEIzRixhQUFLLEVBQUU7QUFGZSxPQURsQjtBQUtOLHVCQUFpQjtBQUNmMkYsZUFBTyxFQUFFLGtFQURNO0FBRWZFLGtCQUFVLEVBQUUsSUFGRztBQUdmN0MsY0FBTSxFQUFFO0FBQ04sdUNBQTZCO0FBQzNCMkMsbUJBQU8sRUFBRSxXQURrQjtBQUUzQjNGLGlCQUFLLEVBQUU7QUFGb0IsV0FEdkI7QUFLTnFFLGNBQUksRUFBRThELEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0I2SDtBQUxoQjtBQUhPLE9BTFg7QUFnQk4sZ0JBQVU7QUFoQko7QUFIUyxHQU5nQztBQTRCbkQscUJBQW1CO0FBQ2pCMUUsV0FBTyxFQUFFLDJFQURRO0FBRWpCRSxjQUFVLEVBQUUsSUFGSztBQUdqQlksVUFBTSxFQUFFLElBSFM7QUFJakJ6RyxTQUFLLEVBQUU7QUFKVTtBQTVCZ0MsQ0FBckQ7QUFtQ0FtSSxLQUFLLENBQUMzRixTQUFOLENBQWdCTyxZQUFoQixDQUE2QixZQUE3QixFQUEyQyxVQUEzQyxFQUF1RDtBQUNyRCxzQkFBb0I7QUFDbEI0QyxXQUFPLEVBQUUsbUZBRFM7QUFFbEJFLGNBQVUsRUFBRSxJQUZNO0FBR2xCN0YsU0FBSyxFQUFFO0FBSFc7QUFEaUMsQ0FBdkQ7O0FBUUEsSUFBSW1JLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0I0RixNQUFwQixFQUE0QjtBQUMxQkQsT0FBSyxDQUFDM0YsU0FBTixDQUFnQjRGLE1BQWhCLENBQXVCaEQsR0FBdkIsQ0FBMkJpRCxVQUEzQixDQUFzQyxRQUF0QyxFQUFnRCxZQUFoRCxFQUQwQixDQUNxQztBQUMvRDs7QUFFQUYsT0FBSyxDQUFDM0YsU0FBTixDQUFnQjRGLE1BQWhCLENBQXVCaEQsR0FBdkIsQ0FBMkI0RSxZQUEzQixDQUF3Qyx5TkFBeU5wRCxNQUFqUSxFQUF5USxZQUF6UTtBQUNEOztBQUVEdUIsS0FBSyxDQUFDM0YsU0FBTixDQUFnQitILEVBQWhCLEdBQXFCcEMsS0FBSyxDQUFDM0YsU0FBTixDQUFnQjZILFVBQXJDO0FBQ0E7O0FBRUEsQ0FBQyxVQUFVaEwsS0FBVixFQUFpQjtBQUNoQjtBQUNBLE1BQUltTCxPQUFPLEdBQUcsV0FBZDtBQUNBLE1BQUlDLGFBQWEsR0FBRztBQUNsQjlFLFdBQU8sRUFBRSxZQURTO0FBRWxCM0YsU0FBSyxFQUFFO0FBRlcsR0FBcEI7QUFJQVgsT0FBSyxDQUFDbUQsU0FBTixDQUFnQmtJLFlBQWhCLEdBQStCckwsS0FBSyxDQUFDbUQsU0FBTixDQUFnQkssTUFBaEIsQ0FBdUIsWUFBdkIsRUFBcUM7QUFDbEUsZUFBVzJILE9BRHVEO0FBRWxFLGNBQVUsQ0FBQztBQUNYO0FBQ0U3RSxhQUFPLEVBQUUsd0JBRFg7QUFFRWMsWUFBTSxFQUFFO0FBRlYsS0FEVSxFQUlQO0FBQ0Q7QUFDQWQsYUFBTyxFQUFFLHdCQUZSO0FBR0RjLFlBQU0sRUFBRSxJQUhQO0FBSUR6RCxZQUFNLEVBQUU7QUFDTix5QkFBaUJ5SDtBQURYO0FBSlAsS0FKTyxDQUZ3RDtBQWNsRSxlQUFXLGtTQWR1RDtBQWVsRSxvQkFBZ0I7QUFDZDlFLGFBQU8sRUFBRSxZQURLO0FBRWQzRixXQUFLLEVBQUU7QUFGTztBQWZrRCxHQUFyQyxDQUEvQjtBQW9CQVgsT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsY0FBN0IsRUFBNkMsU0FBN0MsRUFBd0Q7QUFDdEQseUJBQXFCO0FBQ25CNEMsYUFBTyxFQUFFLGdCQURVO0FBRW5CM0YsV0FBSyxFQUFFO0FBRlksS0FEaUM7QUFLdEQ7QUFDQSxtQkFBZTtBQUNiMkYsYUFBTyxFQUFFLG9CQURJO0FBRWIzRixXQUFLLEVBQUUsT0FGTTtBQUdiZ0QsWUFBTSxFQUFFO0FBQ04sbUJBQVd3SCxPQURMO0FBRU4seUJBQWlCQztBQUZYO0FBSEs7QUFOdUMsR0FBeEQ7QUFlQXBMLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLGNBQTdCLEVBQTZDLFFBQTdDLEVBQXVEO0FBQ3JELHlCQUFxQjtBQUNuQjRDLGFBQU8sRUFBRSx3QkFEVTtBQUVuQjNDLFlBQU0sRUFBRTtBQUNOLHFCQUFhO0FBQ1gyQyxpQkFBTyxFQUFFLE9BREU7QUFFWDNGLGVBQUssRUFBRTtBQUZJLFNBRFA7QUFLTixrQkFBVTtBQUNSMkYsaUJBQU8sRUFBRSxTQUREO0FBRVIzRixlQUFLLEVBQUUscUJBRkM7QUFHUmdELGdCQUFNLEVBQUUzRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCNkg7QUFIaEI7QUFMSjtBQUZXLEtBRGdDO0FBZXJEO0FBQ0Esd0JBQW9CLENBQUM7QUFDbkIxRSxhQUFPLEVBQUUsZ0JBRFU7QUFFbkJjLFlBQU0sRUFBRSxJQUZXO0FBR25CekcsV0FBSyxFQUFFO0FBSFksS0FBRCxFQUlqQjtBQUNEMkYsYUFBTyxFQUFFLGdCQURSO0FBRURjLFlBQU0sRUFBRSxJQUZQO0FBR0R6RyxXQUFLLEVBQUUsUUFITjtBQUlEZ0QsWUFBTSxFQUFFO0FBQ055SCxxQkFBYSxFQUFFQTtBQURUO0FBSlAsS0FKaUI7QUFoQmlDLEdBQXZEO0FBNkJBcEwsT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsY0FBN0IsRUFBNkMsU0FBN0MsRUFBd0Q7QUFDdEQ7QUFDQSxnQkFBWTtBQUYwQyxHQUF4RDtBQUlBLFNBQU8xRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCa0ksWUFBaEIsQ0FBNkIsaUJBQTdCLENBQVA7QUFDQXJMLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JtSSxNQUFoQixHQUF5QnRMLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0JrSSxZQUF6QztBQUNELENBN0VELEVBNkVHdkMsS0E3RUg7QUE4RUE7OztBQUdBLENBQUMsVUFBVTlJLEtBQVYsRUFBaUI7QUFDaEI7QUFDQTtBQUNBLE1BQUl1TCxhQUFhLEdBQUcsa0JBQXBCLENBSGdCLENBR3dCOztBQUV4QyxNQUFJeEYsR0FBRyxHQUFHLGtGQUFWLENBTGdCLENBSzhFOztBQUU5RixNQUFJeUYsVUFBVSxHQUFHLFFBQVF6RixHQUFHLENBQUN3QixNQUFaLEdBQXFCLFdBQXJCLEdBQW1DZ0UsYUFBYSxDQUFDaEUsTUFBakQsR0FBMEQsS0FBMUQsR0FBa0VnRSxhQUFhLENBQUNoRSxNQUFoRixHQUF5RixXQUF6RixHQUF1R3hCLEdBQUcsQ0FBQ3dCLE1BQTNHLEdBQW9ILEtBQXJJLENBUGdCLENBTzRIO0FBQzVJO0FBQ0E7O0FBRUEsTUFBSWtFLFFBQVEsR0FBRyxrSkFBa0psRSxNQUFsSixDQUF5SnhHLE9BQXpKLENBQWlLLFVBQWpLLEVBQTZLLFlBQVk7QUFDdE0sV0FBTywyRUFBMkV3RyxNQUFsRjtBQUNELEdBRmMsQ0FBZjtBQUdBLE1BQUlrRCxNQUFNLEdBQUcsOENBQThDbEQsTUFBM0Q7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUUsV0FBU21FLGtCQUFULENBQTRCakssS0FBNUIsRUFBbUM2RixLQUFuQyxFQUEwQztBQUN4Q0EsU0FBSyxHQUFHLENBQUNBLEtBQUssSUFBSSxFQUFWLEVBQWN2RyxPQUFkLENBQXNCLElBQXRCLEVBQTRCLEVBQTVCLElBQWtDLEdBQTFDLENBRHdDLENBQ087O0FBRS9DLFFBQUl1RixPQUFPLEdBQUcseUZBQXlGaUIsTUFBekYsQ0FBZ0d4RyxPQUFoRyxDQUF3RyxXQUF4RyxFQUFxSCxZQUFZO0FBQzdJLGFBQU95SyxVQUFQO0FBQ0QsS0FGYSxFQUVYekssT0FGVyxDQUVILFlBRkcsRUFFVyxZQUFZO0FBQ25DLGFBQU9VLEtBQVA7QUFDRCxLQUphLENBQWQ7QUFLQSxXQUFPbUIsTUFBTSxDQUFDMEQsT0FBRCxFQUFVZ0IsS0FBVixDQUFiO0FBQ0Q7O0FBRUR0SCxPQUFLLENBQUNtRCxTQUFOLENBQWdCd0ksSUFBaEIsR0FBdUI7QUFDckIsY0FBVTtBQUNSckYsYUFBTyxFQUFFMUQsTUFBTSxDQUFDLDZGQUE2RjJFLE1BQTdGLENBQW9HeEcsT0FBcEcsQ0FBNEcsV0FBNUcsRUFBeUgsWUFBWTtBQUNuSixlQUFPeUssVUFBUDtBQUNELE9BRmUsQ0FBRCxDQURQO0FBSVJoRixnQkFBVSxFQUFFLElBSko7QUFLUjdGLFdBQUssRUFBRTtBQUxDLEtBRFc7QUFRckIsZUFBVyxLQVJVO0FBU3JCLFdBQU87QUFDTDJGLGFBQU8sRUFBRTFELE1BQU0sQ0FBQyxrRUFBa0UyRSxNQUFsRSxDQUF5RXhHLE9BQXpFLENBQWlGLFdBQWpGLEVBQThGLFlBQVk7QUFDeEgsZUFBT3lLLFVBQVA7QUFDRCxPQUZlLEVBRWJ6SyxPQUZhLENBRUwsVUFGSyxFQUVPLFlBQVk7QUFDakMsZUFBTyxRQUFRMEssUUFBUixHQUFtQixHQUFuQixHQUF5QmhCLE1BQXpCLEdBQWtDLEdBQXpDO0FBQ0QsT0FKZSxDQUFELENBRFY7QUFNTGpFLGdCQUFVLEVBQUUsSUFOUDtBQU9MWSxZQUFNLEVBQUUsSUFQSDtBQVFMekcsV0FBSyxFQUFFO0FBUkYsS0FUYztBQW1CckIsaUJBQWE7QUFDWDJGLGFBQU8sRUFBRSxlQURFO0FBRVhFLGdCQUFVLEVBQUUsSUFGRDtBQUdYN0YsV0FBSyxFQUFFO0FBSEksS0FuQlE7QUF3QnJCLGdCQUFZO0FBQ1YyRixhQUFPLEVBQUVvRixrQkFBa0IsQ0FBQyxzSkFBc0puRSxNQUF2SixDQURqQjtBQUVWZixnQkFBVSxFQUFFLElBRkY7QUFHVjdGLFdBQUssRUFBRTtBQUhHLEtBeEJTO0FBNkJyQixlQUFXO0FBQ1QyRixhQUFPLEVBQUVvRixrQkFBa0IsQ0FBQyxhQUFhbkUsTUFBZCxFQUFzQixHQUF0QixDQURsQjtBQUVUZixnQkFBVSxFQUFFLElBRkg7QUFHVDdGLFdBQUssRUFBRTtBQUhFLEtBN0JVO0FBa0NyQixZQUFRO0FBQ04yRixhQUFPLEVBQUVvRixrQkFBa0IsQ0FBQyxTQUFTbkUsTUFBVixFQUFrQixHQUFsQixDQURyQjtBQUVOZixnQkFBVSxFQUFFLElBRk47QUFHTjdGLFdBQUssRUFBRTtBQUhELEtBbENhO0FBdUNyQixjQUFVO0FBQ1IyRixhQUFPLEVBQUVvRixrQkFBa0IsQ0FBQ2pCLE1BQUQsQ0FEbkI7QUFFUmpFLGdCQUFVLEVBQUUsSUFGSjtBQUdSWSxZQUFNLEVBQUU7QUFIQSxLQXZDVztBQTRDckIsY0FBVTtBQUNSZCxhQUFPLEVBQUVvRixrQkFBa0IsQ0FBQyxpRkFBaUZuRSxNQUFsRixFQUEwRixHQUExRixDQURuQjtBQUVSZixnQkFBVSxFQUFFO0FBRkosS0E1Q1c7QUFnRHJCLFdBQU9ULEdBaERjO0FBaURyQixpQkFBYXdGLGFBakRRO0FBa0RyQixtQkFBZTtBQWxETSxHQUF2QjtBQW9EQXZMLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0J5SSxHQUFoQixHQUFzQjVMLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0J3SSxJQUF0QztBQUNELENBdEZELEVBc0ZHN0MsS0F0Rkg7QUF1RkE7OztBQUdBLENBQUMsVUFBVTlJLEtBQVYsRUFBaUI7QUFDaEI7QUFDQSxNQUFJNkwsS0FBSyxHQUFHLDJDQUEyQ3RFLE1BQXZEO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUUsV0FBU3VFLFlBQVQsQ0FBc0J4RixPQUF0QixFQUErQjtBQUM3QkEsV0FBTyxHQUFHQSxPQUFPLENBQUN2RixPQUFSLENBQWdCLFVBQWhCLEVBQTRCLFlBQVk7QUFDaEQsYUFBTzhLLEtBQVA7QUFDRCxLQUZTLENBQVY7QUFHQSxXQUFPakosTUFBTSxDQUFDLDBCQUEwQjJFLE1BQTFCLEdBQW1DLEtBQW5DLEdBQTJDakIsT0FBM0MsR0FBcUQsR0FBdEQsQ0FBYjtBQUNEOztBQUVELE1BQUl5RixTQUFTLEdBQUcsNERBQTREeEUsTUFBNUU7QUFDQSxNQUFJeUUsUUFBUSxHQUFHLCtDQUErQ3pFLE1BQS9DLENBQXNEeEcsT0FBdEQsQ0FBOEQsS0FBOUQsRUFBcUUsWUFBWTtBQUM5RixXQUFPZ0wsU0FBUDtBQUNELEdBRmMsQ0FBZjtBQUdBLE1BQUlFLFNBQVMsR0FBRyxzRUFBc0UxRSxNQUF0RjtBQUNBdkgsT0FBSyxDQUFDbUQsU0FBTixDQUFnQitJLFFBQWhCLEdBQTJCbE0sS0FBSyxDQUFDbUQsU0FBTixDQUFnQkssTUFBaEIsQ0FBdUIsUUFBdkIsRUFBaUMsRUFBakMsQ0FBM0I7QUFDQXhELE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLFVBQTdCLEVBQXlDLFFBQXpDLEVBQW1EO0FBQ2pELDBCQUFzQjtBQUNwQjRDLGFBQU8sRUFBRSxpREFEVztBQUVwQkUsZ0JBQVUsRUFBRSxJQUZRO0FBR3BCWSxZQUFNLEVBQUUsSUFIWTtBQUlwQnpELFlBQU0sRUFBRTtBQUNOLHVCQUFlLFdBRFQ7QUFFTix3QkFBZ0I7QUFDZDJDLGlCQUFPLEVBQUUsZ0JBREs7QUFFZDNGLGVBQUssRUFBRSxDQUFDLE1BQUQsRUFBUyxlQUFULENBRk87QUFHZGdELGdCQUFNLEVBQUUzRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCd0k7QUFIVjtBQUZWO0FBSlksS0FEMkI7QUFjakQsa0JBQWM7QUFDWjtBQUNBckYsYUFBTyxFQUFFLGlCQUZHO0FBR1ozRixXQUFLLEVBQUU7QUFISyxLQWRtQztBQW1CakQsYUFBUztBQUNQMkYsYUFBTyxFQUFFMUQsTUFBTSxDQUFDLE1BQU1vSixRQUFOLEdBQWlCQyxTQUFqQixHQUE2QixLQUE3QixHQUFxQ0QsUUFBckMsR0FBZ0QsSUFBakQsRUFBdUQsR0FBdkQsQ0FEUjtBQUVQckksWUFBTSxFQUFFO0FBQ04sMkJBQW1CO0FBQ2pCMkMsaUJBQU8sRUFBRTFELE1BQU0sQ0FBQyxPQUFPb0osUUFBUCxHQUFrQkMsU0FBbEIsR0FBOEIsTUFBOUIsR0FBdUNELFFBQXZDLEdBQWtELEtBQW5ELENBREU7QUFFakJ4RixvQkFBVSxFQUFFLElBRks7QUFHakI3QyxnQkFBTSxFQUFFO0FBQ04sMEJBQWM7QUFDWjJDLHFCQUFPLEVBQUUxRCxNQUFNLENBQUNtSixTQUFELENBREg7QUFFWnBJLG9CQUFNLEVBQUUzRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCK0k7QUFGWixhQURSO0FBS04sMkJBQWU7QUFMVDtBQUhTLFNBRGI7QUFZTixzQkFBYztBQUNaNUYsaUJBQU8sRUFBRTFELE1BQU0sQ0FBQyxPQUFPb0osUUFBUCxHQUFrQixHQUFsQixHQUF3QkMsU0FBeEIsR0FBb0MsR0FBckMsQ0FESDtBQUVaekYsb0JBQVUsRUFBRSxJQUZBO0FBR1o3QyxnQkFBTSxFQUFFO0FBQ04sMkJBQWU7QUFEVDtBQUhJLFNBWlI7QUFtQk4sNEJBQW9CO0FBQ2xCMkMsaUJBQU8sRUFBRTFELE1BQU0sQ0FBQyxNQUFNb0osUUFBTixHQUFpQixHQUFsQixDQURHO0FBRWxCckksZ0JBQU0sRUFBRTtBQUNOLDRCQUFnQjtBQUNkMkMscUJBQU8sRUFBRTFELE1BQU0sQ0FBQ21KLFNBQUQsQ0FERDtBQUVkcEwsbUJBQUssRUFBRSxXQUZPO0FBR2RnRCxvQkFBTSxFQUFFM0QsS0FBSyxDQUFDbUQsU0FBTixDQUFnQitJO0FBSFYsYUFEVjtBQU1OLDJCQUFlO0FBTlQ7QUFGVTtBQW5CZDtBQUZELEtBbkJ3QztBQXFEakQsWUFBUSxDQUFDO0FBQ1A7QUFDQTVGLGFBQU8sRUFBRSxzRkFGRjtBQUdQRSxnQkFBVSxFQUFFLElBSEw7QUFJUDdGLFdBQUssRUFBRTtBQUpBLEtBQUQsRUFLTDtBQUNEO0FBQ0E7QUFDQTtBQUNBMkYsYUFBTyxFQUFFLG9CQUpSO0FBS0RjLFlBQU0sRUFBRSxJQUxQO0FBTUR6RCxZQUFNLEVBQUU7QUFDTixzQkFBYztBQUNaMkMsaUJBQU8sRUFBRSxvREFERztBQUVaRSxvQkFBVSxFQUFFO0FBRkEsU0FEUjtBQUtOLHlCQUFpQjtBQUNmRixpQkFBTyxFQUFFLFVBRE07QUFFZkUsb0JBQVUsRUFBRTtBQUZHLFNBTFg7QUFTTix1QkFBZTtBQVRUO0FBTlAsS0FMSyxDQXJEeUM7QUE0RWpELGFBQVMsQ0FBQztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0FGLGFBQU8sRUFBRSx5Q0FMRDtBQU1SM0YsV0FBSyxFQUFFLFdBTkM7QUFPUmdELFlBQU0sRUFBRTtBQUNOd0ksbUJBQVcsRUFBRTtBQURQO0FBUEEsS0FBRCxFQVVOO0FBQ0Q7QUFDQTtBQUNBN0YsYUFBTyxFQUFFLFlBSFI7QUFJREUsZ0JBQVUsRUFBRSxJQUpYO0FBS0Q3RixXQUFLLEVBQUUsV0FMTjtBQU1EZ0QsWUFBTSxFQUFFO0FBQ053SSxtQkFBVyxFQUFFO0FBRFA7QUFOUCxLQVZNLENBNUV3QztBQWdHakQsVUFBTTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E3RixhQUFPLEVBQUUsdUNBTEw7QUFNSkUsZ0JBQVUsRUFBRSxJQU5SO0FBT0o3RixXQUFLLEVBQUU7QUFQSCxLQWhHMkM7QUF5R2pELFlBQVE7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBMkYsYUFBTyxFQUFFLGtDQUxIO0FBTU5FLGdCQUFVLEVBQUUsSUFOTjtBQU9ON0YsV0FBSyxFQUFFO0FBUEQsS0F6R3lDO0FBa0hqRCxxQkFBaUI7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBMkYsYUFBTyxFQUFFLG9IQUxNO0FBTWYzQyxZQUFNLEVBQUU7QUFDTixvQkFBWTtBQUNWMkMsaUJBQU8sRUFBRSxlQURDO0FBRVZFLG9CQUFVLEVBQUU7QUFGRixTQUROO0FBS04sa0JBQVUsOERBTEo7QUFNTix1QkFBZTtBQU5ULE9BTk87QUFjZjdGLFdBQUssRUFBRTtBQWRRLEtBbEhnQztBQWtJakQsWUFBUTtBQUNOO0FBQ0E7QUFDQTtBQUNBMkYsYUFBTyxFQUFFd0YsWUFBWSxDQUFDLGtHQUFrR3ZFLE1BQW5HLENBSmY7QUFLTmYsZ0JBQVUsRUFBRSxJQUxOO0FBTU5ZLFlBQU0sRUFBRSxJQU5GO0FBT056RCxZQUFNLEVBQUU7QUFDTixtQkFBVztBQUNUMkMsaUJBQU8sRUFBRSxxQkFEQTtBQUVURSxvQkFBVSxFQUFFLElBRkg7QUFHVDdDLGdCQUFNLEVBQUUsRUFIQyxDQUdFOztBQUhGLFNBREw7QUFPTix1QkFBZTtBQVBUO0FBUEYsS0FsSXlDO0FBbUpqRCxjQUFVO0FBQ1I7QUFDQTtBQUNBO0FBQ0EyQyxhQUFPLEVBQUV3RixZQUFZLENBQUMsa0dBQWtHdkUsTUFBbkcsQ0FKYjtBQUtSZixnQkFBVSxFQUFFLElBTEo7QUFNUlksWUFBTSxFQUFFLElBTkE7QUFPUnpELFlBQU0sRUFBRTtBQUNOLG1CQUFXO0FBQ1QyQyxpQkFBTyxFQUFFLG1CQURBO0FBRVRFLG9CQUFVLEVBQUUsSUFGSDtBQUdUN0MsZ0JBQU0sRUFBRSxFQUhDLENBR0U7O0FBSEYsU0FETDtBQU9OLHVCQUFlO0FBUFQ7QUFQQSxLQW5KdUM7QUFvS2pELGNBQVU7QUFDUjtBQUNBO0FBQ0E7QUFDQTJDLGFBQU8sRUFBRXdGLFlBQVksQ0FBQywyQkFBMkJ2RSxNQUE1QixDQUpiO0FBS1JmLGdCQUFVLEVBQUUsSUFMSjtBQU1SWSxZQUFNLEVBQUUsSUFOQTtBQU9SekQsWUFBTSxFQUFFO0FBQ04sbUJBQVc7QUFDVDJDLGlCQUFPLEVBQUUsc0JBREE7QUFFVEUsb0JBQVUsRUFBRSxJQUZIO0FBR1Q3QyxnQkFBTSxFQUFFLEVBSEMsQ0FHRTs7QUFIRixTQURMO0FBT04sdUJBQWU7QUFQVDtBQVBBLEtBcEt1QztBQXFMakQsb0JBQWdCO0FBQ2Q7QUFDQTtBQUNBMkMsYUFBTyxFQUFFLGtFQUhLO0FBSWRFLGdCQUFVLEVBQUUsSUFKRTtBQUtkWSxZQUFNLEVBQUUsSUFMTTtBQU1kekcsV0FBSyxFQUFFLENBQUMsTUFBRCxFQUFTLFNBQVQ7QUFOTyxLQXJMaUM7QUE2TGpELFdBQU87QUFDTDtBQUNBO0FBQ0E7QUFDQTJGLGFBQU8sRUFBRXdGLFlBQVksQ0FBQyxtR0FBbUd2RSxNQUFwRyxDQUpoQjtBQUtMZixnQkFBVSxFQUFFLElBTFA7QUFNTFksWUFBTSxFQUFFLElBTkg7QUFPTHpELFlBQU0sRUFBRTtBQUNOLG9CQUFZLElBRE47QUFFTixtQkFBVztBQUNUMkMsaUJBQU8sRUFBRSxtQkFEQTtBQUVURSxvQkFBVSxFQUFFLElBRkg7QUFHVDdDLGdCQUFNLEVBQUUsRUFIQyxDQUdFOztBQUhGLFNBRkw7QUFRTixvQkFBWTtBQUNWMkMsaUJBQU8sRUFBRSw0QkFEQztBQUVWRSxvQkFBVSxFQUFFO0FBRkYsU0FSTjtBQVlOLGVBQU87QUFDTEYsaUJBQU8sRUFBRSxnQkFESjtBQUVMRSxvQkFBVSxFQUFFO0FBRlAsU0FaRDtBQWdCTixrQkFBVTtBQUNSRixpQkFBTyxFQUFFLG1DQUREO0FBRVJFLG9CQUFVLEVBQUU7QUFGSjtBQWhCSjtBQVBIO0FBN0wwQyxHQUFuRDtBQTJOQSxHQUFDLEtBQUQsRUFBUSxNQUFSLEVBQWdCLFFBQWhCLEVBQTBCLFFBQTFCLEVBQW9DeEUsT0FBcEMsQ0FBNEMsVUFBVWlDLEtBQVYsRUFBaUI7QUFDM0QsS0FBQyxLQUFELEVBQVEsTUFBUixFQUFnQixRQUFoQixFQUEwQixRQUExQixFQUFvQyxjQUFwQyxFQUFvRGpDLE9BQXBELENBQTRELFVBQVUyQixNQUFWLEVBQWtCO0FBQzVFLFVBQUlNLEtBQUssS0FBS04sTUFBZCxFQUFzQjtBQUNwQjNELGFBQUssQ0FBQ21ELFNBQU4sQ0FBZ0IrSSxRQUFoQixDQUF5QmpJLEtBQXpCLEVBQWdDTixNQUFoQyxDQUF1Q2pELE9BQXZDLENBQStDaUQsTUFBL0MsQ0FBc0RBLE1BQXRELElBQWdFM0QsS0FBSyxDQUFDbUQsU0FBTixDQUFnQitJLFFBQWhCLENBQXlCdkksTUFBekIsQ0FBaEU7QUFDRDtBQUNGLEtBSkQ7QUFLRCxHQU5EO0FBT0EzRCxPQUFLLENBQUM0RSxLQUFOLENBQVk5QixHQUFaLENBQWdCLGdCQUFoQixFQUFrQyxVQUFVNEIsR0FBVixFQUFlO0FBQy9DLFFBQUlBLEdBQUcsQ0FBQy9CLFFBQUosS0FBaUIsVUFBakIsSUFBK0IrQixHQUFHLENBQUMvQixRQUFKLEtBQWlCLElBQXBELEVBQTBEO0FBQ3hEO0FBQ0Q7O0FBRUQsYUFBU3lKLFVBQVQsQ0FBb0I3TCxNQUFwQixFQUE0QjtBQUMxQixVQUFJLENBQUNBLE1BQUQsSUFBVyxPQUFPQSxNQUFQLEtBQWtCLFFBQWpDLEVBQTJDO0FBQ3pDO0FBQ0Q7O0FBRUQsV0FBSyxJQUFJMkIsQ0FBQyxHQUFHLENBQVIsRUFBV21LLENBQUMsR0FBRzlMLE1BQU0sQ0FBQ29GLE1BQTNCLEVBQW1DekQsQ0FBQyxHQUFHbUssQ0FBdkMsRUFBMENuSyxDQUFDLEVBQTNDLEVBQStDO0FBQzdDLFlBQUkrQixLQUFLLEdBQUcxRCxNQUFNLENBQUMyQixDQUFELENBQWxCOztBQUVBLFlBQUkrQixLQUFLLENBQUN4RCxJQUFOLEtBQWUsTUFBbkIsRUFBMkI7QUFDekIyTCxvQkFBVSxDQUFDbkksS0FBSyxDQUFDdkQsT0FBUCxDQUFWO0FBQ0E7QUFDRDtBQUNEO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHUSxZQUFJNEwsUUFBUSxHQUFHckksS0FBSyxDQUFDdkQsT0FBTixDQUFjLENBQWQsQ0FBZjtBQUNBLFlBQUk2TCxTQUFTLEdBQUd0SSxLQUFLLENBQUN2RCxPQUFOLENBQWMsQ0FBZCxDQUFoQjs7QUFFQSxZQUFJNEwsUUFBUSxJQUFJQyxTQUFaLElBQXlCRCxRQUFRLENBQUM3TCxJQUFULEtBQWtCLGVBQTNDLElBQThEOEwsU0FBUyxDQUFDOUwsSUFBVixLQUFtQixZQUFqRixJQUFpRyxPQUFPNkwsUUFBUSxDQUFDNUwsT0FBaEIsS0FBNEIsUUFBakksRUFBMkk7QUFDekk7QUFDQTtBQUNBLGNBQUlULElBQUksR0FBR3FNLFFBQVEsQ0FBQzVMLE9BQVQsQ0FBaUJLLE9BQWpCLENBQXlCLE1BQXpCLEVBQWlDLE9BQWpDLEVBQTBDQSxPQUExQyxDQUFrRCxTQUFsRCxFQUE2RCxJQUE3RCxDQUFYLENBSHlJLENBRzFEOztBQUUvRWQsY0FBSSxHQUFHLENBQUMsZUFBZXFDLElBQWYsQ0FBb0JyQyxJQUFwQixLQUE2QixDQUFDLEVBQUQsQ0FBOUIsRUFBb0MsQ0FBcEMsRUFBdUN1QyxXQUF2QyxFQUFQO0FBQ0EsY0FBSTdCLEtBQUssR0FBRyxjQUFjVixJQUExQixDQU55SSxDQU16Rzs7QUFFaEMsY0FBSSxDQUFDc00sU0FBUyxDQUFDNUwsS0FBZixFQUFzQjtBQUNwQjRMLHFCQUFTLENBQUM1TCxLQUFWLEdBQWtCLENBQUNBLEtBQUQsQ0FBbEI7QUFDRCxXQUZELE1BRU8sSUFBSSxPQUFPNEwsU0FBUyxDQUFDNUwsS0FBakIsS0FBMkIsUUFBL0IsRUFBeUM7QUFDOUM0TCxxQkFBUyxDQUFDNUwsS0FBVixHQUFrQixDQUFDNEwsU0FBUyxDQUFDNUwsS0FBWCxFQUFrQkEsS0FBbEIsQ0FBbEI7QUFDRCxXQUZNLE1BRUE7QUFDTDRMLHFCQUFTLENBQUM1TCxLQUFWLENBQWdCOEUsSUFBaEIsQ0FBcUI5RSxLQUFyQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVEeUwsY0FBVSxDQUFDMUgsR0FBRyxDQUFDbkUsTUFBTCxDQUFWO0FBQ0QsR0F2REQ7QUF3REFQLE9BQUssQ0FBQzRFLEtBQU4sQ0FBWTlCLEdBQVosQ0FBZ0IsTUFBaEIsRUFBd0IsVUFBVTRCLEdBQVYsRUFBZTtBQUNyQyxRQUFJQSxHQUFHLENBQUNqRSxJQUFKLEtBQWEsWUFBakIsRUFBK0I7QUFDN0I7QUFDRDs7QUFFRCxRQUFJNkwsUUFBUSxHQUFHLEVBQWY7O0FBRUEsU0FBSyxJQUFJcEssQ0FBQyxHQUFHLENBQVIsRUFBV21LLENBQUMsR0FBRzNILEdBQUcsQ0FBQ3NCLE9BQUosQ0FBWUwsTUFBaEMsRUFBd0N6RCxDQUFDLEdBQUdtSyxDQUE1QyxFQUErQ25LLENBQUMsRUFBaEQsRUFBb0Q7QUFDbEQsVUFBSXNLLEdBQUcsR0FBRzlILEdBQUcsQ0FBQ3NCLE9BQUosQ0FBWTlELENBQVosQ0FBVjtBQUNBLFVBQUl3RSxLQUFLLEdBQUcsZ0JBQWdCcEUsSUFBaEIsQ0FBcUJrSyxHQUFyQixDQUFaOztBQUVBLFVBQUk5RixLQUFKLEVBQVc7QUFDVDRGLGdCQUFRLEdBQUc1RixLQUFLLENBQUMsQ0FBRCxDQUFoQjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJM0MsT0FBTyxHQUFHL0QsS0FBSyxDQUFDbUQsU0FBTixDQUFnQm1KLFFBQWhCLENBQWQ7O0FBRUEsUUFBSSxDQUFDdkksT0FBTCxFQUFjO0FBQ1osVUFBSXVJLFFBQVEsSUFBSUEsUUFBUSxLQUFLLE1BQXpCLElBQW1DdE0sS0FBSyxDQUFDd0UsT0FBTixDQUFjaUksVUFBckQsRUFBaUU7QUFDL0QsWUFBSTVLLEVBQUUsR0FBRyxRQUFRLElBQUk2SyxJQUFKLEdBQVdDLE9BQVgsRUFBUixHQUErQixHQUEvQixHQUFxQ0MsSUFBSSxDQUFDQyxLQUFMLENBQVdELElBQUksQ0FBQ0UsTUFBTCxLQUFnQixJQUEzQixDQUE5QztBQUNBcEksV0FBRyxDQUFDdUIsVUFBSixDQUFlLElBQWYsSUFBdUJwRSxFQUF2QjtBQUNBN0IsYUFBSyxDQUFDd0UsT0FBTixDQUFjaUksVUFBZCxDQUF5Qk0sYUFBekIsQ0FBdUNULFFBQXZDLEVBQWlELFlBQVk7QUFDM0QsY0FBSVUsR0FBRyxHQUFHQyxRQUFRLENBQUNDLGNBQVQsQ0FBd0JyTCxFQUF4QixDQUFWOztBQUVBLGNBQUltTCxHQUFKLEVBQVM7QUFDUEEsZUFBRyxDQUFDRyxTQUFKLEdBQWdCbk4sS0FBSyxDQUFDeUUsU0FBTixDQUFnQnVJLEdBQUcsQ0FBQ0ksV0FBcEIsRUFBaUNwTixLQUFLLENBQUNtRCxTQUFOLENBQWdCbUosUUFBaEIsQ0FBakMsRUFBNERBLFFBQTVELENBQWhCO0FBQ0Q7QUFDRixTQU5EO0FBT0Q7QUFDRixLQVpELE1BWU87QUFDTDVILFNBQUcsQ0FBQ2hFLE9BQUosR0FBY1YsS0FBSyxDQUFDeUUsU0FBTixDQUFnQjJJLFdBQVcsQ0FBQzFJLEdBQUcsQ0FBQ2hFLE9BQUwsQ0FBM0IsRUFBMENxRCxPQUExQyxFQUFtRHVJLFFBQW5ELENBQWQ7QUFDRDtBQUNGLEdBbENEO0FBbUNBLE1BQUllLFVBQVUsR0FBR3pLLE1BQU0sQ0FBQzVDLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0I0RixNQUFoQixDQUF1QmhELEdBQXZCLENBQTJCTyxPQUEzQixDQUFtQ2lCLE1BQXBDLEVBQTRDLElBQTVDLENBQXZCO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUUsTUFBSStGLGtCQUFrQixHQUFHO0FBQ3ZCLFdBQU8sR0FEZ0I7QUFFdkIsVUFBTSxHQUZpQjtBQUd2QixVQUFNLEdBSGlCO0FBSXZCLFlBQVE7QUFKZSxHQUF6QixDQWpXZ0IsQ0FzV2I7O0FBRUgsTUFBSUMsYUFBYSxHQUFHQyxNQUFNLENBQUNELGFBQVAsSUFBd0JDLE1BQU0sQ0FBQ0MsWUFBbkQ7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUUsV0FBU0wsV0FBVCxDQUFxQi9ELElBQXJCLEVBQTJCO0FBQ3pCO0FBQ0EsUUFBSS9GLElBQUksR0FBRytGLElBQUksQ0FBQ3RJLE9BQUwsQ0FBYXNNLFVBQWIsRUFBeUIsRUFBekIsQ0FBWCxDQUZ5QixDQUVnQjs7QUFFekMvSixRQUFJLEdBQUdBLElBQUksQ0FBQ3ZDLE9BQUwsQ0FBYSwrQkFBYixFQUE4QyxVQUFVc0IsQ0FBVixFQUFhc0MsSUFBYixFQUFtQjtBQUN0RUEsVUFBSSxHQUFHQSxJQUFJLENBQUNuQyxXQUFMLEVBQVA7O0FBRUEsVUFBSW1DLElBQUksQ0FBQyxDQUFELENBQUosS0FBWSxHQUFoQixFQUFxQjtBQUNuQixZQUFJbEQsS0FBSjs7QUFFQSxZQUFJa0QsSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZLEdBQWhCLEVBQXFCO0FBQ25CbEQsZUFBSyxHQUFHaU0sUUFBUSxDQUFDL0ksSUFBSSxDQUFDdEQsS0FBTCxDQUFXLENBQVgsQ0FBRCxFQUFnQixFQUFoQixDQUFoQjtBQUNELFNBRkQsTUFFTztBQUNMSSxlQUFLLEdBQUdrTSxNQUFNLENBQUNoSixJQUFJLENBQUN0RCxLQUFMLENBQVcsQ0FBWCxDQUFELENBQWQ7QUFDRDs7QUFFRCxlQUFPa00sYUFBYSxDQUFDOUwsS0FBRCxDQUFwQjtBQUNELE9BVkQsTUFVTztBQUNMLFlBQUltTSxLQUFLLEdBQUdOLGtCQUFrQixDQUFDM0ksSUFBRCxDQUE5Qjs7QUFFQSxZQUFJaUosS0FBSixFQUFXO0FBQ1QsaUJBQU9BLEtBQVA7QUFDRCxTQUxJLENBS0g7OztBQUdGLGVBQU92TCxDQUFQO0FBQ0Q7QUFDRixLQXZCTSxDQUFQO0FBd0JBLFdBQU9pQixJQUFQO0FBQ0Q7O0FBRUR0RCxPQUFLLENBQUNtRCxTQUFOLENBQWdCMEssRUFBaEIsR0FBcUI3TixLQUFLLENBQUNtRCxTQUFOLENBQWdCK0ksUUFBckM7QUFDRCxDQWhaRCxFQWdaR3BELEtBaFpIO0FBaVpBOzs7QUFHQUEsS0FBSyxDQUFDM0YsU0FBTixDQUFnQjJLLE9BQWhCLEdBQTBCO0FBQ3hCLGFBQVcsS0FEYTtBQUV4QixpQkFBZTtBQUNieEgsV0FBTyxFQUFFLGtFQURJO0FBRWJjLFVBQU0sRUFBRSxJQUZLO0FBR2J6RyxTQUFLLEVBQUUsUUFITTtBQUliZ0QsVUFBTSxFQUFFO0FBQ04sMkJBQXFCO0FBQ25CMkMsZUFBTyxFQUFFLGlDQURVO0FBRW5CRSxrQkFBVSxFQUFFLElBRk87QUFHbkI3QyxjQUFNLEVBQUVtRixLQUFLLENBQUMzRixTQUFOLENBQWdCK0k7QUFITDtBQURmO0FBSkssR0FGUztBQWN4QixZQUFVO0FBQ1I1RixXQUFPLEVBQUUsZ0RBREQ7QUFFUmMsVUFBTSxFQUFFO0FBRkEsR0FkYztBQWtCeEIsWUFBVSwwQ0FsQmM7QUFtQnhCLGFBQVcsb0JBbkJhO0FBb0J4QixjQUFZLGNBcEJZO0FBcUJ4QixlQUFhO0FBQ1hkLFdBQU8sRUFBRSxhQURFO0FBRVgzRixTQUFLLEVBQUU7QUFGSSxHQXJCVztBQXlCeEIsZUFBYTtBQUNYMkYsV0FBTyxFQUFFLGdFQURFO0FBRVhjLFVBQU0sRUFBRTtBQUZHLEdBekJXO0FBNkJ4QixnQkFBYztBQUNaZCxXQUFPLEVBQUUsbUJBREc7QUFFWjNGLFNBQUssRUFBRTtBQUZLLEdBN0JVO0FBaUN4QixZQUFVLHFDQWpDYztBQWtDeEIsY0FBWSxvQkFsQ1k7QUFtQ3hCLGdCQUFjO0FBQ1oyRixXQUFPLEVBQUUsaUZBREc7QUFFWkUsY0FBVSxFQUFFO0FBRkEsR0FuQ1U7QUF1Q3hCLGNBQVk7QUFDVkYsV0FBTyxFQUFFLDhDQURDO0FBRVZFLGNBQVUsRUFBRSxJQUZGO0FBR1Y3RixTQUFLLEVBQUU7QUFIRyxHQXZDWTtBQTRDeEIseUJBQXVCO0FBQ3JCMkYsV0FBTyxFQUFFLDZCQURZO0FBRXJCRSxjQUFVLEVBQUUsSUFGUztBQUdyQjdGLFNBQUssRUFBRTtBQUhjLEdBNUNDO0FBaUR4QixzQkFBb0I7QUFDbEIyRixXQUFPLEVBQUUsMEJBRFM7QUFFbEJFLGNBQVUsRUFBRSxJQUZNO0FBR2xCN0YsU0FBSyxFQUFFO0FBSFcsR0FqREk7QUFzRHhCLGFBQVcsc0lBdERhO0FBdUR4QixjQUFZLGNBdkRZO0FBd0R4QixvQkFBa0IsY0F4RE07QUF5RHhCLFlBQVUsY0F6RGM7QUEwRHhCLGlCQUFlLGdCQTFEUztBQTJEeEIsY0FBWTtBQTNEWSxDQUExQjtBQTZEQW1JLEtBQUssQ0FBQ2xFLEtBQU4sQ0FBWTlCLEdBQVosQ0FBZ0IsZ0JBQWhCLEVBQWtDLFNBQVNpTCxvQkFBVCxDQUE4QnJKLEdBQTlCLEVBQW1DO0FBQ25FLE1BQUlBLEdBQUcsQ0FBQy9CLFFBQUosS0FBaUIsU0FBckIsRUFBZ0M7QUFDOUI7QUFDRDtBQUNEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0UsTUFBSXFMLFdBQVcsR0FBR3RKLEdBQUcsQ0FBQ25FLE1BQUosQ0FBVzBOLE1BQVgsQ0FBa0IsVUFBVWhLLEtBQVYsRUFBaUI7QUFDbkQsV0FBTyxPQUFPQSxLQUFQLEtBQWlCLFFBQWpCLElBQTZCQSxLQUFLLENBQUN4RCxJQUFOLEtBQWUsU0FBNUMsSUFBeUR3RCxLQUFLLENBQUN4RCxJQUFOLEtBQWUsUUFBL0U7QUFDRCxHQUZpQixDQUFsQjtBQUdBLE1BQUl5TixZQUFZLEdBQUcsQ0FBbkI7QUFDQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUUsV0FBU0MsUUFBVCxDQUFrQkMsTUFBbEIsRUFBMEI7QUFDeEIsV0FBT0osV0FBVyxDQUFDRSxZQUFZLEdBQUdFLE1BQWhCLENBQWxCO0FBQ0Q7QUFDRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0UsV0FBU0MsV0FBVCxDQUFxQkMsS0FBckIsRUFBNEJGLE1BQTVCLEVBQW9DO0FBQ2xDQSxVQUFNLEdBQUdBLE1BQU0sSUFBSSxDQUFuQjs7QUFFQSxTQUFLLElBQUlsTSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHb00sS0FBSyxDQUFDM0ksTUFBMUIsRUFBa0N6RCxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLFVBQUkrQixLQUFLLEdBQUdrSyxRQUFRLENBQUNqTSxDQUFDLEdBQUdrTSxNQUFMLENBQXBCOztBQUVBLFVBQUksQ0FBQ25LLEtBQUQsSUFBVUEsS0FBSyxDQUFDeEQsSUFBTixLQUFlNk4sS0FBSyxDQUFDcE0sQ0FBRCxDQUFsQyxFQUF1QztBQUNyQyxlQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNEO0FBQ0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0UsV0FBU3FNLGtCQUFULENBQTRCQyxJQUE1QixFQUFrQ0MsS0FBbEMsRUFBeUM7QUFDdkMsUUFBSUMsV0FBVyxHQUFHLENBQWxCOztBQUVBLFNBQUssSUFBSXhNLENBQUMsR0FBR2dNLFlBQWIsRUFBMkJoTSxDQUFDLEdBQUc4TCxXQUFXLENBQUNySSxNQUEzQyxFQUFtRHpELENBQUMsRUFBcEQsRUFBd0Q7QUFDdEQsVUFBSStCLEtBQUssR0FBRytKLFdBQVcsQ0FBQzlMLENBQUQsQ0FBdkI7QUFDQSxVQUFJeEIsT0FBTyxHQUFHdUQsS0FBSyxDQUFDdkQsT0FBcEI7O0FBRUEsVUFBSXVELEtBQUssQ0FBQ3hELElBQU4sS0FBZSxhQUFmLElBQWdDLE9BQU9DLE9BQVAsS0FBbUIsUUFBdkQsRUFBaUU7QUFDL0QsWUFBSThOLElBQUksQ0FBQ0csSUFBTCxDQUFVak8sT0FBVixDQUFKLEVBQXdCO0FBQ3RCZ08scUJBQVc7QUFDWixTQUZELE1BRU8sSUFBSUQsS0FBSyxDQUFDRSxJQUFOLENBQVdqTyxPQUFYLENBQUosRUFBeUI7QUFDOUJnTyxxQkFBVzs7QUFFWCxjQUFJQSxXQUFXLEtBQUssQ0FBcEIsRUFBdUI7QUFDckIsbUJBQU94TSxDQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsV0FBTyxDQUFDLENBQVI7QUFDRDtBQUNEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHRSxXQUFTME0sUUFBVCxDQUFrQjNLLEtBQWxCLEVBQXlCdEQsS0FBekIsRUFBZ0M7QUFDOUIsUUFBSXVGLE9BQU8sR0FBR2pDLEtBQUssQ0FBQ3RELEtBQXBCOztBQUVBLFFBQUksQ0FBQ3VGLE9BQUwsRUFBYztBQUNaakMsV0FBSyxDQUFDdEQsS0FBTixHQUFjdUYsT0FBTyxHQUFHLEVBQXhCO0FBQ0QsS0FGRCxNQUVPLElBQUksQ0FBQ3RGLEtBQUssQ0FBQ0MsT0FBTixDQUFjcUYsT0FBZCxDQUFMLEVBQTZCO0FBQ2xDakMsV0FBSyxDQUFDdEQsS0FBTixHQUFjdUYsT0FBTyxHQUFHLENBQUNBLE9BQUQsQ0FBeEI7QUFDRDs7QUFFREEsV0FBTyxDQUFDVCxJQUFSLENBQWE5RSxLQUFiO0FBQ0Q7O0FBRUQsU0FBT3VOLFlBQVksR0FBR0YsV0FBVyxDQUFDckksTUFBbEMsR0FBMkM7QUFDekMsUUFBSWtKLFVBQVUsR0FBR2IsV0FBVyxDQUFDRSxZQUFZLEVBQWIsQ0FBNUIsQ0FEeUMsQ0FDSzs7QUFFOUMsUUFBSVcsVUFBVSxDQUFDcE8sSUFBWCxLQUFvQixTQUFwQixJQUFpQ29PLFVBQVUsQ0FBQ25PLE9BQVgsS0FBdUIsVUFBNUQsRUFBd0U7QUFDdEU7QUFDQSxVQUFJb08sY0FBYyxHQUFHLEVBQXJCOztBQUVBLFVBQUlULFdBQVcsQ0FBQyxDQUFDLHFCQUFELEVBQXdCLGFBQXhCLENBQUQsQ0FBWCxJQUF1REYsUUFBUSxDQUFDLENBQUQsQ0FBUixDQUFZek4sT0FBWixLQUF3QixHQUFuRixFQUF3RjtBQUN0RjtBQUNBd04sb0JBQVksSUFBSSxDQUFoQixDQUZzRixDQUVuRTs7QUFFbkIsWUFBSWEsYUFBYSxHQUFHUixrQkFBa0IsQ0FBQyxNQUFELEVBQVMsTUFBVCxDQUF0Qzs7QUFFQSxZQUFJUSxhQUFhLEtBQUssQ0FBQyxDQUF2QixFQUEwQjtBQUN4QjtBQUNELFNBUnFGLENBUXBGOzs7QUFHRixlQUFPYixZQUFZLEdBQUdhLGFBQXRCLEVBQXFDYixZQUFZLEVBQWpELEVBQXFEO0FBQ25ELGNBQUljLENBQUMsR0FBR2IsUUFBUSxDQUFDLENBQUQsQ0FBaEI7O0FBRUEsY0FBSWEsQ0FBQyxDQUFDdk8sSUFBRixLQUFXLFVBQWYsRUFBMkI7QUFDekJtTyxvQkFBUSxDQUFDSSxDQUFELEVBQUksZ0JBQUosQ0FBUjtBQUNBRiwwQkFBYyxDQUFDckosSUFBZixDQUFvQnVKLENBQUMsQ0FBQ3RPLE9BQXRCO0FBQ0Q7QUFDRjs7QUFFRHdOLG9CQUFZLEdBQUdhLGFBQWEsR0FBRyxDQUEvQjtBQUNEOztBQUVELFVBQUlWLFdBQVcsQ0FBQyxDQUFDLGFBQUQsRUFBZ0IsZ0JBQWhCLENBQUQsQ0FBWCxJQUFrREYsUUFBUSxDQUFDLENBQUQsQ0FBUixDQUFZek4sT0FBWixLQUF3QixHQUE5RSxFQUFtRjtBQUNqRndOLG9CQUFZLEdBRHFFLENBQ2pFOztBQUVoQlUsZ0JBQVEsQ0FBQ1QsUUFBUSxDQUFDLENBQUQsQ0FBVCxFQUFjLG1CQUFkLENBQVI7O0FBRUEsWUFBSVcsY0FBYyxDQUFDbkosTUFBZixHQUF3QixDQUE1QixFQUErQjtBQUM3QixjQUFJc0osV0FBVyxHQUFHVixrQkFBa0IsQ0FBQyxNQUFELEVBQVMsTUFBVCxDQUFwQzs7QUFFQSxjQUFJVSxXQUFXLEtBQUssQ0FBQyxDQUFyQixFQUF3QjtBQUN0QjtBQUNELFdBTDRCLENBSzNCOzs7QUFHRixlQUFLLElBQUkvTSxDQUFDLEdBQUdnTSxZQUFiLEVBQTJCaE0sQ0FBQyxHQUFHK00sV0FBL0IsRUFBNEMvTSxDQUFDLEVBQTdDLEVBQWlEO0FBQy9DLGdCQUFJZ04sUUFBUSxHQUFHbEIsV0FBVyxDQUFDOUwsQ0FBRCxDQUExQjs7QUFFQSxnQkFBSWdOLFFBQVEsQ0FBQ3pPLElBQVQsS0FBa0IsVUFBbEIsSUFBZ0NxTyxjQUFjLENBQUNLLE9BQWYsQ0FBdUJELFFBQVEsQ0FBQ3hPLE9BQWhDLEtBQTRDLENBQWhGLEVBQW1GO0FBQ2pGa08sc0JBQVEsQ0FBQ00sUUFBRCxFQUFXLGdCQUFYLENBQVI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7QUFDRixDQTlKRDtBQStKQTs7QUFFQXBHLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JpTSxHQUFoQixHQUFzQjtBQUNwQixhQUFXO0FBQ1Q5SSxXQUFPLEVBQUUsK0NBREE7QUFFVEUsY0FBVSxFQUFFO0FBRkgsR0FEUztBQUtwQixjQUFZLENBQUM7QUFDWEYsV0FBTyxFQUFFLHFDQURFO0FBRVhjLFVBQU0sRUFBRTtBQUZHLEdBQUQsRUFHVCxVQUhTLENBTFE7QUFTcEIsWUFBVTtBQUNSZCxXQUFPLEVBQUUsaURBREQ7QUFFUmMsVUFBTSxFQUFFLElBRkE7QUFHUlosY0FBVSxFQUFFO0FBSEosR0FUVTtBQWNwQixnQkFBYztBQUNaRixXQUFPLEVBQUUscUNBREc7QUFFWmMsVUFBTSxFQUFFLElBRkk7QUFHWlosY0FBVSxFQUFFLElBSEE7QUFJWjdDLFVBQU0sRUFBRTtBQUNOLHFCQUFlO0FBRFQ7QUFKSSxHQWRNO0FBc0JwQixjQUFZLDJGQXRCUTtBQXVCcEI7QUFDQSxhQUFXLHM5RUF4QlM7QUF5QnBCLGFBQVcsMEJBekJTO0FBMEJwQixZQUFVLDJDQTFCVTtBQTJCcEIsY0FBWSw4SEEzQlE7QUE0QnBCLGlCQUFlO0FBNUJLLENBQXRCO0FBOEJBOztBQUVBLENBQUMsVUFBVTNELEtBQVYsRUFBaUI7QUFDaEIsTUFBSXFQLGNBQWMsR0FBR3JQLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0I2SCxVQUFoQixDQUEyQixpQkFBM0IsQ0FBckIsQ0FEZ0IsQ0FDb0Q7O0FBRXBFLE1BQUlzRSxzQkFBc0IsR0FBR0QsY0FBYyxDQUFDL0ksT0FBZixDQUF1QmlCLE1BQXBEO0FBQ0EsTUFBSWdJLG1CQUFtQixHQUFHRixjQUFjLENBQUMxTCxNQUFmLENBQXNCLGVBQXRCLENBQTFCO0FBQ0EsTUFBSTZMLDhCQUE4QixHQUFHRCxtQkFBbUIsQ0FBQzVMLE1BQXBCLENBQTJCLDJCQUEzQixDQUFyQztBQUNBLE1BQUk4TCxvQkFBb0IsR0FBR0YsbUJBQW1CLENBQUNqSixPQUFwQixDQUE0QmlCLE1BQXZEO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRSxXQUFTbUksY0FBVCxDQUF3Qi9NLFFBQXhCLEVBQWtDb0QsR0FBbEMsRUFBdUM7QUFDckMsUUFBSSxDQUFDL0YsS0FBSyxDQUFDbUQsU0FBTixDQUFnQlIsUUFBaEIsQ0FBTCxFQUFnQztBQUM5QixhQUFPZ04sU0FBUDtBQUNEOztBQUVELFdBQU87QUFDTHJKLGFBQU8sRUFBRTFELE1BQU0sQ0FBQyxTQUFTbUQsR0FBVCxHQUFlLFFBQWYsR0FBMEJ1SixzQkFBM0IsQ0FEVjtBQUVMOUksZ0JBQVUsRUFBRSxJQUZQO0FBR0xZLFlBQU0sRUFBRSxJQUhIO0FBSUx6RCxZQUFNLEVBQUU7QUFDTixnQ0FBd0I7QUFDdEIyQyxpQkFBTyxFQUFFLE9BRGE7QUFFdEIzRixlQUFLLEVBQUU7QUFGZSxTQURsQjtBQUtOLHlCQUFpQjtBQUNmMkYsaUJBQU8sRUFBRSxTQURNO0FBRWYzRixlQUFLLEVBQUVnQztBQUZRO0FBTFg7QUFKSCxLQUFQO0FBZUQ7O0FBRUQzQyxPQUFLLENBQUNtRCxTQUFOLENBQWdCNkgsVUFBaEIsQ0FBMkIsaUJBQTNCLElBQWdELENBQUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EwRSxnQkFBYyxDQUFDLEtBQUQsRUFBUSwwSEFBMEhuSSxNQUFsSSxDQUprQyxFQUl5RztBQUN6SjtBQUNBbUksZ0JBQWMsQ0FBQyxNQUFELEVBQVMseUNBQXlDbkksTUFBbEQsQ0FOa0MsRUFNeUI7QUFDekVtSSxnQkFBYyxDQUFDLEtBQUQsRUFBUSxRQUFRbkksTUFBaEIsQ0FQa0MsRUFPVDtBQUN2Q21JLGdCQUFjLENBQUMsVUFBRCxFQUFhLG9CQUFvQm5JLE1BQWpDLENBUmtDLEVBUVE7QUFDeERtSSxnQkFBYyxDQUFDLFNBQUQsRUFBWSw2Q0FBNkNuSSxNQUF6RCxDQVRrQyxFQVNnQztBQUNoRm1JLGdCQUFjLENBQUMsS0FBRCxFQUFRLFFBQVFuSSxNQUFoQixDQVZrQyxFQVVUO0FBQ3ZDOEgsZ0JBWGdELEVBV2hDcEIsTUFYZ0MsQ0FXekIyQixPQVh5QixDQUFoRDtBQVlBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVFLFdBQVNDLGNBQVQsQ0FBd0JDLE9BQXhCLEVBQWlDbk4sUUFBakMsRUFBMkM7QUFDekMsV0FBTyxRQUFRQSxRQUFRLENBQUNvTixXQUFULEVBQVIsR0FBaUMsR0FBakMsR0FBdUNELE9BQXZDLEdBQWlELEtBQXhEO0FBQ0Q7QUFDRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHRSxXQUFTRSxpQkFBVCxDQUEyQnJMLElBQTNCLEVBQWlDWixPQUFqQyxFQUEwQ3BCLFFBQTFDLEVBQW9EO0FBQ2xELFFBQUkrQixHQUFHLEdBQUc7QUFDUkMsVUFBSSxFQUFFQSxJQURFO0FBRVJaLGFBQU8sRUFBRUEsT0FGRDtBQUdScEIsY0FBUSxFQUFFQTtBQUhGLEtBQVY7QUFLQTNDLFNBQUssQ0FBQzRFLEtBQU4sQ0FBWUMsR0FBWixDQUFnQixpQkFBaEIsRUFBbUNILEdBQW5DO0FBQ0FBLE9BQUcsQ0FBQ25FLE1BQUosR0FBYVAsS0FBSyxDQUFDOEUsUUFBTixDQUFlSixHQUFHLENBQUNDLElBQW5CLEVBQXlCRCxHQUFHLENBQUNYLE9BQTdCLENBQWI7QUFDQS9ELFNBQUssQ0FBQzRFLEtBQU4sQ0FBWUMsR0FBWixDQUFnQixnQkFBaEIsRUFBa0NILEdBQWxDO0FBQ0EsV0FBT0EsR0FBRyxDQUFDbkUsTUFBWDtBQUNEO0FBQ0Q7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHRSxXQUFTMFAsK0JBQVQsQ0FBeUNDLFVBQXpDLEVBQXFEO0FBQ25ELFFBQUlDLFdBQVcsR0FBRyxFQUFsQjtBQUNBQSxlQUFXLENBQUMsMkJBQUQsQ0FBWCxHQUEyQ1gsOEJBQTNDO0FBQ0E7O0FBRUEsUUFBSWpQLE1BQU0sR0FBR1AsS0FBSyxDQUFDOEUsUUFBTixDQUFlb0wsVUFBZixFQUEyQkMsV0FBM0IsQ0FBYjs7QUFFQSxRQUFJNVAsTUFBTSxDQUFDb0YsTUFBUCxLQUFrQixDQUF0QixFQUF5QjtBQUN2QjtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ00sVUFBSXlLLElBQUksR0FBRyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVg7QUFDQUEsVUFBSSxDQUFDM0ssSUFBTCxDQUFVVSxLQUFWLENBQWdCaUssSUFBaEIsRUFBc0JKLGlCQUFpQixDQUFDelAsTUFBTSxDQUFDLENBQUQsQ0FBUCxFQUFZUCxLQUFLLENBQUNtRCxTQUFOLENBQWdCNkgsVUFBNUIsRUFBd0MsWUFBeEMsQ0FBdkM7QUFDQXpLLFlBQU0sQ0FBQzhQLE1BQVAsQ0FBY2xLLEtBQWQsQ0FBb0I1RixNQUFwQixFQUE0QjZQLElBQTVCO0FBQ0Q7O0FBRUQsV0FBTyxJQUFJcFEsS0FBSyxDQUFDUSxLQUFWLENBQWdCLGVBQWhCLEVBQWlDRCxNQUFqQyxFQUF5Q2dQLG1CQUFtQixDQUFDNU8sS0FBN0QsRUFBb0V1UCxVQUFwRSxDQUFQO0FBQ0Q7QUFDRDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHRSxXQUFTSSxnQkFBVCxDQUEwQjNMLElBQTFCLEVBQWdDWixPQUFoQyxFQUF5Q3BCLFFBQXpDLEVBQW1EO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQSxRQUFJNE4sT0FBTyxHQUFHdlEsS0FBSyxDQUFDOEUsUUFBTixDQUFlSCxJQUFmLEVBQXFCO0FBQ2pDLHVCQUFpQjtBQUNmMkIsZUFBTyxFQUFFMUQsTUFBTSxDQUFDNk0sb0JBQUQsQ0FEQTtBQUVmakosa0JBQVUsRUFBRTtBQUZHO0FBRGdCLEtBQXJCLENBQWQsQ0FMaUQsQ0FVN0M7OztBQUdKLFFBQUlnSyxrQkFBa0IsR0FBRyxDQUF6QjtBQUNBOztBQUVBLFFBQUlDLGNBQWMsR0FBRyxFQUFyQjs7QUFFQSxRQUFJQyxZQUFZLEdBQUdILE9BQU8sQ0FBQ3pQLEdBQVIsQ0FBWSxVQUFVbUQsS0FBVixFQUFpQjtBQUM5QyxVQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsZUFBT0EsS0FBUDtBQUNELE9BRkQsTUFFTztBQUNMLFlBQUkwTSx1QkFBdUIsR0FBRzFNLEtBQUssQ0FBQ3ZELE9BQXBDO0FBQ0EsWUFBSWtRLFdBQUo7O0FBRUEsZUFBT2pNLElBQUksQ0FBQ3dLLE9BQUwsQ0FBYXlCLFdBQVcsR0FBR2YsY0FBYyxDQUFDVyxrQkFBa0IsRUFBbkIsRUFBdUI3TixRQUF2QixDQUF6QyxNQUErRSxDQUFDLENBQXZGLEVBQTBGO0FBQ3hGO0FBQ0Q7O0FBRUQ4TixzQkFBYyxDQUFDRyxXQUFELENBQWQsR0FBOEJELHVCQUE5QjtBQUNBLGVBQU9DLFdBQVA7QUFDRDtBQUNGLEtBZGtCLEVBY2hCeEssSUFkZ0IsQ0FjWCxFQWRXLENBQW5CLENBbEJpRCxDQWdDcEM7OztBQUdiLFFBQUl5SyxjQUFjLEdBQUdiLGlCQUFpQixDQUFDVSxZQUFELEVBQWUzTSxPQUFmLEVBQXdCcEIsUUFBeEIsQ0FBdEMsQ0FuQ2lELENBbUN3Qjs7QUFFekUsUUFBSW1PLFlBQVksR0FBRzdQLE1BQU0sQ0FBQzhQLElBQVAsQ0FBWU4sY0FBWixDQUFuQjtBQUNBRCxzQkFBa0IsR0FBRyxDQUFyQjtBQUNBO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUksYUFBU3BFLFVBQVQsQ0FBb0I3TCxNQUFwQixFQUE0QjtBQUMxQixXQUFLLElBQUkyQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHM0IsTUFBTSxDQUFDb0YsTUFBM0IsRUFBbUN6RCxDQUFDLEVBQXBDLEVBQXdDO0FBQ3RDLFlBQUlzTyxrQkFBa0IsSUFBSU0sWUFBWSxDQUFDbkwsTUFBdkMsRUFBK0M7QUFDN0M7QUFDRDs7QUFFRCxZQUFJMUIsS0FBSyxHQUFHMUQsTUFBTSxDQUFDMkIsQ0FBRCxDQUFsQjs7QUFFQSxZQUFJLE9BQU8rQixLQUFQLEtBQWlCLFFBQWpCLElBQTZCLE9BQU9BLEtBQUssQ0FBQ3ZELE9BQWIsS0FBeUIsUUFBMUQsRUFBb0U7QUFDbEUsY0FBSWtRLFdBQVcsR0FBR0UsWUFBWSxDQUFDTixrQkFBRCxDQUE5QjtBQUNBLGNBQUkzSyxDQUFDLEdBQUcsT0FBTzVCLEtBQVAsS0FBaUIsUUFBakIsR0FBNEJBLEtBQTVCO0FBQ1I7QUFDQUEsZUFBSyxDQUFDdkQsT0FGTjtBQUdBLGNBQUlrRyxLQUFLLEdBQUdmLENBQUMsQ0FBQ3NKLE9BQUYsQ0FBVXlCLFdBQVYsQ0FBWjs7QUFFQSxjQUFJaEssS0FBSyxLQUFLLENBQUMsQ0FBZixFQUFrQjtBQUNoQixjQUFFNEosa0JBQUY7QUFDQSxnQkFBSTVNLE1BQU0sR0FBR2lDLENBQUMsQ0FBQ21MLFNBQUYsQ0FBWSxDQUFaLEVBQWVwSyxLQUFmLENBQWI7QUFDQSxnQkFBSXFLLE1BQU0sR0FBR2hCLCtCQUErQixDQUFDUSxjQUFjLENBQUNHLFdBQUQsQ0FBZixDQUE1QztBQUNBLGdCQUFJekksS0FBSyxHQUFHdEMsQ0FBQyxDQUFDbUwsU0FBRixDQUFZcEssS0FBSyxHQUFHZ0ssV0FBVyxDQUFDakwsTUFBaEMsQ0FBWjtBQUNBLGdCQUFJdUwsV0FBVyxHQUFHLEVBQWxCOztBQUVBLGdCQUFJdE4sTUFBSixFQUFZO0FBQ1ZzTix5QkFBVyxDQUFDekwsSUFBWixDQUFpQjdCLE1BQWpCO0FBQ0Q7O0FBRURzTix1QkFBVyxDQUFDekwsSUFBWixDQUFpQndMLE1BQWpCOztBQUVBLGdCQUFJOUksS0FBSixFQUFXO0FBQ1Qsa0JBQUlnSixXQUFXLEdBQUcsQ0FBQ2hKLEtBQUQsQ0FBbEI7QUFDQWlFLHdCQUFVLENBQUMrRSxXQUFELENBQVY7QUFDQUQseUJBQVcsQ0FBQ3pMLElBQVosQ0FBaUJVLEtBQWpCLENBQXVCK0ssV0FBdkIsRUFBb0NDLFdBQXBDO0FBQ0Q7O0FBRUQsZ0JBQUksT0FBT2xOLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IxRCxvQkFBTSxDQUFDOFAsTUFBUCxDQUFjbEssS0FBZCxDQUFvQjVGLE1BQXBCLEVBQTRCLENBQUMyQixDQUFELEVBQUksQ0FBSixFQUFPa1AsTUFBUCxDQUFjRixXQUFkLENBQTVCO0FBQ0FoUCxlQUFDLElBQUlnUCxXQUFXLENBQUN2TCxNQUFaLEdBQXFCLENBQTFCO0FBQ0QsYUFIRCxNQUdPO0FBQ0wxQixtQkFBSyxDQUFDdkQsT0FBTixHQUFnQndRLFdBQWhCO0FBQ0Q7QUFDRjtBQUNGLFNBakNELE1BaUNPO0FBQ0wsY0FBSXhRLE9BQU8sR0FBR3VELEtBQUssQ0FBQ3ZELE9BQXBCOztBQUVBLGNBQUlFLEtBQUssQ0FBQ0MsT0FBTixDQUFjSCxPQUFkLENBQUosRUFBNEI7QUFDMUIwTCxzQkFBVSxDQUFDMUwsT0FBRCxDQUFWO0FBQ0QsV0FGRCxNQUVPO0FBQ0wwTCxzQkFBVSxDQUFDLENBQUMxTCxPQUFELENBQUQsQ0FBVjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVEMEwsY0FBVSxDQUFDeUUsY0FBRCxDQUFWO0FBQ0EsV0FBTyxJQUFJN1EsS0FBSyxDQUFDUSxLQUFWLENBQWdCbUMsUUFBaEIsRUFBMEJrTyxjQUExQixFQUEwQyxjQUFjbE8sUUFBeEQsRUFBa0VnQyxJQUFsRSxDQUFQO0FBQ0Q7QUFDRDtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7QUFHRSxNQUFJME0sa0JBQWtCLEdBQUc7QUFDdkIsa0JBQWMsSUFEUztBQUV2QixVQUFNLElBRmlCO0FBR3ZCLGtCQUFjLElBSFM7QUFJdkIsVUFBTSxJQUppQjtBQUt2QixXQUFPLElBTGdCO0FBTXZCLFdBQU87QUFOZ0IsR0FBekI7QUFRQXJSLE9BQUssQ0FBQzRFLEtBQU4sQ0FBWTlCLEdBQVosQ0FBZ0IsZ0JBQWhCLEVBQWtDLFVBQVU0QixHQUFWLEVBQWU7QUFDL0MsUUFBSSxFQUFFQSxHQUFHLENBQUMvQixRQUFKLElBQWdCME8sa0JBQWxCLENBQUosRUFBMkM7QUFDekM7QUFDRDtBQUNEO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0ksYUFBU0MsbUJBQVQsQ0FBNkIvUSxNQUE3QixFQUFxQztBQUNuQyxXQUFLLElBQUkyQixDQUFDLEdBQUcsQ0FBUixFQUFXbUssQ0FBQyxHQUFHOUwsTUFBTSxDQUFDb0YsTUFBM0IsRUFBbUN6RCxDQUFDLEdBQUdtSyxDQUF2QyxFQUEwQ25LLENBQUMsRUFBM0MsRUFBK0M7QUFDN0MsWUFBSStCLEtBQUssR0FBRzFELE1BQU0sQ0FBQzJCLENBQUQsQ0FBbEI7O0FBRUEsWUFBSSxPQUFPK0IsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QjtBQUNEOztBQUVELFlBQUl2RCxPQUFPLEdBQUd1RCxLQUFLLENBQUN2RCxPQUFwQjs7QUFFQSxZQUFJLENBQUNFLEtBQUssQ0FBQ0MsT0FBTixDQUFjSCxPQUFkLENBQUwsRUFBNkI7QUFDM0IsY0FBSSxPQUFPQSxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CNFEsK0JBQW1CLENBQUMsQ0FBQzVRLE9BQUQsQ0FBRCxDQUFuQjtBQUNEOztBQUVEO0FBQ0Q7O0FBRUQsWUFBSXVELEtBQUssQ0FBQ3hELElBQU4sS0FBZSxpQkFBbkIsRUFBc0M7QUFDcEM7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNVLGNBQUk4USxRQUFRLEdBQUc3USxPQUFPLENBQUMsQ0FBRCxDQUF0Qjs7QUFFQSxjQUFJQSxPQUFPLENBQUNpRixNQUFSLEtBQW1CLENBQW5CLElBQXdCLE9BQU80TCxRQUFQLEtBQW9CLFFBQTVDLElBQXdEQSxRQUFRLENBQUM5USxJQUFULEtBQWtCLGVBQTlFLEVBQStGO0FBQzdGO0FBQ0EsZ0JBQUlrRSxJQUFJLEdBQUc2TSxhQUFhLENBQUNELFFBQUQsQ0FBeEI7QUFDQSxnQkFBSTVRLEtBQUssR0FBRzRRLFFBQVEsQ0FBQzVRLEtBQXJCO0FBQ0EsZ0JBQUlnQyxRQUFRLEdBQUcvQixLQUFLLENBQUNDLE9BQU4sQ0FBY0YsS0FBZCxJQUF1QkEsS0FBSyxDQUFDLENBQUQsQ0FBNUIsR0FBa0NBLEtBQWpEO0FBQ0EsZ0JBQUlvRCxPQUFPLEdBQUcvRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCUixRQUFoQixDQUFkOztBQUVBLGdCQUFJLENBQUNvQixPQUFMLEVBQWM7QUFDWjtBQUNBO0FBQ0Q7O0FBRURyRCxtQkFBTyxDQUFDLENBQUQsQ0FBUCxHQUFhNFAsZ0JBQWdCLENBQUMzTCxJQUFELEVBQU9aLE9BQVAsRUFBZ0JwQixRQUFoQixDQUE3QjtBQUNEO0FBQ0YsU0EvQkQsTUErQk87QUFDTDJPLDZCQUFtQixDQUFDNVEsT0FBRCxDQUFuQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDRRLHVCQUFtQixDQUFDNU0sR0FBRyxDQUFDbkUsTUFBTCxDQUFuQjtBQUNELEdBcEVEO0FBcUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRSxXQUFTaVIsYUFBVCxDQUF1Qi9QLEtBQXZCLEVBQThCO0FBQzVCLFFBQUksT0FBT0EsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixhQUFPQSxLQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUliLEtBQUssQ0FBQ0MsT0FBTixDQUFjWSxLQUFkLENBQUosRUFBMEI7QUFDL0IsYUFBT0EsS0FBSyxDQUFDWCxHQUFOLENBQVUwUSxhQUFWLEVBQXlCcEwsSUFBekIsQ0FBOEIsRUFBOUIsQ0FBUDtBQUNELEtBRk0sTUFFQTtBQUNMLGFBQU9vTCxhQUFhLENBQUMvUCxLQUFLLENBQUNmLE9BQVAsQ0FBcEI7QUFDRDtBQUNGO0FBQ0YsQ0FoVkQsRUFnVkdvSSxLQWhWSDtBQWlWQTs7O0FBR0EsQ0FBQyxVQUFVOUksS0FBVixFQUFpQjtBQUNoQkEsT0FBSyxDQUFDbUQsU0FBTixDQUFnQnNPLFVBQWhCLEdBQTZCelIsS0FBSyxDQUFDbUQsU0FBTixDQUFnQkssTUFBaEIsQ0FBdUIsWUFBdkIsRUFBcUM7QUFDaEUsa0JBQWM7QUFDWjhDLGFBQU8sRUFBRSw4S0FERztBQUVaRSxnQkFBVSxFQUFFLElBRkE7QUFHWlksWUFBTSxFQUFFLElBSEk7QUFJWnpELFlBQU0sRUFBRSxJQUpJLENBSUM7O0FBSkQsS0FEa0Q7QUFRaEUsZUFBVztBQVJxRCxHQUFyQyxDQUE3QixDQURnQixDQVVaOztBQUVKM0QsT0FBSyxDQUFDbUQsU0FBTixDQUFnQnNPLFVBQWhCLENBQTJCbkgsT0FBM0IsQ0FBbUM3RSxJQUFuQyxDQUF3QyxvREFBeEMsRUFBOEY7QUFDOUYsNEZBREEsRUFDNEY7QUFDNUYsOEJBRkEsRUFaZ0IsQ0FjZTs7QUFFL0IsU0FBT3pGLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0JzTyxVQUFoQixDQUEyQixXQUEzQixDQUFQO0FBQ0EsU0FBT3pSLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0JzTyxVQUFoQixDQUEyQixrQkFBM0IsQ0FBUCxDQWpCZ0IsQ0FpQnVDOztBQUV2RCxNQUFJQyxVQUFVLEdBQUcxUixLQUFLLENBQUNtRCxTQUFOLENBQWdCSyxNQUFoQixDQUF1QixZQUF2QixFQUFxQyxFQUFyQyxDQUFqQjtBQUNBLFNBQU9rTyxVQUFVLENBQUMsWUFBRCxDQUFqQjtBQUNBMVIsT0FBSyxDQUFDbUQsU0FBTixDQUFnQnNPLFVBQWhCLENBQTJCLFlBQTNCLEVBQXlDOU4sTUFBekMsR0FBa0QrTixVQUFsRDtBQUNBMVIsT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsWUFBN0IsRUFBMkMsVUFBM0MsRUFBdUQ7QUFDckQsaUJBQWE7QUFDWDRDLGFBQU8sRUFBRSxvQkFERTtBQUVYM0MsWUFBTSxFQUFFO0FBQ04sY0FBTTtBQUNKMkMsaUJBQU8sRUFBRSxJQURMO0FBRUozRixlQUFLLEVBQUU7QUFGSCxTQURBO0FBS04sb0JBQVk7QUFMTjtBQUZHLEtBRHdDO0FBV3JELHdCQUFvQjtBQUNsQjtBQUNBMkYsYUFBTyxFQUFFLHdHQUZTO0FBR2xCYyxZQUFNLEVBQUUsSUFIVTtBQUlsQnpELFlBQU0sRUFBRTtBQUNOLG9CQUFZLDJEQUROO0FBRU4sbUJBQVc7QUFDVDJDLGlCQUFPLEVBQUUsVUFEQTtBQUVUO0FBQ0EzRixlQUFLLEVBQUUsWUFIRTtBQUlUZ0QsZ0JBQU0sRUFBRStOO0FBSkM7QUFGTDtBQUpVO0FBWGlDLEdBQXZEO0FBMEJBMVIsT0FBSyxDQUFDbUQsU0FBTixDQUFnQndPLEVBQWhCLEdBQXFCM1IsS0FBSyxDQUFDbUQsU0FBTixDQUFnQnNPLFVBQXJDO0FBQ0QsQ0FqREQsRUFpREczSSxLQWpESDtBQWtEQTs7O0FBR0EsQ0FBQyxVQUFVOUksS0FBVixFQUFpQjtBQUNoQkEsT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsWUFBN0IsRUFBMkMsbUJBQTNDLEVBQWdFO0FBQzlELHVCQUFtQjtBQUNqQjRDLGFBQU8sRUFBRTFELE1BQU0sQ0FBQyxjQUFjNUMsS0FBSyxDQUFDbUQsU0FBTixDQUFnQjZILFVBQWhCLENBQTJCLG1CQUEzQixFQUFnRDFFLE9BQWhELENBQXdEaUIsTUFBdkUsQ0FERTtBQUVqQmYsZ0JBQVUsRUFBRSxJQUZLO0FBR2pCN0YsV0FBSyxFQUFFLENBQUMsbUJBQUQsRUFBc0IsUUFBdEIsRUFBZ0MsVUFBaEMsRUFBNEMsaUJBQTVDO0FBSFU7QUFEMkMsR0FBaEU7QUFPQVgsT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsWUFBN0IsRUFBMkMsVUFBM0MsRUFBdUQ7QUFDckQsY0FBVTtBQUNSNEMsYUFBTyxFQUFFMUQsTUFBTSxDQUFDLGNBQWM1QyxLQUFLLENBQUNtRCxTQUFOLENBQWdCNkgsVUFBaEIsQ0FBMkIsVUFBM0IsRUFBdUN6RCxNQUF0RCxDQURQO0FBRVJmLGdCQUFVLEVBQUUsSUFGSjtBQUdSN0YsV0FBSyxFQUFFLENBQUMsVUFBRCxFQUFhLGlCQUFiO0FBSEM7QUFEMkMsR0FBdkQ7QUFPQVgsT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsWUFBN0IsRUFBMkMsVUFBM0MsRUFBdUQ7QUFDckQsd0JBQW9CLENBQUM7QUFDbkI7QUFDQTtBQUNBNEMsYUFBTyxFQUFFLHdPQUhVO0FBSW5CM0YsV0FBSyxFQUFFO0FBSlksS0FBRCxFQUtqQjtBQUNEO0FBQ0EyRixhQUFPLEVBQUUsdUJBRlI7QUFHRDNGLFdBQUssRUFBRTtBQUhOLEtBTGlCO0FBRGlDLEdBQXZEO0FBWUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUUsV0FBU2lSLE1BQVQsQ0FBZ0JySyxNQUFoQixFQUF3QkQsS0FBeEIsRUFBK0I7QUFDN0IsV0FBTzFFLE1BQU0sQ0FBQzJFLE1BQU0sQ0FBQ3hHLE9BQVAsQ0FBZSxPQUFmLEVBQXdCLFlBQVk7QUFDaEQsYUFBTyx5REFBeUR3RyxNQUFoRTtBQUNELEtBRmEsQ0FBRCxFQUVURCxLQUZTLENBQWI7QUFHRDs7QUFFRHRILE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLFlBQTdCLEVBQTJDLFNBQTNDLEVBQXNEO0FBQ3BELGVBQVc7QUFDVDtBQUNBNEMsYUFBTyxFQUFFc0wsTUFBTSxDQUFDLDRHQUE0R3JLLE1BQTdHLENBRk47QUFHVGYsZ0JBQVUsRUFBRSxJQUhIO0FBSVQ3QyxZQUFNLEVBQUUzRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCNkg7QUFKZixLQUR5QztBQU9wRCxlQUFXO0FBQ1Q7QUFDQTFFLGFBQU8sRUFBRXNMLE1BQU0sQ0FBQyxtRUFBbUVySyxNQUFwRSxDQUZOO0FBR1RmLGdCQUFVLEVBQUUsSUFISDtBQUlUN0MsWUFBTSxFQUFFM0QsS0FBSyxDQUFDbUQsU0FBTixDQUFnQjZIO0FBSmY7QUFQeUMsR0FBdEQ7QUFjQWhMLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0I2SCxVQUFoQixDQUEyQixTQUEzQixFQUFzQzZHLE9BQXRDLENBQThDO0FBQzVDdkwsV0FBTyxFQUFFLHVDQURtQztBQUU1QzNGLFNBQUssRUFBRTtBQUZxQyxHQUE5QyxFQUdHO0FBQ0QyRixXQUFPLEVBQUUsK0ZBRFI7QUFFRDNGLFNBQUssRUFBRTtBQUZOLEdBSEgsRUFNRztBQUNEMkYsV0FBTyxFQUFFLFVBRFI7QUFFRDNGLFNBQUssRUFBRSxDQUFDLE1BQUQsRUFBUyxLQUFUO0FBRk4sR0FOSCxFQVNHO0FBQ0QyRixXQUFPLEVBQUUsZUFEUjtBQUVEM0YsU0FBSyxFQUFFO0FBRk4sR0FUSDtBQWFBWCxPQUFLLENBQUNtRCxTQUFOLENBQWdCTyxZQUFoQixDQUE2QixZQUE3QixFQUEyQyxVQUEzQyxFQUF1RDtBQUNyRCxjQUFVO0FBQ1I0QyxhQUFPLEVBQUUsT0FERDtBQUVSM0YsV0FBSyxFQUFFO0FBRkMsS0FEMkM7QUFLckQsYUFBUztBQUNQMkYsYUFBTyxFQUFFLElBREY7QUFFUDNGLFdBQUssRUFBRTtBQUZBO0FBTDRDLEdBQXZEO0FBVUFYLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLFlBQTdCLEVBQTJDLGFBQTNDLEVBQTBEO0FBQ3hELHVCQUFtQjtBQUNqQjRDLGFBQU8sRUFBRXNMLE1BQU0sQ0FBQyxnQkFBZ0JySyxNQUFqQixDQURFO0FBRWpCZixnQkFBVSxFQUFFO0FBRkssS0FEcUM7QUFLeEQsd0JBQW9CO0FBQ2xCRixhQUFPLEVBQUUsNkNBRFM7QUFFbEJFLGdCQUFVLEVBQUU7QUFGTSxLQUxvQztBQVN4RCxXQUFPO0FBQ0w7QUFDQUYsYUFBTyxFQUFFLGlGQUZKO0FBR0wzRixXQUFLLEVBQUU7QUFIRixLQVRpRDtBQWN4RCxlQUFXO0FBQ1QyRixhQUFPLEVBQUUsb0JBREE7QUFFVDNGLFdBQUssRUFBRTtBQUZFO0FBZDZDLEdBQTFELEVBOUVnQixDQWdHWjs7QUFFSixNQUFJbVIsb0JBQW9CLEdBQUcsQ0FBQyxVQUFELEVBQWEsbUJBQWIsRUFBa0MsUUFBbEMsRUFBNEMsaUJBQTVDLEVBQStELGlCQUEvRCxDQUEzQjs7QUFFQSxPQUFLLElBQUk1UCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNFAsb0JBQW9CLENBQUNuTSxNQUF6QyxFQUFpRHpELENBQUMsRUFBbEQsRUFBc0Q7QUFDcEQsUUFBSStCLEtBQUssR0FBRzZOLG9CQUFvQixDQUFDNVAsQ0FBRCxDQUFoQztBQUNBLFFBQUlULEtBQUssR0FBR3pCLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0I2SCxVQUFoQixDQUEyQi9HLEtBQTNCLENBQVosQ0FGb0QsQ0FFTDs7QUFFL0MsUUFBSWpFLEtBQUssQ0FBQ0ssSUFBTixDQUFXSSxJQUFYLENBQWdCZ0IsS0FBaEIsTUFBMkIsUUFBL0IsRUFBeUM7QUFDdkNBLFdBQUssR0FBR3pCLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0I2SCxVQUFoQixDQUEyQi9HLEtBQTNCLElBQW9DO0FBQzFDcUMsZUFBTyxFQUFFN0U7QUFEaUMsT0FBNUM7QUFHRCxLQVJtRCxDQVFsRDs7O0FBR0YsUUFBSWtDLE1BQU0sR0FBR2xDLEtBQUssQ0FBQ2tDLE1BQU4sSUFBZ0IsRUFBN0I7QUFDQWxDLFNBQUssQ0FBQ2tDLE1BQU4sR0FBZUEsTUFBZjtBQUNBQSxVQUFNLENBQUMsa0JBQUQsQ0FBTixHQUE2QixlQUE3QjtBQUNEO0FBQ0YsQ0FuSEQsRUFtSEdtRixLQW5ISDtBQW9IQTs7O0FBR0EsQ0FBQyxVQUFVOUksS0FBVixFQUFpQjtBQUNoQixNQUFJZ0wsVUFBVSxHQUFHaEwsS0FBSyxDQUFDSyxJQUFOLENBQVdxQixLQUFYLENBQWlCMUIsS0FBSyxDQUFDbUQsU0FBTixDQUFnQjZILFVBQWpDLENBQWpCO0FBQ0EsTUFBSStHLEtBQUssR0FBRywrQ0FBK0N4SyxNQUEzRDtBQUNBLE1BQUl5SyxNQUFNLEdBQUcsK0NBQStDekssTUFBNUQ7QUFDQSxNQUFJMEssTUFBTSxHQUFHLHVDQUF1QzFLLE1BQXBEO0FBQ0E7QUFDRjtBQUNBO0FBQ0E7O0FBRUUsV0FBUzJLLEVBQVQsQ0FBWTNLLE1BQVosRUFBb0JELEtBQXBCLEVBQTJCO0FBQ3pCQyxVQUFNLEdBQUdBLE1BQU0sQ0FBQ3hHLE9BQVAsQ0FBZSxNQUFmLEVBQXVCLFlBQVk7QUFDMUMsYUFBT2dSLEtBQVA7QUFDRCxLQUZRLEVBRU5oUixPQUZNLENBRUUsV0FGRixFQUVlLFlBQVk7QUFDbEMsYUFBT2lSLE1BQVA7QUFDRCxLQUpRLEVBSU5qUixPQUpNLENBSUUsV0FKRixFQUllLFlBQVk7QUFDbEMsYUFBT2tSLE1BQVA7QUFDRCxLQU5RLENBQVQ7QUFPQSxXQUFPclAsTUFBTSxDQUFDMkUsTUFBRCxFQUFTRCxLQUFULENBQWI7QUFDRDs7QUFFRDJLLFFBQU0sR0FBR0MsRUFBRSxDQUFDRCxNQUFELENBQUYsQ0FBVzFLLE1BQXBCO0FBQ0F2SCxPQUFLLENBQUNtRCxTQUFOLENBQWdCZ1AsR0FBaEIsR0FBc0JuUyxLQUFLLENBQUNtRCxTQUFOLENBQWdCSyxNQUFoQixDQUF1QixRQUF2QixFQUFpQ3dILFVBQWpDLENBQXRCO0FBQ0FoTCxPQUFLLENBQUNtRCxTQUFOLENBQWdCZ1AsR0FBaEIsQ0FBb0JwTSxHQUFwQixDQUF3Qk8sT0FBeEIsR0FBa0M0TCxFQUFFLENBQUMsd0lBQXdJM0ssTUFBekksQ0FBcEM7QUFDQXZILE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JnUCxHQUFoQixDQUFvQnBNLEdBQXBCLENBQXdCcEMsTUFBeEIsQ0FBK0IsS0FBL0IsRUFBc0MyQyxPQUF0QyxHQUFnRCxnQkFBaEQ7QUFDQXRHLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JnUCxHQUFoQixDQUFvQnBNLEdBQXBCLENBQXdCcEMsTUFBeEIsQ0FBK0IsWUFBL0IsRUFBNkMyQyxPQUE3QyxHQUF1RCxvRUFBdkQ7QUFDQXRHLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JnUCxHQUFoQixDQUFvQnBNLEdBQXBCLENBQXdCcEMsTUFBeEIsQ0FBK0IsS0FBL0IsRUFBc0NBLE1BQXRDLENBQTZDLFlBQTdDLElBQTZELDJCQUE3RDtBQUNBM0QsT0FBSyxDQUFDbUQsU0FBTixDQUFnQmdQLEdBQWhCLENBQW9CcE0sR0FBcEIsQ0FBd0JwQyxNQUF4QixDQUErQixTQUEvQixJQUE0Q3FILFVBQVUsQ0FBQyxTQUFELENBQXREO0FBQ0FoTCxPQUFLLENBQUNtRCxTQUFOLENBQWdCTyxZQUFoQixDQUE2QixRQUE3QixFQUF1QyxXQUF2QyxFQUFvRDtBQUNsRCxjQUFVO0FBQ1I0QyxhQUFPLEVBQUU0TCxFQUFFLENBQUMsV0FBVzNLLE1BQVosQ0FESDtBQUVSNUQsWUFBTSxFQUFFM0QsS0FBSyxDQUFDbUQsU0FBTixDQUFnQmdQO0FBRmhCO0FBRHdDLEdBQXBELEVBS0duUyxLQUFLLENBQUNtRCxTQUFOLENBQWdCZ1AsR0FBaEIsQ0FBb0JwTSxHQUx2QjtBQU1BL0YsT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsUUFBN0IsRUFBdUMsY0FBdkMsRUFBdUQ7QUFDckQsY0FBVTtBQUNSO0FBQ0E0QyxhQUFPLEVBQUU0TCxFQUFFLENBQUMsWUFBWTNLLE1BQWIsQ0FGSDtBQUdSNUcsV0FBSyxFQUFFLHFCQUhDO0FBSVJnRCxZQUFNLEVBQUU7QUFDTiw4QkFBc0I7QUFDcEIyQyxpQkFBTyxFQUFFLFVBRFc7QUFFcEIzRixlQUFLLEVBQUU7QUFGYSxTQURoQjtBQUtOcUUsWUFBSSxFQUFFaEYsS0FBSyxDQUFDbUQsU0FBTixDQUFnQmdQO0FBTGhCO0FBSkE7QUFEMkMsR0FBdkQsRUFhR25TLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0JnUCxHQUFoQixDQUFvQnBNLEdBYnZCLEVBbENnQixDQStDYTs7QUFFN0IsTUFBSXFNLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBVW5PLEtBQVYsRUFBaUI7QUFDcEMsUUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDVixhQUFPLEVBQVA7QUFDRDs7QUFFRCxRQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsYUFBT0EsS0FBUDtBQUNEOztBQUVELFFBQUksT0FBT0EsS0FBSyxDQUFDdkQsT0FBYixLQUF5QixRQUE3QixFQUF1QztBQUNyQyxhQUFPdUQsS0FBSyxDQUFDdkQsT0FBYjtBQUNEOztBQUVELFdBQU91RCxLQUFLLENBQUN2RCxPQUFOLENBQWNJLEdBQWQsQ0FBa0JzUixjQUFsQixFQUFrQ2hNLElBQWxDLENBQXVDLEVBQXZDLENBQVA7QUFDRCxHQWREOztBQWdCQSxNQUFJZ0csVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBVTdMLE1BQVYsRUFBa0I7QUFDakMsUUFBSThSLFVBQVUsR0FBRyxFQUFqQjs7QUFFQSxTQUFLLElBQUluUSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHM0IsTUFBTSxDQUFDb0YsTUFBM0IsRUFBbUN6RCxDQUFDLEVBQXBDLEVBQXdDO0FBQ3RDLFVBQUkrQixLQUFLLEdBQUcxRCxNQUFNLENBQUMyQixDQUFELENBQWxCO0FBQ0EsVUFBSW9RLGNBQWMsR0FBRyxLQUFyQjs7QUFFQSxVQUFJLE9BQU9yTyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFlBQUlBLEtBQUssQ0FBQ3hELElBQU4sS0FBZSxLQUFmLElBQXdCd0QsS0FBSyxDQUFDdkQsT0FBTixDQUFjLENBQWQsQ0FBeEIsSUFBNEN1RCxLQUFLLENBQUN2RCxPQUFOLENBQWMsQ0FBZCxFQUFpQkQsSUFBakIsS0FBMEIsS0FBMUUsRUFBaUY7QUFDL0U7QUFDQSxjQUFJd0QsS0FBSyxDQUFDdkQsT0FBTixDQUFjLENBQWQsRUFBaUJBLE9BQWpCLENBQXlCLENBQXpCLEVBQTRCQSxPQUE1QixLQUF3QyxJQUE1QyxFQUFrRDtBQUNoRDtBQUNBLGdCQUFJMlIsVUFBVSxDQUFDMU0sTUFBWCxHQUFvQixDQUFwQixJQUF5QjBNLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDMU0sTUFBWCxHQUFvQixDQUFyQixDQUFWLENBQWtDc0QsT0FBbEMsS0FBOENtSixjQUFjLENBQUNuTyxLQUFLLENBQUN2RCxPQUFOLENBQWMsQ0FBZCxFQUFpQkEsT0FBakIsQ0FBeUIsQ0FBekIsQ0FBRCxDQUF6RixFQUF3SDtBQUN0SDtBQUNBMlIsd0JBQVUsQ0FBQ0UsR0FBWDtBQUNEO0FBQ0YsV0FORCxNQU1PO0FBQ0wsZ0JBQUl0TyxLQUFLLENBQUN2RCxPQUFOLENBQWN1RCxLQUFLLENBQUN2RCxPQUFOLENBQWNpRixNQUFkLEdBQXVCLENBQXJDLEVBQXdDakYsT0FBeEMsS0FBb0QsSUFBeEQsRUFBOEQsQ0FBOUQsS0FBcUU7QUFDbkU7QUFDQTJSLHdCQUFVLENBQUM1TSxJQUFYLENBQWdCO0FBQ2R3RCx1QkFBTyxFQUFFbUosY0FBYyxDQUFDbk8sS0FBSyxDQUFDdkQsT0FBTixDQUFjLENBQWQsRUFBaUJBLE9BQWpCLENBQXlCLENBQXpCLENBQUQsQ0FEVDtBQUVkOFIsNEJBQVksRUFBRTtBQUZBLGVBQWhCO0FBSUQ7QUFDRjtBQUNGLFNBakJELE1BaUJPLElBQUlILFVBQVUsQ0FBQzFNLE1BQVgsR0FBb0IsQ0FBcEIsSUFBeUIxQixLQUFLLENBQUN4RCxJQUFOLEtBQWUsYUFBeEMsSUFBeUR3RCxLQUFLLENBQUN2RCxPQUFOLEtBQWtCLEdBQS9FLEVBQW9GO0FBQ3pGO0FBQ0EyUixvQkFBVSxDQUFDQSxVQUFVLENBQUMxTSxNQUFYLEdBQW9CLENBQXJCLENBQVYsQ0FBa0M2TSxZQUFsQztBQUNELFNBSE0sTUFHQSxJQUFJSCxVQUFVLENBQUMxTSxNQUFYLEdBQW9CLENBQXBCLElBQXlCME0sVUFBVSxDQUFDQSxVQUFVLENBQUMxTSxNQUFYLEdBQW9CLENBQXJCLENBQVYsQ0FBa0M2TSxZQUFsQyxHQUFpRCxDQUExRSxJQUErRXZPLEtBQUssQ0FBQ3hELElBQU4sS0FBZSxhQUE5RixJQUErR3dELEtBQUssQ0FBQ3ZELE9BQU4sS0FBa0IsR0FBckksRUFBMEk7QUFDL0k7QUFDQTJSLG9CQUFVLENBQUNBLFVBQVUsQ0FBQzFNLE1BQVgsR0FBb0IsQ0FBckIsQ0FBVixDQUFrQzZNLFlBQWxDO0FBQ0QsU0FITSxNQUdBO0FBQ0xGLHdCQUFjLEdBQUcsSUFBakI7QUFDRDtBQUNGOztBQUVELFVBQUlBLGNBQWMsSUFBSSxPQUFPck8sS0FBUCxLQUFpQixRQUF2QyxFQUFpRDtBQUMvQyxZQUFJb08sVUFBVSxDQUFDMU0sTUFBWCxHQUFvQixDQUFwQixJQUF5QjBNLFVBQVUsQ0FBQ0EsVUFBVSxDQUFDMU0sTUFBWCxHQUFvQixDQUFyQixDQUFWLENBQWtDNk0sWUFBbEMsS0FBbUQsQ0FBaEYsRUFBbUY7QUFDakY7QUFDQTtBQUNBLGNBQUlDLFNBQVMsR0FBR0wsY0FBYyxDQUFDbk8sS0FBRCxDQUE5QixDQUhpRixDQUcxQzs7QUFFdkMsY0FBSS9CLENBQUMsR0FBRzNCLE1BQU0sQ0FBQ29GLE1BQVAsR0FBZ0IsQ0FBcEIsS0FBMEIsT0FBT3BGLE1BQU0sQ0FBQzJCLENBQUMsR0FBRyxDQUFMLENBQWIsS0FBeUIsUUFBekIsSUFBcUMzQixNQUFNLENBQUMyQixDQUFDLEdBQUcsQ0FBTCxDQUFOLENBQWN6QixJQUFkLEtBQXVCLFlBQXRGLENBQUosRUFBeUc7QUFDdkdnUyxxQkFBUyxJQUFJTCxjQUFjLENBQUM3UixNQUFNLENBQUMyQixDQUFDLEdBQUcsQ0FBTCxDQUFQLENBQTNCO0FBQ0EzQixrQkFBTSxDQUFDOFAsTUFBUCxDQUFjbk8sQ0FBQyxHQUFHLENBQWxCLEVBQXFCLENBQXJCO0FBQ0Q7O0FBRUQsY0FBSUEsQ0FBQyxHQUFHLENBQUosS0FBVSxPQUFPM0IsTUFBTSxDQUFDMkIsQ0FBQyxHQUFHLENBQUwsQ0FBYixLQUF5QixRQUF6QixJQUFxQzNCLE1BQU0sQ0FBQzJCLENBQUMsR0FBRyxDQUFMLENBQU4sQ0FBY3pCLElBQWQsS0FBdUIsWUFBdEUsQ0FBSixFQUF5RjtBQUN2RmdTLHFCQUFTLEdBQUdMLGNBQWMsQ0FBQzdSLE1BQU0sQ0FBQzJCLENBQUMsR0FBRyxDQUFMLENBQVAsQ0FBZCxHQUFnQ3VRLFNBQTVDO0FBQ0FsUyxrQkFBTSxDQUFDOFAsTUFBUCxDQUFjbk8sQ0FBQyxHQUFHLENBQWxCLEVBQXFCLENBQXJCO0FBQ0FBLGFBQUM7QUFDRjs7QUFFRDNCLGdCQUFNLENBQUMyQixDQUFELENBQU4sR0FBWSxJQUFJbEMsS0FBSyxDQUFDUSxLQUFWLENBQWdCLFlBQWhCLEVBQThCaVMsU0FBOUIsRUFBeUMsSUFBekMsRUFBK0NBLFNBQS9DLENBQVo7QUFDRDtBQUNGOztBQUVELFVBQUl4TyxLQUFLLENBQUN2RCxPQUFOLElBQWlCLE9BQU91RCxLQUFLLENBQUN2RCxPQUFiLEtBQXlCLFFBQTlDLEVBQXdEO0FBQ3REMEwsa0JBQVUsQ0FBQ25JLEtBQUssQ0FBQ3ZELE9BQVAsQ0FBVjtBQUNEO0FBQ0Y7QUFDRixHQTdERDs7QUErREFWLE9BQUssQ0FBQzRFLEtBQU4sQ0FBWTlCLEdBQVosQ0FBZ0IsZ0JBQWhCLEVBQWtDLFVBQVU0QixHQUFWLEVBQWU7QUFDL0MsUUFBSUEsR0FBRyxDQUFDL0IsUUFBSixLQUFpQixLQUFqQixJQUEwQitCLEdBQUcsQ0FBQy9CLFFBQUosS0FBaUIsS0FBL0MsRUFBc0Q7QUFDcEQ7QUFDRDs7QUFFRHlKLGNBQVUsQ0FBQzFILEdBQUcsQ0FBQ25FLE1BQUwsQ0FBVjtBQUNELEdBTkQ7QUFPRCxDQXZJRCxFQXVJR3VJLEtBdklIO0FBd0lBOzs7QUFHQSxDQUFDLFVBQVU5SSxLQUFWLEVBQWlCO0FBQ2hCQSxPQUFLLENBQUNtRCxTQUFOLENBQWdCdVAsSUFBaEIsR0FBdUI7QUFDckIsYUFBUyxDQUFDO0FBQ1YsK0JBRFMsRUFDb0I7QUFDN0IsZUFGUyxFQUVJO0FBQ2IsYUFIUyxDQURZLENBSVY7O0FBSlUsR0FBdkI7QUFPQTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVFLE1BQUlDLFFBQVEsR0FBRztBQUNiLG9CQUFnQixHQURIO0FBRWIscUJBQWlCLEdBRko7QUFHYixxQkFBaUIsR0FISjtBQUliLHNCQUFrQixHQUpMO0FBS2IsaUJBQWEsR0FMQTtBQU1iLFlBQVE7QUFOSyxHQUFmLENBZGdCLENBcUJiOztBQUVIMVIsUUFBTSxDQUFDOFAsSUFBUCxDQUFZNEIsUUFBWixFQUFzQjNRLE9BQXRCLENBQThCLFVBQVV3RCxJQUFWLEVBQWdCO0FBQzVDLFFBQUlvTixNQUFNLEdBQUdELFFBQVEsQ0FBQ25OLElBQUQsQ0FBckI7QUFDQSxRQUFJN0UsS0FBSyxHQUFHLEVBQVo7O0FBRUEsUUFBSSxDQUFDLFFBQVFnTyxJQUFSLENBQWFuSixJQUFiLENBQUwsRUFBeUI7QUFDdkI7QUFDQTdFLFdBQUssQ0FBQzhFLElBQU4sQ0FBVyxNQUFNbkQsSUFBTixDQUFXa0QsSUFBWCxFQUFpQixDQUFqQixDQUFYO0FBQ0Q7O0FBRUQsUUFBSUEsSUFBSSxLQUFLLE1BQWIsRUFBcUI7QUFDbkI3RSxXQUFLLENBQUM4RSxJQUFOLENBQVcsTUFBWDtBQUNEOztBQUVEekYsU0FBSyxDQUFDbUQsU0FBTixDQUFnQnVQLElBQWhCLENBQXFCbE4sSUFBckIsSUFBNkI7QUFDM0JjLGFBQU8sRUFBRTFELE1BQU0sQ0FBQyxVQUFVZ1EsTUFBVixHQUFtQixnQ0FBcEIsRUFBc0QsR0FBdEQsQ0FEWTtBQUUzQmpTLFdBQUssRUFBRUEsS0FGb0I7QUFHM0JnRCxZQUFNLEVBQUU7QUFDTixnQkFBUTtBQUNOMkMsaUJBQU8sRUFBRSw4QkFESDtBQUVORSxvQkFBVSxFQUFFO0FBRk4sU0FERjtBQUtOLGtCQUFVO0FBQ1JGLGlCQUFPLEVBQUUsUUFERDtBQUVSM0YsZUFBSyxFQUFFLE1BQU0yQixJQUFOLENBQVdrRCxJQUFYLEVBQWlCLENBQWpCO0FBRkM7QUFMSjtBQUhtQixLQUE3QjtBQWNELEdBM0JELEVBdkJnQixDQWtEWjs7QUFFSnZFLFFBQU0sQ0FBQ08sY0FBUCxDQUFzQnhCLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0J1UCxJQUF0QyxFQUE0QyxVQUE1QyxFQUF3RDtBQUN0RGpSLFNBQUssRUFBRWtSO0FBRCtDLEdBQXhEO0FBR0QsQ0F2REQsRUF1REc3SixLQXZESDtBQXdEQTs7O0FBR0FBLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0IwUCxHQUFoQixHQUFzQjtBQUNwQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxhQUFXLE9BVlM7O0FBWXBCO0FBQ0Y7QUFDQTtBQUNFLGFBQVcsVUFmUztBQWdCcEIsY0FBWSxRQWhCUTs7QUFrQnBCO0FBQ0Y7QUFDQTtBQUNFLFlBQVUsaUNBckJVOztBQXVCcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNFLGFBQVc7QUFDVHZNLFdBQU8sRUFBRSxnQkFEQTtBQUVUM0MsVUFBTSxFQUFFO0FBQ047QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ00sbUJBQWE7QUFQUDtBQUZDLEdBNUJTOztBQXlDcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxXQUFTLFdBdERXOztBQXdEcEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRSxpQkFBZTtBQWxFSyxDQUF0QjtBQW9FQTs7QUFFQW1GLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0IyUCxFQUFoQixHQUFxQmhLLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JLLE1BQWhCLENBQXVCLE9BQXZCLEVBQWdDO0FBQ25ELFlBQVU7QUFDUjhDLFdBQU8sRUFBRSx3Q0FERDtBQUVSRSxjQUFVLEVBQUUsSUFGSjtBQUdSWSxVQUFNLEVBQUU7QUFIQSxHQUR5QztBQU1uRCxhQUFXLHFLQU53QztBQU9uRCxhQUFXLCtCQVB3QztBQVFuRCxZQUFVLENBQUM7QUFDWCxnQ0FEVSxFQUNzQjtBQUNoQyxpRkFGVSxFQUV1RTtBQUNqRixzRUFIVSxDQVJ5QztBQVluRCxjQUFZLHVGQVp1QztBQWFuRCxhQUFXO0FBYndDLENBQWhDLENBQXJCO0FBZUEwQixLQUFLLENBQUMzRixTQUFOLENBQWdCTyxZQUFoQixDQUE2QixJQUE3QixFQUFtQyxRQUFuQyxFQUE2QztBQUMzQyxVQUFRO0FBQ040QyxXQUFPLEVBQUUsNEJBREg7QUFFTmMsVUFBTSxFQUFFO0FBRkY7QUFEbUMsQ0FBN0M7QUFNQSxPQUFPMEIsS0FBSyxDQUFDM0YsU0FBTixDQUFnQjJQLEVBQWhCLENBQW1CLFlBQW5CLENBQVA7QUFDQTs7QUFFQSxDQUFDLFVBQVU5UyxLQUFWLEVBQWlCO0FBQ2hCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsV0FBUzZQLGNBQVQsQ0FBd0JsTixRQUF4QixFQUFrQ2lFLEtBQWxDLEVBQXlDO0FBQ3ZDLFdBQU8sUUFBUWpFLFFBQVEsQ0FBQ29OLFdBQVQsRUFBUixHQUFpQ25KLEtBQWpDLEdBQXlDLEtBQWhEO0FBQ0Q7O0FBRUQzRixRQUFNLENBQUM4UixnQkFBUCxDQUF3Qi9TLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0IsbUJBQWhCLElBQXVDLEVBQS9ELEVBQW1FO0FBQ2pFNlAscUJBQWlCLEVBQUU7QUFDakI7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNNdlIsV0FBSyxFQUFFLGVBQVVpRCxHQUFWLEVBQWUvQixRQUFmLEVBQXlCc1Esa0JBQXpCLEVBQTZDQyxhQUE3QyxFQUE0RDtBQUNqRSxZQUFJeE8sR0FBRyxDQUFDL0IsUUFBSixLQUFpQkEsUUFBckIsRUFBK0I7QUFDN0I7QUFDRDs7QUFFRCxZQUFJd1EsVUFBVSxHQUFHek8sR0FBRyxDQUFDeU8sVUFBSixHQUFpQixFQUFsQztBQUNBek8sV0FBRyxDQUFDQyxJQUFKLEdBQVdELEdBQUcsQ0FBQ0MsSUFBSixDQUFTNUQsT0FBVCxDQUFpQmtTLGtCQUFqQixFQUFxQyxVQUFVdk0sS0FBVixFQUFpQjtBQUMvRCxjQUFJLE9BQU93TSxhQUFQLEtBQXlCLFVBQXpCLElBQXVDLENBQUNBLGFBQWEsQ0FBQ3hNLEtBQUQsQ0FBekQsRUFBa0U7QUFDaEUsbUJBQU9BLEtBQVA7QUFDRDs7QUFFRCxjQUFJeEUsQ0FBQyxHQUFHaVIsVUFBVSxDQUFDeE4sTUFBbkI7QUFDQSxjQUFJaUwsV0FBSixDQU4rRCxDQU05Qzs7QUFFakIsaUJBQU9sTSxHQUFHLENBQUNDLElBQUosQ0FBU3dLLE9BQVQsQ0FBaUJ5QixXQUFXLEdBQUdmLGNBQWMsQ0FBQ2xOLFFBQUQsRUFBV1QsQ0FBWCxDQUE3QyxNQUFnRSxDQUFDLENBQXhFLEVBQTJFO0FBQ3pFLGNBQUVBLENBQUY7QUFDRCxXQVY4RCxDQVU3RDs7O0FBR0ZpUixvQkFBVSxDQUFDalIsQ0FBRCxDQUFWLEdBQWdCd0UsS0FBaEI7QUFDQSxpQkFBT2tLLFdBQVA7QUFDRCxTQWZVLENBQVgsQ0FOaUUsQ0FxQjdEOztBQUVKbE0sV0FBRyxDQUFDWCxPQUFKLEdBQWMvRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCNEYsTUFBOUI7QUFDRDtBQXBDZ0IsS0FEOEM7QUF1Q2pFcUssd0JBQW9CLEVBQUU7QUFDcEI7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ00zUixXQUFLLEVBQUUsZUFBVWlELEdBQVYsRUFBZS9CLFFBQWYsRUFBeUI7QUFDOUIsWUFBSStCLEdBQUcsQ0FBQy9CLFFBQUosS0FBaUJBLFFBQWpCLElBQTZCLENBQUMrQixHQUFHLENBQUN5TyxVQUF0QyxFQUFrRDtBQUNoRDtBQUNELFNBSDZCLENBRzVCOzs7QUFHRnpPLFdBQUcsQ0FBQ1gsT0FBSixHQUFjL0QsS0FBSyxDQUFDbUQsU0FBTixDQUFnQlIsUUFBaEIsQ0FBZDtBQUNBLFlBQUlzRSxDQUFDLEdBQUcsQ0FBUjtBQUNBLFlBQUk4SixJQUFJLEdBQUc5UCxNQUFNLENBQUM4UCxJQUFQLENBQVlyTSxHQUFHLENBQUN5TyxVQUFoQixDQUFYOztBQUVBLGlCQUFTL0csVUFBVCxDQUFvQjdMLE1BQXBCLEVBQTRCO0FBQzFCLGVBQUssSUFBSTJCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUczQixNQUFNLENBQUNvRixNQUEzQixFQUFtQ3pELENBQUMsRUFBcEMsRUFBd0M7QUFDdEM7QUFDQSxnQkFBSStFLENBQUMsSUFBSThKLElBQUksQ0FBQ3BMLE1BQWQsRUFBc0I7QUFDcEI7QUFDRDs7QUFFRCxnQkFBSTFCLEtBQUssR0FBRzFELE1BQU0sQ0FBQzJCLENBQUQsQ0FBbEI7O0FBRUEsZ0JBQUksT0FBTytCLEtBQVAsS0FBaUIsUUFBakIsSUFBNkJBLEtBQUssQ0FBQ3ZELE9BQU4sSUFBaUIsT0FBT3VELEtBQUssQ0FBQ3ZELE9BQWIsS0FBeUIsUUFBM0UsRUFBcUY7QUFDbkYsa0JBQUl1SCxDQUFDLEdBQUc4SSxJQUFJLENBQUM5SixDQUFELENBQVo7QUFDQSxrQkFBSStILENBQUMsR0FBR3RLLEdBQUcsQ0FBQ3lPLFVBQUosQ0FBZWxMLENBQWYsQ0FBUjtBQUNBLGtCQUFJcEMsQ0FBQyxHQUFHLE9BQU81QixLQUFQLEtBQWlCLFFBQWpCLEdBQTRCQSxLQUE1QixHQUFvQ0EsS0FBSyxDQUFDdkQsT0FBbEQ7QUFDQSxrQkFBSWtRLFdBQVcsR0FBR2YsY0FBYyxDQUFDbE4sUUFBRCxFQUFXc0YsQ0FBWCxDQUFoQztBQUNBLGtCQUFJckIsS0FBSyxHQUFHZixDQUFDLENBQUNzSixPQUFGLENBQVV5QixXQUFWLENBQVo7O0FBRUEsa0JBQUloSyxLQUFLLEdBQUcsQ0FBQyxDQUFiLEVBQWdCO0FBQ2Qsa0JBQUVLLENBQUY7QUFDQSxvQkFBSXJELE1BQU0sR0FBR2lDLENBQUMsQ0FBQ21MLFNBQUYsQ0FBWSxDQUFaLEVBQWVwSyxLQUFmLENBQWI7QUFDQSxvQkFBSXFLLE1BQU0sR0FBRyxJQUFJalIsS0FBSyxDQUFDUSxLQUFWLENBQWdCbUMsUUFBaEIsRUFBMEIzQyxLQUFLLENBQUM4RSxRQUFOLENBQWVrSyxDQUFmLEVBQWtCdEssR0FBRyxDQUFDWCxPQUF0QixDQUExQixFQUEwRCxjQUFjcEIsUUFBeEUsRUFBa0ZxTSxDQUFsRixDQUFiO0FBQ0Esb0JBQUk3RyxLQUFLLEdBQUd0QyxDQUFDLENBQUNtTCxTQUFGLENBQVlwSyxLQUFLLEdBQUdnSyxXQUFXLENBQUNqTCxNQUFoQyxDQUFaO0FBQ0Esb0JBQUl1TCxXQUFXLEdBQUcsRUFBbEI7O0FBRUEsb0JBQUl0TixNQUFKLEVBQVk7QUFDVnNOLDZCQUFXLENBQUN6TCxJQUFaLENBQWlCVSxLQUFqQixDQUF1QitLLFdBQXZCLEVBQW9DOUUsVUFBVSxDQUFDLENBQUN4SSxNQUFELENBQUQsQ0FBOUM7QUFDRDs7QUFFRHNOLDJCQUFXLENBQUN6TCxJQUFaLENBQWlCd0wsTUFBakI7O0FBRUEsb0JBQUk5SSxLQUFKLEVBQVc7QUFDVCtJLDZCQUFXLENBQUN6TCxJQUFaLENBQWlCVSxLQUFqQixDQUF1QitLLFdBQXZCLEVBQW9DOUUsVUFBVSxDQUFDLENBQUNqRSxLQUFELENBQUQsQ0FBOUM7QUFDRDs7QUFFRCxvQkFBSSxPQUFPbEUsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QjFELHdCQUFNLENBQUM4UCxNQUFQLENBQWNsSyxLQUFkLENBQW9CNUYsTUFBcEIsRUFBNEIsQ0FBQzJCLENBQUQsRUFBSSxDQUFKLEVBQU9rUCxNQUFQLENBQWNGLFdBQWQsQ0FBNUI7QUFDRCxpQkFGRCxNQUVPO0FBQ0xqTix1QkFBSyxDQUFDdkQsT0FBTixHQUFnQndRLFdBQWhCO0FBQ0Q7QUFDRjtBQUNGLGFBOUJELE1BOEJPLElBQUlqTixLQUFLLENBQUN2RDtBQUNqQjtBQURPLGNBRUw7QUFDRTBMLDBCQUFVLENBQUNuSSxLQUFLLENBQUN2RCxPQUFQLENBQVY7QUFDRDtBQUNKOztBQUVELGlCQUFPSCxNQUFQO0FBQ0Q7O0FBRUQ2TCxrQkFBVSxDQUFDMUgsR0FBRyxDQUFDbkUsTUFBTCxDQUFWO0FBQ0Q7QUFuRW1CO0FBdkMyQyxHQUFuRTtBQTZHRCxDQXpIRCxFQXlIR3VJLEtBekhIO0FBMEhBOzs7QUFHQSxDQUFDLFVBQVU5SSxLQUFWLEVBQWlCO0FBQ2hCQSxPQUFLLENBQUNtRCxTQUFOLENBQWdCa1EsVUFBaEIsR0FBNkI7QUFDM0IsZUFBVyxtQkFEZ0I7QUFFM0IsaUJBQWE7QUFDWC9NLGFBQU8sRUFBRSxtQkFERTtBQUVYM0YsV0FBSyxFQUFFO0FBRkksS0FGYztBQU0zQixjQUFVLGtDQU5pQjtBQU8zQixjQUFVLGdFQVBpQjtBQVEzQixlQUFXLG9CQVJnQjtBQVMzQixhQUFTO0FBQ1AyRixhQUFPLEVBQUUsOENBREY7QUFFUEUsZ0JBQVUsRUFBRSxJQUZMO0FBR1A3RixXQUFLLEVBQUU7QUFIQSxLQVRrQjtBQWMzQixnQkFBWTtBQUNWMkYsYUFBTyxFQUFFLFlBREM7QUFFVjNDLFlBQU0sRUFBRTtBQUNOd0ksbUJBQVcsRUFBRSxPQURQO0FBRU5sQyxnQkFBUSxFQUFFO0FBRko7QUFGRSxLQWRlO0FBcUIzQixtQkFBZSxvQ0FyQlk7QUFzQjNCLGdCQUFZO0FBdEJlLEdBQTdCO0FBd0JBakssT0FBSyxDQUFDNEUsS0FBTixDQUFZOUIsR0FBWixDQUFnQixpQkFBaEIsRUFBbUMsVUFBVTRCLEdBQVYsRUFBZTtBQUNoRCxRQUFJNE8saUJBQWlCLEdBQUcsd0NBQXhCO0FBQ0F0VCxTQUFLLENBQUNtRCxTQUFOLENBQWdCLG1CQUFoQixFQUFxQzZQLGlCQUFyQyxDQUF1RHRPLEdBQXZELEVBQTRELFlBQTVELEVBQTBFNE8saUJBQTFFO0FBQ0QsR0FIRDtBQUlBdFQsT0FBSyxDQUFDNEUsS0FBTixDQUFZOUIsR0FBWixDQUFnQixnQkFBaEIsRUFBa0MsVUFBVTRCLEdBQVYsRUFBZTtBQUMvQzFFLFNBQUssQ0FBQ21ELFNBQU4sQ0FBZ0IsbUJBQWhCLEVBQXFDaVEsb0JBQXJDLENBQTBEMU8sR0FBMUQsRUFBK0QsWUFBL0Q7QUFDRCxHQUZEO0FBR0ExRSxPQUFLLENBQUNtRCxTQUFOLENBQWdCb1EsR0FBaEIsR0FBc0J2VCxLQUFLLENBQUNtRCxTQUFOLENBQWdCa1EsVUFBdEM7QUFDRCxDQWpDRCxFQWlDR3ZLLEtBakNIO0FBa0NBO0FBQ0E7OztBQUdBQSxLQUFLLENBQUMzRixTQUFOLENBQWdCcVEsSUFBaEIsR0FBdUI7QUFDckIsY0FBWTtBQUNWbE4sV0FBTyxFQUFFLHdDQURDO0FBRVZFLGNBQVUsRUFBRSxJQUZGO0FBR1ZZLFVBQU0sRUFBRTtBQUhFLEdBRFM7QUFNckIsWUFBVTtBQUNSZCxXQUFPLEVBQUUsd0NBREQ7QUFFUkUsY0FBVSxFQUFFLElBRko7QUFHUlksVUFBTSxFQUFFO0FBSEEsR0FOVztBQVdyQixhQUFXO0FBQ1RkLFdBQU8sRUFBRSwrQkFEQTtBQUVUYyxVQUFNLEVBQUU7QUFGQyxHQVhVO0FBZXJCLFlBQVUsb0NBZlc7QUFnQnJCLGlCQUFlLFVBaEJNO0FBaUJyQixjQUFZLEdBakJTO0FBa0JyQixhQUFXLG9CQWxCVTtBQW1CckIsVUFBUTtBQUNOZCxXQUFPLEVBQUUsVUFESDtBQUVOM0YsU0FBSyxFQUFFO0FBRkQ7QUFuQmEsQ0FBdkI7QUF3QkFtSSxLQUFLLENBQUMzRixTQUFOLENBQWdCc1EsV0FBaEIsR0FBOEIzSyxLQUFLLENBQUMzRixTQUFOLENBQWdCcVEsSUFBOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTFLLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0J1USxJQUFoQixHQUF1QjVLLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JLLE1BQWhCLENBQXVCLEtBQXZCLEVBQThCO0FBQ25ELGFBQVcsQ0FBQyxrQkFBRCxFQUFxQjtBQUM5QjhDLFdBQU8sRUFBRSxpQkFEcUI7QUFFOUJFLGNBQVUsRUFBRTtBQUZrQixHQUFyQixDQUR3QztBQUtuRCxZQUFVO0FBQ1JGLFdBQU8sRUFBRSx5RUFERDtBQUVSM0MsVUFBTSxFQUFFO0FBQ04scUJBQWU7QUFEVDtBQUZBLEdBTHlDO0FBV25EO0FBQ0EsY0FBWTtBQUNWMkMsV0FBTyxFQUFFLHlHQURDO0FBRVYzQyxVQUFNLEVBQUU7QUFDTjtBQUNBLGtCQUFZO0FBRk47QUFGRSxHQVp1QztBQW1CbkQsY0FBWSx5Q0FuQnVDO0FBb0JuRCxjQUFZO0FBcEJ1QyxDQUE5QixDQUF2QjtBQXNCQW1GLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLE1BQTdCLEVBQXFDLFVBQXJDLEVBQWlEO0FBQy9DLGNBQVksQ0FBQztBQUNiO0FBQ0U0QyxXQUFPLEVBQUUsYUFEWDtBQUVFM0MsVUFBTSxFQUFFO0FBQ04scUJBQWU7QUFEVDtBQUZWLEdBRFksRUFNVDtBQUNILGFBUFksQ0FEbUM7QUFTL0MsaUJBQWU7QUFDYjJDLFdBQU8sRUFBRSxxQ0FESTtBQUViRSxjQUFVLEVBQUUsSUFGQztBQUdiN0YsU0FBSyxFQUFFO0FBSE07QUFUZ0MsQ0FBakQ7QUFlQTs7QUFFQW1JLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0J3USxRQUFoQixHQUEyQjtBQUN6QixhQUFXO0FBQ1RyTixXQUFPLEVBQUUsNENBREE7QUFFVEUsY0FBVSxFQUFFO0FBRkgsR0FEYztBQUt6QixZQUFVO0FBQ1JGLFdBQU8sRUFBRSxnREFERDtBQUVSYyxVQUFNLEVBQUU7QUFGQSxHQUxlO0FBU3pCLG9CQUFrQjtBQUNoQmQsV0FBTyxFQUFFLCtCQURPO0FBRWhCM0YsU0FBSyxFQUFFO0FBRlMsR0FUTztBQWF6QixZQUFVO0FBQ1IyRixXQUFPLEVBQUUsNkNBREQ7QUFFUjNGLFNBQUssRUFBRSxRQUZDO0FBR1JnRCxVQUFNLEVBQUU7QUFDTixrQkFBWTtBQUROO0FBSEEsR0FiZTtBQW9CekIsY0FBWSx1REFwQmE7QUFxQnpCO0FBQ0EsYUFBVyw0SEF0QmM7QUF1QnpCLGNBQVk7QUFDVjJDLFdBQU8sRUFBRSx1UUFEQztBQUVWRSxjQUFVLEVBQUU7QUFGRixHQXZCYTtBQTJCekIsY0FBWSxzQkEzQmE7QUE0QnpCLGlCQUFlO0FBNUJVLENBQTNCO0FBOEJBOztBQUVBc0MsS0FBSyxDQUFDM0YsU0FBTixDQUFnQnlRLFVBQWhCLEdBQTZCOUssS0FBSyxDQUFDM0YsU0FBTixDQUFnQkssTUFBaEIsQ0FBdUIsR0FBdkIsRUFBNEI7QUFDdkQsWUFBVTtBQUNSOEMsV0FBTyxFQUFFLHVDQUREO0FBRVJjLFVBQU0sRUFBRTtBQUZBLEdBRDZDO0FBS3ZELGFBQVcsdVlBTDRDO0FBTXZELGNBQVk7QUFOMkMsQ0FBNUIsQ0FBN0I7QUFRQSxPQUFPMEIsS0FBSyxDQUFDM0YsU0FBTixDQUFnQnlRLFVBQWhCLENBQTJCLFlBQTNCLENBQVA7QUFDQTlLLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0IwUSxJQUFoQixHQUF1Qi9LLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0J5USxVQUF2QztBQUNBO0FBQ0E7O0FBRUE5SyxLQUFLLENBQUMzRixTQUFOLENBQWdCMlEsS0FBaEIsR0FBd0I7QUFDdEIsYUFBVztBQUNUeE4sV0FBTyxFQUFFLGtCQURBO0FBRVRjLFVBQU0sRUFBRTtBQUZDLEdBRFc7QUFLdEIsVUFBUTtBQUNOZCxXQUFPLEVBQUUsOENBREg7QUFFTmMsVUFBTSxFQUFFO0FBRkYsR0FMYztBQVN0QixZQUFVLENBQUM7QUFDVGQsV0FBTyxFQUFFLHFDQURBO0FBRVRjLFVBQU0sRUFBRTtBQUZDLEdBQUQsRUFHUDtBQUNEZCxXQUFPLEVBQUUsNkJBRFI7QUFFRGMsVUFBTSxFQUFFO0FBRlAsR0FITyxDQVRZO0FBZ0J0QixZQUFVLENBQUM7QUFDWCx3Q0FEVSxFQUM4QjtBQUN4QyxxRUFGVSxFQUUyRDtBQUNyRSxxREFIVSxDQWhCWTtBQW9CdEIsZUFBYTtBQUNYZCxXQUFPLEVBQUUsUUFERTtBQUVYM0YsU0FBSyxFQUFFO0FBRkksR0FwQlM7QUF3QnRCLFdBQVM7QUFDUDJGLFdBQU8sRUFBRSxRQURGO0FBRVAzRixTQUFLLEVBQUU7QUFGQSxHQXhCYTtBQTRCdEIsbUJBQWlCO0FBQ2YyRixXQUFPLEVBQUUsUUFETTtBQUVmM0YsU0FBSyxFQUFFO0FBRlEsR0E1Qks7QUFnQ3RCLGFBQVc7QUFDVDJGLFdBQU8sRUFBRSxNQURBO0FBRVQzRixTQUFLLEVBQUU7QUFGRSxHQWhDVztBQW9DdEI7QUFDQTtBQUNBLGFBQVcsK1JBdENXO0FBdUN0QixhQUFXLG9CQXZDVztBQXdDdEIsK0JBQTZCO0FBQzNCMkYsV0FBTyxFQUFFLHdCQURrQjtBQUUzQjNGLFNBQUssRUFBRTtBQUZvQixHQXhDUDtBQTRDdEI7QUFDQSxjQUFZLHVHQTdDVTtBQThDdEIsaUJBQWU7QUE5Q08sQ0FBeEI7QUFnREE7O0FBRUFtSSxLQUFLLENBQUMzRixTQUFOLENBQWdCNFEsTUFBaEIsR0FBeUI7QUFDdkIsYUFBVztBQUNUek4sV0FBTyxFQUFFLGNBREE7QUFFVEUsY0FBVSxFQUFFLElBRkg7QUFHVFksVUFBTSxFQUFFO0FBSEMsR0FEWTtBQU12QiwwQkFBd0I7QUFDdEJkLFdBQU8sRUFBRSxxRUFEYTtBQUV0QmMsVUFBTSxFQUFFLElBRmM7QUFHdEJ6RCxVQUFNLEVBQUU7QUFDTix1QkFBaUI7QUFDZjtBQUNBMkMsZUFBTyxFQUFFLHFGQUZNO0FBR2ZFLGtCQUFVLEVBQUUsSUFIRztBQUlmN0MsY0FBTSxFQUFFO0FBQ04seUJBQWU7QUFDYjJDLG1CQUFPLEVBQUUscUJBREk7QUFFYkUsc0JBQVUsRUFBRTtBQUZDLFdBRFQ7QUFLTiwrQkFBcUI7QUFDbkJGLG1CQUFPLEVBQUUsaUJBRFU7QUFFbkIzRixpQkFBSyxFQUFFO0FBRlksV0FMZjtBQVNOcUUsY0FBSSxFQUFFO0FBVEE7QUFKTyxPQURYO0FBaUJOLGdCQUFVO0FBakJKO0FBSGMsR0FORDtBQTZCdkIsMEJBQXdCO0FBQ3RCc0IsV0FBTyxFQUFFLHNDQURhO0FBRXRCYyxVQUFNLEVBQUUsSUFGYztBQUd0QnpHLFNBQUssRUFBRTtBQUhlLEdBN0JEO0FBa0N2QixZQUFVO0FBQ1IyRixXQUFPLEVBQUUsa0RBREQ7QUFFUmMsVUFBTSxFQUFFO0FBRkEsR0FsQ2E7QUFzQ3ZCLGNBQVk7QUFDVmQsV0FBTyxFQUFFLDJDQURDO0FBRVZFLGNBQVUsRUFBRTtBQUZGLEdBdENXO0FBMEN2QixnQkFBYztBQUNaRixXQUFPLEVBQUUsa0JBREc7QUFFWkUsY0FBVSxFQUFFO0FBRkEsR0ExQ1M7QUE4Q3ZCLGVBQWE7QUFDWEYsV0FBTyxFQUFFLDBCQURFO0FBRVhFLGNBQVUsRUFBRSxJQUZEO0FBR1g3RixTQUFLLEVBQUUsQ0FBQyxZQUFELEVBQWUsYUFBZixDQUhJO0FBSVhnRCxVQUFNLEVBQUU7QUFDTixxQkFBZTtBQURUO0FBSkcsR0E5Q1U7QUFzRHZCLGFBQVcsdU5BdERZO0FBdUR2QixhQUFXLHFoQkF2RFk7QUF3RHZCLGFBQVcseUJBeERZO0FBeUR2QixZQUFVLGtKQXpEYTtBQTBEdkIsY0FBWSxzREExRFc7QUEyRHZCLGlCQUFlO0FBM0RRLENBQXpCO0FBNkRBbUYsS0FBSyxDQUFDM0YsU0FBTixDQUFnQjRRLE1BQWhCLENBQXVCLHNCQUF2QixFQUErQ3BRLE1BQS9DLENBQXNELGVBQXRELEVBQXVFQSxNQUF2RSxDQUE4RXFCLElBQTlFLEdBQXFGOEQsS0FBSyxDQUFDM0YsU0FBTixDQUFnQjRRLE1BQXJHO0FBQ0FqTCxLQUFLLENBQUMzRixTQUFOLENBQWdCNlEsRUFBaEIsR0FBcUJsTCxLQUFLLENBQUMzRixTQUFOLENBQWdCNFEsTUFBckM7QUFDQTs7QUFFQWpMLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0I4USxNQUFoQixHQUF5Qm5MLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JLLE1BQWhCLENBQXVCLE9BQXZCLEVBQWdDO0FBQ3ZELFlBQVU7QUFDUjhDLFdBQU8sRUFBRSxxQ0FERDtBQUVSYyxVQUFNLEVBQUU7QUFGQSxHQUQ2QztBQUt2RDtBQUNBLGdCQUFjLFlBTnlDO0FBT3ZELGFBQVcsMlJBUDRDO0FBUXZELGNBQVk7QUFSMkMsQ0FBaEMsQ0FBekI7QUFVQTBCLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLFFBQTdCLEVBQXVDLFlBQXZDLEVBQXFEO0FBQ25ELFVBQVE7QUFDTjRDLFdBQU8sRUFBRSwrREFESDtBQUVOYyxVQUFNLEVBQUU7QUFGRixHQUQyQztBQUtuRDtBQUNBLGlCQUFlLHVCQU5vQztBQU9uRCxXQUFTO0FBQ1BkLFdBQU8sRUFBRSxrQkFERjtBQUVQM0YsU0FBSyxFQUFFO0FBRkE7QUFQMEMsQ0FBckQsRSxDQVdJOztBQUVKLE9BQU9tSSxLQUFLLENBQUMzRixTQUFOLENBQWdCOFEsTUFBaEIsWUFBUDtBQUNBOztBQUVBLENBQUMsVUFBVWpVLEtBQVYsRUFBaUI7QUFDaEJBLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0IrUSxJQUFoQixHQUF1QmxVLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0JLLE1BQWhCLENBQXVCLEtBQXZCLEVBQThCO0FBQ25EO0FBQ0EsZUFBVztBQUNUOEMsYUFBTyxFQUFFLCtDQURBO0FBRVRFLGdCQUFVLEVBQUUsSUFGSDtBQUdUWSxZQUFNLEVBQUU7QUFIQztBQUZ3QyxHQUE5QixDQUF2QjtBQVFBcEgsT0FBSyxDQUFDbUQsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsTUFBN0IsRUFBcUMsUUFBckMsRUFBK0M7QUFDN0M7QUFDQSxtQkFBZTtBQUNiO0FBQ0E0QyxhQUFPLEVBQUUscUJBRkk7QUFHYmMsWUFBTSxFQUFFLElBSEs7QUFJYnpELFlBQU0sRUFBRTtBQUNOLGtCQUFVO0FBREo7QUFKSztBQUY4QixHQUEvQztBQVdBLFNBQU8zRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCK1EsSUFBaEIsQ0FBcUJDLE1BQTVCO0FBQ0EsTUFBSWxLLFFBQVEsR0FBRyx3QkFBZjtBQUNBLE1BQUltSyxRQUFRLEdBQUcsQ0FBQywwQ0FBRCxFQUE2QztBQUMxRDlOLFdBQU8sRUFBRSxhQURpRDtBQUUxREUsY0FBVSxFQUFFO0FBRjhDLEdBQTdDLENBQWY7QUFJQXhHLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLE1BQTdCLEVBQXFDLFVBQXJDLEVBQWlEO0FBQy9DO0FBQ0EscUJBQWlCO0FBQ2Y0QyxhQUFPLEVBQUUsY0FETTtBQUVmYyxZQUFNLEVBQUUsSUFGTztBQUdmekQsWUFBTSxFQUFFO0FBQ04sdUJBQWUsR0FEVDtBQUVOLG9CQUFZc0csUUFGTjtBQUdOLG9CQUFZbUs7QUFITjtBQUhPLEtBRjhCO0FBVy9DO0FBQ0EscUJBQWlCO0FBQ2Y5TixhQUFPLEVBQUUsb0NBRE07QUFFZmMsWUFBTSxFQUFFLElBRk87QUFHZnpELFlBQU0sRUFBRTtBQUNOLG9CQUFZLENBQUMsaUJBQUQsRUFBb0I7QUFDOUIyQyxpQkFBTyxFQUFFLFlBRHFCO0FBRTlCRSxvQkFBVSxFQUFFO0FBRmtCLFNBQXBCLENBRE47QUFLTix1QkFBZSxHQUxUO0FBTU4sb0JBQVl5RCxRQU5OO0FBT04sb0JBQVltSyxRQVBOO0FBUU4scUJBQWFwVSxLQUFLLENBQUNtRCxTQUFOLENBQWdCK1EsSUFBaEIsQ0FBcUJHO0FBUjVCO0FBSE87QUFaOEIsR0FBakQ7QUEyQkEsU0FBT3JVLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0IrUSxJQUFoQixDQUFxQjVQLFFBQTVCO0FBQ0EsU0FBT3RFLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0IrUSxJQUFoQixDQUFxQkcsU0FBNUIsQ0F0RGdCLENBc0R1QjtBQUN2Qzs7QUFFQXJVLE9BQUssQ0FBQ21ELFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLE1BQTdCLEVBQXFDLGFBQXJDLEVBQW9EO0FBQ2xELGdCQUFZO0FBQ1Y0QyxhQUFPLEVBQUUsd0hBREM7QUFFVkUsZ0JBQVUsRUFBRSxJQUZGO0FBR1ZZLFlBQU0sRUFBRTtBQUhFO0FBRHNDLEdBQXBEO0FBT0QsQ0FoRUQsRUFnRUcwQixLQWhFSDtBQWlFQTs7O0FBR0FBLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JtUixJQUFoQixHQUF1QnhMLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JLLE1BQWhCLENBQXVCLEtBQXZCLEVBQThCO0FBQ25ELGFBQVc7QUFDVDhDLFdBQU8sRUFBRSxzQ0FEQTtBQUVURSxjQUFVLEVBQUU7QUFGSCxHQUR3QztBQUtuRCxZQUFVO0FBQ1JGLFdBQU8sRUFBRSxxREFERDtBQUVSM0MsVUFBTSxFQUFFO0FBQ04sY0FBUSxTQURGLENBQ1k7O0FBRFo7QUFGQSxHQUx5QztBQVluRDtBQUNBLFNBQU8seUJBYjRDO0FBY25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBWTtBQUNWO0FBQ0EyQyxXQUFPLEVBQUUsZ0dBRkM7QUFHVjNDLFVBQU0sRUFBRTtBQUNOLGdCQUFVO0FBQ1IyQyxlQUFPLEVBQUUsR0FERDtBQUVSM0YsYUFBSyxFQUFFO0FBRkMsT0FESjtBQUtOLHFCQUFlLFNBTFQ7QUFNTixrQkFBWTtBQU5OO0FBSEUsR0FyQnVDO0FBaUNuRCxjQUFZO0FBQ1YyRixXQUFPLEVBQUUsMENBREM7QUFFVjNDLFVBQU0sRUFBRTtBQUNOLGtCQUFZO0FBRE47QUFGRTtBQWpDdUMsQ0FBOUIsQ0FBdkI7QUF3Q0FtRixLQUFLLENBQUMzRixTQUFOLENBQWdCTyxZQUFoQixDQUE2QixNQUE3QixFQUFxQyxRQUFyQyxFQUErQztBQUM3QyxhQUFXLENBQUMsbUhBQUQsRUFBc0g7QUFDL0g0QyxXQUFPLEVBQUUsMEJBRHNIO0FBRS9IRSxjQUFVLEVBQUU7QUFGbUgsR0FBdEg7QUFEa0MsQ0FBL0M7QUFNQXNDLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JPLFlBQWhCLENBQTZCLE1BQTdCLEVBQXFDLFdBQXJDLEVBQWtEO0FBQ2hEO0FBQ0EsY0FBWTtBQUZvQyxDQUFsRDtBQUlBb0YsS0FBSyxDQUFDM0YsU0FBTixDQUFnQk8sWUFBaEIsQ0FBNkIsTUFBN0IsRUFBcUMsVUFBckMsRUFBaUQ7QUFDL0MscUJBQW1CO0FBQ2pCNEMsV0FBTyxFQUFFLDRCQURRO0FBRWpCM0YsU0FBSyxFQUFFO0FBRlUsR0FENEI7QUFLL0MsaUJBQWU7QUFDYjJGLFdBQU8sRUFBRSxTQURJO0FBRWIzRixTQUFLLEVBQUU7QUFGTSxHQUxnQztBQVMvQyxlQUFhO0FBQ1gyRixXQUFPLEVBQUUsNEJBREU7QUFFWDNGLFNBQUssRUFBRTtBQUZJLEdBVGtDO0FBYS9DLGFBQVcsb0JBYm9DO0FBYy9DLFVBQVE7QUFDTjJGLFdBQU8sRUFBRSxVQURIO0FBRU4zRixTQUFLLEVBQUU7QUFGRCxHQWR1QztBQWtCL0MsY0FBWTtBQUNWMkYsV0FBTyxFQUFFLGlEQURDO0FBRVZFLGNBQVUsRUFBRTtBQUZGO0FBbEJtQyxDQUFqRDtBQXVCQXNDLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0JtUixJQUFoQixDQUFxQixRQUFyQixFQUErQjNRLE1BQS9CLENBQXNDcUIsSUFBdEMsR0FBNkM4RCxLQUFLLENBQUMzRixTQUFOLENBQWdCbVIsSUFBN0Q7QUFDQTs7QUFFQSxDQUFDLFVBQVV0VSxLQUFWLEVBQWlCO0FBQ2hCLE1BQUk4SyxJQUFJLEdBQUc7QUFDVHhFLFdBQU8sRUFBRSxxQkFEQTtBQUVURSxjQUFVLEVBQUU7QUFGSCxHQUFYLENBRGdCLENBSWI7O0FBRUgsTUFBSXVFLE1BQU0sR0FBRztBQUNYekUsV0FBTyxFQUFFLHNDQURFO0FBRVhFLGNBQVUsRUFBRTtBQUZELEdBQWI7QUFJQSxNQUFJN0MsTUFBTSxHQUFHO0FBQ1gsZUFBVztBQUNUMkMsYUFBTyxFQUFFLHNDQURBO0FBRVRFLGdCQUFVLEVBQUU7QUFGSCxLQURBO0FBS1gsV0FBTztBQUNMRixhQUFPLEVBQUUsd0JBREo7QUFFTGMsWUFBTSxFQUFFO0FBRkgsS0FMSTtBQVNYLGNBQVU7QUFDUmQsYUFBTyxFQUFFLCtDQUREO0FBRVJjLFlBQU0sRUFBRTtBQUZBLEtBVEM7QUFhWCxxQkFBaUIsSUFiTjtBQWNYO0FBQ0EsWUFBUSxJQWZHO0FBZ0JYO0FBQ0EsaUJBQWEsOEJBakJGO0FBa0JYLGVBQVc7QUFDVGQsYUFBTyxFQUFFLDBEQURBO0FBRVRFLGdCQUFVLEVBQUU7QUFGSCxLQWxCQTtBQXNCWCxlQUFXLGdCQXRCQTtBQXVCWCxhQUFTLENBQUMsbzVDQUFELEVBQXU1QztBQUM5NUNGLGFBQU8sRUFBRSwySkFEcTVDO0FBRTk1QzNDLFlBQU0sRUFBRTtBQUNOLGdCQUFRbUgsSUFERjtBQUVOLGtCQUFVQyxNQUZKO0FBR04sb0JBQVksY0FITjtBQUlOLHVCQUFlO0FBSlQ7QUFGczVDLEtBQXY1QyxDQXZCRTtBQWdDWCxjQUFVLGlCQWhDQztBQWlDWCxZQUFRRCxJQWpDRztBQWtDWCxlQUFXLG9CQWxDQTtBQW1DWCxnQkFBWSxDQUFDO0FBQ2I7QUFDQSwwR0FGWSxDQW5DRDtBQXNDWCxjQUFVQyxNQXRDQztBQXVDWCxtQkFBZTtBQXZDSixHQUFiO0FBeUNBcEgsUUFBTSxDQUFDLGVBQUQsQ0FBTixHQUEwQjtBQUN4QjJDLFdBQU8sRUFBRSxnQkFEZTtBQUV4QjNGLFNBQUssRUFBRSxVQUZpQjtBQUd4QmdELFVBQU0sRUFBRTtBQUNOLG1CQUFhO0FBQ1gyQyxlQUFPLEVBQUUsU0FERTtBQUVYM0YsYUFBSyxFQUFFO0FBRkksT0FEUDtBQUtOcUUsVUFBSSxFQUFFckI7QUFMQTtBQUhnQixHQUExQjtBQVdBQSxRQUFNLENBQUMsTUFBRCxDQUFOLEdBQWlCO0FBQ2YyQyxXQUFPLEVBQUUsbUJBRE07QUFFZjNDLFVBQU0sRUFBRTtBQUNOLGtCQUFZLFFBRE47QUFFTnFCLFVBQUksRUFBRXJCO0FBRkE7QUFGTyxHQUFqQjtBQU9BM0QsT0FBSyxDQUFDbUQsU0FBTixDQUFnQm9SLE1BQWhCLEdBQXlCO0FBQ3ZCLDBCQUFzQjtBQUNwQmpPLGFBQU8sRUFBRSxlQURXO0FBRXBCRSxnQkFBVSxFQUFFLElBRlE7QUFHcEI3QyxZQUFNLEVBQUU7QUFDTixrQkFBVSxVQURKO0FBRU5xQixZQUFJLEVBQUVyQjtBQUZBO0FBSFksS0FEQztBQVN2Qiw0QkFBd0I7QUFDdEIyQyxhQUFPLEVBQUUsb0RBRGE7QUFFdEJFLGdCQUFVLEVBQUUsSUFGVTtBQUd0QjdDLFlBQU0sRUFBRTtBQUNOLG9CQUFZLE1BRE47QUFFTnFCLFlBQUksRUFBRXJCO0FBRkE7QUFIYyxLQVREO0FBaUJ2QixpQkFBYTtBQUNYMkMsYUFBTyxFQUFFLGdEQURFO0FBRVhFLGdCQUFVLEVBQUUsSUFGRDtBQUdYN0MsWUFBTSxFQUFFO0FBQ04sbUJBQVcsTUFETDtBQUVOcUIsWUFBSSxFQUFFckI7QUFGQTtBQUhHLEtBakJVO0FBeUJ2QjtBQUNBO0FBQ0EsNEJBQXdCO0FBQ3RCMkMsYUFBTyxFQUFFLDRIQURhO0FBRXRCRSxnQkFBVSxFQUFFLElBRlU7QUFHdEI3QyxZQUFNLEVBQUU7QUFDTixvQkFBWTtBQUNWMkMsaUJBQU8sRUFBRSxVQURDO0FBRVYzQyxnQkFBTSxFQUFFO0FBQ04sNkJBQWlCQSxNQUFNLENBQUN5SDtBQURsQjtBQUZFLFNBRE47QUFPTnBHLFlBQUksRUFBRXJCO0FBUEE7QUFIYyxLQTNCRDtBQXdDdkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQVk7QUFDVjJDLGFBQU8sRUFBRSx1T0FEQztBQUVWRSxnQkFBVSxFQUFFLElBRkY7QUFHVjdDLFlBQU0sRUFBRTtBQUNOLHlCQUFpQkEsTUFBTSxDQUFDeUgsYUFEbEI7QUFFTixtQkFBV3pILE1BQU0sQ0FBQ3dILE9BRlo7QUFHTix1QkFBZTtBQUhUO0FBSEUsS0EzQ1c7QUFvRHZCLFlBQVF4SCxNQUFNLENBQUM2USxJQXBEUTtBQXFEdkIsY0FBVTdRLE1BQU0sQ0FBQzhHLE1BckRNO0FBc0R2QixlQUFXO0FBQ1RuRSxhQUFPLEVBQUUsc0NBREE7QUFFVEUsZ0JBQVUsRUFBRSxJQUZIO0FBR1RZLFlBQU0sRUFBRTtBQUhDLEtBdERZO0FBMkR2QixxQkFBaUJ6RCxNQUFNLENBQUN5SCxhQTNERDtBQTREdkIsbUJBQWU7QUE1RFEsR0FBekI7QUE4REQsQ0FuSUQsRUFtSUd0QyxLQW5JSDtBQW9JQTs7O0FBR0EsQ0FBQyxVQUFVOUksS0FBVixFQUFpQjtBQUNoQixNQUFJeVIsVUFBVSxHQUFHelIsS0FBSyxDQUFDSyxJQUFOLENBQVdxQixLQUFYLENBQWlCMUIsS0FBSyxDQUFDbUQsU0FBTixDQUFnQnNPLFVBQWpDLENBQWpCO0FBQ0F6UixPQUFLLENBQUNtRCxTQUFOLENBQWdCc1IsR0FBaEIsR0FBc0J6VSxLQUFLLENBQUNtRCxTQUFOLENBQWdCSyxNQUFoQixDQUF1QixLQUF2QixFQUE4QmlPLFVBQTlCLENBQXRCLENBRmdCLENBRWlEOztBQUVqRSxTQUFPelIsS0FBSyxDQUFDbUQsU0FBTixDQUFnQnNSLEdBQWhCLENBQW9CLFdBQXBCLENBQVA7QUFDQSxTQUFPelUsS0FBSyxDQUFDbUQsU0FBTixDQUFnQnNSLEdBQWhCLENBQW9CLGtCQUFwQixDQUFQLENBTGdCLENBS2dDO0FBQ2hEO0FBQ0E7O0FBRUEsTUFBSTFPLEdBQUcsR0FBRy9GLEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0JzUixHQUFoQixDQUFvQjFPLEdBQTlCO0FBQ0FBLEtBQUcsQ0FBQ08sT0FBSixHQUFjMUQsTUFBTSxDQUFDLHFCQUFxQjJFLE1BQXJCLEdBQThCLEtBQTlCLEdBQXNDeEIsR0FBRyxDQUFDTyxPQUFKLENBQVlpQixNQUFsRCxHQUEyRCxHQUE1RCxFQUFpRXhCLEdBQUcsQ0FBQ08sT0FBSixDQUFZZ0IsS0FBN0UsQ0FBcEI7QUFDQXZCLEtBQUcsQ0FBQ1MsVUFBSixHQUFpQixJQUFqQjtBQUNELENBWkQsRUFZR3NDLEtBWkg7QUFhQTs7O0FBR0FBLEtBQUssQ0FBQzNGLFNBQU4sQ0FBZ0J1UixJQUFoQixHQUF1QjtBQUNyQixhQUFXLENBQUMsZ0JBQUQsRUFBbUI7QUFDNUJwTyxXQUFPLEVBQUUsTUFEbUI7QUFFNUJjLFVBQU0sRUFBRTtBQUZvQixHQUFuQixDQURVO0FBS3JCLFlBQVU7QUFDUmQsV0FBTyxFQUFFLHdCQUREO0FBRVJjLFVBQU0sRUFBRTtBQUZBLEdBTFc7QUFTckIsYUFBVyxDQUFDO0FBQ1ZkLFdBQU8sRUFBRSxxQkFEQztBQUVWM0MsVUFBTSxFQUFFO0FBQ04sa0JBQVk7QUFETjtBQUZFLEdBQUQsRUFLUjtBQUNEMkMsV0FBTyxFQUFFLGdiQURSO0FBRUQzQyxVQUFNLEVBQUU7QUFDTixxQkFBZTtBQURUO0FBRlAsR0FMUSxFQVVSLDBRQVZRLENBVFU7QUFvQnJCLGNBQVksaUNBcEJTO0FBcUJyQixZQUFVLGlOQXJCVztBQXNCckIsaUJBQWU7QUF0Qk0sQ0FBdkI7QUF5QmVtRixvRUFBZixFOztBQ2ppSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJNkwsS0FBSyxHQUFHO0FBQ1Z2UixPQUFLLEVBQUU7QUFDTHdSLG1CQUFlLEVBQUUsU0FEWjtBQUVMQyxTQUFLLEVBQUU7QUFGRixHQURHO0FBS1ZDLFFBQU0sRUFBRSxDQUFDO0FBQ1B4RyxTQUFLLEVBQUUsQ0FBQyxTQUFELEVBQVksUUFBWixFQUFzQixTQUF0QixFQUFpQyxPQUFqQyxFQUEwQyxhQUExQyxDQURBO0FBRVB5RyxTQUFLLEVBQUU7QUFDTEYsV0FBSyxFQUFFO0FBREY7QUFGQSxHQUFELEVBS0w7QUFDRHZHLFNBQUssRUFBRSxDQUFDLFdBQUQsQ0FETjtBQUVEeUcsU0FBSyxFQUFFO0FBQ0xDLGFBQU8sRUFBRTtBQURKO0FBRk4sR0FMSyxFQVVMO0FBQ0QxRyxTQUFLLEVBQUUsQ0FBQyxLQUFELEVBQVEsVUFBUixFQUFvQixRQUFwQixDQUROO0FBRUR5RyxTQUFLLEVBQUU7QUFDTEYsV0FBSyxFQUFFO0FBREY7QUFGTixHQVZLLEVBZUw7QUFDRHZHLFNBQUssRUFBRSxDQUFDLFVBQUQsRUFBYSxVQUFiLENBRE47QUFFRHlHLFNBQUssRUFBRTtBQUNMRixXQUFLLEVBQUU7QUFERjtBQUZOLEdBZkssRUFvQkw7QUFDRHZHLFNBQUssRUFBRSxDQUFDLFFBQUQsRUFBVyxVQUFYLEVBQXVCLFdBQXZCLENBRE47QUFFRHlHLFNBQUssRUFBRTtBQUNMRixXQUFLLEVBQUU7QUFERjtBQUZOLEdBcEJLLEVBeUJMO0FBQ0R2RyxTQUFLLEVBQUUsQ0FBQyxXQUFELENBRE47QUFFRHlHLFNBQUssRUFBRTtBQUNMRixXQUFLLEVBQUU7QUFERjtBQUZOLEdBekJLLEVBOEJMO0FBQ0R2RyxTQUFLLEVBQUUsQ0FBQyxTQUFELEVBQVksUUFBWixFQUFzQixRQUF0QixFQUFnQyxLQUFoQyxFQUF1QyxZQUF2QyxFQUFxRCxTQUFyRCxFQUFnRSxTQUFoRSxFQUEyRSxXQUEzRSxFQUF3RixNQUF4RixFQUFnRyxXQUFoRyxFQUE2RyxPQUE3RyxFQUFzSCxTQUF0SCxFQUFpSSxhQUFqSSxFQUFnSixVQUFoSixDQUROO0FBRUR5RyxTQUFLLEVBQUU7QUFDTEYsV0FBSyxFQUFFO0FBREY7QUFGTixHQTlCSyxFQW1DTDtBQUNEdkcsU0FBSyxFQUFFLENBQUMsU0FBRCxDQUROO0FBRUR5RyxTQUFLLEVBQUU7QUFDTEUsd0JBQWtCLEVBQUU7QUFEZjtBQUZOLEdBbkNLLEVBd0NMO0FBQ0QzRyxTQUFLLEVBQUUsQ0FBQyxVQUFELENBRE47QUFFRHlHLFNBQUssRUFBRTtBQUNMRSx3QkFBa0IsRUFBRTtBQURmO0FBRk4sR0F4Q0ssRUE2Q0w7QUFDRDNHLFNBQUssRUFBRSxDQUFDLFFBQUQsQ0FETjtBQUVEeUcsU0FBSyxFQUFFO0FBQ0xHLGVBQVMsRUFBRTtBQUROO0FBRk4sR0E3Q0ssRUFrREw7QUFDRDVHLFNBQUssRUFBRSxDQUFDLFdBQUQsRUFBYyxNQUFkLENBRE47QUFFRHlHLFNBQUssRUFBRTtBQUNMSSxnQkFBVSxFQUFFO0FBRFA7QUFGTixHQWxESyxFQXVETDtBQUNEN0csU0FBSyxFQUFFLENBQUMsV0FBRCxDQUROO0FBRUR5RyxTQUFLLEVBQUU7QUFDTEYsV0FBSyxFQUFFO0FBREY7QUFGTixHQXZESztBQUxFLENBQVo7QUFvRWVGLHFEQUFmLEU7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBSVMsWUFBWSxHQUFHO0FBQ2pCO0FBQ0FwVixPQUFLLEVBQUU4SSwwQkFGVTtBQUdqQjZMLE9BQUssRUFBRUEsV0FBS0E7QUFISyxDQUFuQjs7QUFNQSxTQUFTVSxlQUFULENBQXlCOVQsR0FBekIsRUFBOEJPLEdBQTlCLEVBQW1DTCxLQUFuQyxFQUEwQztBQUN4QyxNQUFJSyxHQUFHLElBQUlQLEdBQVgsRUFBZ0I7QUFDZE4sVUFBTSxDQUFDTyxjQUFQLENBQXNCRCxHQUF0QixFQUEyQk8sR0FBM0IsRUFBZ0M7QUFDOUJMLFdBQUssRUFBRUEsS0FEdUI7QUFFOUI2VCxnQkFBVSxFQUFFLElBRmtCO0FBRzlCQyxrQkFBWSxFQUFFLElBSGdCO0FBSTlCQyxjQUFRLEVBQUU7QUFKb0IsS0FBaEM7QUFNRCxHQVBELE1BT087QUFDTGpVLE9BQUcsQ0FBQ08sR0FBRCxDQUFILEdBQVdMLEtBQVg7QUFDRDs7QUFFRCxTQUFPRixHQUFQO0FBQ0Q7O0FBRUQsU0FBU2tVLFFBQVQsR0FBb0I7QUFDbEJBLFVBQVEsR0FBR3hVLE1BQU0sQ0FBQ3lVLE1BQVAsSUFBaUIsVUFBVUMsTUFBVixFQUFrQjtBQUM1QyxTQUFLLElBQUl6VCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMFQsU0FBUyxDQUFDalEsTUFBOUIsRUFBc0N6RCxDQUFDLEVBQXZDLEVBQTJDO0FBQ3pDLFVBQUlxRixNQUFNLEdBQUdxTyxTQUFTLENBQUMxVCxDQUFELENBQXRCOztBQUVBLFdBQUssSUFBSUosR0FBVCxJQUFnQnlGLE1BQWhCLEVBQXdCO0FBQ3RCLFlBQUl0RyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJhLGNBQWpCLENBQWdDWCxJQUFoQyxDQUFxQ21HLE1BQXJDLEVBQTZDekYsR0FBN0MsQ0FBSixFQUF1RDtBQUNyRDZULGdCQUFNLENBQUM3VCxHQUFELENBQU4sR0FBY3lGLE1BQU0sQ0FBQ3pGLEdBQUQsQ0FBcEI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBTzZULE1BQVA7QUFDRCxHQVpEOztBQWNBLFNBQU9GLFFBQVEsQ0FBQ3RQLEtBQVQsQ0FBZSxJQUFmLEVBQXFCeVAsU0FBckIsQ0FBUDtBQUNEOztBQUVELElBQUlDLFNBQVMsR0FBRyxZQUFoQixDLENBQThCOztBQUU5QixJQUFJQyxtQkFBbUIsR0FBRyxTQUF0QkEsbUJBQXNCLENBQVVDLElBQVYsRUFBZ0I7QUFDeEMsTUFBSUEsSUFBSSxDQUFDcFEsTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNyQm9RLFFBQUksQ0FBQ3RRLElBQUwsQ0FBVTtBQUNSNkksV0FBSyxFQUFFLENBQUMsT0FBRCxDQURDO0FBRVI1TixhQUFPLEVBQUUsSUFGRDtBQUdSc1YsV0FBSyxFQUFFO0FBSEMsS0FBVjtBQUtELEdBTkQsTUFNTyxJQUFJRCxJQUFJLENBQUNwUSxNQUFMLEtBQWdCLENBQWhCLElBQXFCb1EsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFRclYsT0FBUixLQUFvQixFQUE3QyxFQUFpRDtBQUN0RHFWLFFBQUksQ0FBQyxDQUFELENBQUosQ0FBUXJWLE9BQVIsR0FBa0IsSUFBbEI7QUFDQXFWLFFBQUksQ0FBQyxDQUFELENBQUosQ0FBUUMsS0FBUixHQUFnQixJQUFoQjtBQUNEO0FBQ0YsQ0FYRDs7QUFhQSxJQUFJQyxXQUFXLEdBQUcsU0FBZEEsV0FBYyxDQUFVM0gsS0FBVixFQUFpQnhMLEdBQWpCLEVBQXNCO0FBQ3RDLE1BQUlvVCxTQUFTLEdBQUc1SCxLQUFLLENBQUMzSSxNQUF0Qjs7QUFFQSxNQUFJdVEsU0FBUyxHQUFHLENBQVosSUFBaUI1SCxLQUFLLENBQUM0SCxTQUFTLEdBQUcsQ0FBYixDQUFMLEtBQXlCcFQsR0FBOUMsRUFBbUQ7QUFDakQsV0FBT3dMLEtBQVA7QUFDRDs7QUFFRCxTQUFPQSxLQUFLLENBQUM4QyxNQUFOLENBQWF0TyxHQUFiLENBQVA7QUFDRCxDQVJELEMsQ0FRRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLElBQUlxVCxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQVU1VixNQUFWLEVBQWtCO0FBQ3RDLE1BQUk2VixZQUFZLEdBQUcsQ0FBQyxFQUFELENBQW5CO0FBQ0EsTUFBSUMsYUFBYSxHQUFHLENBQUM5VixNQUFELENBQXBCO0FBQ0EsTUFBSStWLGtCQUFrQixHQUFHLENBQUMsQ0FBRCxDQUF6QjtBQUNBLE1BQUlDLGlCQUFpQixHQUFHLENBQUNoVyxNQUFNLENBQUNvRixNQUFSLENBQXhCO0FBQ0EsTUFBSXpELENBQUMsR0FBRyxDQUFSO0FBQ0EsTUFBSXNVLFVBQVUsR0FBRyxDQUFqQjtBQUNBLE1BQUlDLFdBQVcsR0FBRyxFQUFsQjtBQUNBLE1BQUlDLEdBQUcsR0FBRyxDQUFDRCxXQUFELENBQVY7O0FBRUEsU0FBT0QsVUFBVSxHQUFHLENBQUMsQ0FBckIsRUFBd0I7QUFDdEIsV0FBTyxDQUFDdFUsQ0FBQyxHQUFHb1Usa0JBQWtCLENBQUNFLFVBQUQsQ0FBbEIsRUFBTCxJQUF5Q0QsaUJBQWlCLENBQUNDLFVBQUQsQ0FBakUsRUFBK0U7QUFDN0UsVUFBSTlWLE9BQU8sR0FBRyxLQUFLLENBQW5CO0FBQ0EsVUFBSTROLEtBQUssR0FBRzhILFlBQVksQ0FBQ0ksVUFBRCxDQUF4QjtBQUNBLFVBQUlHLFFBQVEsR0FBR04sYUFBYSxDQUFDRyxVQUFELENBQTVCO0FBQ0EsVUFBSXZTLEtBQUssR0FBRzBTLFFBQVEsQ0FBQ3pVLENBQUQsQ0FBcEIsQ0FKNkUsQ0FJcEQ7O0FBRXpCLFVBQUksT0FBTytCLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0JxSyxhQUFLLEdBQUdrSSxVQUFVLEdBQUcsQ0FBYixHQUFpQmxJLEtBQWpCLEdBQXlCLENBQUMsT0FBRCxDQUFqQztBQUNBNU4sZUFBTyxHQUFHdUQsS0FBVjtBQUNELE9BSEQsTUFHTztBQUNMcUssYUFBSyxHQUFHMkgsV0FBVyxDQUFDM0gsS0FBRCxFQUFRckssS0FBSyxDQUFDeEQsSUFBZCxDQUFuQjs7QUFFQSxZQUFJd0QsS0FBSyxDQUFDdEQsS0FBVixFQUFpQjtBQUNmMk4sZUFBSyxHQUFHMkgsV0FBVyxDQUFDM0gsS0FBRCxFQUFRckssS0FBSyxDQUFDdEQsS0FBZCxDQUFuQjtBQUNEOztBQUVERCxlQUFPLEdBQUd1RCxLQUFLLENBQUN2RCxPQUFoQjtBQUNELE9BakI0RSxDQWlCM0U7OztBQUdGLFVBQUksT0FBT0EsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQjhWLGtCQUFVO0FBQ1ZKLG9CQUFZLENBQUMzUSxJQUFiLENBQWtCNkksS0FBbEI7QUFDQStILHFCQUFhLENBQUM1USxJQUFkLENBQW1CL0UsT0FBbkI7QUFDQTRWLDBCQUFrQixDQUFDN1EsSUFBbkIsQ0FBd0IsQ0FBeEI7QUFDQThRLHlCQUFpQixDQUFDOVEsSUFBbEIsQ0FBdUIvRSxPQUFPLENBQUNpRixNQUEvQjtBQUNBO0FBQ0QsT0EzQjRFLENBMkIzRTs7O0FBR0YsVUFBSWlSLGVBQWUsR0FBR2xXLE9BQU8sQ0FBQ21XLEtBQVIsQ0FBY2hCLFNBQWQsQ0FBdEI7QUFDQSxVQUFJaUIsWUFBWSxHQUFHRixlQUFlLENBQUNqUixNQUFuQztBQUNBOFEsaUJBQVcsQ0FBQ2hSLElBQVosQ0FBaUI7QUFDZjZJLGFBQUssRUFBRUEsS0FEUTtBQUVmNU4sZUFBTyxFQUFFa1csZUFBZSxDQUFDLENBQUQ7QUFGVCxPQUFqQixFQWhDNkUsQ0FtQ3pFOztBQUVKLFdBQUssSUFBSUcsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR0QsWUFBeEIsRUFBc0NDLEdBQUcsRUFBekMsRUFBNkM7QUFDM0NqQiwyQkFBbUIsQ0FBQ1csV0FBRCxDQUFuQjtBQUNBQyxXQUFHLENBQUNqUixJQUFKLENBQVNnUixXQUFXLEdBQUcsRUFBdkI7QUFDQUEsbUJBQVcsQ0FBQ2hSLElBQVosQ0FBaUI7QUFDZjZJLGVBQUssRUFBRUEsS0FEUTtBQUVmNU4saUJBQU8sRUFBRWtXLGVBQWUsQ0FBQ0csR0FBRDtBQUZULFNBQWpCO0FBSUQ7QUFDRixLQTlDcUIsQ0E4Q3BCOzs7QUFHRlAsY0FBVTtBQUNWSixnQkFBWSxDQUFDN0QsR0FBYjtBQUNBOEQsaUJBQWEsQ0FBQzlELEdBQWQ7QUFDQStELHNCQUFrQixDQUFDL0QsR0FBbkI7QUFDQWdFLHFCQUFpQixDQUFDaEUsR0FBbEI7QUFDRDs7QUFFRHVELHFCQUFtQixDQUFDVyxXQUFELENBQW5CO0FBQ0EsU0FBT0MsR0FBUDtBQUNELENBcEVEOztBQXNFQSxJQUFJTSxXQUFXLEdBQUcsU0FBZEEsV0FBYyxDQUFVckMsS0FBVixFQUFpQmhTLFFBQWpCLEVBQTJCO0FBQzNDLE1BQUlTLEtBQUssR0FBR3VSLEtBQUssQ0FBQ3ZSLEtBQWxCLENBRDJDLENBQ2xCOztBQUV6QixNQUFJNlQsSUFBSSxHQUFHaFcsTUFBTSxDQUFDaVcsTUFBUCxDQUFjLElBQWQsQ0FBWDtBQUNBLE1BQUlDLFNBQVMsR0FBR3hDLEtBQUssQ0FBQ0csTUFBTixDQUFhc0MsTUFBYixDQUFvQixVQUFVVixHQUFWLEVBQWVXLFVBQWYsRUFBMkI7QUFDN0QsUUFBSWxVLFNBQVMsR0FBR2tVLFVBQVUsQ0FBQ2xVLFNBQTNCO0FBQ0EsUUFBSTRSLEtBQUssR0FBR3NDLFVBQVUsQ0FBQ3RDLEtBQXZCOztBQUVBLFFBQUk1UixTQUFTLElBQUksQ0FBQ0EsU0FBUyxDQUFDbVUsUUFBVixDQUFtQjNVLFFBQW5CLENBQWxCLEVBQWdEO0FBQzlDLGFBQU8rVCxHQUFQO0FBQ0Q7O0FBRURXLGNBQVUsQ0FBQy9JLEtBQVgsQ0FBaUJ0TSxPQUFqQixDQUF5QixVQUFVdkIsSUFBVixFQUFnQjtBQUN2QztBQUNBLFVBQUk4VyxRQUFRLEdBQUc5QixRQUFRLENBQUMsRUFBRCxFQUFLaUIsR0FBRyxDQUFDalcsSUFBRCxDQUFSLEVBQWdCc1UsS0FBaEIsQ0FBdkI7O0FBRUEyQixTQUFHLENBQUNqVyxJQUFELENBQUgsR0FBWThXLFFBQVo7QUFDRCxLQUxEO0FBTUEsV0FBT2IsR0FBUDtBQUNELEdBZmUsRUFlYk8sSUFmYSxDQUFoQixDQUoyQyxDQW1CakM7O0FBRVZFLFdBQVMsQ0FBQ3JULElBQVYsR0FBaUJWLEtBQWpCLENBckIyQyxDQXFCbkI7O0FBRXhCK1QsV0FBUyxDQUFDL1QsS0FBVixHQUFrQnFTLFFBQVEsQ0FBQyxFQUFELEVBQUtyUyxLQUFMLEVBQVk7QUFDcEN3UixtQkFBZSxFQUFFO0FBRG1CLEdBQVosQ0FBMUI7QUFHQSxTQUFPdUMsU0FBUDtBQUNELENBM0JEOztBQTZCQSxTQUFTSyx1QkFBVCxDQUFpQ2pXLEdBQWpDLEVBQXNDa1csT0FBdEMsRUFBK0M7QUFDN0MsTUFBSTlCLE1BQU0sR0FBRyxFQUFiOztBQUVBLE9BQUssSUFBSTFOLENBQVQsSUFBYzFHLEdBQWQ7QUFBbUIsUUFBSU4sTUFBTSxDQUFDQyxTQUFQLENBQWlCYSxjQUFqQixDQUFnQ1gsSUFBaEMsQ0FBcUNHLEdBQXJDLEVBQTBDMEcsQ0FBMUMsS0FBZ0R3UCxPQUFPLENBQUN0SSxPQUFSLENBQWdCbEgsQ0FBaEIsTUFBdUIsQ0FBQyxDQUE1RSxFQUErRTBOLE1BQU0sQ0FBQzFOLENBQUQsQ0FBTixHQUFZMUcsR0FBRyxDQUFDMEcsQ0FBRCxDQUFmO0FBQWxHOztBQUVBLFNBQU8wTixNQUFQO0FBQ0Q7O0FBRUQsSUFBSStCLFNBQVMsR0FBRyxhQUFhLFVBQVVDLFNBQVYsRUFBcUI7QUFDaEQsV0FBU0QsU0FBVCxHQUFxQjtBQUNuQixRQUFJRSxNQUFNLEdBQUcsSUFBYjtBQUNBLFFBQUl4SCxJQUFJLEdBQUcsRUFBWDtBQUFBLFFBQ0l5SCxHQUFHLEdBQUdqQyxTQUFTLENBQUNqUSxNQURwQjs7QUFHQSxXQUFPa1MsR0FBRyxFQUFWO0FBQWN6SCxVQUFJLENBQUN5SCxHQUFELENBQUosR0FBWWpDLFNBQVMsQ0FBQ2lDLEdBQUQsQ0FBckI7QUFBZDs7QUFFQUYsYUFBUyxDQUFDeFIsS0FBVixDQUFnQixJQUFoQixFQUFzQmlLLElBQXRCOztBQUVBaUYsbUJBQWUsQ0FBQyxJQUFELEVBQU8sY0FBUCxFQUF1QixVQUFVeUMsS0FBVixFQUFpQjtBQUNyRCxVQUFJRixNQUFNLENBQUNULFNBQVAsS0FBcUJ4SCxTQUFyQixJQUFrQ21JLEtBQUssQ0FBQ25ELEtBQU4sS0FBZ0JpRCxNQUFNLENBQUNHLFNBQXpELElBQXNFRCxLQUFLLENBQUNuVixRQUFOLEtBQW1CaVYsTUFBTSxDQUFDSSxZQUFwRyxFQUFrSDtBQUNoSCxlQUFPSixNQUFNLENBQUNULFNBQWQ7QUFDRDs7QUFFRFMsWUFBTSxDQUFDRyxTQUFQLEdBQW1CRCxLQUFLLENBQUNuRCxLQUF6QjtBQUNBaUQsWUFBTSxDQUFDSSxZQUFQLEdBQXNCRixLQUFLLENBQUNuVixRQUE1QjtBQUNBLFVBQUl3VSxTQUFTLEdBQUdXLEtBQUssQ0FBQ25ELEtBQU4sR0FBY3FDLFdBQVcsQ0FBQ2MsS0FBSyxDQUFDbkQsS0FBUCxFQUFjbUQsS0FBSyxDQUFDblYsUUFBcEIsQ0FBekIsR0FBeURnTixTQUF6RTtBQUNBLGFBQU9pSSxNQUFNLENBQUNULFNBQVAsR0FBbUJBLFNBQTFCO0FBQ0QsS0FUYyxDQUFmOztBQVdBOUIsbUJBQWUsQ0FBQyxJQUFELEVBQU8sY0FBUCxFQUF1QixVQUFVNEMsR0FBVixFQUFlO0FBQ25ELFVBQUluVyxHQUFHLEdBQUdtVyxHQUFHLENBQUNuVyxHQUFkO0FBQ0EsVUFBSVMsU0FBUyxHQUFHMFYsR0FBRyxDQUFDMVYsU0FBcEI7QUFDQSxVQUFJd1MsS0FBSyxHQUFHa0QsR0FBRyxDQUFDbEQsS0FBaEI7QUFDQSxVQUFJbUQsTUFBTSxHQUFHVix1QkFBdUIsQ0FBQ1MsR0FBRCxFQUFNLENBQUMsS0FBRCxFQUFRLFdBQVIsRUFBcUIsT0FBckIsRUFBOEIsTUFBOUIsQ0FBTixDQUFwQztBQUNBLFVBQUlqVCxJQUFJLEdBQUdrVCxNQUFYOztBQUVBLFVBQUlDLE1BQU0sR0FBRzFDLFFBQVEsQ0FBQyxFQUFELEVBQUt6USxJQUFMLEVBQVc7QUFDOUJ6QyxpQkFBUyxFQUFFLFlBRG1CO0FBRTlCd1MsYUFBSyxFQUFFcEYsU0FGdUI7QUFHOUI3TixXQUFHLEVBQUU2TjtBQUh5QixPQUFYLENBQXJCOztBQU1BLFVBQUl3SCxTQUFTLEdBQUdTLE1BQU0sQ0FBQ1EsWUFBUCxDQUFvQlIsTUFBTSxDQUFDRSxLQUEzQixDQUFoQjs7QUFFQSxVQUFJWCxTQUFTLEtBQUt4SCxTQUFsQixFQUE2QjtBQUMzQndJLGNBQU0sQ0FBQ3BELEtBQVAsR0FBZW9DLFNBQVMsQ0FBQy9ULEtBQXpCO0FBQ0Q7O0FBRUQsVUFBSTJSLEtBQUssS0FBS3BGLFNBQWQsRUFBeUI7QUFDdkJ3SSxjQUFNLENBQUNwRCxLQUFQLEdBQWVvRCxNQUFNLENBQUNwRCxLQUFQLEtBQWlCcEYsU0FBakIsR0FBNkI4RixRQUFRLENBQUMsRUFBRCxFQUFLMEMsTUFBTSxDQUFDcEQsS0FBWixFQUFtQkEsS0FBbkIsQ0FBckMsR0FBaUVBLEtBQWhGO0FBQ0Q7O0FBRUQsVUFBSWpULEdBQUcsS0FBSzZOLFNBQVosRUFBdUI7QUFDckJ3SSxjQUFNLENBQUNyVyxHQUFQLEdBQWFBLEdBQWI7QUFDRDs7QUFFRCxVQUFJUyxTQUFKLEVBQWU7QUFDYjRWLGNBQU0sQ0FBQzVWLFNBQVAsSUFBb0IsTUFBTUEsU0FBMUI7QUFDRDs7QUFFRCxhQUFPNFYsTUFBUDtBQUNELEtBaENjLENBQWY7O0FBa0NBOUMsbUJBQWUsQ0FBQyxJQUFELEVBQU8sa0JBQVAsRUFBMkIsVUFBVTRDLEdBQVYsRUFBZTtBQUN2RCxVQUFJM0osS0FBSyxHQUFHMkosR0FBRyxDQUFDM0osS0FBaEI7QUFDQSxVQUFJMEgsS0FBSyxHQUFHaUMsR0FBRyxDQUFDakMsS0FBaEI7QUFDQSxVQUFJRSxTQUFTLEdBQUc1SCxLQUFLLENBQUMzSSxNQUF0QjtBQUNBLFVBQUl3UixTQUFTLEdBQUdTLE1BQU0sQ0FBQ1EsWUFBUCxDQUFvQlIsTUFBTSxDQUFDRSxLQUEzQixDQUFoQjs7QUFFQSxVQUFJWCxTQUFTLEtBQUt4SCxTQUFsQixFQUE2QjtBQUMzQixlQUFPQSxTQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUl1RyxTQUFTLEtBQUssQ0FBZCxJQUFtQjVILEtBQUssQ0FBQyxDQUFELENBQUwsS0FBYSxPQUFwQyxFQUE2QztBQUNsRCxlQUFPMEgsS0FBSyxHQUFHO0FBQ2JxQyxpQkFBTyxFQUFFO0FBREksU0FBSCxHQUVSMUksU0FGSjtBQUdELE9BSk0sTUFJQSxJQUFJdUcsU0FBUyxLQUFLLENBQWQsSUFBbUIsQ0FBQ0YsS0FBeEIsRUFBK0I7QUFDcEMsZUFBT21CLFNBQVMsQ0FBQzdJLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBaEI7QUFDRDs7QUFFRCxVQUFJZ0ssU0FBUyxHQUFHdEMsS0FBSyxHQUFHO0FBQ3RCcUMsZUFBTyxFQUFFO0FBRGEsT0FBSCxHQUVqQixFQUZKLENBaEJ1RCxDQWtCL0M7O0FBRVIsVUFBSUUsVUFBVSxHQUFHakssS0FBSyxDQUFDeE4sR0FBTixDQUFVLFVBQVVMLElBQVYsRUFBZ0I7QUFDekMsZUFBTzBXLFNBQVMsQ0FBQzFXLElBQUQsQ0FBaEI7QUFDRCxPQUZnQixDQUFqQjtBQUdBLGFBQU9RLE1BQU0sQ0FBQ3lVLE1BQVAsQ0FBY3ZQLEtBQWQsQ0FBb0JsRixNQUFwQixFQUE0QixDQUFDcVgsU0FBRCxFQUFZbEgsTUFBWixDQUFtQm1ILFVBQW5CLENBQTVCLENBQVA7QUFDRCxLQXhCYyxDQUFmOztBQTBCQWxELG1CQUFlLENBQUMsSUFBRCxFQUFPLGVBQVAsRUFBd0IsVUFBVTRDLEdBQVYsRUFBZTtBQUNwRCxVQUFJblcsR0FBRyxHQUFHbVcsR0FBRyxDQUFDblcsR0FBZDtBQUNBLFVBQUlTLFNBQVMsR0FBRzBWLEdBQUcsQ0FBQzFWLFNBQXBCO0FBQ0EsVUFBSXdTLEtBQUssR0FBR2tELEdBQUcsQ0FBQ2xELEtBQWhCO0FBQ0EsVUFBSTlRLEtBQUssR0FBR2dVLEdBQUcsQ0FBQ2hVLEtBQWhCO0FBQ0EsVUFBSWlVLE1BQU0sR0FBR1YsdUJBQXVCLENBQUNTLEdBQUQsRUFBTSxDQUFDLEtBQUQsRUFBUSxXQUFSLEVBQXFCLE9BQXJCLEVBQThCLE9BQTlCLENBQU4sQ0FBcEM7QUFDQSxVQUFJalQsSUFBSSxHQUFHa1QsTUFBWDs7QUFFQSxVQUFJQyxNQUFNLEdBQUcxQyxRQUFRLENBQUMsRUFBRCxFQUFLelEsSUFBTCxFQUFXO0FBQzlCekMsaUJBQVMsRUFBRSxXQUFXMEIsS0FBSyxDQUFDcUssS0FBTixDQUFZbEksSUFBWixDQUFpQixHQUFqQixDQURRO0FBRTlCb1MsZ0JBQVEsRUFBRXZVLEtBQUssQ0FBQ3ZELE9BRmM7QUFHOUJxVSxhQUFLLEVBQUU2QyxNQUFNLENBQUNhLGdCQUFQLENBQXdCeFUsS0FBeEIsQ0FIdUI7QUFJOUJuQyxXQUFHLEVBQUU2TjtBQUp5QixPQUFYLENBQXJCOztBQU9BLFVBQUlvRixLQUFLLEtBQUtwRixTQUFkLEVBQXlCO0FBQ3ZCd0ksY0FBTSxDQUFDcEQsS0FBUCxHQUFlb0QsTUFBTSxDQUFDcEQsS0FBUCxLQUFpQnBGLFNBQWpCLEdBQTZCOEYsUUFBUSxDQUFDLEVBQUQsRUFBSzBDLE1BQU0sQ0FBQ3BELEtBQVosRUFBbUJBLEtBQW5CLENBQXJDLEdBQWlFQSxLQUFoRjtBQUNEOztBQUVELFVBQUlqVCxHQUFHLEtBQUs2TixTQUFaLEVBQXVCO0FBQ3JCd0ksY0FBTSxDQUFDclcsR0FBUCxHQUFhQSxHQUFiO0FBQ0Q7O0FBRUQsVUFBSVMsU0FBSixFQUFlO0FBQ2I0VixjQUFNLENBQUM1VixTQUFQLElBQW9CLE1BQU1BLFNBQTFCO0FBQ0Q7O0FBRUQsYUFBTzRWLE1BQVA7QUFDRCxLQTVCYyxDQUFmOztBQThCQTlDLG1CQUFlLENBQUMsSUFBRCxFQUFPLFVBQVAsRUFBbUIsVUFBVXJWLEtBQVYsRUFBaUIyRSxJQUFqQixFQUF1QlosT0FBdkIsRUFBZ0NwQixRQUFoQyxFQUEwQztBQUMxRSxVQUFJK0IsR0FBRyxHQUFHO0FBQ1JDLFlBQUksRUFBRUEsSUFERTtBQUVSWixlQUFPLEVBQUVBLE9BRkQ7QUFHUnBCLGdCQUFRLEVBQUVBLFFBSEY7QUFJUnBDLGNBQU0sRUFBRTtBQUpBLE9BQVY7QUFNQVAsV0FBSyxDQUFDNEUsS0FBTixDQUFZQyxHQUFaLENBQWdCLGlCQUFoQixFQUFtQ0gsR0FBbkM7QUFDQSxVQUFJbkUsTUFBTSxHQUFHbUUsR0FBRyxDQUFDbkUsTUFBSixHQUFhUCxLQUFLLENBQUM4RSxRQUFOLENBQWVKLEdBQUcsQ0FBQ0MsSUFBbkIsRUFBeUJELEdBQUcsQ0FBQ1gsT0FBN0IsRUFBc0NXLEdBQUcsQ0FBQy9CLFFBQTFDLENBQTFCO0FBQ0EzQyxXQUFLLENBQUM0RSxLQUFOLENBQVlDLEdBQVosQ0FBZ0IsZ0JBQWhCLEVBQWtDSCxHQUFsQztBQUNBLGFBQU9uRSxNQUFQO0FBQ0QsS0FYYyxDQUFmO0FBWUQ7O0FBRUQsTUFBSW9YLFNBQUosRUFBZUQsU0FBUyxDQUFDZ0IsU0FBVixHQUFzQmYsU0FBdEI7QUFDZkQsV0FBUyxDQUFDeFcsU0FBVixHQUFzQkQsTUFBTSxDQUFDaVcsTUFBUCxDQUFjUyxTQUFTLElBQUlBLFNBQVMsQ0FBQ3pXLFNBQXJDLENBQXRCO0FBQ0F3VyxXQUFTLENBQUN4VyxTQUFWLENBQW9CeVgsV0FBcEIsR0FBa0NqQixTQUFsQzs7QUFFQUEsV0FBUyxDQUFDeFcsU0FBVixDQUFvQjBYLE1BQXBCLEdBQTZCLFNBQVNBLE1BQVQsR0FBa0I7QUFDN0MsUUFBSVgsR0FBRyxHQUFHLEtBQUtILEtBQWY7QUFDQSxRQUFJOVgsS0FBSyxHQUFHaVksR0FBRyxDQUFDalksS0FBaEI7QUFDQSxRQUFJMkMsUUFBUSxHQUFHc1YsR0FBRyxDQUFDdFYsUUFBbkI7QUFDQSxRQUFJZ0MsSUFBSSxHQUFHc1QsR0FBRyxDQUFDdFQsSUFBZjtBQUNBLFFBQUk2VCxRQUFRLEdBQUdQLEdBQUcsQ0FBQ08sUUFBbkI7QUFDQSxRQUFJckIsU0FBUyxHQUFHLEtBQUtpQixZQUFMLENBQWtCLEtBQUtOLEtBQXZCLENBQWhCO0FBQ0EsUUFBSS9ULE9BQU8sR0FBRy9ELEtBQUssQ0FBQ21ELFNBQU4sQ0FBZ0JSLFFBQWhCLENBQWQ7QUFDQSxRQUFJa1csV0FBVyxHQUFHOVUsT0FBTyxLQUFLNEwsU0FBWixHQUF3QixLQUFLN0ssUUFBTCxDQUFjOUUsS0FBZCxFQUFxQjJFLElBQXJCLEVBQTJCWixPQUEzQixFQUFvQ3BCLFFBQXBDLENBQXhCLEdBQXdFLENBQUNnQyxJQUFELENBQTFGO0FBQ0EsUUFBSXBFLE1BQU0sR0FBRzRWLGVBQWUsQ0FBQzBDLFdBQUQsQ0FBNUI7QUFDQSxXQUFPTCxRQUFRLENBQUM7QUFDZGpZLFlBQU0sRUFBRUEsTUFETTtBQUVkZ0MsZUFBUyxFQUFFLHlCQUF5QkksUUFGdEI7QUFHZG9TLFdBQUssRUFBRW9DLFNBQVMsS0FBS3hILFNBQWQsR0FBMEJ3SCxTQUFTLENBQUNyVCxJQUFwQyxHQUEyQyxFQUhwQztBQUlkZ1Ysa0JBQVksRUFBRSxLQUFLQSxZQUpMO0FBS2RDLG1CQUFhLEVBQUUsS0FBS0E7QUFMTixLQUFELENBQWY7QUFPRCxHQWpCRDs7QUFtQkEsU0FBT3JCLFNBQVA7QUFDRCxDQXJKNEIsQ0FxSjNCQyxrQkFySjJCLENBQTdCOztBQXVKZUQsNkVBQWYiLCJmaWxlIjoiM01wdy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUHJpc206IExpZ2h0d2VpZ2h0LCByb2J1c3QsIGVsZWdhbnQgc3ludGF4IGhpZ2hsaWdodGluZ1xuICpcbiAqIEBsaWNlbnNlIE1JVCA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+XG4gKiBAYXV0aG9yIExlYSBWZXJvdSA8aHR0cHM6Ly9sZWEudmVyb3UubWU+XG4gKiBAbmFtZXNwYWNlXG4gKiBAcHVibGljXG4gKi9cbi8qKlxuICogcHJpc20tcmVhY3QtcmVuZGVyZXI6XG4gKiBUaGlzIGZpbGUgaGFzIGJlZW4gbW9kaWZpZWQgdG8gcmVtb3ZlOlxuICogLSBnbG9iYWxzIGFuZCB3aW5kb3cgZGVwZW5kZW5jeVxuICogLSB3b3JrZXIgc3VwcG9ydFxuICogLSBoaWdobGlnaHRBbGwgYW5kIG90aGVyIGVsZW1lbnQgZGVwZW5kZW50IG1ldGhvZHNcbiAqIC0gXy5ob29rcyBoZWxwZXJzXG4gKiAtIFVNRC9ub2RlLXNwZWNpZmljIGhhY2tzXG4gKiBJdCBoYXMgYWxzbyBiZWVuIHJ1biB0aHJvdWdoIHByZXR0aWVyXG4gKi9cblxuIHZhciBQcmlzbSA9IChmdW5jdGlvbiAoKSB7XG5cblx0Ly8gUHJpdmF0ZSBoZWxwZXIgdmFyc1xuXHR2YXIgbGFuZyA9IC8oPzpefFxccylsYW5nKD86dWFnZSk/LShbXFx3LV0rKSg/PVxcc3wkKS9pO1xuXHR2YXIgdW5pcXVlSWQgPSAwO1xuXG5cdC8vIFRoZSBncmFtbWFyIG9iamVjdCBmb3IgcGxhaW50ZXh0XG5cdHZhciBwbGFpblRleHRHcmFtbWFyID0ge307XG5cblxuXHR2YXIgXyA9IHtcblx0XHQvKipcblx0XHQgKiBBIG5hbWVzcGFjZSBmb3IgdXRpbGl0eSBtZXRob2RzLlxuXHRcdCAqXG5cdFx0ICogQWxsIGZ1bmN0aW9uIGluIHRoaXMgbmFtZXNwYWNlIHRoYXQgYXJlIG5vdCBleHBsaWNpdGx5IG1hcmtlZCBhcyBfcHVibGljXyBhcmUgZm9yIF9faW50ZXJuYWwgdXNlIG9ubHlfXyBhbmQgbWF5XG5cdFx0ICogY2hhbmdlIG9yIGRpc2FwcGVhciBhdCBhbnkgdGltZS5cblx0XHQgKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKi9cblx0XHR1dGlsOiB7XG5cdFx0XHRlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZSh0b2tlbnMpIHtcblx0XHRcdFx0aWYgKHRva2VucyBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBUb2tlbih0b2tlbnMudHlwZSwgZW5jb2RlKHRva2Vucy5jb250ZW50KSwgdG9rZW5zLmFsaWFzKTtcblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRva2VucykpIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLm1hcChlbmNvZGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIHZhbHVlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7YW55fSBvXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHR5cGUobnVsbCkgICAgICA9PT0gJ051bGwnXG5cdFx0XHQgKiB0eXBlKHVuZGVmaW5lZCkgPT09ICdVbmRlZmluZWQnXG5cdFx0XHQgKiB0eXBlKDEyMykgICAgICAgPT09ICdOdW1iZXInXG5cdFx0XHQgKiB0eXBlKCdmb28nKSAgICAgPT09ICdTdHJpbmcnXG5cdFx0XHQgKiB0eXBlKHRydWUpICAgICAgPT09ICdCb29sZWFuJ1xuXHRcdFx0ICogdHlwZShbMSwgMl0pICAgID09PSAnQXJyYXknXG5cdFx0XHQgKiB0eXBlKHt9KSAgICAgICAgPT09ICdPYmplY3QnXG5cdFx0XHQgKiB0eXBlKFN0cmluZykgICAgPT09ICdGdW5jdGlvbidcblx0XHRcdCAqIHR5cGUoL2FiYysvKSAgICA9PT0gJ1JlZ0V4cCdcblx0XHRcdCAqL1xuXHRcdFx0dHlwZTogZnVuY3Rpb24gKG8pIHtcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgYSB1bmlxdWUgbnVtYmVyIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LiBMYXRlciBjYWxscyB3aWxsIHN0aWxsIHJldHVybiB0aGUgc2FtZSBudW1iZXIuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHRcdFx0ICogQHJldHVybnMge251bWJlcn1cblx0XHRcdCAqL1xuXHRcdFx0b2JqSWQ6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0aWYgKCFvYmpbJ19faWQnXSkge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICdfX2lkJywgeyB2YWx1ZTogKyt1bmlxdWVJZCB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2JqWydfX2lkJ107XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIHRoZSBnaXZlbiBvYmplY3QuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIG1haW4gaW50ZW5kZWQgdXNlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gY2xvbmUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtUfSBvXG5cdFx0XHQgKiBAcGFyYW0ge1JlY29yZDxudW1iZXIsIGFueT59IFt2aXNpdGVkXVxuXHRcdFx0ICogQHJldHVybnMge1R9XG5cdFx0XHQgKiBAdGVtcGxhdGUgVFxuXHRcdFx0ICovXG5cdFx0XHRjbG9uZTogZnVuY3Rpb24gZGVlcENsb25lKG8sIHZpc2l0ZWQpIHtcblx0XHRcdFx0dmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG5cblx0XHRcdFx0dmFyIGNsb25lOyB2YXIgaWQ7XG5cdFx0XHRcdHN3aXRjaCAoXy51dGlsLnR5cGUobykpIHtcblx0XHRcdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0XHRcdFx0aWQgPSBfLnV0aWwub2JqSWQobyk7XG5cdFx0XHRcdFx0XHRpZiAodmlzaXRlZFtpZF0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZpc2l0ZWRbaWRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2xvbmUgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovICh7fSk7XG5cdFx0XHRcdFx0XHR2aXNpdGVkW2lkXSA9IGNsb25lO1xuXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbykge1xuXHRcdFx0XHRcdFx0XHRpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvbmVba2V5XSA9IGRlZXBDbG9uZShvW2tleV0sIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKGNsb25lKTtcblxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0XHRcdGlkID0gXy51dGlsLm9iaklkKG8pO1xuXHRcdFx0XHRcdFx0aWYgKHZpc2l0ZWRbaWRdKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2aXNpdGVkW2lkXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0XHR2aXNpdGVkW2lkXSA9IGNsb25lO1xuXG5cdFx0XHRcdFx0XHQoLyoqIEB0eXBlIHtBcnJheX0gKi8oLyoqIEB0eXBlIHthbnl9ICovKG8pKSkuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuXHRcdFx0XHRcdFx0XHRjbG9uZVtpXSA9IGRlZXBDbG9uZSh2LCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChjbG9uZSk7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIG87XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyB0aGUgUHJpc20gbGFuZ3VhZ2Ugb2YgdGhlIGdpdmVuIGVsZW1lbnQgc2V0IGJ5IGEgYGxhbmd1YWdlLXh4eHhgIG9yIGBsYW5nLXh4eHhgIGNsYXNzLlxuXHRcdFx0ICpcblx0XHRcdCAqIElmIG5vIGxhbmd1YWdlIGlzIHNldCBmb3IgdGhlIGVsZW1lbnQgb3IgdGhlIGVsZW1lbnQgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBgbm9uZWAgd2lsbCBiZSByZXR1cm5lZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdGdldExhbmd1YWdlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0XHR3aGlsZSAoZWxlbWVudCkge1xuXHRcdFx0XHRcdHZhciBtID0gbGFuZy5leGVjKGVsZW1lbnQuY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRpZiAobSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1bMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gJ25vbmUnO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXRzIHRoZSBQcmlzbSBgbGFuZ3VhZ2UteHh4eGAgY2xhc3Mgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2Vcblx0XHRcdCAqIEByZXR1cm5zIHt2b2lkfVxuXHRcdFx0ICovXG5cdFx0XHRzZXRMYW5ndWFnZTogZnVuY3Rpb24gKGVsZW1lbnQsIGxhbmd1YWdlKSB7XG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgYGxhbmd1YWdlLXh4eHhgIGNsYXNzZXNcblx0XHRcdFx0Ly8gKHRoaXMgbWlnaHQgbGVhdmUgYmVoaW5kIGEgbGVhZGluZyBzcGFjZSlcblx0XHRcdFx0ZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKFJlZ0V4cChsYW5nLCAnZ2knKSwgJycpO1xuXG5cdFx0XHRcdC8vIGFkZCB0aGUgbmV3IGBsYW5ndWFnZS14eHh4YCBjbGFzc1xuXHRcdFx0XHQvLyAodXNpbmcgYGNsYXNzTGlzdGAgd2lsbCBhdXRvbWF0aWNhbGx5IGNsZWFuIHVwIHNwYWNlcyBmb3IgdXMpXG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbGFuZ3VhZ2UtJyArIGxhbmd1YWdlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyB3aGV0aGVyIGEgZ2l2ZW4gY2xhc3MgaXMgYWN0aXZlIGZvciBgZWxlbWVudGAuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGNsYXNzIGNhbiBiZSBhY3RpdmF0ZWQgaWYgYGVsZW1lbnRgIG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzIGhhcyB0aGUgZ2l2ZW4gY2xhc3MgYW5kIGl0IGNhbiBiZSBkZWFjdGl2YXRlZFxuXHRcdFx0ICogaWYgYGVsZW1lbnRgIG9yIG9uZSBvZiBpdHMgYW5jZXN0b3JzIGhhcyB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBjbGFzcy4gVGhlIF9uZWdhdGVkIHZlcnNpb25fIG9mIHRoZVxuXHRcdFx0ICogZ2l2ZW4gY2xhc3MgaXMganVzdCB0aGUgZ2l2ZW4gY2xhc3Mgd2l0aCBhIGBuby1gIHByZWZpeC5cblx0XHRcdCAqXG5cdFx0XHQgKiBXaGV0aGVyIHRoZSBjbGFzcyBpcyBhY3RpdmUgaXMgZGV0ZXJtaW5lZCBieSB0aGUgY2xvc2VzdCBhbmNlc3RvciBvZiBgZWxlbWVudGAgKHdoZXJlIGBlbGVtZW50YCBpdHNlbGYgaXNcblx0XHRcdCAqIGNsb3Nlc3QgYW5jZXN0b3IpIHRoYXQgaGFzIHRoZSBnaXZlbiBjbGFzcyBvciB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIGl0LiBJZiBuZWl0aGVyIGBlbGVtZW50YCBub3IgYW55IG9mIGl0c1xuXHRcdFx0ICogYW5jZXN0b3JzIGhhdmUgdGhlIGdpdmVuIGNsYXNzIG9yIHRoZSBuZWdhdGVkIHZlcnNpb24gb2YgaXQsIHRoZW4gdGhlIGRlZmF1bHQgYWN0aXZhdGlvbiB3aWxsIGJlIHJldHVybmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEluIHRoZSBwYXJhZG94aWNhbCBzaXR1YXRpb24gd2hlcmUgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgY29udGFpbnMgX19ib3RoX18gdGhlIGdpdmVuIGNsYXNzIGFuZCB0aGUgbmVnYXRlZFxuXHRcdFx0ICogdmVyc2lvbiBvZiBpdCwgdGhlIGNsYXNzIGlzIGNvbnNpZGVyZWQgYWN0aXZlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuXHRcdFx0ICogQHBhcmFtIHtib29sZWFufSBbZGVmYXVsdEFjdGl2YXRpb249ZmFsc2VdXG5cdFx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0XHRcdCAqL1xuXHRcdFx0aXNBY3RpdmU6IGZ1bmN0aW9uIChlbGVtZW50LCBjbGFzc05hbWUsIGRlZmF1bHRBY3RpdmF0aW9uKSB7XG5cdFx0XHRcdHZhciBubyA9ICduby0nICsgY2xhc3NOYW1lO1xuXG5cdFx0XHRcdHdoaWxlIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0dmFyIGNsYXNzTGlzdCA9IGVsZW1lbnQuY2xhc3NMaXN0O1xuXHRcdFx0XHRcdGlmIChjbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChjbGFzc0xpc3QuY29udGFpbnMobm8pKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICEhZGVmYXVsdEFjdGl2YXRpb247XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoaXMgbmFtZXNwYWNlIGNvbnRhaW5zIGFsbCBjdXJyZW50bHkgbG9hZGVkIGxhbmd1YWdlcyBhbmQgdGhlIHNvbWUgaGVscGVyIGZ1bmN0aW9ucyB0byBjcmVhdGUgYW5kIG1vZGlmeSBsYW5ndWFnZXMuXG5cdFx0ICpcblx0XHQgKiBAbmFtZXNwYWNlXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGxhbmd1YWdlczoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgZ3JhbW1hciBmb3IgcGxhaW4sIHVuZm9ybWF0dGVkIHRleHQuXG5cdFx0XHQgKi9cblx0XHRcdHBsYWluOiBwbGFpblRleHRHcmFtbWFyLFxuXHRcdFx0cGxhaW50ZXh0OiBwbGFpblRleHRHcmFtbWFyLFxuXHRcdFx0dGV4dDogcGxhaW5UZXh0R3JhbW1hcixcblx0XHRcdHR4dDogcGxhaW5UZXh0R3JhbW1hcixcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSBsYW5ndWFnZSB3aXRoIHRoZSBnaXZlbiBpZCBhbmQgYXBwZW5kcyB0aGUgZ2l2ZW4gdG9rZW5zLlxuXHRcdFx0ICpcblx0XHRcdCAqIElmIGEgdG9rZW4gaW4gYHJlZGVmYCBhbHNvIGFwcGVhcnMgaW4gdGhlIGNvcGllZCBsYW5ndWFnZSwgdGhlbiB0aGUgZXhpc3RpbmcgdG9rZW4gaW4gdGhlIGNvcGllZCBsYW5ndWFnZVxuXHRcdFx0ICogd2lsbCBiZSBvdmVyd3JpdHRlbiBhdCBpdHMgb3JpZ2luYWwgcG9zaXRpb24uXG5cdFx0XHQgKlxuXHRcdFx0ICogIyMgQmVzdCBwcmFjdGljZXNcblx0XHRcdCAqXG5cdFx0XHQgKiBTaW5jZSB0aGUgcG9zaXRpb24gb2Ygb3ZlcndyaXRpbmcgdG9rZW5zICh0b2tlbiBpbiBgcmVkZWZgIHRoYXQgb3ZlcndyaXRlIHRva2VucyBpbiB0aGUgY29waWVkIGxhbmd1YWdlKVxuXHRcdFx0ICogZG9lc24ndCBtYXR0ZXIsIHRoZXkgY2FuIHRlY2huaWNhbGx5IGJlIGluIGFueSBvcmRlci4gSG93ZXZlciwgdGhpcyBjYW4gYmUgY29uZnVzaW5nIHRvIG90aGVycyB0aGF0IHRyeWluZyB0b1xuXHRcdFx0ICogdW5kZXJzdGFuZCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBiZWNhdXNlLCBub3JtYWxseSwgdGhlIG9yZGVyIG9mIHRva2VucyBtYXR0ZXJzIGluIFByaXNtIGdyYW1tYXJzLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZXJlZm9yZSwgaXQgaXMgZW5jb3VyYWdlZCB0byBvcmRlciBvdmVyd3JpdGluZyB0b2tlbnMgYWNjb3JkaW5nIHRvIHRoZSBwb3NpdGlvbnMgb2YgdGhlIG92ZXJ3cml0dGVuIHRva2Vucy5cblx0XHRcdCAqIEZ1cnRoZXJtb3JlLCBhbGwgbm9uLW92ZXJ3cml0aW5nIHRva2VucyBzaG91bGQgYmUgcGxhY2VkIGFmdGVyIHRoZSBvdmVyd3JpdGluZyBvbmVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGxhbmd1YWdlIHRvIGV4dGVuZC4gVGhpcyBoYXMgdG8gYmUgYSBrZXkgaW4gYFByaXNtLmxhbmd1YWdlc2AuXG5cdFx0XHQgKiBAcGFyYW0ge0dyYW1tYXJ9IHJlZGVmIFRoZSBuZXcgdG9rZW5zIHRvIGFwcGVuZC5cblx0XHRcdCAqIEByZXR1cm5zIHtHcmFtbWFyfSBUaGUgbmV3IGxhbmd1YWdlIGNyZWF0ZWQuXG5cdFx0XHQgKiBAcHVibGljXG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogUHJpc20ubGFuZ3VhZ2VzWydjc3Mtd2l0aC1jb2xvcnMnXSA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NzcycsIHtcblx0XHRcdCAqICAgICAvLyBQcmlzbS5sYW5ndWFnZXMuY3NzIGFscmVhZHkgaGFzIGEgJ2NvbW1lbnQnIHRva2VuLCBzbyB0aGlzIHRva2VuIHdpbGwgb3ZlcndyaXRlIENTUycgJ2NvbW1lbnQnIHRva2VuXG5cdFx0XHQgKiAgICAgLy8gYXQgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXG5cdFx0XHQgKiAgICAgJ2NvbW1lbnQnOiB7IC4uLiB9LFxuXHRcdFx0ICogICAgIC8vIENTUyBkb2Vzbid0IGhhdmUgYSAnY29sb3InIHRva2VuLCBzbyB0aGlzIHRva2VuIHdpbGwgYmUgYXBwZW5kZWRcblx0XHRcdCAqICAgICAnY29sb3InOiAvXFxiKD86cmVkfGdyZWVufGJsdWUpXFxiL1xuXHRcdFx0ICogfSk7XG5cdFx0XHQgKi9cblx0XHRcdGV4dGVuZDogZnVuY3Rpb24gKGlkLCByZWRlZikge1xuXHRcdFx0XHR2YXIgbGFuZyA9IF8udXRpbC5jbG9uZShfLmxhbmd1YWdlc1tpZF0pO1xuXG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiByZWRlZikge1xuXHRcdFx0XHRcdGxhbmdba2V5XSA9IHJlZGVmW2tleV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbGFuZztcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogSW5zZXJ0cyB0b2tlbnMgX2JlZm9yZV8gYW5vdGhlciB0b2tlbiBpbiBhIGxhbmd1YWdlIGRlZmluaXRpb24gb3IgYW55IG90aGVyIGdyYW1tYXIuXG5cdFx0XHQgKlxuXHRcdFx0ICogIyMgVXNhZ2Vcblx0XHRcdCAqXG5cdFx0XHQgKiBUaGlzIGhlbHBlciBtZXRob2QgbWFrZXMgaXQgZWFzeSB0byBtb2RpZnkgZXhpc3RpbmcgbGFuZ3VhZ2VzLiBGb3IgZXhhbXBsZSwgdGhlIENTUyBsYW5ndWFnZSBkZWZpbml0aW9uXG5cdFx0XHQgKiBub3Qgb25seSBkZWZpbmVzIENTUyBoaWdobGlnaHRpbmcgZm9yIENTUyBkb2N1bWVudHMsIGJ1dCBhbHNvIG5lZWRzIHRvIGRlZmluZSBoaWdobGlnaHRpbmcgZm9yIENTUyBlbWJlZGRlZFxuXHRcdFx0ICogaW4gSFRNTCB0aHJvdWdoIGA8c3R5bGU+YCBlbGVtZW50cy4gVG8gZG8gdGhpcywgaXQgbmVlZHMgdG8gbW9kaWZ5IGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYCBhbmQgYWRkIHRoZVxuXHRcdFx0ICogYXBwcm9wcmlhdGUgdG9rZW5zLiBIb3dldmVyLCBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAgaXMgYSByZWd1bGFyIEphdmFTY3JpcHQgb2JqZWN0IGxpdGVyYWwsIHNvIGlmIHlvdSBkb1xuXHRcdFx0ICogdGhpczpcblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC5zdHlsZSA9IHtcblx0XHRcdCAqICAgICAvLyB0b2tlblxuXHRcdFx0ICogfTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqIHRoZW4gdGhlIGBzdHlsZWAgdG9rZW4gd2lsbCBiZSBhZGRlZCAoYW5kIHByb2Nlc3NlZCkgYXQgdGhlIGVuZC4gYGluc2VydEJlZm9yZWAgYWxsb3dzIHlvdSB0byBpbnNlcnQgdG9rZW5zXG5cdFx0XHQgKiBiZWZvcmUgZXhpc3RpbmcgdG9rZW5zLiBGb3IgdGhlIENTUyBleGFtcGxlIGFib3ZlLCB5b3Ugd291bGQgdXNlIGl0IGxpa2UgdGhpczpcblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NkYXRhJywge1xuXHRcdFx0ICogICAgICdzdHlsZSc6IHtcblx0XHRcdCAqICAgICAgICAgLy8gdG9rZW5cblx0XHRcdCAqICAgICB9XG5cdFx0XHQgKiB9KTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqICMjIFNwZWNpYWwgY2FzZXNcblx0XHRcdCAqXG5cdFx0XHQgKiBJZiB0aGUgZ3JhbW1hcnMgb2YgYGluc2lkZWAgYW5kIGBpbnNlcnRgIGhhdmUgdG9rZW5zIHdpdGggdGhlIHNhbWUgbmFtZSwgdGhlIHRva2VucyBpbiBgaW5zaWRlYCdzIGdyYW1tYXJcblx0XHRcdCAqIHdpbGwgYmUgaWdub3JlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGlzIGJlaGF2aW9yIGNhbiBiZSB1c2VkIHRvIGluc2VydCB0b2tlbnMgYWZ0ZXIgYGJlZm9yZWA6XG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjb21tZW50Jywge1xuXHRcdFx0ICogICAgICdjb21tZW50JzogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC5jb21tZW50LFxuXHRcdFx0ICogICAgIC8vIHRva2VucyBhZnRlciAnY29tbWVudCdcblx0XHRcdCAqIH0pO1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogIyMgTGltaXRhdGlvbnNcblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgbWFpbiBwcm9ibGVtIGBpbnNlcnRCZWZvcmVgIGhhcyB0byBzb2x2ZSBpcyBpdGVyYXRpb24gb3JkZXIuIFNpbmNlIEVTMjAxNSwgdGhlIGl0ZXJhdGlvbiBvcmRlciBmb3Igb2JqZWN0XG5cdFx0XHQgKiBwcm9wZXJ0aWVzIGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIGluc2VydGlvbiBvcmRlciAoZXhjZXB0IGZvciBpbnRlZ2VyIGtleXMpIGJ1dCBzb21lIGJyb3dzZXJzIGJlaGF2ZVxuXHRcdFx0ICogZGlmZmVyZW50bHkgd2hlbiBrZXlzIGFyZSBkZWxldGVkIGFuZCByZS1pbnNlcnRlZC4gU28gYGluc2VydEJlZm9yZWAgY2FuJ3QgYmUgaW1wbGVtZW50ZWQgYnkgdGVtcG9yYXJpbHlcblx0XHRcdCAqIGRlbGV0aW5nIHByb3BlcnRpZXMgd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIGluc2VydCBhdCBhcmJpdHJhcnkgcG9zaXRpb25zLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRvIHNvbHZlIHRoaXMgcHJvYmxlbSwgYGluc2VydEJlZm9yZWAgZG9lc24ndCBhY3R1YWxseSBpbnNlcnQgdGhlIGdpdmVuIHRva2VucyBpbnRvIHRoZSB0YXJnZXQgb2JqZWN0LlxuXHRcdFx0ICogSW5zdGVhZCwgaXQgd2lsbCBjcmVhdGUgYSBuZXcgb2JqZWN0IGFuZCByZXBsYWNlIGFsbCByZWZlcmVuY2VzIHRvIHRoZSB0YXJnZXQgb2JqZWN0IHdpdGggdGhlIG5ldyBvbmUuIFRoaXNcblx0XHRcdCAqIGNhbiBiZSBkb25lIHdpdGhvdXQgdGVtcG9yYXJpbHkgZGVsZXRpbmcgcHJvcGVydGllcywgc28gdGhlIGl0ZXJhdGlvbiBvcmRlciBpcyB3ZWxsLWRlZmluZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogSG93ZXZlciwgb25seSByZWZlcmVuY2VzIHRoYXQgY2FuIGJlIHJlYWNoZWQgZnJvbSBgUHJpc20ubGFuZ3VhZ2VzYCBvciBgaW5zZXJ0YCB3aWxsIGJlIHJlcGxhY2VkLiBJLmUuIGlmXG5cdFx0XHQgKiB5b3UgaG9sZCB0aGUgdGFyZ2V0IG9iamVjdCBpbiBhIHZhcmlhYmxlLCB0aGVuIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgd2lsbCBub3QgY2hhbmdlLlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiB2YXIgb2xkTWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblx0XHRcdCAqIHZhciBuZXdNYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY29tbWVudCcsIHsgLi4uIH0pO1xuXHRcdFx0ICpcblx0XHRcdCAqIGFzc2VydChvbGRNYXJrdXAgIT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuXHRcdFx0ICogYXNzZXJ0KG5ld01hcmt1cCA9PT0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCk7XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gaW5zaWRlIFRoZSBwcm9wZXJ0eSBvZiBgcm9vdGAgKGUuZy4gYSBsYW5ndWFnZSBpZCBpbiBgUHJpc20ubGFuZ3VhZ2VzYCkgdGhhdCBjb250YWlucyB0aGVcblx0XHRcdCAqIG9iamVjdCB0byBiZSBtb2RpZmllZC5cblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBiZWZvcmUgVGhlIGtleSB0byBpbnNlcnQgYmVmb3JlLlxuXHRcdFx0ICogQHBhcmFtIHtHcmFtbWFyfSBpbnNlcnQgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGtleS12YWx1ZSBwYWlycyB0byBiZSBpbnNlcnRlZC5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gW3Jvb3RdIFRoZSBvYmplY3QgY29udGFpbmluZyBgaW5zaWRlYCwgaS5lLiB0aGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlXG5cdFx0XHQgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogRGVmYXVsdHMgdG8gYFByaXNtLmxhbmd1YWdlc2AuXG5cdFx0XHQgKiBAcmV0dXJucyB7R3JhbW1hcn0gVGhlIG5ldyBncmFtbWFyIG9iamVjdC5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqL1xuXHRcdFx0aW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAoaW5zaWRlLCBiZWZvcmUsIGluc2VydCwgcm9vdCkge1xuXHRcdFx0XHRyb290ID0gcm9vdCB8fCAvKiogQHR5cGUge2FueX0gKi8gKF8ubGFuZ3VhZ2VzKTtcblx0XHRcdFx0dmFyIGdyYW1tYXIgPSByb290W2luc2lkZV07XG5cdFx0XHRcdC8qKiBAdHlwZSB7R3JhbW1hcn0gKi9cblx0XHRcdFx0dmFyIHJldCA9IHt9O1xuXG5cdFx0XHRcdGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblx0XHRcdFx0XHRpZiAoZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcblxuXHRcdFx0XHRcdFx0aWYgKHRva2VuID09IGJlZm9yZSkge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBuZXdUb2tlbiBpbiBpbnNlcnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaW5zZXJ0Lmhhc093blByb3BlcnR5KG5ld1Rva2VuKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0W25ld1Rva2VuXSA9IGluc2VydFtuZXdUb2tlbl07XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIERvIG5vdCBpbnNlcnQgdG9rZW4gd2hpY2ggYWxzbyBvY2N1ciBpbiBpbnNlcnQuIFNlZSAjMTUyNVxuXHRcdFx0XHRcdFx0aWYgKCFpbnNlcnQuaGFzT3duUHJvcGVydHkodG9rZW4pKSB7XG5cdFx0XHRcdFx0XHRcdHJldFt0b2tlbl0gPSBncmFtbWFyW3Rva2VuXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgb2xkID0gcm9vdFtpbnNpZGVdO1xuXHRcdFx0XHRyb290W2luc2lkZV0gPSByZXQ7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHJlZmVyZW5jZXMgaW4gb3RoZXIgbGFuZ3VhZ2UgZGVmaW5pdGlvbnNcblx0XHRcdFx0Xy5sYW5ndWFnZXMuREZTKF8ubGFuZ3VhZ2VzLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PT0gb2xkICYmIGtleSAhPSBpbnNpZGUpIHtcblx0XHRcdFx0XHRcdHRoaXNba2V5XSA9IHJldDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBUcmF2ZXJzZSBhIGxhbmd1YWdlIGRlZmluaXRpb24gd2l0aCBEZXB0aCBGaXJzdCBTZWFyY2hcblx0XHRcdERGUzogZnVuY3Rpb24gREZTKG8sIGNhbGxiYWNrLCB0eXBlLCB2aXNpdGVkKSB7XG5cdFx0XHRcdHZpc2l0ZWQgPSB2aXNpdGVkIHx8IHt9O1xuXG5cdFx0XHRcdHZhciBvYmpJZCA9IF8udXRpbC5vYmpJZDtcblxuXHRcdFx0XHRmb3IgKHZhciBpIGluIG8pIHtcblx0XHRcdFx0XHRpZiAoby5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbChvLCBpLCBvW2ldLCB0eXBlIHx8IGkpO1xuXG5cdFx0XHRcdFx0XHR2YXIgcHJvcGVydHkgPSBvW2ldO1xuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnR5VHlwZSA9IF8udXRpbC50eXBlKHByb3BlcnR5KTtcblxuXHRcdFx0XHRcdFx0aWYgKHByb3BlcnR5VHlwZSA9PT0gJ09iamVjdCcgJiYgIXZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSkge1xuXHRcdFx0XHRcdFx0XHR2aXNpdGVkW29iaklkKHByb3BlcnR5KV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRERlMocHJvcGVydHksIGNhbGxiYWNrLCBudWxsLCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAocHJvcGVydHlUeXBlID09PSAnQXJyYXknICYmICF2aXNpdGVkW29iaklkKHByb3BlcnR5KV0pIHtcblx0XHRcdFx0XHRcdFx0dmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0REZTKHByb3BlcnR5LCBjYWxsYmFjaywgaSwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHBsdWdpbnM6IHt9LFxuXG5cblx0XHQvKipcblx0XHQgKiBMb3ctbGV2ZWwgZnVuY3Rpb24sIG9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW914oCZcmUgZG9pbmcuIEl0IGFjY2VwdHMgYSBzdHJpbmcgb2YgdGV4dCBhcyBpbnB1dFxuXHRcdCAqIGFuZCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgdG8gdXNlLCBhbmQgcmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBIVE1MIHByb2R1Y2VkLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcblx0XHQgKiAxLiBgYmVmb3JlLXRva2VuaXplYFxuXHRcdCAqIDIuIGBhZnRlci10b2tlbml6ZWBcblx0XHQgKiAzLiBgd3JhcGA6IE9uIGVhY2gge0BsaW5rIFRva2VufS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWQuXG5cdFx0ICogQHBhcmFtIHtHcmFtbWFyfSBncmFtbWFyIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbnMgdG8gdXNlLlxuXHRcdCAqXG5cdFx0ICogVXN1YWxseSBhIGxhbmd1YWdlIGRlZmluaXRpb24gbGlrZSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIHBhc3NlZCB0byBgZ3JhbW1hcmAuXG5cdFx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIGhpZ2hsaWdodGVkIEhUTUwuXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogUHJpc20uaGlnaGxpZ2h0KCd2YXIgZm9vID0gdHJ1ZTsnLCBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCwgJ2phdmFzY3JpcHQnKTtcblx0XHQgKi9cblx0XHRoaWdobGlnaHQ6IGZ1bmN0aW9uICh0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuXHRcdFx0dmFyIGVudiA9IHtcblx0XHRcdFx0Y29kZTogdGV4dCxcblx0XHRcdFx0Z3JhbW1hcjogZ3JhbW1hcixcblx0XHRcdFx0bGFuZ3VhZ2U6IGxhbmd1YWdlXG5cdFx0XHR9O1xuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS10b2tlbml6ZScsIGVudik7XG5cdFx0XHRlbnYudG9rZW5zID0gXy50b2tlbml6ZShlbnYuY29kZSwgZW52LmdyYW1tYXIpO1xuXHRcdFx0Xy5ob29rcy5ydW4oJ2FmdGVyLXRva2VuaXplJywgZW52KTtcblx0XHRcdHJldHVybiBUb2tlbi5zdHJpbmdpZnkoXy51dGlsLmVuY29kZShlbnYudG9rZW5zKSwgZW52Lmxhbmd1YWdlKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBpcyB0aGUgaGVhcnQgb2YgUHJpc20sIGFuZCB0aGUgbW9zdCBsb3ctbGV2ZWwgZnVuY3Rpb24geW91IGNhbiB1c2UuIEl0IGFjY2VwdHMgYSBzdHJpbmcgb2YgdGV4dCBhcyBpbnB1dFxuXHRcdCAqIGFuZCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgdG8gdXNlLCBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSB0b2tlbml6ZWQgY29kZS5cblx0XHQgKlxuXHRcdCAqIFdoZW4gdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gaW5jbHVkZXMgbmVzdGVkIHRva2VucywgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCByZWN1cnNpdmVseSBvbiBlYWNoIG9mIHRoZXNlIHRva2Vucy5cblx0XHQgKlxuXHRcdCAqIFRoaXMgbWV0aG9kIGNvdWxkIGJlIHVzZWZ1bCBpbiBvdGhlciBjb250ZXh0cyBhcyB3ZWxsLCBhcyBhIHZlcnkgY3J1ZGUgcGFyc2VyLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgQSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0byBiZSBoaWdobGlnaHRlZC5cblx0XHQgKiBAcGFyYW0ge0dyYW1tYXJ9IGdyYW1tYXIgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRva2VucyB0byB1c2UuXG5cdFx0ICpcblx0XHQgKiBVc3VhbGx5IGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBsaWtlIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYC5cblx0XHQgKiBAcmV0dXJucyB7VG9rZW5TdHJlYW19IEFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHRva2VucywgYSB0b2tlbiBzdHJlYW0uXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogbGV0IGNvZGUgPSBgdmFyIGZvbyA9IDA7YDtcblx0XHQgKiBsZXQgdG9rZW5zID0gUHJpc20udG9rZW5pemUoY29kZSwgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xuXHRcdCAqIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHtcblx0XHQgKiAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgUHJpc20uVG9rZW4gJiYgdG9rZW4udHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHQgKiAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBudW1lcmljIGxpdGVyYWw6ICR7dG9rZW4uY29udGVudH1gKTtcblx0XHQgKiAgICAgfVxuXHRcdCAqIH0pO1xuXHRcdCAqL1xuXHRcdHRva2VuaXplOiBmdW5jdGlvbiAodGV4dCwgZ3JhbW1hcikge1xuXHRcdFx0dmFyIHJlc3QgPSBncmFtbWFyLnJlc3Q7XG5cdFx0XHRpZiAocmVzdCkge1xuXHRcdFx0XHRmb3IgKHZhciB0b2tlbiBpbiByZXN0KSB7XG5cdFx0XHRcdFx0Z3JhbW1hclt0b2tlbl0gPSByZXN0W3Rva2VuXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBncmFtbWFyLnJlc3Q7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB0b2tlbkxpc3QgPSBuZXcgTGlua2VkTGlzdCgpO1xuXHRcdFx0YWRkQWZ0ZXIodG9rZW5MaXN0LCB0b2tlbkxpc3QuaGVhZCwgdGV4dCk7XG5cblx0XHRcdG1hdGNoR3JhbW1hcih0ZXh0LCB0b2tlbkxpc3QsIGdyYW1tYXIsIHRva2VuTGlzdC5oZWFkLCAwKTtcblxuXHRcdFx0cmV0dXJuIHRvQXJyYXkodG9rZW5MaXN0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRob29rczoge1xuXHRcdFx0YWxsOiB7fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZGRzIHRoZSBnaXZlbiBjYWxsYmFjayB0byB0aGUgbGlzdCBvZiBjYWxsYmFja3MgZm9yIHRoZSBnaXZlbiBob29rLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgaG9vayBpdCBpcyByZWdpc3RlcmVkIGZvciBpcyBydW4uXG5cdFx0XHQgKiBIb29rcyBhcmUgdXN1YWxseSBkaXJlY3RseSBydW4gYnkgYSBoaWdobGlnaHQgZnVuY3Rpb24gYnV0IHlvdSBjYW4gYWxzbyBydW4gaG9va3MgeW91cnNlbGYuXG5cdFx0XHQgKlxuXHRcdFx0ICogT25lIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbiBiZSByZWdpc3RlcmVkIHRvIG11bHRpcGxlIGhvb2tzIGFuZCB0aGUgc2FtZSBob29rIG11bHRpcGxlIHRpbWVzLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rLlxuXHRcdFx0ICogQHBhcmFtIHtIb29rQ2FsbGJhY2t9IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGljaCBpcyBnaXZlbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG5cdFx0XHQgKiBAcHVibGljXG5cdFx0XHQgKi9cblx0XHRcdGFkZDogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7XG5cdFx0XHRcdHZhciBob29rcyA9IF8uaG9va3MuYWxsO1xuXG5cdFx0XHRcdGhvb2tzW25hbWVdID0gaG9va3NbbmFtZV0gfHwgW107XG5cblx0XHRcdFx0aG9va3NbbmFtZV0ucHVzaChjYWxsYmFjayk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJ1bnMgYSBob29rIGludm9raW5nIGFsbCByZWdpc3RlcmVkIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQ2FsbGJhY2tzIHdpbGwgYmUgaW52b2tlZCBzeW5jaHJvbm91c2x5IGFuZCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIHJlZ2lzdGVyZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2suXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IGVudiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIG9mIHRoZSBob29rIHBhc3NlZCB0byBhbGwgY2FsbGJhY2tzIHJlZ2lzdGVyZWQuXG5cdFx0XHQgKiBAcHVibGljXG5cdFx0XHQgKi9cblx0XHRcdHJ1bjogZnVuY3Rpb24gKG5hbWUsIGVudikge1xuXHRcdFx0XHR2YXIgY2FsbGJhY2tzID0gXy5ob29rcy5hbGxbbmFtZV07XG5cblx0XHRcdFx0aWYgKCFjYWxsYmFja3MgfHwgIWNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgY2FsbGJhY2s7IChjYWxsYmFjayA9IGNhbGxiYWNrc1tpKytdKTspIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlbnYpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdFRva2VuOiBUb2tlblxuXHR9O1xuXG5cblx0Ly8gVHlwZXNjcmlwdCBub3RlOlxuXHQvLyBUaGUgZm9sbG93aW5nIGNhbiBiZSB1c2VkIHRvIGltcG9ydCB0aGUgVG9rZW4gdHlwZSBpbiBKU0RvYzpcblx0Ly9cblx0Ly8gICBAdHlwZWRlZiB7SW5zdGFuY2VUeXBlPGltcG9ydChcIi4vcHJpc20tY29yZVwiKVtcIlRva2VuXCJdPn0gVG9rZW5cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIG5ldyB0b2tlbi5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgU2VlIHtAbGluayBUb2tlbiN0eXBlIHR5cGV9XG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgVG9rZW5TdHJlYW19IGNvbnRlbnQgU2VlIHtAbGluayBUb2tlbiNjb250ZW50IGNvbnRlbnR9XG5cdCAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbYWxpYXNdIFRoZSBhbGlhcyhlcykgb2YgdGhlIHRva2VuLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21hdGNoZWRTdHI9XCJcIl0gQSBjb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb20uXG5cdCAqIEBjbGFzc1xuXHQgKiBAZ2xvYmFsXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIFRva2VuKHR5cGUsIGNvbnRlbnQsIGFsaWFzLCBtYXRjaGVkU3RyKSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHR5cGUgb2YgdGhlIHRva2VuLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBpcyB1c3VhbGx5IHRoZSBrZXkgb2YgYSBwYXR0ZXJuIGluIGEge0BsaW5rIEdyYW1tYXJ9LlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAc2VlIEdyYW1tYXJUb2tlblxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBzdHJpbmdzIG9yIHRva2VucyBjb250YWluZWQgYnkgdGhpcyB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIFRoaXMgd2lsbCBiZSBhIHRva2VuIHN0cmVhbSBpZiB0aGUgcGF0dGVybiBtYXRjaGVkIGFsc28gZGVmaW5lZCBhbiBgaW5zaWRlYCBncmFtbWFyLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZyB8IFRva2VuU3RyZWFtfVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBhbGlhcyhlcykgb2YgdGhlIHRva2VuLlxuXHRcdCAqXG5cdFx0ICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXX1cblx0XHQgKiBAc2VlIEdyYW1tYXJUb2tlblxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHR0aGlzLmFsaWFzID0gYWxpYXM7XG5cdFx0Ly8gQ29weSBvZiB0aGUgZnVsbCBzdHJpbmcgdGhpcyB0b2tlbiB3YXMgY3JlYXRlZCBmcm9tXG5cdFx0dGhpcy5sZW5ndGggPSAobWF0Y2hlZFN0ciB8fCAnJykubGVuZ3RoIHwgMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHRva2VuIHN0cmVhbSBpcyBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCB7QGxpbmsgVG9rZW4gVG9rZW59IG9iamVjdHMuXG5cdCAqXG5cdCAqIFRva2VuIHN0cmVhbXMgaGF2ZSB0byBmdWxmaWxsIGEgZmV3IHByb3BlcnRpZXMgdGhhdCBhcmUgYXNzdW1lZCBieSBtb3N0IGZ1bmN0aW9ucyAobW9zdGx5IGludGVybmFsIG9uZXMpIHRoYXQgcHJvY2Vzc1xuXHQgKiB0aGVtLlxuXHQgKlxuXHQgKiAxLiBObyBhZGphY2VudCBzdHJpbmdzLlxuXHQgKiAyLiBObyBlbXB0eSBzdHJpbmdzLlxuXHQgKlxuXHQgKiAgICBUaGUgb25seSBleGNlcHRpb24gaGVyZSBpcyB0aGUgdG9rZW4gc3RyZWFtIHRoYXQgb25seSBjb250YWlucyB0aGUgZW1wdHkgc3RyaW5nIGFuZCBub3RoaW5nIGVsc2UuXG5cdCAqXG5cdCAqIEB0eXBlZGVmIHtBcnJheTxzdHJpbmcgfCBUb2tlbj59IFRva2VuU3RyZWFtXG5cdCAqIEBnbG9iYWxcblx0ICogQHB1YmxpY1xuXHQgKi9cblxuXHQvKipcblx0ICogQ29udmVydHMgdGhlIGdpdmVuIHRva2VuIG9yIHRva2VuIHN0cmVhbSB0byBhbiBIVE1MIHJlcHJlc2VudGF0aW9uLlxuXHQgKlxuXHQgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuXHQgKiAxLiBgd3JhcGA6IE9uIGVhY2gge0BsaW5rIFRva2VufS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBUb2tlbiB8IFRva2VuU3RyZWFtfSBvIFRoZSB0b2tlbiBvciB0b2tlbiBzdHJlYW0gdG8gYmUgY29udmVydGVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIG5hbWUgb2YgY3VycmVudCBsYW5ndWFnZS5cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIEhUTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRva2VuIG9yIHRva2VuIHN0cmVhbS5cblx0ICogQG1lbWJlcm9mIFRva2VuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdFRva2VuLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShvLCBsYW5ndWFnZSkge1xuXHRcdGlmICh0eXBlb2YgbyA9PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIG87XG5cdFx0fVxuXHRcdGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG5cdFx0XHR2YXIgcyA9ICcnO1xuXHRcdFx0by5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHMgKz0gc3RyaW5naWZ5KGUsIGxhbmd1YWdlKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHM7XG5cdFx0fVxuXG5cdFx0dmFyIGVudiA9IHtcblx0XHRcdHR5cGU6IG8udHlwZSxcblx0XHRcdGNvbnRlbnQ6IHN0cmluZ2lmeShvLmNvbnRlbnQsIGxhbmd1YWdlKSxcblx0XHRcdHRhZzogJ3NwYW4nLFxuXHRcdFx0Y2xhc3NlczogWyd0b2tlbicsIG8udHlwZV0sXG5cdFx0XHRhdHRyaWJ1dGVzOiB7fSxcblx0XHRcdGxhbmd1YWdlOiBsYW5ndWFnZVxuXHRcdH07XG5cblx0XHR2YXIgYWxpYXNlcyA9IG8uYWxpYXM7XG5cdFx0aWYgKGFsaWFzZXMpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFsaWFzZXMpKSB7XG5cdFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVudi5jbGFzc2VzLCBhbGlhc2VzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVudi5jbGFzc2VzLnB1c2goYWxpYXNlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Xy5ob29rcy5ydW4oJ3dyYXAnLCBlbnYpO1xuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSAnJztcblx0XHRmb3IgKHZhciBuYW1lIGluIGVudi5hdHRyaWJ1dGVzKSB7XG5cdFx0XHRhdHRyaWJ1dGVzICs9ICcgJyArIG5hbWUgKyAnPVwiJyArIChlbnYuYXR0cmlidXRlc1tuYW1lXSB8fCAnJykucmVwbGFjZSgvXCIvZywgJyZxdW90OycpICsgJ1wiJztcblx0XHR9XG5cblx0XHRyZXR1cm4gJzwnICsgZW52LnRhZyArICcgY2xhc3M9XCInICsgZW52LmNsYXNzZXMuam9pbignICcpICsgJ1wiJyArIGF0dHJpYnV0ZXMgKyAnPicgKyBlbnYuY29udGVudCArICc8LycgKyBlbnYudGFnICsgJz4nO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge1JlZ0V4cH0gcGF0dGVyblxuXHQgKiBAcGFyYW0ge251bWJlcn0gcG9zXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9va2JlaGluZFxuXHQgKiBAcmV0dXJucyB7UmVnRXhwRXhlY0FycmF5IHwgbnVsbH1cblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwb3MsIHRleHQsIGxvb2tiZWhpbmQpIHtcblx0XHRwYXR0ZXJuLmxhc3RJbmRleCA9IHBvcztcblx0XHR2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWModGV4dCk7XG5cdFx0aWYgKG1hdGNoICYmIGxvb2tiZWhpbmQgJiYgbWF0Y2hbMV0pIHtcblx0XHRcdC8vIGNoYW5nZSB0aGUgbWF0Y2ggdG8gcmVtb3ZlIHRoZSB0ZXh0IG1hdGNoZWQgYnkgdGhlIFByaXNtIGxvb2tiZWhpbmQgZ3JvdXBcblx0XHRcdHZhciBsb29rYmVoaW5kTGVuZ3RoID0gbWF0Y2hbMV0ubGVuZ3RoO1xuXHRcdFx0bWF0Y2guaW5kZXggKz0gbG9va2JlaGluZExlbmd0aDtcblx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UobG9va2JlaGluZExlbmd0aCk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaDtcblx0fVxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8c3RyaW5nIHwgVG9rZW4+fSB0b2tlbkxpc3Rcblx0ICogQHBhcmFtIHthbnl9IGdyYW1tYXJcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0Tm9kZTxzdHJpbmcgfCBUb2tlbj59IHN0YXJ0Tm9kZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRQb3Ncblx0ICogQHBhcmFtIHtSZW1hdGNoT3B0aW9uc30gW3JlbWF0Y2hdXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKlxuXHQgKiBAdHlwZWRlZiBSZW1hdGNoT3B0aW9uc1xuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gY2F1c2Vcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IHJlYWNoXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCBzdGFydE5vZGUsIHN0YXJ0UG9zLCByZW1hdGNoKSB7XG5cdFx0Zm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuXHRcdFx0aWYgKCFncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSB8fCAhZ3JhbW1hclt0b2tlbl0pIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwYXR0ZXJucyA9IGdyYW1tYXJbdG9rZW5dO1xuXHRcdFx0cGF0dGVybnMgPSBBcnJheS5pc0FycmF5KHBhdHRlcm5zKSA/IHBhdHRlcm5zIDogW3BhdHRlcm5zXTtcblxuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBwYXR0ZXJucy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRpZiAocmVtYXRjaCAmJiByZW1hdGNoLmNhdXNlID09IHRva2VuICsgJywnICsgaikge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBwYXR0ZXJuT2JqID0gcGF0dGVybnNbal07XG5cdFx0XHRcdHZhciBpbnNpZGUgPSBwYXR0ZXJuT2JqLmluc2lkZTtcblx0XHRcdFx0dmFyIGxvb2tiZWhpbmQgPSAhIXBhdHRlcm5PYmoubG9va2JlaGluZDtcblx0XHRcdFx0dmFyIGdyZWVkeSA9ICEhcGF0dGVybk9iai5ncmVlZHk7XG5cdFx0XHRcdHZhciBhbGlhcyA9IHBhdHRlcm5PYmouYWxpYXM7XG5cblx0XHRcdFx0aWYgKGdyZWVkeSAmJiAhcGF0dGVybk9iai5wYXR0ZXJuLmdsb2JhbCkge1xuXHRcdFx0XHRcdC8vIFdpdGhvdXQgdGhlIGdsb2JhbCBmbGFnLCBsYXN0SW5kZXggd29uJ3Qgd29ya1xuXHRcdFx0XHRcdHZhciBmbGFncyA9IHBhdHRlcm5PYmoucGF0dGVybi50b1N0cmluZygpLm1hdGNoKC9baW1zdXldKiQvKVswXTtcblx0XHRcdFx0XHRwYXR0ZXJuT2JqLnBhdHRlcm4gPSBSZWdFeHAocGF0dGVybk9iai5wYXR0ZXJuLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0LyoqIEB0eXBlIHtSZWdFeHB9ICovXG5cdFx0XHRcdHZhciBwYXR0ZXJuID0gcGF0dGVybk9iai5wYXR0ZXJuIHx8IHBhdHRlcm5PYmo7XG5cblx0XHRcdFx0Zm9yICggLy8gaXRlcmF0ZSB0aGUgdG9rZW4gbGlzdCBhbmQga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCB0b2tlbi9zdHJpbmcgcG9zaXRpb25cblx0XHRcdFx0XHR2YXIgY3VycmVudE5vZGUgPSBzdGFydE5vZGUubmV4dCwgcG9zID0gc3RhcnRQb3M7XG5cdFx0XHRcdFx0Y3VycmVudE5vZGUgIT09IHRva2VuTGlzdC50YWlsO1xuXHRcdFx0XHRcdHBvcyArPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGgsIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dFxuXHRcdFx0XHQpIHtcblxuXHRcdFx0XHRcdGlmIChyZW1hdGNoICYmIHBvcyA+PSByZW1hdGNoLnJlYWNoKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgc3RyID0gY3VycmVudE5vZGUudmFsdWU7XG5cblx0XHRcdFx0XHRpZiAodG9rZW5MaXN0Lmxlbmd0aCA+IHRleHQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHQvLyBTb21ldGhpbmcgd2VudCB0ZXJyaWJseSB3cm9uZywgQUJPUlQsIEFCT1JUIVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChzdHIgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHJlbW92ZUNvdW50ID0gMTsgLy8gdGhpcyBpcyB0aGUgdG8gcGFyYW1ldGVyIG9mIHJlbW92ZUJldHdlZW5cblx0XHRcdFx0XHR2YXIgbWF0Y2g7XG5cblx0XHRcdFx0XHRpZiAoZ3JlZWR5KSB7XG5cdFx0XHRcdFx0XHRtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCBwb3MsIHRleHQsIGxvb2tiZWhpbmQpO1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCA+PSB0ZXh0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dmFyIGZyb20gPSBtYXRjaC5pbmRleDtcblx0XHRcdFx0XHRcdHZhciB0byA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdFx0XHRcdFx0dmFyIHAgPSBwb3M7XG5cblx0XHRcdFx0XHRcdC8vIGZpbmQgdGhlIG5vZGUgdGhhdCBjb250YWlucyB0aGUgbWF0Y2hcblx0XHRcdFx0XHRcdHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPj0gcCkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHQ7XG5cdFx0XHRcdFx0XHRcdHAgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gYWRqdXN0IHBvcyAoYW5kIHApXG5cdFx0XHRcdFx0XHRwIC09IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdHBvcyA9IHA7XG5cblx0XHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBUb2tlbiwgdGhlbiB0aGUgbWF0Y2ggc3RhcnRzIGluc2lkZSBhbm90aGVyIFRva2VuLCB3aGljaCBpcyBpbnZhbGlkXG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudE5vZGUudmFsdWUgaW5zdGFuY2VvZiBUb2tlbikge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gZmluZCB0aGUgbGFzdCBub2RlIHdoaWNoIGlzIGFmZmVjdGVkIGJ5IHRoaXMgbWF0Y2hcblx0XHRcdFx0XHRcdGZvciAoXG5cdFx0XHRcdFx0XHRcdHZhciBrID0gY3VycmVudE5vZGU7XG5cdFx0XHRcdFx0XHRcdGsgIT09IHRva2VuTGlzdC50YWlsICYmIChwIDwgdG8gfHwgdHlwZW9mIGsudmFsdWUgPT09ICdzdHJpbmcnKTtcblx0XHRcdFx0XHRcdFx0ayA9IGsubmV4dFxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZUNvdW50Kys7XG5cdFx0XHRcdFx0XHRcdHAgKz0gay52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZW1vdmVDb3VudC0tO1xuXG5cdFx0XHRcdFx0XHQvLyByZXBsYWNlIHdpdGggdGhlIG5ldyBtYXRjaFxuXHRcdFx0XHRcdFx0c3RyID0gdGV4dC5zbGljZShwb3MsIHApO1xuXHRcdFx0XHRcdFx0bWF0Y2guaW5kZXggLT0gcG9zO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtYXRjaCA9IG1hdGNoUGF0dGVybihwYXR0ZXJuLCAwLCBzdHIsIGxvb2tiZWhpbmQpO1xuXHRcdFx0XHRcdFx0aWYgKCFtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cdFx0XHRcdFx0dmFyIGZyb20gPSBtYXRjaC5pbmRleDtcblx0XHRcdFx0XHR2YXIgbWF0Y2hTdHIgPSBtYXRjaFswXTtcblx0XHRcdFx0XHR2YXIgYmVmb3JlID0gc3RyLnNsaWNlKDAsIGZyb20pO1xuXHRcdFx0XHRcdHZhciBhZnRlciA9IHN0ci5zbGljZShmcm9tICsgbWF0Y2hTdHIubGVuZ3RoKTtcblxuXHRcdFx0XHRcdHZhciByZWFjaCA9IHBvcyArIHN0ci5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgcmVhY2ggPiByZW1hdGNoLnJlYWNoKSB7XG5cdFx0XHRcdFx0XHRyZW1hdGNoLnJlYWNoID0gcmVhY2g7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHJlbW92ZUZyb20gPSBjdXJyZW50Tm9kZS5wcmV2O1xuXG5cdFx0XHRcdFx0aWYgKGJlZm9yZSkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlRnJvbSA9IGFkZEFmdGVyKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgYmVmb3JlKTtcblx0XHRcdFx0XHRcdHBvcyArPSBiZWZvcmUubGVuZ3RoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlbW92ZVJhbmdlKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgcmVtb3ZlQ291bnQpO1xuXG5cdFx0XHRcdFx0dmFyIHdyYXBwZWQgPSBuZXcgVG9rZW4odG9rZW4sIGluc2lkZSA/IF8udG9rZW5pemUobWF0Y2hTdHIsIGluc2lkZSkgOiBtYXRjaFN0ciwgYWxpYXMsIG1hdGNoU3RyKTtcblx0XHRcdFx0XHRjdXJyZW50Tm9kZSA9IGFkZEFmdGVyKHRva2VuTGlzdCwgcmVtb3ZlRnJvbSwgd3JhcHBlZCk7XG5cblx0XHRcdFx0XHRpZiAoYWZ0ZXIpIHtcblx0XHRcdFx0XHRcdGFkZEFmdGVyKHRva2VuTGlzdCwgY3VycmVudE5vZGUsIGFmdGVyKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAocmVtb3ZlQ291bnQgPiAxKSB7XG5cdFx0XHRcdFx0XHQvLyBhdCBsZWFzdCBvbmUgVG9rZW4gb2JqZWN0IHdhcyByZW1vdmVkLCBzbyB3ZSBoYXZlIHRvIGRvIHNvbWUgcmVtYXRjaGluZ1xuXHRcdFx0XHRcdFx0Ly8gdGhpcyBjYW4gb25seSBoYXBwZW4gaWYgdGhlIGN1cnJlbnQgcGF0dGVybiBpcyBncmVlZHlcblxuXHRcdFx0XHRcdFx0LyoqIEB0eXBlIHtSZW1hdGNoT3B0aW9uc30gKi9cblx0XHRcdFx0XHRcdHZhciBuZXN0ZWRSZW1hdGNoID0ge1xuXHRcdFx0XHRcdFx0XHRjYXVzZTogdG9rZW4gKyAnLCcgKyBqLFxuXHRcdFx0XHRcdFx0XHRyZWFjaDogcmVhY2hcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRtYXRjaEdyYW1tYXIodGV4dCwgdG9rZW5MaXN0LCBncmFtbWFyLCBjdXJyZW50Tm9kZS5wcmV2LCBwb3MsIG5lc3RlZFJlbWF0Y2gpO1xuXG5cdFx0XHRcdFx0XHQvLyB0aGUgcmVhY2ggbWlnaHQgaGF2ZSBiZWVuIGV4dGVuZGVkIGJlY2F1c2Ugb2YgdGhlIHJlbWF0Y2hpbmdcblx0XHRcdFx0XHRcdGlmIChyZW1hdGNoICYmIG5lc3RlZFJlbWF0Y2gucmVhY2ggPiByZW1hdGNoLnJlYWNoKSB7XG5cdFx0XHRcdFx0XHRcdHJlbWF0Y2gucmVhY2ggPSBuZXN0ZWRSZW1hdGNoLnJlYWNoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBAdHlwZWRlZiBMaW5rZWRMaXN0Tm9kZVxuXHQgKiBAcHJvcGVydHkge1R9IHZhbHVlXG5cdCAqIEBwcm9wZXJ0eSB7TGlua2VkTGlzdE5vZGU8VD4gfCBudWxsfSBwcmV2IFRoZSBwcmV2aW91cyBub2RlLlxuXHQgKiBAcHJvcGVydHkge0xpbmtlZExpc3ROb2RlPFQ+IHwgbnVsbH0gbmV4dCBUaGUgbmV4dCBub2RlLlxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblxuXHQvKipcblx0ICogQHRlbXBsYXRlIFRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR2YXIgaGVhZCA9IHsgdmFsdWU6IG51bGwsIHByZXY6IG51bGwsIG5leHQ6IG51bGwgfTtcblx0XHQvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuXHRcdHZhciB0YWlsID0geyB2YWx1ZTogbnVsbCwgcHJldjogaGVhZCwgbmV4dDogbnVsbCB9O1xuXHRcdGhlYWQubmV4dCA9IHRhaWw7XG5cblx0XHQvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuXHRcdHRoaXMuaGVhZCA9IGhlYWQ7XG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR0aGlzLnRhaWwgPSB0YWlsO1xuXHRcdHRoaXMubGVuZ3RoID0gMDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgbmV3IG5vZGUgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGxpc3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxUPn0gbGlzdFxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPFQ+fSBub2RlXG5cdCAqIEBwYXJhbSB7VH0gdmFsdWVcblx0ICogQHJldHVybnMge0xpbmtlZExpc3ROb2RlPFQ+fSBUaGUgYWRkZWQgbm9kZS5cblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdGZ1bmN0aW9uIGFkZEFmdGVyKGxpc3QsIG5vZGUsIHZhbHVlKSB7XG5cdFx0Ly8gYXNzdW1lcyB0aGF0IG5vZGUgIT0gbGlzdC50YWlsICYmIHZhbHVlcy5sZW5ndGggPj0gMFxuXHRcdHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuXG5cdFx0dmFyIG5ld05vZGUgPSB7IHZhbHVlOiB2YWx1ZSwgcHJldjogbm9kZSwgbmV4dDogbmV4dCB9O1xuXHRcdG5vZGUubmV4dCA9IG5ld05vZGU7XG5cdFx0bmV4dC5wcmV2ID0gbmV3Tm9kZTtcblx0XHRsaXN0Lmxlbmd0aCsrO1xuXG5cdFx0cmV0dXJuIG5ld05vZGU7XG5cdH1cblx0LyoqXG5cdCAqIFJlbW92ZXMgYGNvdW50YCBub2RlcyBhZnRlciB0aGUgZ2l2ZW4gbm9kZS4gVGhlIGdpdmVuIG5vZGUgd2lsbCBub3QgYmUgcmVtb3ZlZC5cblx0ICpcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8VD59IG5vZGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiByZW1vdmVSYW5nZShsaXN0LCBub2RlLCBjb3VudCkge1xuXHRcdHZhciBuZXh0ID0gbm9kZS5uZXh0O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgbmV4dCAhPT0gbGlzdC50YWlsOyBpKyspIHtcblx0XHRcdG5leHQgPSBuZXh0Lm5leHQ7XG5cdFx0fVxuXHRcdG5vZGUubmV4dCA9IG5leHQ7XG5cdFx0bmV4dC5wcmV2ID0gbm9kZTtcblx0XHRsaXN0Lmxlbmd0aCAtPSBpO1xuXHR9XG5cdC8qKlxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3Rcblx0ICogQHJldHVybnMge1RbXX1cblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdGZ1bmN0aW9uIHRvQXJyYXkobGlzdCkge1xuXHRcdHZhciBhcnJheSA9IFtdO1xuXHRcdHZhciBub2RlID0gbGlzdC5oZWFkLm5leHQ7XG5cdFx0d2hpbGUgKG5vZGUgIT09IGxpc3QudGFpbCkge1xuXHRcdFx0YXJyYXkucHVzaChub2RlLnZhbHVlKTtcblx0XHRcdG5vZGUgPSBub2RlLm5leHQ7XG5cdFx0fVxuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXG5cdHJldHVybiBfO1xuXG59KCkpO1xuXG52YXIgcHJpc20gPSBQcmlzbTtcblByaXNtLmRlZmF1bHQgPSBQcmlzbTtcblxuLyogVGhpcyBjb250ZW50IGlzIGF1dG8tZ2VuZXJhdGVkIHRvIGluY2x1ZGUgc29tZSBwcmlzbWpzIGxhbmd1YWdlIGNvbXBvbmVudHM6ICovXG5cbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1hcmt1cFwiICovXG5cbnByaXNtLmxhbmd1YWdlcy5tYXJrdXAgPSB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC88IS0tKD86KD8hPCEtLSlbXFxzXFxTXSkqPy0tPi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdwcm9sb2cnOiB7XG4gICAgcGF0dGVybjogLzxcXD9bXFxzXFxTXSs/XFw/Pi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdkb2N0eXBlJzoge1xuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94bWwvI05ULWRvY3R5cGVkZWNsXG4gICAgcGF0dGVybjogLzwhRE9DVFlQRSg/OltePlwiJ1tcXF1dfFwiW15cIl0qXCJ8J1teJ10qJykrKD86XFxbKD86W148XCInXFxdXXxcIlteXCJdKlwifCdbXiddKid8PCg/ISEtLSl8PCEtLSg/OlteLV18LSg/IS0+KSkqLS0+KSpcXF1cXHMqKT8+L2ksXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2ludGVybmFsLXN1YnNldCc6IHtcbiAgICAgICAgcGF0dGVybjogLyheW15cXFtdKlxcWylbXFxzXFxTXSsoPz1cXF0+JCkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBncmVlZHk6IHRydWUsXG4gICAgICAgIGluc2lkZTogbnVsbCAvLyBzZWUgYmVsb3dcblxuICAgICAgfSxcbiAgICAgICdzdHJpbmcnOiB7XG4gICAgICAgIHBhdHRlcm46IC9cIlteXCJdKlwifCdbXiddKicvLFxuICAgICAgICBncmVlZHk6IHRydWVcbiAgICAgIH0sXG4gICAgICAncHVuY3R1YXRpb24nOiAvXjwhfD4kfFtbXFxdXS8sXG4gICAgICAnZG9jdHlwZS10YWcnOiAvXkRPQ1RZUEUvaSxcbiAgICAgICduYW1lJzogL1teXFxzPD4nXCJdKy9cbiAgICB9XG4gIH0sXG4gICdjZGF0YSc6IHtcbiAgICBwYXR0ZXJuOiAvPCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0+L2ksXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICd0YWcnOiB7XG4gICAgcGF0dGVybjogLzxcXC8/KD8hXFxkKVteXFxzPlxcLz0kPCVdKyg/Olxccyg/OlxccypbXlxccz5cXC89XSsoPzpcXHMqPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKD89W1xccz5dKSl8KD89W1xccy8+XSkpKSspP1xccypcXC8/Pi8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3RhZyc6IHtcbiAgICAgICAgcGF0dGVybjogL148XFwvP1teXFxzPlxcL10rLyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL148XFwvPy8sXG4gICAgICAgICAgJ25hbWVzcGFjZSc6IC9eW15cXHM+XFwvOl0rOi9cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdzcGVjaWFsLWF0dHInOiBbXSxcbiAgICAgICdhdHRyLXZhbHVlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKS8sXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdwdW5jdHVhdGlvbic6IFt7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvXj0vLFxuICAgICAgICAgICAgYWxpYXM6ICdhdHRyLWVxdWFscydcbiAgICAgICAgICB9LCAvXCJ8Jy9dXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAncHVuY3R1YXRpb24nOiAvXFwvPz4vLFxuICAgICAgJ2F0dHItbmFtZSc6IHtcbiAgICAgICAgcGF0dGVybjogL1teXFxzPlxcL10rLyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ25hbWVzcGFjZSc6IC9eW15cXHM+XFwvOl0rOi9cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJ2VudGl0eSc6IFt7XG4gICAgcGF0dGVybjogLyZbXFxkYS16XXsxLDh9Oy9pLFxuICAgIGFsaWFzOiAnbmFtZWQtZW50aXR5J1xuICB9LCAvJiN4P1tcXGRhLWZdezEsOH07L2ldXG59O1xucHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsndGFnJ10uaW5zaWRlWydhdHRyLXZhbHVlJ10uaW5zaWRlWydlbnRpdHknXSA9IHByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2VudGl0eSddO1xucHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsnZG9jdHlwZSddLmluc2lkZVsnaW50ZXJuYWwtc3Vic2V0J10uaW5zaWRlID0gcHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDsgLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblxucHJpc20uaG9va3MuYWRkKCd3cmFwJywgZnVuY3Rpb24gKGVudikge1xuICBpZiAoZW52LnR5cGUgPT09ICdlbnRpdHknKSB7XG4gICAgZW52LmF0dHJpYnV0ZXNbJ3RpdGxlJ10gPSBlbnYuY29udGVudC5yZXBsYWNlKC8mYW1wOy8sICcmJyk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLCAnYWRkSW5saW5lZCcsIHtcbiAgLyoqXG4gICAqIEFkZHMgYW4gaW5saW5lZCBsYW5ndWFnZSB0byBtYXJrdXAuXG4gICAqXG4gICAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgPHN0eWxlPmAgdGFncy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAqIGNhc2UgaW5zZW5zaXRpdmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIFRoZSBsYW5ndWFnZSBrZXkuXG4gICAqIEBleGFtcGxlXG4gICAqIGFkZElubGluZWQoJ3N0eWxlJywgJ2NzcycpO1xuICAgKi9cbiAgdmFsdWU6IGZ1bmN0aW9uIGFkZElubGluZWQodGFnTmFtZSwgbGFuZykge1xuICAgIHZhciBpbmNsdWRlZENkYXRhSW5zaWRlID0ge307XG4gICAgaW5jbHVkZWRDZGF0YUluc2lkZVsnbGFuZ3VhZ2UtJyArIGxhbmddID0ge1xuICAgICAgcGF0dGVybjogLyhePCFcXFtDREFUQVxcWylbXFxzXFxTXSs/KD89XFxdXFxdPiQpL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXNbbGFuZ11cbiAgICB9O1xuICAgIGluY2x1ZGVkQ2RhdGFJbnNpZGVbJ2NkYXRhJ10gPSAvXjwhXFxbQ0RBVEFcXFt8XFxdXFxdPiQvaTtcbiAgICB2YXIgaW5zaWRlID0ge1xuICAgICAgJ2luY2x1ZGVkLWNkYXRhJzoge1xuICAgICAgICBwYXR0ZXJuOiAvPCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0+L2ksXG4gICAgICAgIGluc2lkZTogaW5jbHVkZWRDZGF0YUluc2lkZVxuICAgICAgfVxuICAgIH07XG4gICAgaW5zaWRlWydsYW5ndWFnZS0nICsgbGFuZ10gPSB7XG4gICAgICBwYXR0ZXJuOiAvW1xcc1xcU10rLyxcbiAgICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzW2xhbmddXG4gICAgfTtcbiAgICB2YXIgZGVmID0ge307XG4gICAgZGVmW3RhZ05hbWVdID0ge1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oPF9fW14+XSo+KSg/OjwhXFxbQ0RBVEFcXFsoPzpbXlxcXV18XFxdKD8hXFxdPikpKlxcXVxcXT58KD8hPCFcXFtDREFUQVxcWylbXFxzXFxTXSkqPyg/PTxcXC9fXz4pLy5zb3VyY2UucmVwbGFjZSgvX18vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGFnTmFtZTtcbiAgICAgIH0pLCAnaScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogaW5zaWRlXG4gICAgfTtcbiAgICBwcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY2RhdGEnLCBkZWYpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZywgJ2FkZEF0dHJpYnV0ZScsIHtcbiAgLyoqXG4gICAqIEFkZHMgYW4gcGF0dGVybiB0byBoaWdobGlnaHQgbGFuZ3VhZ2VzIGVtYmVkZGVkIGluIEhUTUwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQW4gZXhhbXBsZSBvZiBhbiBpbmxpbmVkIGxhbmd1YWdlIGlzIENTUyB3aXRoIGBzdHlsZWAgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJOYW1lIFRoZSBuYW1lIG9mIHRoZSB0YWcgdGhhdCBjb250YWlucyB0aGUgaW5saW5lZCBsYW5ndWFnZS4gVGhpcyBuYW1lIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgKiBjYXNlIGluc2Vuc2l0aXZlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyBUaGUgbGFuZ3VhZ2Uga2V5LlxuICAgKiBAZXhhbXBsZVxuICAgKiBhZGRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2NzcycpO1xuICAgKi9cbiAgdmFsdWU6IGZ1bmN0aW9uIChhdHRyTmFtZSwgbGFuZykge1xuICAgIHByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmluc2lkZVsnc3BlY2lhbC1hdHRyJ10ucHVzaCh7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhefFtcIidcXHNdKS8uc291cmNlICsgJyg/OicgKyBhdHRyTmFtZSArICcpJyArIC9cXHMqPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKD89W1xccz5dKSkvLnNvdXJjZSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2F0dHItbmFtZSc6IC9eW15cXHM9XSsvLFxuICAgICAgICAnYXR0ci12YWx1ZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvPVtcXHNcXFNdKy8sXG4gICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAndmFsdWUnOiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IC8oXj1cXHMqKFtcIiddfCg/IVtcIiddKSkpXFxTW1xcc1xcU10qKD89XFwyJCkvLFxuICAgICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgICAgICBhbGlhczogW2xhbmcsICdsYW5ndWFnZS0nICsgbGFuZ10sXG4gICAgICAgICAgICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzW2xhbmddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogW3tcbiAgICAgICAgICAgICAgcGF0dGVybjogL149LyxcbiAgICAgICAgICAgICAgYWxpYXM6ICdhdHRyLWVxdWFscydcbiAgICAgICAgICAgIH0sIC9cInwnL11cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSk7XG5wcmlzbS5sYW5ndWFnZXMuaHRtbCA9IHByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5wcmlzbS5sYW5ndWFnZXMubWF0aG1sID0gcHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcbnByaXNtLmxhbmd1YWdlcy5zdmcgPSBwcmlzbS5sYW5ndWFnZXMubWFya3VwO1xucHJpc20ubGFuZ3VhZ2VzLnhtbCA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ21hcmt1cCcsIHt9KTtcbnByaXNtLmxhbmd1YWdlcy5zc21sID0gcHJpc20ubGFuZ3VhZ2VzLnhtbDtcbnByaXNtLmxhbmd1YWdlcy5hdG9tID0gcHJpc20ubGFuZ3VhZ2VzLnhtbDtcbnByaXNtLmxhbmd1YWdlcy5yc3MgPSBwcmlzbS5sYW5ndWFnZXMueG1sO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tYmFzaFwiICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgLy8gJCBzZXQgfCBncmVwICdeW0EtWl1bXls6c3BhY2U6XV0qPScgfCBjdXQgLWQ9IC1mMSB8IHRyICdcXG4nICd8J1xuICAvLyArIExDX0FMTCwgUkFORE9NLCBSRVBMWSwgU0VDT05EUy5cbiAgLy8gKyBtYWtlIHN1cmUgUFMxLi40IGFyZSBoZXJlIGFzIHRoZXkgYXJlIG5vdCBhbHdheXMgc2V0LFxuICAvLyAtIHNvbWUgdXNlbGVzcyB0aGluZ3MuXG4gIHZhciBlbnZWYXJzID0gJ1xcXFxiKD86QkFTSHxCQVNIT1BUU3xCQVNIX0FMSUFTRVN8QkFTSF9BUkdDfEJBU0hfQVJHVnxCQVNIX0NNRFN8QkFTSF9DT01QTEVUSU9OX0NPTVBBVF9ESVJ8QkFTSF9MSU5FTk98QkFTSF9SRU1BVENIfEJBU0hfU09VUkNFfEJBU0hfVkVSU0lORk98QkFTSF9WRVJTSU9OfENPTE9SVEVSTXxDT0xVTU5TfENPTVBfV09SREJSRUFLU3xEQlVTX1NFU1NJT05fQlVTX0FERFJFU1N8REVGQVVMVFNfUEFUSHxERVNLVE9QX1NFU1NJT058RElSU1RBQ0t8RElTUExBWXxFVUlEfEdETVNFU1NJT058R0RNX0xBTkd8R05PTUVfS0VZUklOR19DT05UUk9MfEdOT01FX0tFWVJJTkdfUElEfEdQR19BR0VOVF9JTkZPfEdST1VQU3xISVNUQ09OVFJPTHxISVNURklMRXxISVNURklMRVNJWkV8SElTVFNJWkV8SE9NRXxIT1NUTkFNRXxIT1NUVFlQRXxJRlN8SU5TVEFOQ0V8Sk9CfExBTkd8TEFOR1VBR0V8TENfQUREUkVTU3xMQ19BTEx8TENfSURFTlRJRklDQVRJT058TENfTUVBU1VSRU1FTlR8TENfTU9ORVRBUll8TENfTkFNRXxMQ19OVU1FUklDfExDX1BBUEVSfExDX1RFTEVQSE9ORXxMQ19USU1FfExFU1NDTE9TRXxMRVNTT1BFTnxMSU5FU3xMT0dOQU1FfExTX0NPTE9SU3xNQUNIVFlQRXxNQUlMQ0hFQ0t8TUFOREFUT1JZX1BBVEh8Tk9fQVRfQlJJREdFfE9MRFBXRHxPUFRFUlJ8T1BUSU5EfE9SQklUX1NPQ0tFVERJUnxPU1RZUEV8UEFQRVJTSVpFfFBBVEh8UElQRVNUQVRVU3xQUElEfFBTMXxQUzJ8UFMzfFBTNHxQV0R8UkFORE9NfFJFUExZfFNFQ09ORFN8U0VMSU5VWF9JTklUfFNFU1NJT058U0VTU0lPTlRZUEV8U0VTU0lPTl9NQU5BR0VSfFNIRUxMfFNIRUxMT1BUU3xTSExWTHxTU0hfQVVUSF9TT0NLfFRFUk18VUlEfFVQU1RBUlRfRVZFTlRTfFVQU1RBUlRfSU5TVEFOQ0V8VVBTVEFSVF9KT0J8VVBTVEFSVF9TRVNTSU9OfFVTRVJ8V0lORE9XSUR8WEFVVEhPUklUWXxYREdfQ09ORklHX0RJUlN8WERHX0NVUlJFTlRfREVTS1RPUHxYREdfREFUQV9ESVJTfFhER19HUkVFVEVSX0RBVEFfRElSfFhER19NRU5VX1BSRUZJWHxYREdfUlVOVElNRV9ESVJ8WERHX1NFQVR8WERHX1NFQVRfUEFUSHxYREdfU0VTU0lPTl9ERVNLVE9QfFhER19TRVNTSU9OX0lEfFhER19TRVNTSU9OX1BBVEh8WERHX1NFU1NJT05fVFlQRXxYREdfVlROUnxYTU9ESUZJRVJTKVxcXFxiJztcbiAgdmFyIGNvbW1hbmRBZnRlckhlcmVkb2MgPSB7XG4gICAgcGF0dGVybjogLyheKFtcIiddPylcXHcrXFwyKVsgXFx0XStcXFMuKi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ3B1bmN0dWF0aW9uJyxcbiAgICAvLyB0aGlzIGxvb2tzIHJlYXNvbmFibHkgd2VsbCBpbiBhbGwgdGhlbWVzXG4gICAgaW5zaWRlOiBudWxsIC8vIHNlZSBiZWxvd1xuXG4gIH07XG4gIHZhciBpbnNpZGVTdHJpbmcgPSB7XG4gICAgJ2Jhc2gnOiBjb21tYW5kQWZ0ZXJIZXJlZG9jLFxuICAgICdlbnZpcm9ubWVudCc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXFxcXCQnICsgZW52VmFycyksXG4gICAgICBhbGlhczogJ2NvbnN0YW50J1xuICAgIH0sXG4gICAgJ3ZhcmlhYmxlJzogWy8vIFswXTogQXJpdGhtZXRpYyBFbnZpcm9ubWVudFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC9cXCQ/XFwoXFwoW1xcc1xcU10rP1xcKVxcKS8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSAkIHNpZ24gYXQgdGhlIGJlZ2lubmluZyBoaWdobGlnaHQgJCgoIGFuZCApKSBhcyB2YXJpYWJsZVxuICAgICAgICAndmFyaWFibGUnOiBbe1xuICAgICAgICAgIHBhdHRlcm46IC8oXlxcJFxcKFxcKFtcXHNcXFNdKylcXClcXCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSwgL15cXCRcXChcXCgvXSxcbiAgICAgICAgJ251bWJlcic6IC9cXGIweFtcXGRBLUZhLWZdK1xcYnwoPzpcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86W0VlXS0/XFxkKyk/LyxcbiAgICAgICAgLy8gT3BlcmF0b3JzIGFjY29yZGluZyB0byBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2Jhc2hyZWYuaHRtbCNTaGVsbC1Bcml0aG1ldGljXG4gICAgICAgICdvcGVyYXRvcic6IC8tLXxcXCtcXCt8XFwqXFwqPT98PDw9P3w+Pj0/fCYmfFxcfFxcfHxbPSErXFwtKi8lPD5eJnxdPT98Wz9+Ol0vLFxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyAkIHNpZ24gYXQgdGhlIGJlZ2lubmluZyBoaWdobGlnaHQgKCggYW5kICkpIGFzIHB1bmN0dWF0aW9uXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXChcXCg/fFxcKVxcKT98LHw7L1xuICAgICAgfVxuICAgIH0sIC8vIFsxXTogQ29tbWFuZCBTdWJzdGl0dXRpb25cbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvXFwkXFwoKD86XFwoW14pXStcXCl8W14oKV0pK1xcKXxgW15gXStgLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndmFyaWFibGUnOiAvXlxcJFxcKHxeYHxcXCkkfGAkL1xuICAgICAgfVxuICAgIH0sIC8vIFsyXTogQnJhY2UgZXhwYW5zaW9uXG4gICAge1xuICAgICAgcGF0dGVybjogL1xcJFxce1tefV0rXFx9LyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnb3BlcmF0b3InOiAvOlstPT8rXT98WyFcXC9dfCMjP3wlJT98XFxeXFxeP3wsLD8vLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvW1xcW1xcXV0vLFxuICAgICAgICAnZW52aXJvbm1lbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCcoXFxcXHspJyArIGVudlZhcnMpLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgYWxpYXM6ICdjb25zdGFudCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIC9cXCQoPzpcXHcrfFsjPyohQCRdKS9dLFxuICAgIC8vIEVzY2FwZSBzZXF1ZW5jZXMgZnJvbSBlY2hvIGFuZCBwcmludGYncyBtYW51YWxzLCBhbmQgZXNjYXBlZCBxdW90ZXMuXG4gICAgJ2VudGl0eSc6IC9cXFxcKD86W2FiY2VFZm5ydHZcXFxcXCJdfE8/WzAtN117MSwzfXxVWzAtOWEtZkEtRl17OH18dVswLTlhLWZBLUZdezR9fHhbMC05YS1mQS1GXXsxLDJ9KS9cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmJhc2ggPSB7XG4gICAgJ3NoZWJhbmcnOiB7XG4gICAgICBwYXR0ZXJuOiAvXiMhXFxzKlxcLy4qLyxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ2NvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cIntcXFxcJF0pIy4qLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdmdW5jdGlvbi1uYW1lJzogWy8vIGEpIGZ1bmN0aW9uIGZvbyB7XG4gICAgLy8gYikgZm9vKCkge1xuICAgIC8vIGMpIGZ1bmN0aW9uIGZvbygpIHtcbiAgICAvLyBidXQgbm90IOKAnGZvbyB74oCdXG4gICAge1xuICAgICAgLy8gYSkgYW5kIGMpXG4gICAgICBwYXR0ZXJuOiAvKFxcYmZ1bmN0aW9uXFxzKylbXFx3LV0rKD89KD86XFxzKlxcKD86XFxzKlxcKSk/XFxzKlxceykvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gICAgfSwge1xuICAgICAgLy8gYilcbiAgICAgIHBhdHRlcm46IC9cXGJbXFx3LV0rKD89XFxzKlxcKFxccypcXClcXHMqXFx7KS8sXG4gICAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICAgIH1dLFxuICAgIC8vIEhpZ2hsaWdodCB2YXJpYWJsZSBuYW1lcyBhcyB2YXJpYWJsZXMgaW4gZm9yIGFuZCBzZWxlY3QgYmVnaW5uaW5ncy5cbiAgICAnZm9yLW9yLXNlbGVjdCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxiKD86Zm9yfHNlbGVjdClcXHMrKVxcdysoPz1cXHMraW5cXHMpLyxcbiAgICAgIGFsaWFzOiAndmFyaWFibGUnLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gSGlnaGxpZ2h0IHZhcmlhYmxlIG5hbWVzIGFzIHZhcmlhYmxlcyBpbiB0aGUgbGVmdC1oYW5kIHBhcnRcbiAgICAvLyBvZiBhc3NpZ25tZW50cyAo4oCcPeKAnSBhbmQg4oCcKz3igJ0pLlxuICAgICdhc3NpZ24tbGVmdCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKVxcdysoPz1cXCs/PSkvLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdlbnZpcm9ubWVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhefFtcXFxcczt8Jl18Wzw+XVxcXFwoKScgKyBlbnZWYXJzKSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGFsaWFzOiAnY29uc3RhbnQnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhbGlhczogJ3ZhcmlhYmxlJyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdzdHJpbmcnOiBbLy8gU3VwcG9ydCBmb3IgSGVyZS1kb2N1bWVudHMgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGVyZV9kb2N1bWVudFxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8oKD86XnxbXjxdKTw8LT9cXHMqKShcXHcrKVxcc1tcXHNcXFNdKj8oPzpcXHI/XFxufFxccilcXDIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogaW5zaWRlU3RyaW5nXG4gICAgfSwgLy8gSGVyZS1kb2N1bWVudCB3aXRoIHF1b3RlcyBhcm91bmQgdGhlIHRhZ1xuICAgIC8vIOKGkiBObyBleHBhbnNpb24gKHNvIG5vIOKAnGluc2lkZeKAnSkuXG4gICAge1xuICAgICAgcGF0dGVybjogLygoPzpefFtePF0pPDwtP1xccyopKFtcIiddKShcXHcrKVxcMlxcc1tcXHNcXFNdKj8oPzpcXHI/XFxufFxccilcXDMvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnYmFzaCc6IGNvbW1hbmRBZnRlckhlcmVkb2NcbiAgICAgIH1cbiAgICB9LCAvLyDigJxOb3JtYWzigJ0gc3RyaW5nXG4gICAge1xuICAgICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvRG91YmxlLVF1b3Rlcy5odG1sXG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSg/OlxcXFxcXFxcKSopXCIoPzpcXFxcW1xcc1xcU118XFwkXFwoW14pXStcXCl8XFwkKD8hXFwoKXxgW15gXStgfFteXCJcXFxcYCRdKSpcIi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBpbnNpZGVTdHJpbmdcbiAgICB9LCB7XG4gICAgICAvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9TaW5nbGUtUXVvdGVzLmh0bWxcbiAgICAgIHBhdHRlcm46IC8oXnxbXiRcXFxcXSknW14nXSonLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LCB7XG4gICAgICAvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9BTlNJXzAwMmRDLVF1b3RpbmcuaHRtbFxuICAgICAgcGF0dGVybjogL1xcJCcoPzpbXidcXFxcXXxcXFxcW1xcc1xcU10pKicvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdlbnRpdHknOiBpbnNpZGVTdHJpbmcuZW50aXR5XG4gICAgICB9XG4gICAgfV0sXG4gICAgJ2Vudmlyb25tZW50Jzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdcXFxcJD8nICsgZW52VmFycyksXG4gICAgICBhbGlhczogJ2NvbnN0YW50J1xuICAgIH0sXG4gICAgJ3ZhcmlhYmxlJzogaW5zaWRlU3RyaW5nLnZhcmlhYmxlLFxuICAgICdmdW5jdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OmFkZHxhcHJvcG9zfGFwdHxhcHQtY2FjaGV8YXB0LWdldHxhcHRpdHVkZXxhc3BlbGx8YXV0b215c3FsYmFja3VwfGF3a3xiYXNlbmFtZXxiYXNofGJjfGJjb25zb2xlfGJnfGJ6aXAyfGNhbHxjYXR8Y2ZkaXNrfGNoZ3JwfGNoa2NvbmZpZ3xjaG1vZHxjaG93bnxjaHJvb3R8Y2tzdW18Y2xlYXJ8Y21wfGNvbHVtbnxjb21tfGNvbXBvc2VyfGNwfGNyb258Y3JvbnRhYnxjc3BsaXR8Y3VybHxjdXR8ZGF0ZXxkY3xkZHxkZHJlc2N1ZXxkZWJvb3RzdHJhcHxkZnxkaWZmfGRpZmYzfGRpZ3xkaXJ8ZGlyY29sb3JzfGRpcm5hbWV8ZGlyc3xkbWVzZ3xkb2NrZXJ8ZG9ja2VyLWNvbXBvc2V8ZHV8ZWdyZXB8ZWplY3R8ZW52fGV0aHRvb2x8ZXhwYW5kfGV4cGVjdHxleHByfGZkZm9ybWF0fGZkaXNrfGZnfGZncmVwfGZpbGV8ZmluZHxmbXR8Zm9sZHxmb3JtYXR8ZnJlZXxmc2NrfGZ0cHxmdXNlcnxnYXdrfGdpdHxncGFydGVkfGdyZXB8Z3JvdXBhZGR8Z3JvdXBkZWx8Z3JvdXBtb2R8Z3JvdXBzfGdydWItbWtjb25maWd8Z3ppcHxoYWx0fGhlYWR8aGd8aGlzdG9yeXxob3N0fGhvc3RuYW1lfGh0b3B8aWNvbnZ8aWR8aWZjb25maWd8aWZkb3dufGlmdXB8aW1wb3J0fGluc3RhbGx8aXB8am9ic3xqb2lufGtpbGx8a2lsbGFsbHxsZXNzfGxpbmt8bG58bG9jYXRlfGxvZ25hbWV8bG9ncm90YXRlfGxvb2t8bHBjfGxwcnxscHJpbnR8bHByaW50ZHxscHJpbnRxfGxwcm18bHN8bHNvZnxseW54fG1ha2V8bWFufG1jfG1kYWRtfG1rY29uZmlnfG1rZGlyfG1rZTJmc3xta2ZpZm98bWtmc3xta2lzb2ZzfG1rbm9kfG1rc3dhcHxtbXZ8bW9yZXxtb3N0fG1vdW50fG10b29sc3xtdHJ8bXV0dHxtdnxuYW5vfG5jfG5ldHN0YXR8bmljZXxubHxub2RlfG5vaHVwfG5vdGlmeS1zZW5kfG5wbXxuc2xvb2t1cHxvcHxvcGVufHBhcnRlZHxwYXNzd2R8cGFzdGV8cGF0aGNoa3xwaW5nfHBraWxsfHBucG18cG9kbWFufHBvZG1hbi1jb21wb3NlfHBvcGR8cHJ8cHJpbnRjYXB8cHJpbnRlbnZ8cHN8cHVzaGR8cHZ8cXVvdGF8cXVvdGFjaGVja3xxdW90YWN0bHxyYW18cmFyfHJjcHxyZWJvb3R8cmVtc3luY3xyZW5hbWV8cmVuaWNlfHJldnxybXxybWRpcnxycG18cnN5bmN8c2NwfHNjcmVlbnxzZGlmZnxzZWR8c2VuZG1haWx8c2VxfHNlcnZpY2V8c2Z0cHxzaHxzaGVsbGNoZWNrfHNodWZ8c2h1dGRvd258c2xlZXB8c2xvY2F0ZXxzb3J0fHNwbGl0fHNzaHxzdGF0fHN0cmFjZXxzdXxzdWRvfHN1bXxzdXNwZW5kfHN3YXBvbnxzeW5jfHRhY3x0YWlsfHRhcnx0ZWV8dGltZXx0aW1lb3V0fHRvcHx0b3VjaHx0cnx0cmFjZXJvdXRlfHRzb3J0fHR0eXx1bW91bnR8dW5hbWV8dW5leHBhbmR8dW5pcXx1bml0c3x1bnJhcnx1bnNoYXJ8dW56aXB8dXBkYXRlLWdydWJ8dXB0aW1lfHVzZXJhZGR8dXNlcmRlbHx1c2VybW9kfHVzZXJzfHV1ZGVjb2RlfHV1ZW5jb2RlfHZ8dmNwa2d8dmRpcnx2aXx2aW18dmlyc2h8dm1zdGF0fHdhaXR8d2F0Y2h8d2N8d2dldHx3aGVyZWlzfHdoaWNofHdob3x3aG9hbWl8d3JpdGV8eGFyZ3N8eGRnLW9wZW58eWFybnx5ZXN8emVuaXR5fHppcHx6c2h8enlwcGVyKSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAna2V5d29yZCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OmNhc2V8ZG98ZG9uZXxlbGlmfGVsc2V8ZXNhY3xmaXxmb3J8ZnVuY3Rpb258aWZ8aW58c2VsZWN0fHRoZW58dW50aWx8d2hpbGUpKD89JHxbKVxcczt8Jl0pLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL1NoZWxsLUJ1aWx0aW4tQ29tbWFuZHMuaHRtbFxuICAgICdidWlsdGluJzoge1xuICAgICAgcGF0dGVybjogLyhefFtcXHM7fCZdfFs8Pl1cXCgpKD86XFwufDp8YWxpYXN8YmluZHxicmVha3xidWlsdGlufGNhbGxlcnxjZHxjb21tYW5kfGNvbnRpbnVlfGRlY2xhcmV8ZWNob3xlbmFibGV8ZXZhbHxleGVjfGV4aXR8ZXhwb3J0fGdldG9wdHN8aGFzaHxoZWxwfGxldHxsb2NhbHxsb2dvdXR8bWFwZmlsZXxwcmludGZ8cHdkfHJlYWR8cmVhZGFycmF5fHJlYWRvbmx5fHJldHVybnxzZXR8c2hpZnR8c2hvcHR8c291cmNlfHRlc3R8dGltZXN8dHJhcHx0eXBlfHR5cGVzZXR8dWxpbWl0fHVtYXNrfHVuYWxpYXN8dW5zZXQpKD89JHxbKVxcczt8Jl0pLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAvLyBBbGlhcyBhZGRlZCB0byBtYWtlIHRob3NlIGVhc2llciB0byBkaXN0aW5ndWlzaCBmcm9tIHN0cmluZ3MuXG4gICAgICBhbGlhczogJ2NsYXNzLW5hbWUnXG4gICAgfSxcbiAgICAnYm9vbGVhbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OmZhbHNlfHRydWUpKD89JHxbKVxcczt8Jl0pLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdmaWxlLWRlc2NyaXB0b3InOiB7XG4gICAgICBwYXR0ZXJuOiAvXFxCJlxcZFxcYi8sXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdvcGVyYXRvcic6IHtcbiAgICAgIC8vIExvdHMgb2YgcmVkaXJlY3Rpb25zIGhlcmUsIGJ1dCBub3QganVzdCB0aGF0LlxuICAgICAgcGF0dGVybjogL1xcZD88Pnw+XFx8fFxcKz18PVs9fl0/fCE9P3w8PFs8LV0/fFsmXFxkXT8+PnxcXGRbPD5dJj98Wzw+XVsmPV0/fCZbPiZdP3xcXHxbJnxdPy8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2ZpbGUtZGVzY3JpcHRvcic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXlxcZC8sXG4gICAgICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdwdW5jdHVhdGlvbic6IC9cXCQ/XFwoXFwoP3xcXClcXCk/fFxcLlxcLnxbe31bXFxdO1xcXFxdLyxcbiAgICAnbnVtYmVyJzoge1xuICAgICAgcGF0dGVybjogLyhefFxccykoPzpbMS05XVxcZCp8MCkoPzpbLixdXFxkKyk/XFxiLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9XG4gIH07XG4gIGNvbW1hbmRBZnRlckhlcmVkb2MuaW5zaWRlID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2g7XG4gIC8qIFBhdHRlcm5zIGluIGNvbW1hbmQgc3Vic3RpdHV0aW9uLiAqL1xuXG4gIHZhciB0b0JlQ29waWVkID0gWydjb21tZW50JywgJ2Z1bmN0aW9uLW5hbWUnLCAnZm9yLW9yLXNlbGVjdCcsICdhc3NpZ24tbGVmdCcsICdzdHJpbmcnLCAnZW52aXJvbm1lbnQnLCAnZnVuY3Rpb24nLCAna2V5d29yZCcsICdidWlsdGluJywgJ2Jvb2xlYW4nLCAnZmlsZS1kZXNjcmlwdG9yJywgJ29wZXJhdG9yJywgJ3B1bmN0dWF0aW9uJywgJ251bWJlciddO1xuICB2YXIgaW5zaWRlID0gaW5zaWRlU3RyaW5nLnZhcmlhYmxlWzFdLmluc2lkZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRvQmVDb3BpZWQubGVuZ3RoOyBpKyspIHtcbiAgICBpbnNpZGVbdG9CZUNvcGllZFtpXV0gPSBQcmlzbS5sYW5ndWFnZXMuYmFzaFt0b0JlQ29waWVkW2ldXTtcbiAgfVxuXG4gIFByaXNtLmxhbmd1YWdlcy5zaGVsbCA9IFByaXNtLmxhbmd1YWdlcy5iYXNoO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY2xpa2VcIiAqL1xuXG5cbnByaXNtLmxhbmd1YWdlcy5jbGlrZSA9IHtcbiAgJ2NvbW1lbnQnOiBbe1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcOl0pXFwvXFwvLiovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH1dLFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdjbGFzcy1uYW1lJzoge1xuICAgIHBhdHRlcm46IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ld3x0cmFpdClcXHMrfFxcYmNhdGNoXFxzK1xcKClbXFx3LlxcXFxdKy9pLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvWy5cXFxcXS9cbiAgICB9XG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/OmJyZWFrfGNhdGNofGNvbnRpbnVlfGRvfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258aWZ8aW58aW5zdGFuY2VvZnxuZXd8bnVsbHxyZXR1cm58dGhyb3d8dHJ5fHdoaWxlKVxcYi8sXG4gICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgJ2Z1bmN0aW9uJzogL1xcYlxcdysoPz1cXCgpLyxcbiAgJ251bWJlcic6IC9cXGIweFtcXGRhLWZdK1xcYnwoPzpcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86ZVsrLV0/XFxkKyk/L2ksXG4gICdvcGVyYXRvcic6IC9bPD5dPT98WyE9XT0/PT98LS0/fFxcK1xcKz98JiY/fFxcfFxcfD98Wz8qL35eJV0vLFxuICAncHVuY3R1YXRpb24nOiAvW3t9W1xcXTsoKSwuOl0vXG59O1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY1wiICovXG5cbnByaXNtLmxhbmd1YWdlcy5jID0gcHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICdjb21tZW50Jzoge1xuICAgIHBhdHRlcm46IC9cXC9cXC8oPzpbXlxcclxcblxcXFxdfFxcXFwoPzpcXHJcXG4/fFxcbnwoPyFbXFxyXFxuXSkpKSp8XFwvXFwqW1xcc1xcU10qPyg/OlxcKlxcL3wkKS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdzdHJpbmcnOiB7XG4gICAgLy8gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvYy9sYW5ndWFnZS9zdHJpbmdfbGl0ZXJhbFxuICAgIHBhdHRlcm46IC9cIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCIvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnY2xhc3MtbmFtZSc6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYig/OmVudW18c3RydWN0KVxccysoPzpfX2F0dHJpYnV0ZV9fXFxzKlxcKFxcKFtcXHNcXFNdKj9cXClcXClcXHMqKT8pXFx3K3xcXGJbYS16XVxcdypfdFxcYi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpfQWxpZ25hc3xfQWxpZ25vZnxfQXRvbWljfF9Cb29sfF9Db21wbGV4fF9HZW5lcmljfF9JbWFnaW5hcnl8X05vcmV0dXJufF9TdGF0aWNfYXNzZXJ0fF9UaHJlYWRfbG9jYWx8X19hdHRyaWJ1dGVfX3xhc218YXV0b3xicmVha3xjYXNlfGNoYXJ8Y29uc3R8Y29udGludWV8ZGVmYXVsdHxkb3xkb3VibGV8ZWxzZXxlbnVtfGV4dGVybnxmbG9hdHxmb3J8Z290b3xpZnxpbmxpbmV8aW50fGxvbmd8cmVnaXN0ZXJ8cmV0dXJufHNob3J0fHNpZ25lZHxzaXplb2Z8c3RhdGljfHN0cnVjdHxzd2l0Y2h8dHlwZWRlZnx0eXBlb2Z8dW5pb258dW5zaWduZWR8dm9pZHx2b2xhdGlsZXx3aGlsZSlcXGIvLFxuICAnZnVuY3Rpb24nOiAvXFxiW2Etel9dXFx3Kig/PVxccypcXCgpL2ksXG4gICdudW1iZXInOiAvKD86XFxiMHgoPzpbXFxkYS1mXSsoPzpcXC5bXFxkYS1mXSopP3xcXC5bXFxkYS1mXSspKD86cFsrLV0/XFxkKyk/fCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8pW2Z1bF17MCw0fS9pLFxuICAnb3BlcmF0b3InOiAvPj49P3w8PD0/fC0+fChbLSsmfDpdKVxcMXxbPzp+XXxbLSsqLyUmfF4hPTw+XT0/L1xufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjJywgJ3N0cmluZycsIHtcbiAgJ2NoYXInOiB7XG4gICAgLy8gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvYy9sYW5ndWFnZS9jaGFyYWN0ZXJfY29uc3RhbnRcbiAgICBwYXR0ZXJuOiAvJyg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteJ1xcXFxcXHJcXG5dKXswLDMyfScvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2MnLCAnc3RyaW5nJywge1xuICAnbWFjcm8nOiB7XG4gICAgLy8gYWxsb3cgZm9yIG11bHRpbGluZSBtYWNybyBkZWZpbml0aW9uc1xuICAgIC8vIHNwYWNlcyBhZnRlciB0aGUgIyBjaGFyYWN0ZXIgY29tcGlsZSBmaW5lIHdpdGggZ2NjXG4gICAgcGF0dGVybjogLyheW1xcdCBdKikjXFxzKlthLXpdKD86W15cXHJcXG5cXFxcL118XFwvKD8hXFwqKXxcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKlxcKlxcL3xcXFxcKD86XFxyXFxufFtcXHNcXFNdKSkqL2ltLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGFsaWFzOiAncHJvcGVydHknLFxuICAgIGluc2lkZToge1xuICAgICAgJ3N0cmluZyc6IFt7XG4gICAgICAgIC8vIGhpZ2hsaWdodCB0aGUgcGF0aCBvZiB0aGUgaW5jbHVkZSBzdGF0ZW1lbnQgYXMgYSBzdHJpbmdcbiAgICAgICAgcGF0dGVybjogL14oI1xccyppbmNsdWRlXFxzKik8W14+XSs+LyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgfSwgcHJpc20ubGFuZ3VhZ2VzLmNbJ3N0cmluZyddXSxcbiAgICAgICdjaGFyJzogcHJpc20ubGFuZ3VhZ2VzLmNbJ2NoYXInXSxcbiAgICAgICdjb21tZW50JzogcHJpc20ubGFuZ3VhZ2VzLmNbJ2NvbW1lbnQnXSxcbiAgICAgICdtYWNyby1uYW1lJzogW3tcbiAgICAgICAgcGF0dGVybjogLyheI1xccypkZWZpbmVcXHMrKVxcdytcXGIoPyFcXCgpL2ksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcGF0dGVybjogLyheI1xccypkZWZpbmVcXHMrKVxcdytcXGIoPz1cXCgpL2ksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gICAgICB9XSxcbiAgICAgIC8vIGhpZ2hsaWdodCBtYWNybyBkaXJlY3RpdmVzIGFzIGtleXdvcmRzXG4gICAgICAnZGlyZWN0aXZlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXigjXFxzKilbYS16XSsvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgICB9LFxuICAgICAgJ2RpcmVjdGl2ZS1oYXNoJzogL14jLyxcbiAgICAgICdwdW5jdHVhdGlvbic6IC8jI3xcXFxcKD89W1xcclxcbl0pLyxcbiAgICAgICdleHByZXNzaW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXFxTW1xcc1xcU10qLyxcbiAgICAgICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXMuY1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjJywgJ2Z1bmN0aW9uJywge1xuICAvLyBoaWdobGlnaHQgcHJlZGVmaW5lZCBtYWNyb3MgYXMgY29uc3RhbnRzXG4gICdjb25zdGFudCc6IC9cXGIoPzpFT0Z8TlVMTHxTRUVLX0NVUnxTRUVLX0VORHxTRUVLX1NFVHxfX0RBVEVfX3xfX0ZJTEVfX3xfX0xJTkVfX3xfX1RJTUVTVEFNUF9ffF9fVElNRV9ffF9fZnVuY19ffHN0ZGVycnxzdGRpbnxzdGRvdXQpXFxiL1xufSk7XG5kZWxldGUgcHJpc20ubGFuZ3VhZ2VzLmNbJ2Jvb2xlYW4nXTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNwcFwiICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIGtleXdvcmQgPSAvXFxiKD86YWxpZ25hc3xhbGlnbm9mfGFzbXxhdXRvfGJvb2x8YnJlYWt8Y2FzZXxjYXRjaHxjaGFyfGNoYXIxNl90fGNoYXIzMl90fGNoYXI4X3R8Y2xhc3N8Y29fYXdhaXR8Y29fcmV0dXJufGNvX3lpZWxkfGNvbXBsfGNvbmNlcHR8Y29uc3R8Y29uc3RfY2FzdHxjb25zdGV2YWx8Y29uc3RleHByfGNvbnN0aW5pdHxjb250aW51ZXxkZWNsdHlwZXxkZWZhdWx0fGRlbGV0ZXxkb3xkb3VibGV8ZHluYW1pY19jYXN0fGVsc2V8ZW51bXxleHBsaWNpdHxleHBvcnR8ZXh0ZXJufGZpbmFsfGZsb2F0fGZvcnxmcmllbmR8Z290b3xpZnxpbXBvcnR8aW5saW5lfGludHxpbnQxNl90fGludDMyX3R8aW50NjRfdHxpbnQ4X3R8bG9uZ3xtb2R1bGV8bXV0YWJsZXxuYW1lc3BhY2V8bmV3fG5vZXhjZXB0fG51bGxwdHJ8b3BlcmF0b3J8b3ZlcnJpZGV8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJlZ2lzdGVyfHJlaW50ZXJwcmV0X2Nhc3R8cmVxdWlyZXN8cmV0dXJufHNob3J0fHNpZ25lZHxzaXplb2Z8c3RhdGljfHN0YXRpY19hc3NlcnR8c3RhdGljX2Nhc3R8c3RydWN0fHN3aXRjaHx0ZW1wbGF0ZXx0aGlzfHRocmVhZF9sb2NhbHx0aHJvd3x0cnl8dHlwZWRlZnx0eXBlaWR8dHlwZW5hbWV8dWludDE2X3R8dWludDMyX3R8dWludDY0X3R8dWludDhfdHx1bmlvbnx1bnNpZ25lZHx1c2luZ3x2aXJ0dWFsfHZvaWR8dm9sYXRpbGV8d2NoYXJfdHx3aGlsZSlcXGIvO1xuICB2YXIgbW9kTmFtZSA9IC9cXGIoPyE8a2V5d29yZD4pXFx3Kyg/OlxccypcXC5cXHMqXFx3KykqXFxiLy5zb3VyY2UucmVwbGFjZSgvPGtleXdvcmQ+L2csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ga2V5d29yZC5zb3VyY2U7XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuY3BwID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnYycsIHtcbiAgICAnY2xhc3MtbmFtZSc6IFt7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhcXGIoPzpjbGFzc3xjb25jZXB0fGVudW18c3RydWN0fHR5cGVuYW1lKVxccyspKD8hPGtleXdvcmQ+KVxcdysvLnNvdXJjZS5yZXBsYWNlKC88a2V5d29yZD4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ga2V5d29yZC5zb3VyY2U7XG4gICAgICB9KSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSwgLy8gVGhpcyBpcyBpbnRlbmRlZCB0byBjYXB0dXJlIHRoZSBjbGFzcyBuYW1lIG9mIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMgbGlrZTpcbiAgICAvLyAgIHZvaWQgZm9vOjpiYXIoKSBjb25zdCB7fVxuICAgIC8vIEhvd2V2ZXIhIFRoZSBgZm9vYCBpbiB0aGUgYWJvdmUgZXhhbXBsZSBjb3VsZCBhbHNvIGJlIGEgbmFtZXNwYWNlLCBzbyB3ZSBvbmx5IGNhcHR1cmUgdGhlIGNsYXNzIG5hbWUgaWZcbiAgICAvLyBpdCBzdGFydHMgd2l0aCBhbiB1cHBlcmNhc2UgbGV0dGVyLiBUaGlzIGFwcHJveGltYXRpb24gc2hvdWxkIGdpdmUgZGVjZW50IHJlc3VsdHMuXG4gICAgL1xcYltBLVpdXFx3Kig/PVxccyo6OlxccypcXHcrXFxzKlxcKCkvLCAvLyBUaGlzIHdpbGwgY2FwdHVyZSB0aGUgY2xhc3MgbmFtZSBiZWZvcmUgZGVzdHJ1Y3RvcnMgbGlrZTpcbiAgICAvLyAgIEZvbzo6fkZvbygpIHt9XG4gICAgL1xcYltBLVpfXVxcdyooPz1cXHMqOjpcXHMqflxcdytcXHMqXFwoKS9pLCAvLyBUaGlzIGFsc28gaW50ZW5kcyB0byBjYXB0dXJlIHRoZSBjbGFzcyBuYW1lIG9mIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnMgYnV0IGhlcmUgdGhlIGNsYXNzIGhhcyB0ZW1wbGF0ZVxuICAgIC8vIHBhcmFtZXRlcnMsIHNvIGl0IGNhbid0IGJlIGEgbmFtZXNwYWNlICh1bnRpbCBDKysgYWRkcyBnZW5lcmljIG5hbWVzcGFjZXMpLlxuICAgIC9cXGJcXHcrKD89XFxzKjwoPzpbXjw+XXw8KD86W148Pl18PFtePD5dKj4pKj4pKj5cXHMqOjpcXHMqXFx3K1xccypcXCgpL10sXG4gICAgJ2tleXdvcmQnOiBrZXl3b3JkLFxuICAgICdudW1iZXInOiB7XG4gICAgICBwYXR0ZXJuOiAvKD86XFxiMGJbMDEnXSt8XFxiMHgoPzpbXFxkYS1mJ10rKD86XFwuW1xcZGEtZiddKik/fFxcLltcXGRhLWYnXSspKD86cFsrLV0/W1xcZCddKyk/fCg/OlxcYltcXGQnXSsoPzpcXC5bXFxkJ10qKT98XFxCXFwuW1xcZCddKykoPzplWystXT9bXFxkJ10rKT8pW2Z1bF17MCw0fS9pLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAnb3BlcmF0b3InOiAvPj49P3w8PD0/fC0+fC0tfFxcK1xcK3wmJnxcXHxcXHx8Wz86fl18PD0+fFstKyovJSZ8XiE9PD5dPT98XFxiKD86YW5kfGFuZF9lcXxiaXRhbmR8Yml0b3J8bm90fG5vdF9lcXxvcnxvcl9lcXx4b3J8eG9yX2VxKVxcYi8sXG4gICAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvXG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjcHAnLCAnc3RyaW5nJywge1xuICAgICdtb2R1bGUnOiB7XG4gICAgICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvbGFuZ3VhZ2UvbW9kdWxlc1xuICAgICAgcGF0dGVybjogUmVnRXhwKC8oXFxiKD86aW1wb3J0fG1vZHVsZSlcXHMrKS8uc291cmNlICsgJyg/OicgKyAvLyBoZWFkZXItbmFtZVxuICAgICAgL1wiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcInw8W148Plxcclxcbl0qPi8uc291cmNlICsgJ3wnICsgLy8gbW9kdWxlIG5hbWUgb3IgcGFydGl0aW9uIG9yIGJvdGhcbiAgICAgIC88bW9kLW5hbWU+KD86XFxzKjpcXHMqPG1vZC1uYW1lPik/fDpcXHMqPG1vZC1uYW1lPi8uc291cmNlLnJlcGxhY2UoLzxtb2QtbmFtZT4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbW9kTmFtZTtcbiAgICAgIH0pICsgJyknKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3N0cmluZyc6IC9eWzxcIl1bXFxzXFxTXSsvLFxuICAgICAgICAnb3BlcmF0b3InOiAvOi8sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vXG4gICAgICB9XG4gICAgfSxcbiAgICAncmF3LXN0cmluZyc6IHtcbiAgICAgIHBhdHRlcm46IC9SXCIoW14oKVxcXFwgXXswLDE2fSlcXChbXFxzXFxTXSo/XFwpXFwxXCIvLFxuICAgICAgYWxpYXM6ICdzdHJpbmcnLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3BwJywgJ2tleXdvcmQnLCB7XG4gICAgJ2dlbmVyaWMtZnVuY3Rpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvXFxiKD8hb3BlcmF0b3JcXGIpW2Etel9dXFx3Klxccyo8KD86W148Pl18PFtePD5dKj4pKj4oPz1cXHMqXFwoKS9pLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmdW5jdGlvbic6IC9eXFx3Ky8sXG4gICAgICAgICdnZW5lcmljJzoge1xuICAgICAgICAgIHBhdHRlcm46IC88W1xcc1xcU10rLyxcbiAgICAgICAgICBhbGlhczogJ2NsYXNzLW5hbWUnLFxuICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmNwcFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3BwJywgJ29wZXJhdG9yJywge1xuICAgICdkb3VibGUtY29sb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvOjovLFxuICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjcHAnLCAnY2xhc3MtbmFtZScsIHtcbiAgICAvLyB0aGUgYmFzZSBjbGF1c2UgaXMgYW4gb3B0aW9uYWwgbGlzdCBvZiBwYXJlbnQgY2xhc3Nlc1xuICAgIC8vIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2NwcC9sYW5ndWFnZS9jbGFzc1xuICAgICdiYXNlLWNsYXVzZSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxiKD86Y2xhc3N8c3RydWN0KVxccytcXHcrXFxzKjpcXHMqKVteO3t9XCInXFxzXSsoPzpcXHMrW147e31cIidcXHNdKykqKD89XFxzKls7e10pLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NwcCcsIHt9KVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2luc2lkZScsICdkb3VibGUtY29sb24nLCB7XG4gICAgLy8gQWxsIHVudG9rZW5pemVkIHdvcmRzIHRoYXQgYXJlIG5vdCBuYW1lc3BhY2VzIHNob3VsZCBiZSBjbGFzcyBuYW1lc1xuICAgICdjbGFzcy1uYW1lJzogL1xcYlthLXpfXVxcdypcXGIoPyFcXHMqOjopL2lcbiAgfSwgUHJpc20ubGFuZ3VhZ2VzLmNwcFsnYmFzZS1jbGF1c2UnXSk7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jc3NcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIHN0cmluZyA9IC8oPzpcIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCJ8Jyg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteJ1xcXFxcXHJcXG5dKSonKS87XG4gIFByaXNtLmxhbmd1YWdlcy5jc3MgPSB7XG4gICAgJ2NvbW1lbnQnOiAvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy8sXG4gICAgJ2F0cnVsZSc6IHtcbiAgICAgIHBhdHRlcm46IC9AW1xcdy1dKD86W147e1xcc118XFxzKyg/IVtcXHN7XSkpKig/Ojt8KD89XFxzKlxceykpLyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncnVsZSc6IC9eQFtcXHctXSsvLFxuICAgICAgICAnc2VsZWN0b3ItZnVuY3Rpb24tYXJndW1lbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyhcXGJzZWxlY3RvclxccypcXChcXHMqKD8hW1xccyldKSkoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKSkrKD89XFxzKlxcKSkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgYWxpYXM6ICdzZWxlY3RvcidcbiAgICAgICAgfSxcbiAgICAgICAgJ2tleXdvcmQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyhefFteXFx3LV0pKD86YW5kfG5vdHxvbmx5fG9yKSg/IVtcXHctXSkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSAvLyBTZWUgcmVzdCBiZWxvd1xuXG4gICAgICB9XG4gICAgfSxcbiAgICAndXJsJzoge1xuICAgICAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdcXFxcYnVybFxcXFwoKD86JyArIHN0cmluZy5zb3VyY2UgKyAnfCcgKyAvKD86W15cXFxcXFxyXFxuKClcIiddfFxcXFxbXFxzXFxTXSkqLy5zb3VyY2UgKyAnKVxcXFwpJywgJ2knKSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZnVuY3Rpb24nOiAvXnVybC9pLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvXlxcKHxcXCkkLyxcbiAgICAgICAgJ3N0cmluZyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14nICsgc3RyaW5nLnNvdXJjZSArICckJyksXG4gICAgICAgICAgYWxpYXM6ICd1cmwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdzZWxlY3Rvcic6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnKF58W3t9XFxcXHNdKVtee31cXFxcc10oPzpbXnt9O1wiXFwnXFxcXHNdfFxcXFxzKyg/IVtcXFxcc3tdKXwnICsgc3RyaW5nLnNvdXJjZSArICcpKig/PVxcXFxzKlxcXFx7KScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3N0cmluZyc6IHtcbiAgICAgIHBhdHRlcm46IHN0cmluZyxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sXG4gICAgJ3Byb3BlcnR5Jzoge1xuICAgICAgcGF0dGVybjogLyhefFteLVxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbLV9hLXpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbLVxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqOikvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdpbXBvcnRhbnQnOiAvIWltcG9ydGFudFxcYi9pLFxuICAgICdmdW5jdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi1hLXowLTldKVstYS16MC05XSsoPz1cXCgpL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAncHVuY3R1YXRpb24nOiAvWygpe307OixdL1xuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMuY3NzWydhdHJ1bGUnXS5pbnNpZGUucmVzdCA9IFByaXNtLmxhbmd1YWdlcy5jc3M7XG4gIHZhciBtYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXG4gIGlmIChtYXJrdXApIHtcbiAgICBtYXJrdXAudGFnLmFkZElubGluZWQoJ3N0eWxlJywgJ2NzcycpO1xuICAgIG1hcmt1cC50YWcuYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcbiAgfVxufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY3NzLWV4dHJhc1wiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgc3RyaW5nID0gLyhcInwnKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvO1xuICB2YXIgc2VsZWN0b3JJbnNpZGU7XG4gIFByaXNtLmxhbmd1YWdlcy5jc3Muc2VsZWN0b3IgPSB7XG4gICAgcGF0dGVybjogUHJpc20ubGFuZ3VhZ2VzLmNzcy5zZWxlY3Rvci5wYXR0ZXJuLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBzZWxlY3Rvckluc2lkZSA9IHtcbiAgICAgICdwc2V1ZG8tZWxlbWVudCc6IC86KD86YWZ0ZXJ8YmVmb3JlfGZpcnN0LWxldHRlcnxmaXJzdC1saW5lfHNlbGVjdGlvbil8OjpbLVxcd10rLyxcbiAgICAgICdwc2V1ZG8tY2xhc3MnOiAvOlstXFx3XSsvLFxuICAgICAgJ2NsYXNzJzogL1xcLlstXFx3XSsvLFxuICAgICAgJ2lkJzogLyNbLVxcd10rLyxcbiAgICAgICdhdHRyaWJ1dGUnOiB7XG4gICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXFxcXFsoPzpbXltcXFxcXVwiXFwnXXwnICsgc3RyaW5nLnNvdXJjZSArICcpKlxcXFxdJyksXG4gICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL15cXFt8XFxdJC8sXG4gICAgICAgICAgJ2Nhc2Utc2Vuc2l0aXZpdHknOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvKFxccylbc2ldJC9pLFxuICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICAgIGFsaWFzOiAna2V5d29yZCdcbiAgICAgICAgICB9LFxuICAgICAgICAgICduYW1lc3BhY2UnOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvXihcXHMqKSg/Oig/IVxccylbLSpcXHdcXHhBMC1cXHVGRkZGXSkqXFx8KD8hPSkvLFxuICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXFx8JC9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgICdhdHRyLW5hbWUnOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvXihcXHMqKSg/Oig/IVxccylbLVxcd1xceEEwLVxcdUZGRkZdKSsvLFxuICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2F0dHItdmFsdWUnOiBbc3RyaW5nLCB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvKD1cXHMqKSg/Oig/IVxccylbLVxcd1xceEEwLVxcdUZGRkZdKSsoPz1cXHMqJCkvLFxuICAgICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICAgIH1dLFxuICAgICAgICAgICdvcGVyYXRvcic6IC9bfH4qXiRdPz0vXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnbi10aCc6IFt7XG4gICAgICAgIHBhdHRlcm46IC8oXFwoXFxzKilbKy1dP1xcZCpbXFxkbl0oPzpcXHMqWystXVxccypcXGQrKT8oPz1cXHMqXFwpKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdudW1iZXInOiAvW1xcZG5dKy8sXG4gICAgICAgICAgJ29wZXJhdG9yJzogL1srLV0vXG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgcGF0dGVybjogLyhcXChcXHMqKSg/OmV2ZW58b2RkKSg/PVxccypcXCkpL2ksXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgIH1dLFxuICAgICAgJ2NvbWJpbmF0b3InOiAvPnxcXCt8fnxcXHxcXHwvLFxuICAgICAgLy8gdGhlIGB0YWdgIHRva2VuIGhhcyBiZWVuIGV4aXN0ZWQgYW5kIHJlbW92ZWQuXG4gICAgICAvLyBiZWNhdXNlIHdlIGNhbid0IGZpbmQgYSBwZXJmZWN0IHRva2VuaXplIHRvIG1hdGNoIGl0LlxuICAgICAgLy8gaWYgeW91IHdhbnQgdG8gYWRkIGl0LCBwbGVhc2UgcmVhZCBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9wdWxsLzIzNzMgZmlyc3QuXG4gICAgICAncHVuY3R1YXRpb24nOiAvWygpLF0vXG4gICAgfVxuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMuY3NzWydhdHJ1bGUnXS5pbnNpZGVbJ3NlbGVjdG9yLWZ1bmN0aW9uLWFyZ3VtZW50J10uaW5zaWRlID0gc2VsZWN0b3JJbnNpZGU7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NzcycsICdwcm9wZXJ0eScsIHtcbiAgICAndmFyaWFibGUnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14tXFx3XFx4QTAtXFx1RkZGRl0pLS0oPyFcXHMpWy1fYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWy1cXHdcXHhBMC1cXHVGRkZGXSkqL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgdmFyIHVuaXQgPSB7XG4gICAgcGF0dGVybjogLyhcXGJcXGQrKSg/OiV8W2Etel0rKD8hW1xcdy1dKSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfTsgLy8gMTIzIC0xMjMgLjEyMyAtLjEyMyAxMi4zIC0xMi4zXG5cbiAgdmFyIG51bWJlciA9IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXHcuLV0pLT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NzcycsICdmdW5jdGlvbicsIHtcbiAgICAnb3BlcmF0b3InOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxccylbK1xcLSpcXC9dKD89XFxzKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAvLyBDQVJFRlVMIVxuICAgIC8vIFByZXZpZXdlcnMgYW5kIElubGluZSBjb2xvciB1c2UgaGV4Y29kZSBhbmQgY29sb3IuXG4gICAgJ2hleGNvZGUnOiB7XG4gICAgICBwYXR0ZXJuOiAvXFxCI1tcXGRhLWZdezMsOH1cXGIvaSxcbiAgICAgIGFsaWFzOiAnY29sb3InXG4gICAgfSxcbiAgICAnY29sb3InOiBbe1xuICAgICAgcGF0dGVybjogLyhefFteXFx3LV0pKD86QWxpY2VCbHVlfEFudGlxdWVXaGl0ZXxBcXVhfEFxdWFtYXJpbmV8QXp1cmV8QmVpZ2V8QmlzcXVlfEJsYWNrfEJsYW5jaGVkQWxtb25kfEJsdWV8Qmx1ZVZpb2xldHxCcm93bnxCdXJseVdvb2R8Q2FkZXRCbHVlfENoYXJ0cmV1c2V8Q2hvY29sYXRlfENvcmFsfENvcm5mbG93ZXJCbHVlfENvcm5zaWxrfENyaW1zb258Q3lhbnxEYXJrQmx1ZXxEYXJrQ3lhbnxEYXJrR29sZGVuUm9kfERhcmtHclthZV15fERhcmtHcmVlbnxEYXJrS2hha2l8RGFya01hZ2VudGF8RGFya09saXZlR3JlZW58RGFya09yYW5nZXxEYXJrT3JjaGlkfERhcmtSZWR8RGFya1NhbG1vbnxEYXJrU2VhR3JlZW58RGFya1NsYXRlQmx1ZXxEYXJrU2xhdGVHclthZV15fERhcmtUdXJxdW9pc2V8RGFya1Zpb2xldHxEZWVwUGlua3xEZWVwU2t5Qmx1ZXxEaW1HclthZV15fERvZGdlckJsdWV8RmlyZUJyaWNrfEZsb3JhbFdoaXRlfEZvcmVzdEdyZWVufEZ1Y2hzaWF8R2FpbnNib3JvfEdob3N0V2hpdGV8R29sZHxHb2xkZW5Sb2R8R3JbYWVdeXxHcmVlbnxHcmVlblllbGxvd3xIb25leURld3xIb3RQaW5rfEluZGlhblJlZHxJbmRpZ298SXZvcnl8S2hha2l8TGF2ZW5kZXJ8TGF2ZW5kZXJCbHVzaHxMYXduR3JlZW58TGVtb25DaGlmZm9ufExpZ2h0Qmx1ZXxMaWdodENvcmFsfExpZ2h0Q3lhbnxMaWdodEdvbGRlblJvZFllbGxvd3xMaWdodEdyW2FlXXl8TGlnaHRHcmVlbnxMaWdodFBpbmt8TGlnaHRTYWxtb258TGlnaHRTZWFHcmVlbnxMaWdodFNreUJsdWV8TGlnaHRTbGF0ZUdyW2FlXXl8TGlnaHRTdGVlbEJsdWV8TGlnaHRZZWxsb3d8TGltZXxMaW1lR3JlZW58TGluZW58TWFnZW50YXxNYXJvb258TWVkaXVtQXF1YU1hcmluZXxNZWRpdW1CbHVlfE1lZGl1bU9yY2hpZHxNZWRpdW1QdXJwbGV8TWVkaXVtU2VhR3JlZW58TWVkaXVtU2xhdGVCbHVlfE1lZGl1bVNwcmluZ0dyZWVufE1lZGl1bVR1cnF1b2lzZXxNZWRpdW1WaW9sZXRSZWR8TWlkbmlnaHRCbHVlfE1pbnRDcmVhbXxNaXN0eVJvc2V8TW9jY2FzaW58TmF2YWpvV2hpdGV8TmF2eXxPbGRMYWNlfE9saXZlfE9saXZlRHJhYnxPcmFuZ2V8T3JhbmdlUmVkfE9yY2hpZHxQYWxlR29sZGVuUm9kfFBhbGVHcmVlbnxQYWxlVHVycXVvaXNlfFBhbGVWaW9sZXRSZWR8UGFwYXlhV2hpcHxQZWFjaFB1ZmZ8UGVydXxQaW5rfFBsdW18UG93ZGVyQmx1ZXxQdXJwbGV8UmVkfFJvc3lCcm93bnxSb3lhbEJsdWV8U2FkZGxlQnJvd258U2FsbW9ufFNhbmR5QnJvd258U2VhR3JlZW58U2VhU2hlbGx8U2llbm5hfFNpbHZlcnxTa3lCbHVlfFNsYXRlQmx1ZXxTbGF0ZUdyW2FlXXl8U25vd3xTcHJpbmdHcmVlbnxTdGVlbEJsdWV8VGFufFRlYWx8VGhpc3RsZXxUb21hdG98VHJhbnNwYXJlbnR8VHVycXVvaXNlfFZpb2xldHxXaGVhdHxXaGl0ZXxXaGl0ZVNtb2tlfFllbGxvd3xZZWxsb3dHcmVlbikoPyFbXFx3LV0pL2ksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogL1xcYig/OmhzbHxyZ2IpXFwoXFxzKlxcZHsxLDN9XFxzKixcXHMqXFxkezEsM30lP1xccyosXFxzKlxcZHsxLDN9JT9cXHMqXFwpXFxCfFxcYig/OmhzbHxyZ2IpYVxcKFxccypcXGR7MSwzfVxccyosXFxzKlxcZHsxLDN9JT9cXHMqLFxccypcXGR7MSwzfSU/XFxzKixcXHMqKD86MHwwP1xcLlxcZCt8MSlcXHMqXFwpXFxCL2ksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3VuaXQnOiB1bml0LFxuICAgICAgICAnbnVtYmVyJzogbnVtYmVyLFxuICAgICAgICAnZnVuY3Rpb24nOiAvW1xcdy1dKyg/PVxcKCkvLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvWygpLF0vXG4gICAgICB9XG4gICAgfV0sXG4gICAgLy8gaXQncyBpbXBvcnRhbnQgdGhhdCB0aGVyZSBpcyBubyBib3VuZGFyeSBhc3NlcnRpb24gYWZ0ZXIgdGhlIGhleCBkaWdpdHNcbiAgICAnZW50aXR5JzogL1xcXFxbXFxkYS1mXXsxLDh9L2ksXG4gICAgJ3VuaXQnOiB1bml0LFxuICAgICdudW1iZXInOiBudW1iZXJcbiAgfSk7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qYXZhc2NyaXB0XCIgKi9cblxuXG5wcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICAnY2xhc3MtbmFtZSc6IFtwcmlzbS5sYW5ndWFnZXMuY2xpa2VbJ2NsYXNzLW5hbWUnXSwge1xuICAgIHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpW18kQS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFwuKD86Y29uc3RydWN0b3J8cHJvdG90eXBlKSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV0sXG4gICdrZXl3b3JkJzogW3tcbiAgICBwYXR0ZXJuOiAvKCg/Ol58XFx9KVxccyopY2F0Y2hcXGIvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oXnxbXi5dfFxcLlxcLlxcLlxccyopXFxiKD86YXN8YXNzZXJ0KD89XFxzKlxceyl8YXN5bmMoPz1cXHMqKD86ZnVuY3Rpb25cXGJ8XFwofFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGF3YWl0fGJyZWFrfGNhc2V8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHkoPz1cXHMqKD86XFx7fCQpKXxmb3J8ZnJvbSg/PVxccyooPzpbJ1wiXXwkKSl8ZnVuY3Rpb258KD86Z2V0fHNldCkoPz1cXHMqKD86WyNcXFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dLFxuICAvLyBBbGxvdyBmb3IgYWxsIG5vbi1BU0NJSSBjaGFyYWN0ZXJzIChTZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAwODQ0NClcbiAgJ2Z1bmN0aW9uJzogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyooPzpcXC5cXHMqKD86YXBwbHl8YmluZHxjYWxsKVxccyopP1xcKCkvLFxuICAnbnVtYmVyJzoge1xuICAgIHBhdHRlcm46IFJlZ0V4cCgvKF58W15cXHckXSkvLnNvdXJjZSArICcoPzonICsgKCAvLyBjb25zdGFudFxuICAgIC9OYU58SW5maW5pdHkvLnNvdXJjZSArICd8JyArIC8vIGJpbmFyeSBpbnRlZ2VyXG4gICAgLzBbYkJdWzAxXSsoPzpfWzAxXSspKm4/Ly5zb3VyY2UgKyAnfCcgKyAvLyBvY3RhbCBpbnRlZ2VyXG4gICAgLzBbb09dWzAtN10rKD86X1swLTddKykqbj8vLnNvdXJjZSArICd8JyArIC8vIGhleGFkZWNpbWFsIGludGVnZXJcbiAgICAvMFt4WF1bXFxkQS1GYS1mXSsoPzpfW1xcZEEtRmEtZl0rKSpuPy8uc291cmNlICsgJ3wnICsgLy8gZGVjaW1hbCBiaWdpbnRcbiAgICAvXFxkKyg/Ol9cXGQrKSpuLy5zb3VyY2UgKyAnfCcgKyAvLyBkZWNpbWFsIG51bWJlciAoaW50ZWdlciBvciBmbG9hdCkgYnV0IG5vIGJpZ2ludFxuICAgIC8oPzpcXGQrKD86X1xcZCspKig/OlxcLig/OlxcZCsoPzpfXFxkKykqKT8pP3xcXC5cXGQrKD86X1xcZCspKikoPzpbRWVdWystXT9cXGQrKD86X1xcZCspKik/Ly5zb3VyY2UpICsgJyknICsgLyg/IVtcXHckXSkvLnNvdXJjZSksXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnb3BlcmF0b3InOiAvLS18XFwrXFwrfFxcKlxcKj0/fD0+fCYmPT98XFx8XFx8PT98WyE9XT09fDw8PT98Pj4+Pz0/fFstKyovJSZ8XiE9PD5dPT98XFwuezN9fFxcP1xcPz0/fFxcP1xcLj98W346XS9cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ2NsYXNzLW5hbWUnXVswXS5wYXR0ZXJuID0gLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3KVxccyspW1xcdy5cXFxcXSsvO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdrZXl3b3JkJywge1xuICAncmVnZXgnOiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1kdXBlLWNoYXJhY3RlcnMtY2hhcmFjdGVyLWNsYXNzXG4gICAgcGF0dGVybjogLygoPzpefFteJFxcd1xceEEwLVxcdUZGRkYuXCInXFxdKVxcc118XFxiKD86cmV0dXJufHlpZWxkKSlcXHMqKVxcLyg/OlxcWyg/OlteXFxdXFxcXFxcclxcbl18XFxcXC4pKlxcXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2RnaW15dXNdezAsN30oPz0oPzpcXHN8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC8pKig/OiR8W1xcclxcbiwuOzp9KVxcXV18XFwvXFwvKSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3JlZ2V4LXNvdXJjZSc6IHtcbiAgICAgICAgcGF0dGVybjogL14oXFwvKVtcXHNcXFNdKyg/PVxcL1thLXpdKiQpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdsYW5ndWFnZS1yZWdleCcsXG4gICAgICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzLnJlZ2V4XG4gICAgICB9LFxuICAgICAgJ3JlZ2V4LWRlbGltaXRlcic6IC9eXFwvfFxcLyQvLFxuICAgICAgJ3JlZ2V4LWZsYWdzJzogL15bYS16XSskL1xuICAgIH1cbiAgfSxcbiAgLy8gVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGJlZm9yZSBrZXl3b3JkIGJlY2F1c2Ugd2UgdXNlIFwiZnVuY3Rpb25cIiBpbnNpZGUgdGhlIGxvb2stZm9yd2FyZFxuICAnZnVuY3Rpb24tdmFyaWFibGUnOiB7XG4gICAgcGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccypbPTpdXFxzKig/OmFzeW5jXFxzKik/KD86XFxiZnVuY3Rpb25cXGJ8KD86XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCl8KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKilcXHMqPT4pKS8sXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ3BhcmFtZXRlcic6IFt7XG4gICAgcGF0dGVybjogLyhmdW5jdGlvbig/OlxccysoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKT9cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJGEtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo9PikvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpXFxzKj0+KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvKCg/OlxcYnxcXHN8XikoPyEoPzphc3xhc3luY3xhd2FpdHxicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5fGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZCkoPyFbJFxcd1xceEEwLVxcdUZGRkZdKSkoPzooPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqXFxzKilcXChcXHMqfFxcXVxccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqXFx7KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gIH1dLFxuICAnY29uc3RhbnQnOiAvXFxiW0EtWl0oPzpbQS1aX118XFxkeD8pKlxcYi9cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdzdHJpbmcnLCB7XG4gICdoYXNoYmFuZyc6IHtcbiAgICBwYXR0ZXJuOiAvXiMhLiovLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ2NvbW1lbnQnXG4gIH0sXG4gICd0ZW1wbGF0ZS1zdHJpbmcnOiB7XG4gICAgcGF0dGVybjogL2AoPzpcXFxcW1xcc1xcU118XFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9fCg/IVxcJFxceylbXlxcXFxgXSkqYC8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3RlbXBsYXRlLXB1bmN0dWF0aW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXmB8YCQvLFxuICAgICAgICBhbGlhczogJ3N0cmluZydcbiAgICAgIH0sXG4gICAgICAnaW50ZXJwb2xhdGlvbic6IHtcbiAgICAgICAgcGF0dGVybjogLygoPzpefFteXFxcXF0pKD86XFxcXHsyfSkqKVxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJzoge1xuICAgICAgICAgICAgcGF0dGVybjogL15cXCRcXHt8XFx9JC8sXG4gICAgICAgICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzdDogcHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgIH1cbiAgfSxcbiAgJ3N0cmluZy1wcm9wZXJ0eSc6IHtcbiAgICBwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKShbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDIpW15cXFxcXFxyXFxuXSkqXFwyKD89XFxzKjopL20sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdwcm9wZXJ0eSdcbiAgfVxufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ29wZXJhdG9yJywge1xuICAnbGl0ZXJhbC1wcm9wZXJ0eSc6IHtcbiAgICBwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKSg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqOikvbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAncHJvcGVydHknXG4gIH1cbn0pO1xuXG5pZiAocHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCkge1xuICBwcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRJbmxpbmVkKCdzY3JpcHQnLCAnamF2YXNjcmlwdCcpOyAvLyBhZGQgYXR0cmlidXRlIHN1cHBvcnQgZm9yIGFsbCBET00gZXZlbnRzLlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMjU3RhbmRhcmRfZXZlbnRzXG5cbiAgcHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkQXR0cmlidXRlKC9vbig/OmFib3J0fGJsdXJ8Y2hhbmdlfGNsaWNrfGNvbXBvc2l0aW9uKD86ZW5kfHN0YXJ0fHVwZGF0ZSl8ZGJsY2xpY2t8ZXJyb3J8Zm9jdXMoPzppbnxvdXQpP3xrZXkoPzpkb3dufHVwKXxsb2FkfG1vdXNlKD86ZG93bnxlbnRlcnxsZWF2ZXxtb3ZlfG91dHxvdmVyfHVwKXxyZXNldHxyZXNpemV8c2Nyb2xsfHNlbGVjdHxzbG90Y2hhbmdlfHN1Ym1pdHx1bmxvYWR8d2hlZWwpLy5zb3VyY2UsICdqYXZhc2NyaXB0Jyk7XG59XG5cbnByaXNtLmxhbmd1YWdlcy5qcyA9IHByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0O1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY29mZmVlc2NyaXB0XCIgKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvLyBJZ25vcmUgY29tbWVudHMgc3RhcnRpbmcgd2l0aCB7IHRvIHByaXZpbGVnZSBzdHJpbmcgaW50ZXJwb2xhdGlvbiBoaWdobGlnaHRpbmdcbiAgdmFyIGNvbW1lbnQgPSAvIyg/IVxceykuKy87XG4gIHZhciBpbnRlcnBvbGF0aW9uID0ge1xuICAgIHBhdHRlcm46IC8jXFx7W159XStcXH0vLFxuICAgIGFsaWFzOiAndmFyaWFibGUnXG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5jb2ZmZWVzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdqYXZhc2NyaXB0Jywge1xuICAgICdjb21tZW50JzogY29tbWVudCxcbiAgICAnc3RyaW5nJzogWy8vIFN0cmluZ3MgYXJlIG11bHRpbGluZVxuICAgIHtcbiAgICAgIHBhdHRlcm46IC8nKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonLyxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIC8vIFN0cmluZ3MgYXJlIG11bHRpbGluZVxuICAgICAgcGF0dGVybjogL1wiKD86XFxcXFtcXHNcXFNdfFteXFxcXFwiXSkqXCIvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW50ZXJwb2xhdGlvblxuICAgICAgfVxuICAgIH1dLFxuICAgICdrZXl3b3JkJzogL1xcYig/OmFuZHxicmVha3xieXxjYXRjaHxjbGFzc3xjb250aW51ZXxkZWJ1Z2dlcnxkZWxldGV8ZG98ZWFjaHxlbHNlfGV4dGVuZHxleHRlbmRzfGZhbHNlfGZpbmFsbHl8Zm9yfGlmfGlufGluc3RhbmNlb2Z8aXN8aXNudHxsZXR8bG9vcHxuYW1lc3BhY2V8bmV3fG5vfG5vdHxudWxsfG9mfG9mZnxvbnxvcnxvd258cmV0dXJufHN1cGVyfHN3aXRjaHx0aGVufHRoaXN8dGhyb3d8dHJ1ZXx0cnl8dHlwZW9mfHVuZGVmaW5lZHx1bmxlc3N8dW50aWx8d2hlbnx3aGlsZXx3aW5kb3d8d2l0aHx5ZXN8eWllbGQpXFxiLyxcbiAgICAnY2xhc3MtbWVtYmVyJzoge1xuICAgICAgcGF0dGVybjogL0AoPyFcXGQpXFx3Ky8sXG4gICAgICBhbGlhczogJ3ZhcmlhYmxlJ1xuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NvZmZlZXNjcmlwdCcsICdjb21tZW50Jywge1xuICAgICdtdWx0aWxpbmUtY29tbWVudCc6IHtcbiAgICAgIHBhdHRlcm46IC8jIyNbXFxzXFxTXSs/IyMjLyxcbiAgICAgIGFsaWFzOiAnY29tbWVudCdcbiAgICB9LFxuICAgIC8vIEJsb2NrIHJlZ2V4cCBjYW4gY29udGFpbiBjb21tZW50cyBhbmQgaW50ZXJwb2xhdGlvblxuICAgICdibG9jay1yZWdleCc6IHtcbiAgICAgIHBhdHRlcm46IC9cXC97M31bXFxzXFxTXSo/XFwvezN9LyxcbiAgICAgIGFsaWFzOiAncmVnZXgnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjb21tZW50JzogY29tbWVudCxcbiAgICAgICAgJ2ludGVycG9sYXRpb24nOiBpbnRlcnBvbGF0aW9uXG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY29mZmVlc2NyaXB0JywgJ3N0cmluZycsIHtcbiAgICAnaW5saW5lLWphdmFzY3JpcHQnOiB7XG4gICAgICBwYXR0ZXJuOiAvYCg/OlxcXFxbXFxzXFxTXXxbXlxcXFxgXSkqYC8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2RlbGltaXRlcic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXmB8YCQvLFxuICAgICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICAgIH0sXG4gICAgICAgICdzY3JpcHQnOiB7XG4gICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdKy8sXG4gICAgICAgICAgYWxpYXM6ICdsYW5ndWFnZS1qYXZhc2NyaXB0JyxcbiAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEJsb2NrIHN0cmluZ3NcbiAgICAnbXVsdGlsaW5lLXN0cmluZyc6IFt7XG4gICAgICBwYXR0ZXJuOiAvJycnW1xcc1xcU10qPycnJy8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBhbGlhczogJ3N0cmluZydcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXCJcIlwiW1xcc1xcU10qP1wiXCJcIi8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBhbGlhczogJ3N0cmluZycsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgaW50ZXJwb2xhdGlvbjogaW50ZXJwb2xhdGlvblxuICAgICAgfVxuICAgIH1dXG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjb2ZmZWVzY3JpcHQnLCAna2V5d29yZCcsIHtcbiAgICAvLyBPYmplY3QgcHJvcGVydHlcbiAgICAncHJvcGVydHknOiAvKD8hXFxkKVxcdysoPz1cXHMqOig/ITopKS9cbiAgfSk7XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMuY29mZmVlc2NyaXB0Wyd0ZW1wbGF0ZS1zdHJpbmcnXTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNvZmZlZSA9IFByaXNtLmxhbmd1YWdlcy5jb2ZmZWVzY3JpcHQ7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS15YW1sXCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2MtbnMtYW5jaG9yLXByb3BlcnR5XG4gIC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2MtbnMtYWxpYXMtbm9kZVxuICB2YXIgYW5jaG9yT3JBbGlhcyA9IC9bKiZdW15cXHNbXFxde30sXSsvOyAvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNjLW5zLXRhZy1wcm9wZXJ0eVxuXG4gIHZhciB0YWcgPSAvISg/OjxbXFx3XFwtJSM7Lz86QCY9KyQsLiF+KicoKVtcXF1dKz58KD86W2EtekEtWlxcZC1dKiEpP1tcXHdcXC0lIzsvPzpAJj0rJC5+KicoKV0rKT8vOyAvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNjLW5zLXByb3BlcnRpZXMobixjKVxuXG4gIHZhciBwcm9wZXJ0aWVzID0gJyg/OicgKyB0YWcuc291cmNlICsgJyg/OlsgXFx0XSsnICsgYW5jaG9yT3JBbGlhcy5zb3VyY2UgKyAnKT98JyArIGFuY2hvck9yQWxpYXMuc291cmNlICsgJyg/OlsgXFx0XSsnICsgdGFnLnNvdXJjZSArICcpPyknOyAvLyBodHRwczovL3lhbWwub3JnL3NwZWMvMS4yL3NwZWMuaHRtbCNucy1wbGFpbihuLGMpXG4gIC8vIFRoaXMgaXMgYSBzaW1wbGlmaWVkIHZlcnNpb24gdGhhdCBkb2Vzbid0IHN1cHBvcnQgXCIjXCIgYW5kIG11bHRpbGluZSBrZXlzXG4gIC8vIEFsbCB0aGVzZSBsb25nIHNjYXJyeSBjaGFyYWN0ZXIgY2xhc3NlcyBhcmUgc2ltcGxpZmllZCB2ZXJzaW9ucyBvZiBZQU1MJ3MgY2hhcmFjdGVyc1xuXG4gIHZhciBwbGFpbktleSA9IC8oPzpbXlxcc1xceDAwLVxceDA4XFx4MGUtXFx4MWYhXCIjJSYnKixcXC06Pj9AW1xcXWB7fH1cXHg3Zi1cXHg4NFxceDg2LVxceDlmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZdfFs/Oi1dPFBMQUlOPikoPzpbIFxcdF0qKD86KD8hWyM6XSk8UExBSU4+fDo8UExBSU4+KSkqLy5zb3VyY2UucmVwbGFjZSgvPFBMQUlOPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIC9bXlxcc1xceDAwLVxceDA4XFx4MGUtXFx4MWYsW1xcXXt9XFx4N2YtXFx4ODRcXHg4Ni1cXHg5ZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXS8uc291cmNlO1xuICB9KTtcbiAgdmFyIHN0cmluZyA9IC9cIig/OlteXCJcXFxcXFxyXFxuXXxcXFxcLikqXCJ8Jyg/OlteJ1xcXFxcXHJcXG5dfFxcXFwuKSonLy5zb3VyY2U7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmbGFnc11cbiAgICogQHJldHVybnMge1JlZ0V4cH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlVmFsdWVQYXR0ZXJuKHZhbHVlLCBmbGFncykge1xuICAgIGZsYWdzID0gKGZsYWdzIHx8ICcnKS5yZXBsYWNlKC9tL2csICcnKSArICdtJzsgLy8gYWRkIG0gZmxhZ1xuXG4gICAgdmFyIHBhdHRlcm4gPSAvKFs6XFwtLFt7XVxccyooPzpcXHM8PHByb3A+PlsgXFx0XSspPykoPzo8PHZhbHVlPj4pKD89WyBcXHRdKig/OiR8LHxcXF18XFx9fCg/OltcXHJcXG5dXFxzKik/IykpLy5zb3VyY2UucmVwbGFjZSgvPDxwcm9wPj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfSkucmVwbGFjZSgvPDx2YWx1ZT4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfVxuXG4gIFByaXNtLmxhbmd1YWdlcy55YW1sID0ge1xuICAgICdzY2FsYXInOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhbXFwtOl1cXHMqKD86XFxzPDxwcm9wPj5bIFxcdF0rKT9bfD5dKVsgXFx0XSooPzooKD86XFxyP1xcbnxcXHIpWyBcXHRdKylcXFNbXlxcclxcbl0qKD86XFwyW15cXHJcXG5dKykqKS8uc291cmNlLnJlcGxhY2UoLzw8cHJvcD4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgICB9KSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgfSxcbiAgICAnY29tbWVudCc6IC8jLiovLFxuICAgICdrZXknOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLygoPzpefFs6XFwtLFt7XFxyXFxuP10pWyBcXHRdKig/Ojw8cHJvcD4+WyBcXHRdKyk/KTw8a2V5Pj4oPz1cXHMqOlxccykvLnNvdXJjZS5yZXBsYWNlKC88PHByb3A+Pi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgICAgfSkucmVwbGFjZSgvPDxrZXk+Pi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnKD86JyArIHBsYWluS2V5ICsgJ3wnICsgc3RyaW5nICsgJyknO1xuICAgICAgfSkpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnYXRydWxlJ1xuICAgIH0sXG4gICAgJ2RpcmVjdGl2ZSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXlsgXFx0XSopJS4rL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgfSxcbiAgICAnZGF0ZXRpbWUnOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oL1xcZHs0fS1cXGRcXGQ/LVxcZFxcZD8oPzpbdFRdfFsgXFx0XSspXFxkXFxkPzpcXGR7Mn06XFxkezJ9KD86XFwuXFxkKik/KD86WyBcXHRdKig/Olp8Wy0rXVxcZFxcZD8oPzo6XFxkezJ9KT8pKT98XFxkezR9LVxcZHsyfS1cXGR7Mn18XFxkXFxkPzpcXGR7Mn0oPzo6XFxkezJ9KD86XFwuXFxkKik/KT8vLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdudW1iZXInXG4gICAgfSxcbiAgICAnYm9vbGVhbic6IHtcbiAgICAgIHBhdHRlcm46IGNyZWF0ZVZhbHVlUGF0dGVybigvZmFsc2V8dHJ1ZS8uc291cmNlLCAnaScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ251bGwnOiB7XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVWYWx1ZVBhdHRlcm4oL251bGx8fi8uc291cmNlLCAnaScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ3N0cmluZyc6IHtcbiAgICAgIHBhdHRlcm46IGNyZWF0ZVZhbHVlUGF0dGVybihzdHJpbmcpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sXG4gICAgJ251bWJlcic6IHtcbiAgICAgIHBhdHRlcm46IGNyZWF0ZVZhbHVlUGF0dGVybigvWystXT8oPzoweFtcXGRhLWZdK3wwb1swLTddK3woPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/fFxcLmluZnxcXC5uYW4pLy5zb3VyY2UsICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAndGFnJzogdGFnLFxuICAgICdpbXBvcnRhbnQnOiBhbmNob3JPckFsaWFzLFxuICAgICdwdW5jdHVhdGlvbic6IC8tLS18WzpbXFxde31cXC0sfD4/XXxcXC5cXC5cXC4vXG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy55bWwgPSBQcmlzbS5sYW5ndWFnZXMueWFtbDtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1hcmtkb3duXCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8vIEFsbG93IG9ubHkgb25lIGxpbmUgYnJlYWtcbiAgdmFyIGlubmVyID0gLyg/OlxcXFwufFteXFxcXFxcblxccl18KD86XFxufFxcclxcbj8pKD8hW1xcclxcbl0pKS8uc291cmNlO1xuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCBmb3IgdGhlIGNyZWF0aW9uIG9mIHRoZSBib2xkIG9yIGl0YWxpYyBwYXR0ZXJuLlxuICAgKlxuICAgKiBUaGlzIGFsc28gYWRkcyBhIGxvb2tiZWhpbmQgZ3JvdXAgdG8gdGhlIGdpdmVuIHBhdHRlcm4gdG8gZW5zdXJlIHRoYXQgdGhlIHBhdHRlcm4gaXMgbm90IGJhY2tzbGFzaC1lc2NhcGVkLlxuICAgKlxuICAgKiBfTm90ZTpfIEtlZXAgaW4gbWluZCB0aGF0IHRoaXMgYWRkcyBhIGNhcHR1cmluZyBncm91cC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdHRlcm5cbiAgICogQHJldHVybnMge1JlZ0V4cH1cbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5saW5lKHBhdHRlcm4pIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKC88aW5uZXI+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBpbm5lcjtcbiAgICB9KTtcbiAgICByZXR1cm4gUmVnRXhwKC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKikvLnNvdXJjZSArICcoPzonICsgcGF0dGVybiArICcpJyk7XG4gIH1cblxuICB2YXIgdGFibGVDZWxsID0gLyg/OlxcXFwufGBgKD86W15gXFxyXFxuXXxgKD8hYCkpK2BgfGBbXmBcXHJcXG5dK2B8W15cXFxcfFxcclxcbmBdKSsvLnNvdXJjZTtcbiAgdmFyIHRhYmxlUm93ID0gL1xcfD9fXyg/OlxcfF9fKStcXHw/KD86KD86XFxufFxcclxcbj8pfCg/IVtcXHNcXFNdKSkvLnNvdXJjZS5yZXBsYWNlKC9fXy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRhYmxlQ2VsbDtcbiAgfSk7XG4gIHZhciB0YWJsZUxpbmUgPSAvXFx8P1sgXFx0XSo6Py17Myx9Oj9bIFxcdF0qKD86XFx8WyBcXHRdKjo/LXszLH06P1sgXFx0XSopK1xcfD8oPzpcXG58XFxyXFxuPykvLnNvdXJjZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnbWFya3VwJywge30pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrZG93bicsICdwcm9sb2cnLCB7XG4gICAgJ2Zyb250LW1hdHRlci1ibG9jayc6IHtcbiAgICAgIHBhdHRlcm46IC8oXig/OlxccypbXFxyXFxuXSk/KS0tLSg/IS4pW1xcc1xcU10qP1tcXHJcXG5dLS0tKD8hLikvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHVuY3R1YXRpb24nOiAvXi0tLXwtLS0kLyxcbiAgICAgICAgJ2Zyb250LW1hdHRlcic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXFxTKyg/OlxccytcXFMrKSovLFxuICAgICAgICAgIGFsaWFzOiBbJ3lhbWwnLCAnbGFuZ3VhZ2UteWFtbCddLFxuICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLnlhbWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2Jsb2NrcXVvdGUnOiB7XG4gICAgICAvLyA+IC4uLlxuICAgICAgcGF0dGVybjogL14+KD86W1xcdCBdKj4pKi9tLFxuICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICB9LFxuICAgICd0YWJsZSc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXicgKyB0YWJsZVJvdyArIHRhYmxlTGluZSArICcoPzonICsgdGFibGVSb3cgKyAnKSonLCAnbScpLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd0YWJsZS1kYXRhLXJvd3MnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCdeKCcgKyB0YWJsZVJvdyArIHRhYmxlTGluZSArICcpKD86JyArIHRhYmxlUm93ICsgJykqJCcpLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAndGFibGUtZGF0YSc6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogUmVnRXhwKHRhYmxlQ2VsbCksXG4gICAgICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcfC9cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICd0YWJsZS1saW5lJzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXignICsgdGFibGVSb3cgKyAnKScgKyB0YWJsZUxpbmUgKyAnJCcpLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXFx8fDo/LXszLH06Py9cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICd0YWJsZS1oZWFkZXItcm93Jzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXicgKyB0YWJsZVJvdyArICckJyksXG4gICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAndGFibGUtaGVhZGVyJzoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAodGFibGVDZWxsKSxcbiAgICAgICAgICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5tYXJrZG93blxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXHwvXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnY29kZSc6IFt7XG4gICAgICAvLyBQcmVmaXhlZCBieSA0IHNwYWNlcyBvciAxIHRhYiBhbmQgcHJlY2VkZWQgYnkgYW4gZW1wdHkgbGluZVxuICAgICAgcGF0dGVybjogLygoPzpefFxcbilbIFxcdF0qXFxufCg/Ol58XFxyXFxuPylbIFxcdF0qXFxyXFxuPykoPzogezR9fFxcdCkuKyg/Oig/OlxcbnxcXHJcXG4/KSg/OiB7NH18XFx0KS4rKSovLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAna2V5d29yZCdcbiAgICB9LCB7XG4gICAgICAvLyBgYGBvcHRpb25hbCBsYW5ndWFnZVxuICAgICAgLy8gY29kZSBibG9ja1xuICAgICAgLy8gYGBgXG4gICAgICBwYXR0ZXJuOiAvXmBgYFtcXHNcXFNdKj9eYGBgJC9tLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjb2RlLWJsb2NrJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eKGBgYC4qKD86XFxufFxcclxcbj8pKVtcXHNcXFNdKz8oPz0oPzpcXG58XFxyXFxuPyleYGBgJCkvbSxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdjb2RlLWxhbmd1YWdlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eKGBgYCkuKy8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvYGBgL1xuICAgICAgfVxuICAgIH1dLFxuICAgICd0aXRsZSc6IFt7XG4gICAgICAvLyB0aXRsZSAxXG4gICAgICAvLyA9PT09PT09XG4gICAgICAvLyB0aXRsZSAyXG4gICAgICAvLyAtLS0tLS0tXG4gICAgICBwYXR0ZXJuOiAvXFxTLiooPzpcXG58XFxyXFxuPykoPzo9PSt8LS0rKSg/PVsgXFx0XSokKS9tLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIHB1bmN0dWF0aW9uOiAvPT0rJHwtLSskL1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vICMgdGl0bGUgMVxuICAgICAgLy8gIyMjIyMjIHRpdGxlIDZcbiAgICAgIHBhdHRlcm46IC8oXlxccyopIy4rL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIHB1bmN0dWF0aW9uOiAvXiMrfCMrJC9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAnaHInOiB7XG4gICAgICAvLyAqKipcbiAgICAgIC8vIC0tLVxuICAgICAgLy8gKiAqICpcbiAgICAgIC8vIC0tLS0tLS0tLS0tXG4gICAgICBwYXR0ZXJuOiAvKF5cXHMqKShbKi1dKSg/OltcXHQgXSpcXDIpezIsfSg/PVxccyokKS9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfSxcbiAgICAnbGlzdCc6IHtcbiAgICAgIC8vICogaXRlbVxuICAgICAgLy8gKyBpdGVtXG4gICAgICAvLyAtIGl0ZW1cbiAgICAgIC8vIDEuIGl0ZW1cbiAgICAgIHBhdHRlcm46IC8oXlxccyopKD86WyorLV18XFxkK1xcLikoPz1bXFx0IF0uKS9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfSxcbiAgICAndXJsLXJlZmVyZW5jZSc6IHtcbiAgICAgIC8vIFtpZF06IGh0dHA6Ly9leGFtcGxlLmNvbSBcIk9wdGlvbmFsIHRpdGxlXCJcbiAgICAgIC8vIFtpZF06IGh0dHA6Ly9leGFtcGxlLmNvbSAnT3B0aW9uYWwgdGl0bGUnXG4gICAgICAvLyBbaWRdOiBodHRwOi8vZXhhbXBsZS5jb20gKE9wdGlvbmFsIHRpdGxlKVxuICAgICAgLy8gW2lkXTogPGh0dHA6Ly9leGFtcGxlLmNvbT4gXCJPcHRpb25hbCB0aXRsZVwiXG4gICAgICBwYXR0ZXJuOiAvIT9cXFtbXlxcXV0rXFxdOltcXHQgXSsoPzpcXFMrfDwoPzpcXFxcLnxbXj5cXFxcXSkrPikoPzpbXFx0IF0rKD86XCIoPzpcXFxcLnxbXlwiXFxcXF0pKlwifCcoPzpcXFxcLnxbXidcXFxcXSkqJ3xcXCgoPzpcXFxcLnxbXilcXFxcXSkqXFwpKSk/LyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndmFyaWFibGUnOiB7XG4gICAgICAgICAgcGF0dGVybjogL14oIT9cXFspW15cXF1dKy8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAnc3RyaW5nJzogLyg/OlwiKD86XFxcXC58W15cIlxcXFxdKSpcInwnKD86XFxcXC58W14nXFxcXF0pKid8XFwoKD86XFxcXC58W14pXFxcXF0pKlxcKSkkLyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL15bXFxbXFxdITpdfFs8Pl0vXG4gICAgICB9LFxuICAgICAgYWxpYXM6ICd1cmwnXG4gICAgfSxcbiAgICAnYm9sZCc6IHtcbiAgICAgIC8vICoqc3Ryb25nKipcbiAgICAgIC8vIF9fc3Ryb25nX19cbiAgICAgIC8vIGFsbG93IG9uZSBuZXN0ZWQgaW5zdGFuY2Ugb2YgaXRhbGljIHRleHQgdXNpbmcgdGhlIHNhbWUgZGVsaW1pdGVyXG4gICAgICBwYXR0ZXJuOiBjcmVhdGVJbmxpbmUoL1xcYl9fKD86KD8hXyk8aW5uZXI+fF8oPzooPyFfKTxpbm5lcj4pK18pK19fXFxifFxcKlxcKig/Oig/IVxcKik8aW5uZXI+fFxcKig/Oig/IVxcKik8aW5uZXI+KStcXCopK1xcKlxcKi8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2NvbnRlbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheLi4pW1xcc1xcU10rKD89Li4kKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHt9IC8vIHNlZSBiZWxvd1xuXG4gICAgICAgIH0sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9cXCpcXCp8X18vXG4gICAgICB9XG4gICAgfSxcbiAgICAnaXRhbGljJzoge1xuICAgICAgLy8gKmVtKlxuICAgICAgLy8gX2VtX1xuICAgICAgLy8gYWxsb3cgb25lIG5lc3RlZCBpbnN0YW5jZSBvZiBib2xkIHRleHQgdXNpbmcgdGhlIHNhbWUgZGVsaW1pdGVyXG4gICAgICBwYXR0ZXJuOiBjcmVhdGVJbmxpbmUoL1xcYl8oPzooPyFfKTxpbm5lcj58X18oPzooPyFfKTxpbm5lcj4pK19fKStfXFxifFxcKig/Oig/IVxcKik8aW5uZXI+fFxcKlxcKig/Oig/IVxcKik8aW5uZXI+KStcXCpcXCopK1xcKi8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2NvbnRlbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheLilbXFxzXFxTXSsoPz0uJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB7fSAvLyBzZWUgYmVsb3dcblxuICAgICAgICB9LFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvWypfXS9cbiAgICAgIH1cbiAgICB9LFxuICAgICdzdHJpa2UnOiB7XG4gICAgICAvLyB+fnN0cmlrZSB0aHJvdWdofn5cbiAgICAgIC8vIH5zdHJpa2V+XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL3N0cmljdFxuICAgICAgcGF0dGVybjogY3JlYXRlSW5saW5lKC8ofn4/KSg/Oig/IX4pPGlubmVyPikrXFwyLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29udGVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5+fj8pW1xcc1xcU10rKD89XFwxJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgaW5zaWRlOiB7fSAvLyBzZWUgYmVsb3dcblxuICAgICAgICB9LFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvfn4/L1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2NvZGUtc25pcHBldCc6IHtcbiAgICAgIC8vIGBjb2RlYFxuICAgICAgLy8gYGBjb2RlYGBcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFxgXSkoPzpgYFteYFxcclxcbl0rKD86YFteYFxcclxcbl0rKSpgYCg/IWApfGBbXmBcXHJcXG5dK2AoPyFgKSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGFsaWFzOiBbJ2NvZGUnLCAna2V5d29yZCddXG4gICAgfSxcbiAgICAndXJsJzoge1xuICAgICAgLy8gW2V4YW1wbGVdKGh0dHA6Ly9leGFtcGxlLmNvbSBcIk9wdGlvbmFsIHRpdGxlXCIpXG4gICAgICAvLyBbZXhhbXBsZV1baWRdXG4gICAgICAvLyBbZXhhbXBsZV0gW2lkXVxuICAgICAgcGF0dGVybjogY3JlYXRlSW5saW5lKC8hP1xcWyg/Oig/IVxcXSk8aW5uZXI+KStcXF0oPzpcXChbXlxccyldKyg/OltcXHQgXStcIig/OlxcXFwufFteXCJcXFxcXSkqXCIpP1xcKXxbIFxcdF0/XFxbKD86KD8hXFxdKTxpbm5lcj4pK1xcXSkvLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdvcGVyYXRvcic6IC9eIS8sXG4gICAgICAgICdjb250ZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXlxcWylbXlxcXV0rKD89XFxdKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHt9IC8vIHNlZSBiZWxvd1xuXG4gICAgICAgIH0sXG4gICAgICAgICd2YXJpYWJsZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF5cXF1bIFxcdF0/XFxbKVteXFxdXSsoPz1cXF0kKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAndXJsJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXlxcXVxcKClbXlxccyldKy8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAnc3RyaW5nJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXlsgXFx0XSspXCIoPzpcXFxcLnxbXlwiXFxcXF0pKlwiKD89XFwpJCkvLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFsndXJsJywgJ2JvbGQnLCAnaXRhbGljJywgJ3N0cmlrZSddLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgWyd1cmwnLCAnYm9sZCcsICdpdGFsaWMnLCAnc3RyaWtlJywgJ2NvZGUtc25pcHBldCddLmZvckVhY2goZnVuY3Rpb24gKGluc2lkZSkge1xuICAgICAgaWYgKHRva2VuICE9PSBpbnNpZGUpIHtcbiAgICAgICAgUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duW3Rva2VuXS5pbnNpZGUuY29udGVudC5pbnNpZGVbaW5zaWRlXSA9IFByaXNtLmxhbmd1YWdlcy5tYXJrZG93bltpbnNpZGVdO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgUHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBpZiAoZW52Lmxhbmd1YWdlICE9PSAnbWFya2Rvd24nICYmIGVudi5sYW5ndWFnZSAhPT0gJ21kJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhbGtUb2tlbnModG9rZW5zKSB7XG4gICAgICBpZiAoIXRva2VucyB8fCB0eXBlb2YgdG9rZW5zID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdjb2RlJykge1xuICAgICAgICAgIHdhbGtUb2tlbnModG9rZW4uY29udGVudCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogQWRkIHRoZSBjb3JyZWN0IGBsYW5ndWFnZS14eHh4YCBjbGFzcyB0byB0aGlzIGNvZGUgYmxvY2suIEtlZXAgaW4gbWluZCB0aGF0IHRoZSBgY29kZS1sYW5ndWFnZWAgdG9rZW5cbiAgICAgICAgICogaXMgb3B0aW9uYWwuIEJ1dCB0aGUgZ3JhbW1hciBpcyBkZWZpbmVkIHNvIHRoYXQgdGhlcmUgaXMgb25seSBvbmUgY2FzZSB3ZSBoYXZlIHRvIGhhbmRsZTpcbiAgICAgICAgICpcbiAgICAgICAgICogdG9rZW4uY29udGVudCA9IFtcbiAgICAgICAgICogICAgIDxzcGFuIGNsYXNzPVwicHVuY3R1YXRpb25cIj5gYGA8L3NwYW4+LFxuICAgICAgICAgKiAgICAgPHNwYW4gY2xhc3M9XCJjb2RlLWxhbmd1YWdlXCI+eHh4eDwvc3Bhbj4sXG4gICAgICAgICAqICAgICAnXFxuJywgLy8gZXhhY3RseSBvbmUgbmV3IGxpbmVzIChcXHIgb3IgXFxuIG9yIFxcclxcbilcbiAgICAgICAgICogICAgIDxzcGFuIGNsYXNzPVwiY29kZS1ibG9ja1wiPi4uLjwvc3Bhbj4sXG4gICAgICAgICAqICAgICAnXFxuJywgLy8gZXhhY3RseSBvbmUgbmV3IGxpbmVzIGFnYWluXG4gICAgICAgICAqICAgICA8c3BhbiBjbGFzcz1cInB1bmN0dWF0aW9uXCI+YGBgPC9zcGFuPlxuICAgICAgICAgKiBdO1xuICAgICAgICAgKi9cblxuXG4gICAgICAgIHZhciBjb2RlTGFuZyA9IHRva2VuLmNvbnRlbnRbMV07XG4gICAgICAgIHZhciBjb2RlQmxvY2sgPSB0b2tlbi5jb250ZW50WzNdO1xuXG4gICAgICAgIGlmIChjb2RlTGFuZyAmJiBjb2RlQmxvY2sgJiYgY29kZUxhbmcudHlwZSA9PT0gJ2NvZGUtbGFuZ3VhZ2UnICYmIGNvZGVCbG9jay50eXBlID09PSAnY29kZS1ibG9jaycgJiYgdHlwZW9mIGNvZGVMYW5nLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gdGhpcyBtaWdodCBiZSBhIGxhbmd1YWdlIHRoYXQgUHJpc20gZG9lcyBub3Qgc3VwcG9ydFxuICAgICAgICAgIC8vIGRvIHNvbWUgcmVwbGFjZW1lbnRzIHRvIHN1cHBvcnQgQysrLCBDIywgYW5kIEYjXG4gICAgICAgICAgdmFyIGxhbmcgPSBjb2RlTGFuZy5jb250ZW50LnJlcGxhY2UoL1xcYiMvZywgJ3NoYXJwJykucmVwbGFjZSgvXFxiXFwrXFwrL2csICdwcCcpOyAvLyBvbmx5IHVzZSB0aGUgZmlyc3Qgd29yZFxuXG4gICAgICAgICAgbGFuZyA9ICgvW2Etel1bXFx3LV0qL2kuZXhlYyhsYW5nKSB8fCBbJyddKVswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHZhciBhbGlhcyA9ICdsYW5ndWFnZS0nICsgbGFuZzsgLy8gYWRkIGFsaWFzXG5cbiAgICAgICAgICBpZiAoIWNvZGVCbG9jay5hbGlhcykge1xuICAgICAgICAgICAgY29kZUJsb2NrLmFsaWFzID0gW2FsaWFzXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb2RlQmxvY2suYWxpYXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb2RlQmxvY2suYWxpYXMgPSBbY29kZUJsb2NrLmFsaWFzLCBhbGlhc107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGVCbG9jay5hbGlhcy5wdXNoKGFsaWFzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YWxrVG9rZW5zKGVudi50b2tlbnMpO1xuICB9KTtcbiAgUHJpc20uaG9va3MuYWRkKCd3cmFwJywgZnVuY3Rpb24gKGVudikge1xuICAgIGlmIChlbnYudHlwZSAhPT0gJ2NvZGUtYmxvY2snKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvZGVMYW5nID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVudi5jbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNscyA9IGVudi5jbGFzc2VzW2ldO1xuICAgICAgdmFyIG1hdGNoID0gL2xhbmd1YWdlLSguKykvLmV4ZWMoY2xzKTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvZGVMYW5nID0gbWF0Y2hbMV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBncmFtbWFyID0gUHJpc20ubGFuZ3VhZ2VzW2NvZGVMYW5nXTtcblxuICAgIGlmICghZ3JhbW1hcikge1xuICAgICAgaWYgKGNvZGVMYW5nICYmIGNvZGVMYW5nICE9PSAnbm9uZScgJiYgUHJpc20ucGx1Z2lucy5hdXRvbG9hZGVyKSB7XG4gICAgICAgIHZhciBpZCA9ICdtZC0nICsgbmV3IERhdGUoKS52YWx1ZU9mKCkgKyAnLScgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxZTE2KTtcbiAgICAgICAgZW52LmF0dHJpYnV0ZXNbJ2lkJ10gPSBpZDtcbiAgICAgICAgUHJpc20ucGx1Z2lucy5hdXRvbG9hZGVyLmxvYWRMYW5ndWFnZXMoY29kZUxhbmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgICAgICAgaWYgKGVsZSkge1xuICAgICAgICAgICAgZWxlLmlubmVySFRNTCA9IFByaXNtLmhpZ2hsaWdodChlbGUudGV4dENvbnRlbnQsIFByaXNtLmxhbmd1YWdlc1tjb2RlTGFuZ10sIGNvZGVMYW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbnYuY29udGVudCA9IFByaXNtLmhpZ2hsaWdodCh0ZXh0Q29udGVudChlbnYuY29udGVudCksIGdyYW1tYXIsIGNvZGVMYW5nKTtcbiAgICB9XG4gIH0pO1xuICB2YXIgdGFnUGF0dGVybiA9IFJlZ0V4cChQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5wYXR0ZXJuLnNvdXJjZSwgJ2dpJyk7XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2Yga25vd24gZW50aXR5IG5hbWVzLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgYWx3YXlzIGJlIGluY29tcGxldGUgdG8gc2F2ZSBzcGFjZS4gVGhlIGN1cnJlbnQgbGlzdCBpcyB0aGUgb25lIHVzZWQgYnkgbG93ZGFzaCdzIHVuZXNjYXBlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iLzJkYTAyNGMzYjRmOTk0N2E0ODUxNzYzOWRlNzU2MDQ1N2NkNGVjNmMvdW5lc2NhcGUuanMjTDJ9XG4gICAqL1xuXG4gIHZhciBLTk9XTl9FTlRJVFlfTkFNRVMgPSB7XG4gICAgJ2FtcCc6ICcmJyxcbiAgICAnbHQnOiAnPCcsXG4gICAgJ2d0JzogJz4nLFxuICAgICdxdW90JzogJ1wiJ1xuICB9OyAvLyBJRSAxMSBkb2Vzbid0IHN1cHBvcnQgYFN0cmluZy5mcm9tQ29kZVBvaW50YFxuXG4gIHZhciBmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQgfHwgU3RyaW5nLmZyb21DaGFyQ29kZTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRleHQgY29udGVudCBvZiBhIGdpdmVuIEhUTUwgc291cmNlIGNvZGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuICBmdW5jdGlvbiB0ZXh0Q29udGVudChodG1sKSB7XG4gICAgLy8gcmVtb3ZlIGFsbCB0YWdzXG4gICAgdmFyIHRleHQgPSBodG1sLnJlcGxhY2UodGFnUGF0dGVybiwgJycpOyAvLyBkZWNvZGUga25vd24gZW50aXRpZXNcblxuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyYoXFx3ezEsOH18I3g/W1xcZGEtZl17MSw4fSk7L2dpLCBmdW5jdGlvbiAobSwgY29kZSkge1xuICAgICAgY29kZSA9IGNvZGUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKGNvZGVbMF0gPT09ICcjJykge1xuICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgaWYgKGNvZGVbMV0gPT09ICd4Jykge1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoY29kZS5zbGljZSgyKSwgMTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gTnVtYmVyKGNvZGUuc2xpY2UoMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyb21Db2RlUG9pbnQodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGtub3duID0gS05PV05fRU5USVRZX05BTUVTW2NvZGVdO1xuXG4gICAgICAgIGlmIChrbm93bikge1xuICAgICAgICAgIHJldHVybiBrbm93bjtcbiAgICAgICAgfSAvLyB1bmFibGUgdG8gZGVjb2RlXG5cblxuICAgICAgICByZXR1cm4gbTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIFByaXNtLmxhbmd1YWdlcy5tZCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrZG93bjtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWdyYXBocWxcIiAqL1xuXG5cbnByaXNtLmxhbmd1YWdlcy5ncmFwaHFsID0ge1xuICAnY29tbWVudCc6IC8jLiovLFxuICAnZGVzY3JpcHRpb24nOiB7XG4gICAgcGF0dGVybjogLyg/OlwiXCJcIig/OlteXCJdfCg/IVwiXCJcIilcIikqXCJcIlwifFwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIikoPz1cXHMqW2Etel9dKS9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ3N0cmluZycsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnbGFuZ3VhZ2UtbWFya2Rvd24nOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXlwiKD86XCJcIik/KSg/IVxcMSlbXFxzXFxTXSsoPz1cXDEkKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9cIlwiXCIoPzpbXlwiXXwoPyFcIlwiXCIpXCIpKlwiXCJcInxcIig/OlxcXFwufFteXFxcXFwiXFxyXFxuXSkqXCIvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnbnVtYmVyJzogLyg/OlxcQi18XFxiKVxcZCsoPzpcXC5cXGQrKT8oPzplWystXT9cXGQrKT9cXGIvaSxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAndmFyaWFibGUnOiAvXFwkW2Etel9dXFx3Ki9pLFxuICAnZGlyZWN0aXZlJzoge1xuICAgIHBhdHRlcm46IC9AW2Etel9dXFx3Ki9pLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH0sXG4gICdhdHRyLW5hbWUnOiB7XG4gICAgcGF0dGVybjogL1xcYlthLXpfXVxcdyooPz1cXHMqKD86XFwoKD86W14oKVwiXXxcIig/OlxcXFwufFteXFxcXFwiXFxyXFxuXSkqXCIpKlxcKSk/OikvaSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2F0b20taW5wdXQnOiB7XG4gICAgcGF0dGVybjogL1xcYltBLVpdXFx3KklucHV0XFxiLyxcbiAgICBhbGlhczogJ2NsYXNzLW5hbWUnXG4gIH0sXG4gICdzY2FsYXInOiAvXFxiKD86Qm9vbGVhbnxGbG9hdHxJRHxJbnR8U3RyaW5nKVxcYi8sXG4gICdjb25zdGFudCc6IC9cXGJbQS1aXVtBLVpfXFxkXSpcXGIvLFxuICAnY2xhc3MtbmFtZSc6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYig/OmVudW18aW1wbGVtZW50c3xpbnRlcmZhY2V8b258c2NhbGFyfHR5cGV8dW5pb24pXFxzK3wmXFxzKnw6XFxzKnxcXFspW0EtWl9dXFx3Ki8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnZnJhZ21lbnQnOiB7XG4gICAgcGF0dGVybjogLyhcXGJmcmFnbWVudFxccyt8XFwuezN9XFxzKig/IW9uXFxiKSlbYS16QS1aX11cXHcqLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH0sXG4gICdkZWZpbml0aW9uLW11dGF0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oXFxibXV0YXRpb25cXHMrKVthLXpBLVpfXVxcdyovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ2RlZmluaXRpb24tcXVlcnknOiB7XG4gICAgcGF0dGVybjogLyhcXGJxdWVyeVxccyspW2EtekEtWl9dXFx3Ki8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpkaXJlY3RpdmV8ZW51bXxleHRlbmR8ZnJhZ21lbnR8aW1wbGVtZW50c3xpbnB1dHxpbnRlcmZhY2V8bXV0YXRpb258b258cXVlcnl8cmVwZWF0YWJsZXxzY2FsYXJ8c2NoZW1hfHN1YnNjcmlwdGlvbnx0eXBlfHVuaW9uKVxcYi8sXG4gICdvcGVyYXRvcic6IC9bIT18Jl18XFwuezN9LyxcbiAgJ3Byb3BlcnR5LXF1ZXJ5JzogL1xcdysoPz1cXHMqXFwoKS8sXG4gICdvYmplY3QnOiAvXFx3Kyg/PVxccypcXHspLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1shKCl7fVxcW1xcXTo9LF0vLFxuICAncHJvcGVydHknOiAvXFx3Ky9cbn07XG5wcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gYWZ0ZXJUb2tlbml6ZUdyYXBocWwoZW52KSB7XG4gIGlmIChlbnYubGFuZ3VhZ2UgIT09ICdncmFwaHFsJykge1xuICAgIHJldHVybjtcbiAgfVxuICAvKipcbiAgICogZ2V0IHRoZSBncmFwaHFsIHRva2VuIHN0cmVhbSB0aGF0IHdlIHdhbnQgdG8gY3VzdG9taXplXG4gICAqXG4gICAqIEB0eXBlZGVmIHtJbnN0YW5jZVR5cGU8aW1wb3J0KFwiLi9wcmlzbS1jb3JlXCIpW1wiVG9rZW5cIl0+fSBUb2tlblxuICAgKiBAdHlwZSB7VG9rZW5bXX1cbiAgICovXG5cblxuICB2YXIgdmFsaWRUb2tlbnMgPSBlbnYudG9rZW5zLmZpbHRlcihmdW5jdGlvbiAodG9rZW4pIHtcbiAgICByZXR1cm4gdHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJyAmJiB0b2tlbi50eXBlICE9PSAnY29tbWVudCcgJiYgdG9rZW4udHlwZSAhPT0gJ3NjYWxhcic7XG4gIH0pO1xuICB2YXIgY3VycmVudEluZGV4ID0gMDtcbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgdG9rZW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgaW5kZXggaGFzIHRoZSBnaXZlbiB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm5zIHtUb2tlbiB8IHVuZGVmaW5lZH1cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0VG9rZW4ob2Zmc2V0KSB7XG4gICAgcmV0dXJuIHZhbGlkVG9rZW5zW2N1cnJlbnRJbmRleCArIG9mZnNldF07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgdG9rZW4gcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgaW5kZXggaGFzIHRoZSBnaXZlbiB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge3JlYWRvbmx5IHN0cmluZ1tdfSB0eXBlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldD0wXVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBpc1Rva2VuVHlwZSh0eXBlcywgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSBnZXRUb2tlbihpICsgb2Zmc2V0KTtcblxuICAgICAgaWYgKCF0b2tlbiB8fCB0b2tlbi50eXBlICE9PSB0eXBlc1tpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zaW5nIGJyYWNrZXQgdG8gYW4gb3BlbmluZyBicmFja2V0LlxuICAgKlxuICAgKiBJdCBpcyBhc3N1bWVkIHRoYXQgYHRva2VuW2N1cnJlbnRJbmRleCAtIDFdYCBpcyBhbiBvcGVuaW5nIGJyYWNrZXQuXG4gICAqXG4gICAqIElmIG5vIGNsb3NpbmcgYnJhY2tldCBjb3VsZCBiZSBmb3VuZCwgYC0xYCB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gb3BlblxuICAgKiBAcGFyYW0ge1JlZ0V4cH0gY2xvc2VcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG5cblxuICBmdW5jdGlvbiBmaW5kQ2xvc2luZ0JyYWNrZXQob3BlbiwgY2xvc2UpIHtcbiAgICB2YXIgc3RhY2tIZWlnaHQgPSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IGN1cnJlbnRJbmRleDsgaSA8IHZhbGlkVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB2YWxpZFRva2Vuc1tpXTtcbiAgICAgIHZhciBjb250ZW50ID0gdG9rZW4uY29udGVudDtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdwdW5jdHVhdGlvbicgJiYgdHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChvcGVuLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICBzdGFja0hlaWdodCsrO1xuICAgICAgICB9IGVsc2UgaWYgKGNsb3NlLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICBzdGFja0hlaWdodC0tO1xuXG4gICAgICAgICAgaWYgKHN0YWNrSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYW4gYWxpYXMgdG8gdGhlIGdpdmVuIHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0ge1Rva2VufSB0b2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWxpYXNcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYWRkQWxpYXModG9rZW4sIGFsaWFzKSB7XG4gICAgdmFyIGFsaWFzZXMgPSB0b2tlbi5hbGlhcztcblxuICAgIGlmICghYWxpYXNlcykge1xuICAgICAgdG9rZW4uYWxpYXMgPSBhbGlhc2VzID0gW107XG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShhbGlhc2VzKSkge1xuICAgICAgdG9rZW4uYWxpYXMgPSBhbGlhc2VzID0gW2FsaWFzZXNdO1xuICAgIH1cblxuICAgIGFsaWFzZXMucHVzaChhbGlhcyk7XG4gIH1cblxuICBmb3IgKDsgY3VycmVudEluZGV4IDwgdmFsaWRUb2tlbnMubGVuZ3RoOykge1xuICAgIHZhciBzdGFydFRva2VuID0gdmFsaWRUb2tlbnNbY3VycmVudEluZGV4KytdOyAvLyBhZGQgc3BlY2lhbCBhbGlhc2VzIGZvciBtdXRhdGlvbiB0b2tlbnNcblxuICAgIGlmIChzdGFydFRva2VuLnR5cGUgPT09ICdrZXl3b3JkJyAmJiBzdGFydFRva2VuLmNvbnRlbnQgPT09ICdtdXRhdGlvbicpIHtcbiAgICAgIC8vIGFueSBhcnJheSBvZiB0aGUgbmFtZXMgb2YgYWxsIGlucHV0IHZhcmlhYmxlcyAoaWYgYW55KVxuICAgICAgdmFyIGlucHV0VmFyaWFibGVzID0gW107XG5cbiAgICAgIGlmIChpc1Rva2VuVHlwZShbJ2RlZmluaXRpb24tbXV0YXRpb24nLCAncHVuY3R1YXRpb24nXSkgJiYgZ2V0VG9rZW4oMSkuY29udGVudCA9PT0gJygnKSB7XG4gICAgICAgIC8vIGRlZmluaXRpb25cbiAgICAgICAgY3VycmVudEluZGV4ICs9IDI7IC8vIHNraXAgJ2RlZmluaXRpb24tbXV0YXRpb24nIGFuZCAncHVuY3R1YXRpb24nXG5cbiAgICAgICAgdmFyIGRlZmluaXRpb25FbmQgPSBmaW5kQ2xvc2luZ0JyYWNrZXQoL15cXCgkLywgL15cXCkkLyk7XG5cbiAgICAgICAgaWYgKGRlZmluaXRpb25FbmQgPT09IC0xKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gZmluZCBhbGwgaW5wdXQgdmFyaWFibGVzXG5cblxuICAgICAgICBmb3IgKDsgY3VycmVudEluZGV4IDwgZGVmaW5pdGlvbkVuZDsgY3VycmVudEluZGV4KyspIHtcbiAgICAgICAgICB2YXIgdCA9IGdldFRva2VuKDApO1xuXG4gICAgICAgICAgaWYgKHQudHlwZSA9PT0gJ3ZhcmlhYmxlJykge1xuICAgICAgICAgICAgYWRkQWxpYXModCwgJ3ZhcmlhYmxlLWlucHV0Jyk7XG4gICAgICAgICAgICBpbnB1dFZhcmlhYmxlcy5wdXNoKHQuY29udGVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudEluZGV4ID0gZGVmaW5pdGlvbkVuZCArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1Rva2VuVHlwZShbJ3B1bmN0dWF0aW9uJywgJ3Byb3BlcnR5LXF1ZXJ5J10pICYmIGdldFRva2VuKDApLmNvbnRlbnQgPT09ICd7Jykge1xuICAgICAgICBjdXJyZW50SW5kZXgrKzsgLy8gc2tpcCBvcGVuaW5nIGJyYWNrZXRcblxuICAgICAgICBhZGRBbGlhcyhnZXRUb2tlbigwKSwgJ3Byb3BlcnR5LW11dGF0aW9uJyk7XG5cbiAgICAgICAgaWYgKGlucHV0VmFyaWFibGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgbXV0YXRpb25FbmQgPSBmaW5kQ2xvc2luZ0JyYWNrZXQoL15cXHskLywgL15cXH0kLyk7XG5cbiAgICAgICAgICBpZiAobXV0YXRpb25FbmQgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IC8vIGdpdmUgcmVmZXJlbmNlcyB0byBpbnB1dCB2YXJpYWJsZXMgYSBzcGVjaWFsIGFsaWFzXG5cblxuICAgICAgICAgIGZvciAodmFyIGkgPSBjdXJyZW50SW5kZXg7IGkgPCBtdXRhdGlvbkVuZDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFyVG9rZW4gPSB2YWxpZFRva2Vuc1tpXTtcblxuICAgICAgICAgICAgaWYgKHZhclRva2VuLnR5cGUgPT09ICd2YXJpYWJsZScgJiYgaW5wdXRWYXJpYWJsZXMuaW5kZXhPZih2YXJUb2tlbi5jb250ZW50KSA+PSAwKSB7XG4gICAgICAgICAgICAgIGFkZEFsaWFzKHZhclRva2VuLCAndmFyaWFibGUtaW5wdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc3FsXCIgKi9cblxucHJpc20ubGFuZ3VhZ2VzLnNxbCA9IHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pKD86XFwvXFwqW1xcc1xcU10qP1xcKlxcL3woPzotLXxcXC9cXC98IykuKikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ3ZhcmlhYmxlJzogW3tcbiAgICBwYXR0ZXJuOiAvQChbXCInYF0pKD86XFxcXFtcXHNcXFNdfCg/IVxcMSlbXlxcXFxdKStcXDEvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LCAvQFtcXHcuJF0rL10sXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyhefFteQFxcXFxdKShcInwnKSg/OlxcXFxbXFxzXFxTXXwoPyFcXDIpW15cXFxcXXxcXDJcXDIpKlxcMi8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2lkZW50aWZpZXInOiB7XG4gICAgcGF0dGVybjogLyhefFteQFxcXFxdKWAoPzpcXFxcW1xcc1xcU118W15gXFxcXF18YGApKmAvLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL15gfGAkL1xuICAgIH1cbiAgfSxcbiAgJ2Z1bmN0aW9uJzogL1xcYig/OkFWR3xDT1VOVHxGSVJTVHxGT1JNQVR8TEFTVHxMQ0FTRXxMRU58TUFYfE1JRHxNSU58TU9EfE5PV3xST1VORHxTVU18VUNBU0UpKD89XFxzKlxcKCkvaSxcbiAgLy8gU2hvdWxkIHdlIGhpZ2hsaWdodCB1c2VyIGRlZmluZWQgZnVuY3Rpb25zIHRvbz9cbiAgJ2tleXdvcmQnOiAvXFxiKD86QUNUSU9OfEFERHxBRlRFUnxBTEdPUklUSE18QUxMfEFMVEVSfEFOQUxZWkV8QU5ZfEFQUExZfEFTfEFTQ3xBVVRIT1JJWkFUSU9OfEFVVE9fSU5DUkVNRU5UfEJBQ0tVUHxCREJ8QkVHSU58QkVSS0VMRVlEQnxCSUdJTlR8QklOQVJZfEJJVHxCTE9CfEJPT0x8Qk9PTEVBTnxCUkVBS3xCUk9XU0V8QlRSRUV8QlVMS3xCWXxDQUxMfENBU0NBREVEP3xDQVNFfENIQUlOfENIQVIoPzpBQ1RFUnxTRVQpP3xDSEVDSyg/OlBPSU5UKT98Q0xPU0V8Q0xVU1RFUkVEfENPQUxFU0NFfENPTExBVEV8Q09MVU1OUz98Q09NTUVOVHxDT01NSVQoPzpURUQpP3xDT01QVVRFfENPTk5FQ1R8Q09OU0lTVEVOVHxDT05TVFJBSU5UfENPTlRBSU5TKD86VEFCTEUpP3xDT05USU5VRXxDT05WRVJUfENSRUFURXxDUk9TU3xDVVJSRU5UKD86X0RBVEV8X1RJTUV8X1RJTUVTVEFNUHxfVVNFUik/fENVUlNPUnxDWUNMRXxEQVRBKD86QkFTRVM/KT98REFURSg/OlRJTUUpP3xEQVl8REJDQ3xERUFMTE9DQVRFfERFQ3xERUNJTUFMfERFQ0xBUkV8REVGQVVMVHxERUZJTkVSfERFTEFZRUR8REVMRVRFfERFTElNSVRFUlM/fERFTll8REVTQ3xERVNDUklCRXxERVRFUk1JTklTVElDfERJU0FCTEV8RElTQ0FSRHxESVNLfERJU1RJTkNUfERJU1RJTkNUUk9XfERJU1RSSUJVVEVEfERPfERPVUJMRXxEUk9QfERVTU1ZfERVTVAoPzpGSUxFKT98RFVQTElDQVRFfEVMU0UoPzpJRik/fEVOQUJMRXxFTkNMT1NFRHxFTkR8RU5HSU5FfEVOVU18RVJSTFZMfEVSUk9SU3xFU0NBUEVEP3xFWENFUFR8RVhFQyg/OlVURSk/fEVYSVNUU3xFWElUfEVYUExBSU58RVhURU5ERUR8RkVUQ0h8RklFTERTfEZJTEV8RklMTEZBQ1RPUnxGSVJTVHxGSVhFRHxGTE9BVHxGT0xMT1dJTkd8Rk9SKD86IEVBQ0ggUk9XKT98Rk9SQ0V8Rk9SRUlHTnxGUkVFVEVYVCg/OlRBQkxFKT98RlJPTXxGVUxMfEZVTkNUSU9OfEdFT01FVFJZKD86Q09MTEVDVElPTik/fEdMT0JBTHxHT1RPfEdSQU5UfEdST1VQfEhBTkRMRVJ8SEFTSHxIQVZJTkd8SE9MRExPQ0t8SE9VUnxJREVOVElUWSg/OkNPTHxfSU5TRVJUKT98SUZ8SUdOT1JFfElNUE9SVHxJTkRFWHxJTkZJTEV8SU5ORVJ8SU5OT0RCfElOT1VUfElOU0VSVHxJTlR8SU5URUdFUnxJTlRFUlNFQ1R8SU5URVJWQUx8SU5UT3xJTlZPS0VSfElTT0xBVElPTnxJVEVSQVRFfEpPSU58S0VZUz98S0lMTHxMQU5HVUFHRXxMQVNUfExFQVZFfExFRlR8TEVWRUx8TElNSVR8TElORU5PfExJTkVTfExJTkVTVFJJTkd8TE9BRHxMT0NBTHxMT0NLfExPTkcoPzpCTE9CfFRFWFQpfExPT1B8TUFUQ0goPzpFRCk/fE1FRElVTSg/OkJMT0J8SU5UfFRFWFQpfE1FUkdFfE1JRERMRUlOVHxNSU5VVEV8TU9ERXxNT0RJRklFU3xNT0RJRll8TU9OVEh8TVVMVEkoPzpMSU5FU1RSSU5HfFBPSU5UfFBPTFlHT04pfE5BVElPTkFMfE5BVFVSQUx8TkNIQVJ8TkVYVHxOT3xOT05DTFVTVEVSRUR8TlVMTElGfE5VTUVSSUN8T0ZGP3xPRkZTRVRTP3xPTnxPUEVOKD86REFUQVNPVVJDRXxRVUVSWXxST1dTRVQpP3xPUFRJTUlaRXxPUFRJT04oPzpBTExZKT98T1JERVJ8T1VUKD86RVJ8RklMRSk/fE9WRVJ8UEFSVElBTHxQQVJUSVRJT058UEVSQ0VOVHxQSVZPVHxQTEFOfFBPSU5UfFBPTFlHT058UFJFQ0VESU5HfFBSRUNJU0lPTnxQUkVQQVJFfFBSRVZ8UFJJTUFSWXxQUklOVHxQUklWSUxFR0VTfFBST0MoPzpFRFVSRSk/fFBVQkxJQ3xQVVJHRXxRVUlDS3xSQUlTRVJST1J8UkVBRFM/fFJFQUx8UkVDT05GSUdVUkV8UkVGRVJFTkNFU3xSRUxFQVNFfFJFTkFNRXxSRVBFQVQoPzpBQkxFKT98UkVQTEFDRXxSRVBMSUNBVElPTnxSRVFVSVJFfFJFU0lHTkFMfFJFU1RPUkV8UkVTVFJJQ1R8UkVUVVJOKD86SU5HfFMpP3xSRVZPS0V8UklHSFR8Uk9MTEJBQ0t8Uk9VVElORXxST1coPzpDT1VOVHxHVUlEQ09MfFMpP3xSVFJFRXxSVUxFfFNBVkUoPzpQT0lOVCk/fFNDSEVNQXxTRUNPTkR8U0VMRUNUfFNFUklBTCg/OklaQUJMRSk/fFNFU1NJT04oPzpfVVNFUik/fFNFVCg/OlVTRVIpP3xTSEFSRXxTSE9XfFNIVVRET1dOfFNJTVBMRXxTTUFMTElOVHxTTkFQU0hPVHxTT01FfFNPTkFNRXxTUUx8U1RBUlQoPzpJTkcpP3xTVEFUSVNUSUNTfFNUQVRVU3xTVFJJUEVEfFNZU1RFTV9VU0VSfFRBQkxFUz98VEFCTEVTUEFDRXxURU1QKD86T1JBUll8VEFCTEUpP3xURVJNSU5BVEVEfFRFWFQoPzpTSVpFKT98VEhFTnxUSU1FKD86U1RBTVApP3xUSU5ZKD86QkxPQnxJTlR8VEVYVCl8VE9QP3xUUkFOKD86U0FDVElPTlM/KT98VFJJR0dFUnxUUlVOQ0FURXxUU0VRVUFMfFRZUEVTP3xVTkJPVU5ERUR8VU5DT01NSVRURUR8VU5ERUZJTkVEfFVOSU9OfFVOSVFVRXxVTkxPQ0t8VU5QSVZPVHxVTlNJR05FRHxVUERBVEUoPzpURVhUKT98VVNBR0V8VVNFfFVTRVJ8VVNJTkd8VkFMVUVTP3xWQVIoPzpCSU5BUll8Q0hBUnxDSEFSQUNURVJ8WUlORyl8VklFV3xXQUlURk9SfFdBUk5JTkdTfFdIRU58V0hFUkV8V0hJTEV8V0lUSCg/OiBST0xMVVB8SU4pP3xXT1JLfFdSSVRFKD86VEVYVCk/fFlFQVIpXFxiL2ksXG4gICdib29sZWFuJzogL1xcYig/OkZBTFNFfE5VTEx8VFJVRSlcXGIvaSxcbiAgJ251bWJlcic6IC9cXGIweFtcXGRhLWZdK1xcYnxcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCtcXGIvaSxcbiAgJ29wZXJhdG9yJzogL1stKypcXC89JV5+XXwmJj98XFx8XFx8P3whPT98PCg/Oj0+P3w8fD4pP3w+Wz49XT98XFxiKD86QU5EfEJFVFdFRU58RElWfElMSUtFfElOfElTfExJS0V8Tk9UfE9SfFJFR0VYUHxSTElLRXxTT1VORFMgTElLRXxYT1IpXFxiL2ksXG4gICdwdW5jdHVhdGlvbic6IC9bO1tcXF0oKWAsLl0vXG59O1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tanMtdGVtcGxhdGVzXCIgKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgdGVtcGxhdGVTdHJpbmcgPSBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsndGVtcGxhdGUtc3RyaW5nJ107IC8vIHNlZSB0aGUgcGF0dGVybiBpbiBwcmlzbS1qYXZhc2NyaXB0LmpzXG5cbiAgdmFyIHRlbXBsYXRlTGl0ZXJhbFBhdHRlcm4gPSB0ZW1wbGF0ZVN0cmluZy5wYXR0ZXJuLnNvdXJjZTtcbiAgdmFyIGludGVycG9sYXRpb25PYmplY3QgPSB0ZW1wbGF0ZVN0cmluZy5pbnNpZGVbJ2ludGVycG9sYXRpb24nXTtcbiAgdmFyIGludGVycG9sYXRpb25QdW5jdHVhdGlvbk9iamVjdCA9IGludGVycG9sYXRpb25PYmplY3QuaW5zaWRlWydpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJ107XG4gIHZhciBpbnRlcnBvbGF0aW9uUGF0dGVybiA9IGludGVycG9sYXRpb25PYmplY3QucGF0dGVybi5zb3VyY2U7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHBhdHRlcm4gdG8gbWF0Y2ggYSB0ZW1wbGF0ZSBzdHJpbmcgd2l0aCBhIHNwZWNpYWwgdGFnLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIGdyYW1tYXIgd2l0aCB0aGUgZ2l2ZW4gbGFuZ3VhZ2UgaWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbGFuZ3VhZ2UgaWQgb2YgdGhlIGVtYmVkZGVkIGxhbmd1YWdlLiBFLmcuIGBtYXJrZG93bmAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIHJlZ2V4IHBhdHRlcm4gdG8gbWF0Y2ggdGhlIHRhZy5cbiAgICogQHJldHVybnMge29iamVjdCB8IHVuZGVmaW5lZH1cbiAgICogQGV4YW1wbGVcbiAgICogY3JlYXRlVGVtcGxhdGUoJ2NzcycsIC9cXGJjc3MvLnNvdXJjZSk7XG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRlbXBsYXRlKGxhbmd1YWdlLCB0YWcpIHtcbiAgICBpZiAoIVByaXNtLmxhbmd1YWdlc1tsYW5ndWFnZV0pIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnKCg/OicgKyB0YWcgKyAnKVxcXFxzKiknICsgdGVtcGxhdGVMaXRlcmFsUGF0dGVybiksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd0ZW1wbGF0ZS1wdW5jdHVhdGlvbic6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXmB8YCQvLFxuICAgICAgICAgIGFsaWFzOiAnc3RyaW5nJ1xuICAgICAgICB9LFxuICAgICAgICAnZW1iZWRkZWQtY29kZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvW1xcc1xcU10rLyxcbiAgICAgICAgICBhbGlhczogbGFuZ3VhZ2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsndGVtcGxhdGUtc3RyaW5nJ10gPSBbLy8gc3R5bGVkLWpzeDpcbiAgLy8gICBjc3NgYSB7IGNvbG9yOiAjMjVGOyB9YFxuICAvLyBzdHlsZWQtY29tcG9uZW50czpcbiAgLy8gICBzdHlsZWQuaDFgY29sb3I6IHJlZDtgXG4gIGNyZWF0ZVRlbXBsYXRlKCdjc3MnLCAvXFxiKD86c3R5bGVkKD86XFwoW14pXSpcXCkpPyg/OlxccypcXC5cXHMqXFx3Kyg/OlxcKFteKV0qXFwpKSopKnxjc3MoPzpcXHMqXFwuXFxzKig/Omdsb2JhbHxyZXNvbHZlKSk/fGNyZWF0ZUdsb2JhbFN0eWxlfGtleWZyYW1lcykvLnNvdXJjZSksIC8vIGh0bWxgPHA+PC9wPmBcbiAgLy8gZGl2LmlubmVySFRNTCA9IGA8cD48L3A+YFxuICBjcmVhdGVUZW1wbGF0ZSgnaHRtbCcsIC9cXGJodG1sfFxcLlxccyooPzppbm5lcnxvdXRlcilIVE1MXFxzKlxcKz89Ly5zb3VyY2UpLCAvLyBzdmdgPHBhdGggZmlsbD1cIiNmZmZcIiBkPVwiTTU1LjM3IC4uLlwiLz5gXG4gIGNyZWF0ZVRlbXBsYXRlKCdzdmcnLCAvXFxic3ZnLy5zb3VyY2UpLCAvLyBtZGAjIGgxYCwgbWFya2Rvd25gIyMgaDJgXG4gIGNyZWF0ZVRlbXBsYXRlKCdtYXJrZG93bicsIC9cXGIoPzptYXJrZG93bnxtZCkvLnNvdXJjZSksIC8vIGdxbGAuLi5gLCBncmFwaHFsYC4uLmAsIGdyYXBocWwuZXhwZXJpbWVudGFsYC4uLmBcbiAgY3JlYXRlVGVtcGxhdGUoJ2dyYXBocWwnLCAvXFxiKD86Z3FsfGdyYXBocWwoPzpcXHMqXFwuXFxzKmV4cGVyaW1lbnRhbCk/KS8uc291cmNlKSwgLy8gc3FsYC4uLmBcbiAgY3JlYXRlVGVtcGxhdGUoJ3NxbCcsIC9cXGJzcWwvLnNvdXJjZSksIC8vIHZhbmlsbGEgdGVtcGxhdGUgc3RyaW5nXG4gIHRlbXBsYXRlU3RyaW5nXS5maWx0ZXIoQm9vbGVhbik7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWMgcGxhY2Vob2xkZXIgbGl0ZXJhbCBmb3IgdGhlIGdpdmVuIGxhbmd1YWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY291bnRlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIoY291bnRlciwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gJ19fXycgKyBsYW5ndWFnZS50b1VwcGVyQ2FzZSgpICsgJ18nICsgY291bnRlciArICdfX18nO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0b2tlbnMgb2YgYFByaXNtLnRva2VuaXplYCBidXQgYWxzbyBydW5zIHRoZSBgYmVmb3JlLXRva2VuaXplYCBhbmQgYGFmdGVyLXRva2VuaXplYCBob29rcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAgICogQHBhcmFtIHthbnl9IGdyYW1tYXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAqIEByZXR1cm5zIHsoc3RyaW5nfFRva2VuKVtdfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHRva2VuaXplV2l0aEhvb2tzKGNvZGUsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGVudiA9IHtcbiAgICAgIGNvZGU6IGNvZGUsXG4gICAgICBncmFtbWFyOiBncmFtbWFyLFxuICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlXG4gICAgfTtcbiAgICBQcmlzbS5ob29rcy5ydW4oJ2JlZm9yZS10b2tlbml6ZScsIGVudik7XG4gICAgZW52LnRva2VucyA9IFByaXNtLnRva2VuaXplKGVudi5jb2RlLCBlbnYuZ3JhbW1hcik7XG4gICAgUHJpc20uaG9va3MucnVuKCdhZnRlci10b2tlbml6ZScsIGVudik7XG4gICAgcmV0dXJuIGVudi50b2tlbnM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRva2VuIG9mIHRoZSBnaXZlbiBKYXZhU2NyaXB0IGludGVycG9sYXRpb24gZXhwcmVzc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gVGhlIGNvZGUgb2YgdGhlIGV4cHJlc3Npb24uIEUuZy4gYFwiJHs0Mn1cImBcbiAgICogQHJldHVybnMge1Rva2VufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHRva2VuaXplSW50ZXJwb2xhdGlvbkV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIHZhciB0ZW1wR3JhbW1hciA9IHt9O1xuICAgIHRlbXBHcmFtbWFyWydpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uJ10gPSBpbnRlcnBvbGF0aW9uUHVuY3R1YXRpb25PYmplY3Q7XG4gICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cblxuICAgIHZhciB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShleHByZXNzaW9uLCB0ZW1wR3JhbW1hcik7XG5cbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMykge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgdG9rZW4gYXJyYXkgd2lsbCBsb29rIGxpa2UgdGhpc1xuICAgICAgICogW1xuICAgICAgICogICAgIFtcImludGVycG9sYXRpb24tcHVuY3R1YXRpb25cIiwgXCIke1wiXVxuICAgICAgICogICAgIFwiLi4uXCIgLy8gSmF2YVNjcmlwdCBleHByZXNzaW9uIG9mIHRoZSBpbnRlcnBvbGF0aW9uXG4gICAgICAgKiAgICAgW1wiaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvblwiLCBcIn1cIl1cbiAgICAgICAqIF1cbiAgICAgICAqL1xuICAgICAgdmFyIGFyZ3MgPSBbMSwgMV07XG4gICAgICBhcmdzLnB1c2guYXBwbHkoYXJncywgdG9rZW5pemVXaXRoSG9va3ModG9rZW5zWzFdLCBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCwgJ2phdmFzY3JpcHQnKSk7XG4gICAgICB0b2tlbnMuc3BsaWNlLmFwcGx5KHRva2VucywgYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcmlzbS5Ub2tlbignaW50ZXJwb2xhdGlvbicsIHRva2VucywgaW50ZXJwb2xhdGlvbk9iamVjdC5hbGlhcywgZXhwcmVzc2lvbik7XG4gIH1cbiAgLyoqXG4gICAqIFRva2VuaXplcyB0aGUgZ2l2ZW4gY29kZSB3aXRoIHN1cHBvcnQgZm9yIEphdmFTY3JpcHQgaW50ZXJwb2xhdGlvbiBleHByZXNzaW9ucyBtaXhlZCBpbi5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBoYXMgMyBwaGFzZXM6XG4gICAqXG4gICAqIDEuIFJlcGxhY2UgYWxsIEphdmFTY3JpcHQgaW50ZXJwb2xhdGlvbiBleHByZXNzaW9uIHdpdGggYSBwbGFjZWhvbGRlci5cbiAgICogICAgVGhlIHBsYWNlaG9sZGVyIHdpbGwgaGF2ZSB0aGUgc3ludGF4IG9mIGEgaWRlbnRpZnkgb2YgdGhlIHRhcmdldCBsYW5ndWFnZS5cbiAgICogMi4gVG9rZW5pemUgdGhlIGNvZGUgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAqIDMuIFRva2VuaXplIHRoZSBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb25zIGFuZCByZS1pbnNlcnQgdGhlbSBpbnRvIHRoZSB0b2tlbml6ZSBjb2RlLlxuICAgKiAgICBUaGUgaW5zZXJ0aW9uIG9ubHkgd29ya3MgaWYgYSBwbGFjZWhvbGRlciBoYXNuJ3QgYmVlbiBcInJpcHBlZCBhcGFydFwiIG1lYW5pbmcgdGhhdCB0aGUgcGxhY2Vob2xkZXIgaGFzIGJlZW5cbiAgICogICAgdG9rZW5pemVkIGFzIHR3byB0b2tlbnMgYnkgdGhlIGdyYW1tYXIgb2YgdGhlIGVtYmVkZGVkIGxhbmd1YWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gZ3JhbW1hclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICogQHJldHVybnMge1Rva2VufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHRva2VuaXplRW1iZWRkZWQoY29kZSwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcbiAgICAvLyAxLiBGaXJzdCBmaWx0ZXIgb3V0IGFsbCBpbnRlcnBvbGF0aW9uc1xuICAgIC8vIGJlY2F1c2UgdGhleSBtaWdodCBiZSBlc2NhcGVkLCB3ZSBuZWVkIGEgbG9va2JlaGluZCwgc28gd2UgdXNlIFByaXNtXG5cbiAgICAvKiogQHR5cGUgeyhUb2tlbnxzdHJpbmcpW119ICovXG4gICAgdmFyIF90b2tlbnMgPSBQcmlzbS50b2tlbml6ZShjb2RlLCB7XG4gICAgICAnaW50ZXJwb2xhdGlvbic6IHtcbiAgICAgICAgcGF0dGVybjogUmVnRXhwKGludGVycG9sYXRpb25QYXR0ZXJuKSxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgfVxuICAgIH0pOyAvLyByZXBsYWNlIGFsbCBpbnRlcnBvbGF0aW9ucyB3aXRoIGEgcGxhY2Vob2xkZXIgd2hpY2ggaXMgbm90IGluIHRoZSBjb2RlIGFscmVhZHlcblxuXG4gICAgdmFyIHBsYWNlaG9sZGVyQ291bnRlciA9IDA7XG4gICAgLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSAqL1xuXG4gICAgdmFyIHBsYWNlaG9sZGVyTWFwID0ge307XG5cbiAgICB2YXIgZW1iZWRkZWRDb2RlID0gX3Rva2Vucy5tYXAoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW50ZXJwb2xhdGlvbkV4cHJlc3Npb24gPSB0b2tlbi5jb250ZW50O1xuICAgICAgICB2YXIgcGxhY2Vob2xkZXI7XG5cbiAgICAgICAgd2hpbGUgKGNvZGUuaW5kZXhPZihwbGFjZWhvbGRlciA9IGdldFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyQ291bnRlcisrLCBsYW5ndWFnZSkpICE9PSAtMSkge1xuICAgICAgICAgIC8qIG5vb3AgKi9cbiAgICAgICAgfVxuXG4gICAgICAgIHBsYWNlaG9sZGVyTWFwW3BsYWNlaG9sZGVyXSA9IGludGVycG9sYXRpb25FeHByZXNzaW9uO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgICB9XG4gICAgfSkuam9pbignJyk7IC8vIDIuIFRva2VuaXplIHRoZSBlbWJlZGRlZCBjb2RlXG5cblxuICAgIHZhciBlbWJlZGRlZFRva2VucyA9IHRva2VuaXplV2l0aEhvb2tzKGVtYmVkZGVkQ29kZSwgZ3JhbW1hciwgbGFuZ3VhZ2UpOyAvLyAzLiBSZS1pbnNlcnQgdGhlIGludGVycG9sYXRpb25cblxuICAgIHZhciBwbGFjZWhvbGRlcnMgPSBPYmplY3Qua2V5cyhwbGFjZWhvbGRlck1hcCk7XG4gICAgcGxhY2Vob2xkZXJDb3VudGVyID0gMDtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KFRva2VufHN0cmluZylbXX0gdG9rZW5zXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB3YWxrVG9rZW5zKHRva2Vucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyQ291bnRlciA+PSBwbGFjZWhvbGRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0b2tlbi5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyc1twbGFjZWhvbGRlckNvdW50ZXJdO1xuICAgICAgICAgIHZhciBzID0gdHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyA/IHRva2VuIDpcbiAgICAgICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgICAgICB0b2tlbi5jb250ZW50O1xuICAgICAgICAgIHZhciBpbmRleCA9IHMuaW5kZXhPZihwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICArK3BsYWNlaG9sZGVyQ291bnRlcjtcbiAgICAgICAgICAgIHZhciBiZWZvcmUgPSBzLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gdG9rZW5pemVJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihwbGFjZWhvbGRlck1hcFtwbGFjZWhvbGRlcl0pO1xuICAgICAgICAgICAgdmFyIGFmdGVyID0gcy5zdWJzdHJpbmcoaW5kZXggKyBwbGFjZWhvbGRlci5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gW107XG5cbiAgICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucHVzaChiZWZvcmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXBsYWNlbWVudC5wdXNoKG1pZGRsZSk7XG5cbiAgICAgICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgICAgICB2YXIgYWZ0ZXJUb2tlbnMgPSBbYWZ0ZXJdO1xuICAgICAgICAgICAgICB3YWxrVG9rZW5zKGFmdGVyVG9rZW5zKTtcbiAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucHVzaC5hcHBseShyZXBsYWNlbWVudCwgYWZ0ZXJUb2tlbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB0b2tlbnMuc3BsaWNlLmFwcGx5KHRva2VucywgW2ksIDFdLmNvbmNhdChyZXBsYWNlbWVudCkpO1xuICAgICAgICAgICAgICBpICs9IHJlcGxhY2VtZW50Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb250ZW50ID0gdG9rZW4uY29udGVudDtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICB3YWxrVG9rZW5zKGNvbnRlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YWxrVG9rZW5zKFtjb250ZW50XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Fsa1Rva2VucyhlbWJlZGRlZFRva2Vucyk7XG4gICAgcmV0dXJuIG5ldyBQcmlzbS5Ub2tlbihsYW5ndWFnZSwgZW1iZWRkZWRUb2tlbnMsICdsYW5ndWFnZS0nICsgbGFuZ3VhZ2UsIGNvZGUpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbGFuZ3VhZ2VzIGZvciB3aGljaCBKUyB0ZW1wbGF0aW5nIHdpbGwgaGFuZGxlIHRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFscy5cbiAgICpcbiAgICogSlMgdGVtcGxhdGluZyBpc24ndCBhY3RpdmUgZm9yIG9ubHkgSmF2YVNjcmlwdCBidXQgYWxzbyByZWxhdGVkIGxhbmd1YWdlcyBsaWtlIFR5cGVTY3JpcHQsIEpTWCwgYW5kIFRTWC5cbiAgICovXG5cblxuICB2YXIgc3VwcG9ydGVkTGFuZ3VhZ2VzID0ge1xuICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAnanMnOiB0cnVlLFxuICAgICd0eXBlc2NyaXB0JzogdHJ1ZSxcbiAgICAndHMnOiB0cnVlLFxuICAgICdqc3gnOiB0cnVlLFxuICAgICd0c3gnOiB0cnVlXG4gIH07XG4gIFByaXNtLmhvb2tzLmFkZCgnYWZ0ZXItdG9rZW5pemUnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgaWYgKCEoZW52Lmxhbmd1YWdlIGluIHN1cHBvcnRlZExhbmd1YWdlcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgYW5kIHRva2VuaXplcyBhbGwgdGVtcGxhdGUgc3RyaW5ncyB3aXRoIGFuIGVtYmVkZGVkIGxhbmd1YWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KFRva2VuIHwgc3RyaW5nKVtdfSB0b2tlbnNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gZmluZFRlbXBsYXRlU3RyaW5ncyh0b2tlbnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250ZW50ID0gdG9rZW4uY29udGVudDtcblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmaW5kVGVtcGxhdGVTdHJpbmdzKFtjb250ZW50XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RlbXBsYXRlLXN0cmluZycpIHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBIEphdmFTY3JpcHQgdGVtcGxhdGUtc3RyaW5nIHRva2VuIHdpbGwgbG9vayBsaWtlIHRoaXM6XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBbXCJ0ZW1wbGF0ZS1zdHJpbmdcIiwgW1xuICAgICAgICAgICAqICAgICBbXCJ0ZW1wbGF0ZS1wdW5jdHVhdGlvblwiLCBcImBcIl0sXG4gICAgICAgICAgICogICAgIChcbiAgICAgICAgICAgKiAgICAgICAgIEFuIGFycmF5IG9mIFwic3RyaW5nXCIgYW5kIFwiaW50ZXJwb2xhdGlvblwiIHRva2Vucy4gVGhpcyBpcyB0aGUgc2ltcGxlIHN0cmluZyBjYXNlLlxuICAgICAgICAgICAqICAgICAgICAgb3JcbiAgICAgICAgICAgKiAgICAgICAgIFtcImVtYmVkZGVkLWNvZGVcIiwgXCIuLi5cIl0gVGhpcyBpcyB0aGUgdG9rZW4gY29udGFpbmluZyB0aGUgZW1iZWRkZWQgY29kZS5cbiAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCBhbHNvIGhhcyBhbiBhbGlhcyB3aGljaCBpcyB0aGUgbGFuZ3VhZ2Ugb2YgdGhlIGVtYmVkZGVkIGNvZGUuXG4gICAgICAgICAgICogICAgICksXG4gICAgICAgICAgICogICAgIFtcInRlbXBsYXRlLXB1bmN0dWF0aW9uXCIsIFwiYFwiXVxuICAgICAgICAgICAqIF1dXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIGVtYmVkZGVkID0gY29udGVudFsxXTtcblxuICAgICAgICAgIGlmIChjb250ZW50Lmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgZW1iZWRkZWQgIT09ICdzdHJpbmcnICYmIGVtYmVkZGVkLnR5cGUgPT09ICdlbWJlZGRlZC1jb2RlJykge1xuICAgICAgICAgICAgLy8gZ2V0IHN0cmluZyBjb250ZW50XG4gICAgICAgICAgICB2YXIgY29kZSA9IHN0cmluZ0NvbnRlbnQoZW1iZWRkZWQpO1xuICAgICAgICAgICAgdmFyIGFsaWFzID0gZW1iZWRkZWQuYWxpYXM7XG4gICAgICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBBcnJheS5pc0FycmF5KGFsaWFzKSA/IGFsaWFzWzBdIDogYWxpYXM7XG4gICAgICAgICAgICB2YXIgZ3JhbW1hciA9IFByaXNtLmxhbmd1YWdlc1tsYW5ndWFnZV07XG5cbiAgICAgICAgICAgIGlmICghZ3JhbW1hcikge1xuICAgICAgICAgICAgICAvLyB0aGUgZW1iZWRkZWQgbGFuZ3VhZ2UgaXNuJ3QgcmVnaXN0ZXJlZC5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRlbnRbMV0gPSB0b2tlbml6ZUVtYmVkZGVkKGNvZGUsIGdyYW1tYXIsIGxhbmd1YWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluZFRlbXBsYXRlU3RyaW5ncyhjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZpbmRUZW1wbGF0ZVN0cmluZ3MoZW52LnRva2Vucyk7XG4gIH0pO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RyaW5nIGNvbnRlbnQgb2YgYSB0b2tlbiBvciB0b2tlbiBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgVG9rZW4gfCAoc3RyaW5nIHwgVG9rZW4pW119IHZhbHVlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHN0cmluZ0NvbnRlbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5tYXAoc3RyaW5nQ29udGVudCkuam9pbignJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHJpbmdDb250ZW50KHZhbHVlLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tdHlwZXNjcmlwdFwiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2phdmFzY3JpcHQnLCB7XG4gICAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgICBwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXd8dHlwZSlcXHMrKSg/IWtleW9mXFxiKSg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPzpcXHMqPCg/OltePD5dfDwoPzpbXjw+XXw8W148Pl0qPikqPikqPik/LyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG5cbiAgICB9LFxuICAgICdidWlsdGluJzogL1xcYig/OkFycmF5fEZ1bmN0aW9ufFByb21pc2V8YW55fGJvb2xlYW58Y29uc29sZXxuZXZlcnxudW1iZXJ8c3RyaW5nfHN5bWJvbHx1bmtub3duKVxcYi9cbiAgfSk7IC8vIFRoZSBrZXl3b3JkcyBUeXBlU2NyaXB0IGFkZHMgdG8gSmF2YVNjcmlwdFxuXG4gIFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0LmtleXdvcmQucHVzaCgvXFxiKD86YWJzdHJhY3R8ZGVjbGFyZXxpc3xrZXlvZnxyZWFkb25seXxyZXF1aXJlKVxcYi8sIC8vIGtleXdvcmRzIHRoYXQgaGF2ZSB0byBiZSBmb2xsb3dlZCBieSBhbiBpZGVudGlmaWVyXG4gIC9cXGIoPzphc3NlcnRzfGluZmVyfGludGVyZmFjZXxtb2R1bGV8bmFtZXNwYWNlfHR5cGUpXFxiKD89XFxzKig/Olt7XyRhLXpBLVpcXHhBMC1cXHVGRkZGXXwkKSkvLCAvLyBUaGlzIGlzIGZvciBgaW1wb3J0IHR5cGUgKiwge31gXG4gIC9cXGJ0eXBlXFxiKD89XFxzKig/OltcXHsqXXwkKSkvKTsgLy8gZG9lc24ndCB3b3JrIHdpdGggVFMgYmVjYXVzZSBUUyBpcyB0b28gY29tcGxleFxuXG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdFsncGFyYW1ldGVyJ107XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdFsnbGl0ZXJhbC1wcm9wZXJ0eSddOyAvLyBhIHZlcnNpb24gb2YgdHlwZXNjcmlwdCBzcGVjaWZpY2FsbHkgZm9yIGhpZ2hsaWdodGluZyB0eXBlc1xuXG4gIHZhciB0eXBlSW5zaWRlID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgndHlwZXNjcmlwdCcsIHt9KTtcbiAgZGVsZXRlIHR5cGVJbnNpZGVbJ2NsYXNzLW5hbWUnXTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ2NsYXNzLW5hbWUnXS5pbnNpZGUgPSB0eXBlSW5zaWRlO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCd0eXBlc2NyaXB0JywgJ2Z1bmN0aW9uJywge1xuICAgICdkZWNvcmF0b3InOiB7XG4gICAgICBwYXR0ZXJuOiAvQFskXFx3XFx4QTAtXFx1RkZGRl0rLyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnYXQnOiB7XG4gICAgICAgICAgcGF0dGVybjogL15ALyxcbiAgICAgICAgICBhbGlhczogJ29wZXJhdG9yJ1xuICAgICAgICB9LFxuICAgICAgICAnZnVuY3Rpb24nOiAvXltcXHNcXFNdKy9cbiAgICAgIH1cbiAgICB9LFxuICAgICdnZW5lcmljLWZ1bmN0aW9uJzoge1xuICAgICAgLy8gZS5nLiBmb288VCBleHRlbmRzIFwiYmFyXCIgfCBcImJhelwiPiggLi4uXG4gICAgICBwYXR0ZXJuOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqXFxzKjwoPzpbXjw+XXw8KD86W148Pl18PFtePD5dKj4pKj4pKj4oPz1cXHMqXFwoKS8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogL14jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSovLFxuICAgICAgICAnZ2VuZXJpYyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvPFtcXHNcXFNdKy8sXG4gICAgICAgICAgLy8gZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgPFxuICAgICAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZScsXG4gICAgICAgICAgaW5zaWRlOiB0eXBlSW5zaWRlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMudHMgPSBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdDtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWpzLWV4dHJhc1wiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2Z1bmN0aW9uLXZhcmlhYmxlJywge1xuICAgICdtZXRob2QtdmFyaWFibGUnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhcXFxcLlxcXFxzKiknICsgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ2Z1bmN0aW9uLXZhcmlhYmxlJ10ucGF0dGVybi5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiBbJ2Z1bmN0aW9uLXZhcmlhYmxlJywgJ21ldGhvZCcsICdmdW5jdGlvbicsICdwcm9wZXJ0eS1hY2Nlc3MnXVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnZnVuY3Rpb24nLCB7XG4gICAgJ21ldGhvZCc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnKFxcXFwuXFxcXHMqKScgKyBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsnZnVuY3Rpb24nXS5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGFsaWFzOiBbJ2Z1bmN0aW9uJywgJ3Byb3BlcnR5LWFjY2VzcyddXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdjb25zdGFudCcsIHtcbiAgICAna25vd24tY2xhc3MtbmFtZSc6IFt7XG4gICAgICAvLyBzdGFuZGFyZCBidWlsdC1pbnNcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzXG4gICAgICBwYXR0ZXJuOiAvXFxiKD86KD86RmxvYXQoPzozMnw2NCl8KD86SW50fFVpbnQpKD86OHwxNnwzMil8VWludDhDbGFtcGVkKT9BcnJheXxBcnJheUJ1ZmZlcnxCaWdJbnR8Qm9vbGVhbnxEYXRhVmlld3xEYXRlfEVycm9yfEZ1bmN0aW9ufEludGx8SlNPTnwoPzpXZWFrKT8oPzpNYXB8U2V0KXxNYXRofE51bWJlcnxPYmplY3R8UHJvbWlzZXxQcm94eXxSZWZsZWN0fFJlZ0V4cHxTdHJpbmd8U3ltYm9sfFdlYkFzc2VtYmx5KVxcYi8sXG4gICAgICBhbGlhczogJ2NsYXNzLW5hbWUnXG4gICAgfSwge1xuICAgICAgLy8gZXJyb3JzXG4gICAgICBwYXR0ZXJuOiAvXFxiKD86W0EtWl1cXHcqKUVycm9yXFxiLyxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9XVxuICB9KTtcbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBgPElEPmAgcGxhY2Vob2xkZXIgaW4gdGhlIGdpdmVuIHBhdHRlcm4gd2l0aCBhIHBhdHRlcm4gZm9yIGdlbmVyYWwgSlMgaWRlbnRpZmllcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmbGFnc11cbiAgICogQHJldHVybnMge1JlZ0V4cH1cbiAgICovXG5cbiAgZnVuY3Rpb24gd2l0aElkKHNvdXJjZSwgZmxhZ3MpIHtcbiAgICByZXR1cm4gUmVnRXhwKHNvdXJjZS5yZXBsYWNlKC88SUQ+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAvKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKi8uc291cmNlO1xuICAgIH0pLCBmbGFncyk7XG4gIH1cblxuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG4gICAgJ2ltcG9ydHMnOiB7XG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWltcG9ydHNcbiAgICAgIHBhdHRlcm46IHdpdGhJZCgvKFxcYmltcG9ydFxcYlxccyopKD86PElEPig/OlxccyosXFxzKig/OlxcKlxccyphc1xccys8SUQ+fFxce1tee31dKlxcfSkpP3xcXCpcXHMqYXNcXHMrPElEPnxcXHtbXnt9XSpcXH0pKD89XFxzKlxcYmZyb21cXGIpLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICB9LFxuICAgICdleHBvcnRzJzoge1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1leHBvcnRzXG4gICAgICBwYXR0ZXJuOiB3aXRoSWQoLyhcXGJleHBvcnRcXGJcXHMqKSg/OlxcKig/Olxccyphc1xccys8SUQ+KT8oPz1cXHMqXFxiZnJvbVxcYil8XFx7W157fV0qXFx9KS8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ2tleXdvcmQnXS51bnNoaWZ0KHtcbiAgICBwYXR0ZXJuOiAvXFxiKD86YXN8ZGVmYXVsdHxleHBvcnR8ZnJvbXxpbXBvcnQpXFxiLyxcbiAgICBhbGlhczogJ21vZHVsZSdcbiAgfSwge1xuICAgIHBhdHRlcm46IC9cXGIoPzphd2FpdHxicmVha3xjYXRjaHxjb250aW51ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGlmfHJldHVybnxzd2l0Y2h8dGhyb3d8dHJ5fHdoaWxlfHlpZWxkKVxcYi8sXG4gICAgYWxpYXM6ICdjb250cm9sLWZsb3cnXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvXFxibnVsbFxcYi8sXG4gICAgYWxpYXM6IFsnbnVsbCcsICduaWwnXVxuICB9LCB7XG4gICAgcGF0dGVybjogL1xcYnVuZGVmaW5lZFxcYi8sXG4gICAgYWxpYXM6ICduaWwnXG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ29wZXJhdG9yJywge1xuICAgICdzcHJlYWQnOiB7XG4gICAgICBwYXR0ZXJuOiAvXFwuezN9LyxcbiAgICAgIGFsaWFzOiAnb3BlcmF0b3InXG4gICAgfSxcbiAgICAnYXJyb3cnOiB7XG4gICAgICBwYXR0ZXJuOiAvPT4vLFxuICAgICAgYWxpYXM6ICdvcGVyYXRvcidcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ3B1bmN0dWF0aW9uJywge1xuICAgICdwcm9wZXJ0eS1hY2Nlc3MnOiB7XG4gICAgICBwYXR0ZXJuOiB3aXRoSWQoLyhcXC5cXHMqKSM/PElEPi8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdtYXliZS1jbGFzcy1uYW1lJzoge1xuICAgICAgcGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKVtBLVpdWyRcXHdcXHhBMC1cXHVGRkZGXSsvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2RvbSc6IHtcbiAgICAgIC8vIHRoaXMgY29udGFpbnMgb25seSBhIGZldyBjb21tb25seSB1c2VkIERPTSB2YXJpYWJsZXNcbiAgICAgIHBhdHRlcm46IC9cXGIoPzpkb2N1bWVudHwoPzpsb2NhbHxzZXNzaW9uKVN0b3JhZ2V8bG9jYXRpb258bmF2aWdhdG9yfHBlcmZvcm1hbmNlfHdpbmRvdylcXGIvLFxuICAgICAgYWxpYXM6ICd2YXJpYWJsZSdcbiAgICB9LFxuICAgICdjb25zb2xlJzoge1xuICAgICAgcGF0dGVybjogL1xcYmNvbnNvbGUoPz1cXHMqXFwuKS8sXG4gICAgICBhbGlhczogJ2NsYXNzLW5hbWUnXG4gICAgfVxuICB9KTsgLy8gYWRkICdtYXliZS1jbGFzcy1uYW1lJyB0byB0b2tlbnMgd2hpY2ggbWlnaHQgYmUgYSBjbGFzcyBuYW1lXG5cbiAgdmFyIG1heWJlQ2xhc3NOYW1lVG9rZW5zID0gWydmdW5jdGlvbicsICdmdW5jdGlvbi12YXJpYWJsZScsICdtZXRob2QnLCAnbWV0aG9kLXZhcmlhYmxlJywgJ3Byb3BlcnR5LWFjY2VzcyddO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWF5YmVDbGFzc05hbWVUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSBtYXliZUNsYXNzTmFtZVRva2Vuc1tpXTtcbiAgICB2YXIgdmFsdWUgPSBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFt0b2tlbl07IC8vIGNvbnZlcnQgcmVnZXggdG8gb2JqZWN0XG5cbiAgICBpZiAoUHJpc20udXRpbC50eXBlKHZhbHVlKSA9PT0gJ1JlZ0V4cCcpIHtcbiAgICAgIHZhbHVlID0gUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbdG9rZW5dID0ge1xuICAgICAgICBwYXR0ZXJuOiB2YWx1ZVxuICAgICAgfTtcbiAgICB9IC8vIGtlZXAgaW4gbWluZCB0aGF0IHdlIGRvbid0IHN1cHBvcnQgYXJyYXlzXG5cblxuICAgIHZhciBpbnNpZGUgPSB2YWx1ZS5pbnNpZGUgfHwge307XG4gICAgdmFsdWUuaW5zaWRlID0gaW5zaWRlO1xuICAgIGluc2lkZVsnbWF5YmUtY2xhc3MtbmFtZSddID0gL15bQS1aXVtcXHNcXFNdKi87XG4gIH1cbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWpzeFwiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgamF2YXNjcmlwdCA9IFByaXNtLnV0aWwuY2xvbmUoUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xuICB2YXIgc3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qKD8hLil8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKVxcKlxcLykvLnNvdXJjZTtcbiAgdmFyIGJyYWNlcyA9IC8oPzpcXHsoPzpcXHsoPzpcXHtbXnt9XSpcXH18W157fV0pKlxcfXxbXnt9XSkqXFx9KS8uc291cmNlO1xuICB2YXIgc3ByZWFkID0gLyg/OlxcezxTPipcXC57M30oPzpbXnt9XXw8QlJBQ0VTPikqXFx9KS8uc291cmNlO1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICAgKi9cblxuICBmdW5jdGlvbiByZShzb3VyY2UsIGZsYWdzKSB7XG4gICAgc291cmNlID0gc291cmNlLnJlcGxhY2UoLzxTPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3BhY2U7XG4gICAgfSkucmVwbGFjZSgvPEJSQUNFUz4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJyYWNlcztcbiAgICB9KS5yZXBsYWNlKC88U1BSRUFEPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3ByZWFkO1xuICAgIH0pO1xuICAgIHJldHVybiBSZWdFeHAoc291cmNlLCBmbGFncyk7XG4gIH1cblxuICBzcHJlYWQgPSByZShzcHJlYWQpLnNvdXJjZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ21hcmt1cCcsIGphdmFzY3JpcHQpO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5wYXR0ZXJuID0gcmUoLzxcXC8/KD86W1xcdy46LV0rKD86PFM+Kyg/OltcXHcuOiQtXSsoPzo9KD86XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcInwnKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonfFteXFxzeydcIi8+PV0rfDxCUkFDRVM+KSk/fDxTUFJFQUQ+KSkqPFM+KlxcLz8pPz4vLnNvdXJjZSk7XG4gIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsndGFnJ10ucGF0dGVybiA9IC9ePFxcLz9bXlxccz5cXC9dKi87XG4gIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsnYXR0ci12YWx1ZSddLnBhdHRlcm4gPSAvPSg/IVxceykoPzpcIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwifCcoPzpcXFxcW1xcc1xcU118W15cXFxcJ10pKid8W15cXHMnXCI+XSspLztcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcuaW5zaWRlWyd0YWcnXS5pbnNpZGVbJ2NsYXNzLW5hbWUnXSA9IC9eW0EtWl1cXHcqKD86XFwuW0EtWl1cXHcqKSokLztcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcuaW5zaWRlWydjb21tZW50J10gPSBqYXZhc2NyaXB0Wydjb21tZW50J107XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2luc2lkZScsICdhdHRyLW5hbWUnLCB7XG4gICAgJ3NwcmVhZCc6IHtcbiAgICAgIHBhdHRlcm46IHJlKC88U1BSRUFEPi8uc291cmNlKSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmpzeFxuICAgIH1cbiAgfSwgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcpO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdpbnNpZGUnLCAnc3BlY2lhbC1hdHRyJywge1xuICAgICdzY3JpcHQnOiB7XG4gICAgICAvLyBBbGxvdyBmb3IgdHdvIGxldmVscyBvZiBuZXN0aW5nXG4gICAgICBwYXR0ZXJuOiByZSgvPTxCUkFDRVM+Ly5zb3VyY2UpLFxuICAgICAgYWxpYXM6ICdsYW5ndWFnZS1qYXZhc2NyaXB0JyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnc2NyaXB0LXB1bmN0dWF0aW9uJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9ePSg/PVxceykvLFxuICAgICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICAgIH0sXG4gICAgICAgIHJlc3Q6IFByaXNtLmxhbmd1YWdlcy5qc3hcbiAgICAgIH1cbiAgICB9XG4gIH0sIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnKTsgLy8gVGhlIGZvbGxvd2luZyB3aWxsIGhhbmRsZSBwbGFpbiB0ZXh0IGluc2lkZSB0YWdzXG5cbiAgdmFyIHN0cmluZ2lmeVRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbi5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHRva2VuLmNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VuLmNvbnRlbnQubWFwKHN0cmluZ2lmeVRva2VuKS5qb2luKCcnKTtcbiAgfTtcblxuICB2YXIgd2Fsa1Rva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgICB2YXIgb3BlbmVkVGFncyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIHZhciBub3RUYWdOb3JCcmFjZSA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3RhZycgJiYgdG9rZW4uY29udGVudFswXSAmJiB0b2tlbi5jb250ZW50WzBdLnR5cGUgPT09ICd0YWcnKSB7XG4gICAgICAgICAgLy8gV2UgZm91bmQgYSB0YWcsIG5vdyBmaW5kIGl0cyBraW5kXG4gICAgICAgICAgaWYgKHRva2VuLmNvbnRlbnRbMF0uY29udGVudFswXS5jb250ZW50ID09PSAnPC8nKSB7XG4gICAgICAgICAgICAvLyBDbG9zaW5nIHRhZ1xuICAgICAgICAgICAgaWYgKG9wZW5lZFRhZ3MubGVuZ3RoID4gMCAmJiBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0udGFnTmFtZSA9PT0gc3RyaW5naWZ5VG9rZW4odG9rZW4uY29udGVudFswXS5jb250ZW50WzFdKSkge1xuICAgICAgICAgICAgICAvLyBQb3AgbWF0Y2hpbmcgb3BlbmluZyB0YWdcbiAgICAgICAgICAgICAgb3BlbmVkVGFncy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRva2VuLmNvbnRlbnRbdG9rZW4uY29udGVudC5sZW5ndGggLSAxXS5jb250ZW50ID09PSAnLz4nKSA7IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBPcGVuaW5nIHRhZ1xuICAgICAgICAgICAgICBvcGVuZWRUYWdzLnB1c2goe1xuICAgICAgICAgICAgICAgIHRhZ05hbWU6IHN0cmluZ2lmeVRva2VuKHRva2VuLmNvbnRlbnRbMF0uY29udGVudFsxXSksXG4gICAgICAgICAgICAgICAgb3BlbmVkQnJhY2VzOiAwXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvcGVuZWRUYWdzLmxlbmd0aCA+IDAgJiYgdG9rZW4udHlwZSA9PT0gJ3B1bmN0dWF0aW9uJyAmJiB0b2tlbi5jb250ZW50ID09PSAneycpIHtcbiAgICAgICAgICAvLyBIZXJlIHdlIG1pZ2h0IGhhdmUgZW50ZXJlZCBhIEpTWCBjb250ZXh0IGluc2lkZSBhIHRhZ1xuICAgICAgICAgIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS5vcGVuZWRCcmFjZXMrKztcbiAgICAgICAgfSBlbHNlIGlmIChvcGVuZWRUYWdzLmxlbmd0aCA+IDAgJiYgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLm9wZW5lZEJyYWNlcyA+IDAgJiYgdG9rZW4udHlwZSA9PT0gJ3B1bmN0dWF0aW9uJyAmJiB0b2tlbi5jb250ZW50ID09PSAnfScpIHtcbiAgICAgICAgICAvLyBIZXJlIHdlIG1pZ2h0IGhhdmUgbGVmdCBhIEpTWCBjb250ZXh0IGluc2lkZSBhIHRhZ1xuICAgICAgICAgIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS5vcGVuZWRCcmFjZXMtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3RUYWdOb3JCcmFjZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5vdFRhZ05vckJyYWNlIHx8IHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKG9wZW5lZFRhZ3MubGVuZ3RoID4gMCAmJiBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgLy8gSGVyZSB3ZSBhcmUgaW5zaWRlIGEgdGFnLCBhbmQgbm90IGluc2lkZSBhIEpTWCBjb250ZXh0LlxuICAgICAgICAgIC8vIFRoYXQncyBwbGFpbiB0ZXh0OiBkcm9wIGFueSB0b2tlbnMgbWF0Y2hlZC5cbiAgICAgICAgICB2YXIgcGxhaW5UZXh0ID0gc3RyaW5naWZ5VG9rZW4odG9rZW4pOyAvLyBBbmQgbWVyZ2UgdGV4dCB3aXRoIGFkamFjZW50IHRleHRcblxuICAgICAgICAgIGlmIChpIDwgdG9rZW5zLmxlbmd0aCAtIDEgJiYgKHR5cGVvZiB0b2tlbnNbaSArIDFdID09PSAnc3RyaW5nJyB8fCB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICdwbGFpbi10ZXh0JykpIHtcbiAgICAgICAgICAgIHBsYWluVGV4dCArPSBzdHJpbmdpZnlUb2tlbih0b2tlbnNbaSArIDFdKTtcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID4gMCAmJiAodHlwZW9mIHRva2Vuc1tpIC0gMV0gPT09ICdzdHJpbmcnIHx8IHRva2Vuc1tpIC0gMV0udHlwZSA9PT0gJ3BsYWluLXRleHQnKSkge1xuICAgICAgICAgICAgcGxhaW5UZXh0ID0gc3RyaW5naWZ5VG9rZW4odG9rZW5zW2kgLSAxXSkgKyBwbGFpblRleHQ7XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlKGkgLSAxLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnNbaV0gPSBuZXcgUHJpc20uVG9rZW4oJ3BsYWluLXRleHQnLCBwbGFpblRleHQsIG51bGwsIHBsYWluVGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLmNvbnRlbnQgJiYgdHlwZW9mIHRva2VuLmNvbnRlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHdhbGtUb2tlbnModG9rZW4uY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFByaXNtLmhvb2tzLmFkZCgnYWZ0ZXItdG9rZW5pemUnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgaWYgKGVudi5sYW5ndWFnZSAhPT0gJ2pzeCcgJiYgZW52Lmxhbmd1YWdlICE9PSAndHN4Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhbGtUb2tlbnMoZW52LnRva2Vucyk7XG4gIH0pO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tZGlmZlwiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICBQcmlzbS5sYW5ndWFnZXMuZGlmZiA9IHtcbiAgICAnY29vcmQnOiBbLy8gTWF0Y2ggYWxsIGtpbmRzIG9mIGNvb3JkIGxpbmVzIChwcmVmaXhlZCBieSBcIisrK1wiLCBcIi0tLVwiIG9yIFwiKioqXCIpLlxuICAgIC9eKD86XFwqezN9fC17M318XFwrezN9KS4qJC9tLCAvLyBNYXRjaCBcIkBAIC4uLiBAQFwiIGNvb3JkIGxpbmVzIGluIHVuaWZpZWQgZGlmZi5cbiAgICAvXkBALipAQCQvbSwgLy8gTWF0Y2ggY29vcmQgbGluZXMgaW4gbm9ybWFsIGRpZmYgKHN0YXJ0cyB3aXRoIGEgbnVtYmVyKS5cbiAgICAvXlxcZC4qJC9tXSAvLyBkZWxldGVkLCBpbnNlcnRlZCwgdW5jaGFuZ2VkLCBkaWZmXG5cbiAgfTtcbiAgLyoqXG4gICAqIEEgbWFwIGZyb20gdGhlIG5hbWUgb2YgYSBibG9jayB0byBpdHMgbGluZSBwcmVmaXguXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICAgKi9cblxuICB2YXIgUFJFRklYRVMgPSB7XG4gICAgJ2RlbGV0ZWQtc2lnbic6ICctJyxcbiAgICAnZGVsZXRlZC1hcnJvdyc6ICc8JyxcbiAgICAnaW5zZXJ0ZWQtc2lnbic6ICcrJyxcbiAgICAnaW5zZXJ0ZWQtYXJyb3cnOiAnPicsXG4gICAgJ3VuY2hhbmdlZCc6ICcgJyxcbiAgICAnZGlmZic6ICchJ1xuICB9OyAvLyBhZGQgYSB0b2tlbiBmb3IgZWFjaCBwcmVmaXhcblxuICBPYmplY3Qua2V5cyhQUkVGSVhFUykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBwcmVmaXggPSBQUkVGSVhFU1tuYW1lXTtcbiAgICB2YXIgYWxpYXMgPSBbXTtcblxuICAgIGlmICghL15cXHcrJC8udGVzdChuYW1lKSkge1xuICAgICAgLy8gXCJkZWxldGVkLXNpZ25cIiAtPiBcImRlbGV0ZWRcIlxuICAgICAgYWxpYXMucHVzaCgvXFx3Ky8uZXhlYyhuYW1lKVswXSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdkaWZmJykge1xuICAgICAgYWxpYXMucHVzaCgnYm9sZCcpO1xuICAgIH1cblxuICAgIFByaXNtLmxhbmd1YWdlcy5kaWZmW25hbWVdID0ge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdeKD86WycgKyBwcmVmaXggKyAnXS4qKD86XFxyXFxuP3xcXG58KD8hW1xcXFxzXFxcXFNdKSkpKycsICdtJyksXG4gICAgICBhbGlhczogYWxpYXMsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2xpbmUnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyguKSg/PVtcXHNcXFNdKS4qKD86XFxyXFxuP3xcXG4pPy8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAncHJlZml4Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC9bXFxzXFxTXS8sXG4gICAgICAgICAgYWxpYXM6IC9cXHcrLy5leGVjKG5hbWUpWzBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KTsgLy8gbWFrZSBwcmVmaXhlcyBhdmFpbGFibGUgdG8gRGlmZiBwbHVnaW5cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLmRpZmYsICdQUkVGSVhFUycsIHtcbiAgICB2YWx1ZTogUFJFRklYRVNcbiAgfSk7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1naXRcIiAqL1xuXG5cbnByaXNtLmxhbmd1YWdlcy5naXQgPSB7XG4gIC8qXG4gICAqIEEgc2ltcGxlIG9uZSBsaW5lIGNvbW1lbnQgbGlrZSBpbiBhIGdpdCBzdGF0dXMgY29tbWFuZFxuICAgKiBGb3IgaW5zdGFuY2U6XG4gICAqICQgZ2l0IHN0YXR1c1xuICAgKiAjIE9uIGJyYW5jaCBpbmZpbml0ZS1zY3JvbGxcbiAgICogIyBZb3VyIGJyYW5jaCBhbmQgJ29yaWdpbi9zaGFyZWRCcmFuY2hlcy9mcm9udGVuZFRlYW0vaW5maW5pdGUtc2Nyb2xsJyBoYXZlIGRpdmVyZ2VkLFxuICAgKiAjIGFuZCBoYXZlIDEgYW5kIDIgZGlmZmVyZW50IGNvbW1pdHMgZWFjaCwgcmVzcGVjdGl2ZWx5LlxuICAgKiBub3RoaW5nIHRvIGNvbW1pdCAod29ya2luZyBkaXJlY3RvcnkgY2xlYW4pXG4gICAqL1xuICAnY29tbWVudCc6IC9eIy4qL20sXG5cbiAgLypcbiAgICogUmVnZXhwIHRvIG1hdGNoIHRoZSBjaGFuZ2VkIGxpbmVzIGluIGEgZ2l0IGRpZmYgb3V0cHV0LiBDaGVjayB0aGUgZXhhbXBsZSBiZWxvdy5cbiAgICovXG4gICdkZWxldGVkJzogL15bLeKAk10uKi9tLFxuICAnaW5zZXJ0ZWQnOiAvXlxcKy4qL20sXG5cbiAgLypcbiAgICogYSBzdHJpbmcgKGRvdWJsZSBhbmQgc2ltcGxlIHF1b3RlKVxuICAgKi9cbiAgJ3N0cmluZyc6IC8oXCJ8JykoPzpcXFxcLnwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcblxuICAvKlxuICAgKiBhIGdpdCBjb21tYW5kLiBJdCBzdGFydHMgd2l0aCBhIHJhbmRvbSBwcm9tcHQgZmluaXNoaW5nIGJ5IGEgJCwgdGhlbiBcImdpdFwiIHRoZW4gc29tZSBvdGhlciBwYXJhbWV0ZXJzXG4gICAqIEZvciBpbnN0YW5jZTpcbiAgICogJCBnaXQgYWRkIGZpbGUudHh0XG4gICAqL1xuICAnY29tbWFuZCc6IHtcbiAgICBwYXR0ZXJuOiAvXi4qXFwkIGdpdCAuKiQvbSxcbiAgICBpbnNpZGU6IHtcbiAgICAgIC8qXG4gICAgICAgKiBBIGdpdCBjb21tYW5kIGNhbiBjb250YWluIGEgcGFyYW1ldGVyIHN0YXJ0aW5nIGJ5IGEgc2luZ2xlIG9yIGEgZG91YmxlIGRhc2ggZm9sbG93ZWQgYnkgYSBzdHJpbmdcbiAgICAgICAqIEZvciBpbnN0YW5jZTpcbiAgICAgICAqICQgZ2l0IGRpZmYgLS1jYWNoZWRcbiAgICAgICAqICQgZ2l0IGxvZyAtcFxuICAgICAgICovXG4gICAgICAncGFyYW1ldGVyJzogL1xccy0tP1xcdysvXG4gICAgfVxuICB9LFxuXG4gIC8qXG4gICAqIENvb3JkaW5hdGVzIGRpc3BsYXllZCBpbiBhIGdpdCBkaWZmIGNvbW1hbmRcbiAgICogRm9yIGluc3RhbmNlOlxuICAgKiAkIGdpdCBkaWZmXG4gICAqIGRpZmYgLS1naXQgZmlsZS50eHQgZmlsZS50eHRcbiAgICogaW5kZXggNjIxNDk1My4uMWQ1NGE1MiAxMDA2NDRcbiAgICogLS0tIGZpbGUudHh0XG4gICAqICsrKyBmaWxlLnR4dFxuICAgKiBAQCAtMSArMSwyIEBAXG4gICAqIC1IZXJlJ3MgbXkgdGV0eCBmaWxlXG4gICAqICtIZXJlJ3MgbXkgdGV4dCBmaWxlXG4gICAqICtBbmQgdGhpcyBpcyB0aGUgc2Vjb25kIGxpbmVcbiAgICovXG4gICdjb29yZCc6IC9eQEAuKkBAJC9tLFxuXG4gIC8qXG4gICAqIE1hdGNoIGEgXCJjb21taXQgW1NIQTFdXCIgbGluZSBpbiBhIGdpdCBsb2cgb3V0cHV0LlxuICAgKiBGb3IgaW5zdGFuY2U6XG4gICAqICQgZ2l0IGxvZ1xuICAgKiBjb21taXQgYTExYTE0ZWY3ZTI2ZjJjYTYyZDRiMzVlYWM0NTVjZTYzNmQwZGMwOVxuICAgKiBBdXRob3I6IGxnaXJhdWRlbFxuICAgKiBEYXRlOiAgIE1vbiBGZWIgMTcgMTE6MTg6MzQgMjAxNCArMDEwMFxuICAgKlxuICAgKiAgICAgQWRkIG9mIGEgbmV3IGxpbmVcbiAgICovXG4gICdjb21taXQtc2hhMSc6IC9eY29tbWl0IFxcd3s0MH0kL21cbn07XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1nb1wiICovXG5cbnByaXNtLmxhbmd1YWdlcy5nbyA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NsaWtlJywge1xuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVwiKD86XFxcXC58W15cIlxcXFxcXHJcXG5dKSpcInxgW15gXSpgLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpicmVha3xjYXNlfGNoYW58Y29uc3R8Y29udGludWV8ZGVmYXVsdHxkZWZlcnxlbHNlfGZhbGx0aHJvdWdofGZvcnxmdW5jfGdvKD86dG8pP3xpZnxpbXBvcnR8aW50ZXJmYWNlfG1hcHxwYWNrYWdlfHJhbmdlfHJldHVybnxzZWxlY3R8c3RydWN0fHN3aXRjaHx0eXBlfHZhcilcXGIvLFxuICAnYm9vbGVhbic6IC9cXGIoPzpffGZhbHNlfGlvdGF8bmlsfHRydWUpXFxiLyxcbiAgJ251bWJlcic6IFsvLyBiaW5hcnkgYW5kIG9jdGFsIGludGVnZXJzXG4gIC9cXGIwKD86YlswMV9dK3xvWzAtN19dKylpP1xcYi9pLCAvLyBoZXhhZGVjaW1hbCBpbnRlZ2VycyBhbmQgZmxvYXRzXG4gIC9cXGIweCg/OlthLWZcXGRfXSsoPzpcXC5bYS1mXFxkX10qKT98XFwuW2EtZlxcZF9dKykoPzpwWystXT9cXGQrKD86X1xcZCspKik/aT8oPyFcXHcpL2ksIC8vIGRlY2ltYWwgaW50ZWdlcnMgYW5kIGZsb2F0c1xuICAvKD86XFxiXFxkW1xcZF9dKig/OlxcLltcXGRfXSopP3xcXEJcXC5cXGRbXFxkX10qKSg/OmVbKy1dP1tcXGRfXSspP2k/KD8hXFx3KS9pXSxcbiAgJ29wZXJhdG9yJzogL1sqXFwvJV4hPV09P3xcXCtbPStdP3wtWz0tXT98XFx8Wz18XT98Jig/Oj18JnxcXF49Pyk/fD4oPzo+PT98PSk/fDwoPzo8PT98PXwtKT98Oj18XFwuXFwuXFwuLyxcbiAgJ2J1aWx0aW4nOiAvXFxiKD86YXBwZW5kfGJvb2x8Ynl0ZXxjYXB8Y2xvc2V8Y29tcGxleHxjb21wbGV4KD86NjR8MTI4KXxjb3B5fGRlbGV0ZXxlcnJvcnxmbG9hdCg/OjMyfDY0KXx1P2ludCg/Ojh8MTZ8MzJ8NjQpP3xpbWFnfGxlbnxtYWtlfG5ld3xwYW5pY3xwcmludCg/OmxuKT98cmVhbHxyZWNvdmVyfHJ1bmV8c3RyaW5nfHVpbnRwdHIpXFxiL1xufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdnbycsICdzdHJpbmcnLCB7XG4gICdjaGFyJzoge1xuICAgIHBhdHRlcm46IC8nKD86XFxcXC58W14nXFxcXFxcclxcbl0pezAsMTB9Jy8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH1cbn0pO1xuZGVsZXRlIHByaXNtLmxhbmd1YWdlcy5nb1snY2xhc3MtbmFtZSddO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFya3VwLXRlbXBsYXRpbmdcIiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBmb3IgdGhlIGdpdmVuIGxhbmd1YWdlIGlkIGFuZCBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gaW5kZXhcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGZ1bmN0aW9uIGdldFBsYWNlaG9sZGVyKGxhbmd1YWdlLCBpbmRleCkge1xuICAgIHJldHVybiAnX19fJyArIGxhbmd1YWdlLnRvVXBwZXJDYXNlKCkgKyBpbmRleCArICdfX18nO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUHJpc20ubGFuZ3VhZ2VzWydtYXJrdXAtdGVtcGxhdGluZyddID0ge30sIHtcbiAgICBidWlsZFBsYWNlaG9sZGVyczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUb2tlbml6ZSBhbGwgaW5saW5lIHRlbXBsYXRpbmcgZXhwcmVzc2lvbnMgbWF0Y2hpbmcgYHBsYWNlaG9sZGVyUGF0dGVybmAuXG4gICAgICAgKlxuICAgICAgICogSWYgYHJlcGxhY2VGaWx0ZXJgIGlzIHByb3ZpZGVkLCBvbmx5IG1hdGNoZXMgb2YgYHBsYWNlaG9sZGVyUGF0dGVybmAgZm9yIHdoaWNoIGByZXBsYWNlRmlsdGVyYCByZXR1cm5zXG4gICAgICAgKiBgdHJ1ZWAgd2lsbCBiZSByZXBsYWNlZC5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gZW52IFRoZSBlbnZpcm9ubWVudCBvZiB0aGUgYGJlZm9yZS10b2tlbml6ZWAgaG9vay5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbGFuZ3VhZ2UgaWQuXG4gICAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gcGxhY2Vob2xkZXJQYXR0ZXJuIFRoZSBtYXRjaGVzIG9mIHRoaXMgcGF0dGVybiB3aWxsIGJlIHJlcGxhY2VkIGJ5IHBsYWNlaG9sZGVycy5cbiAgICAgICAqIEBwYXJhbSB7KG1hdGNoOiBzdHJpbmcpID0+IGJvb2xlYW59IFtyZXBsYWNlRmlsdGVyXVxuICAgICAgICovXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKGVudiwgbGFuZ3VhZ2UsIHBsYWNlaG9sZGVyUGF0dGVybiwgcmVwbGFjZUZpbHRlcikge1xuICAgICAgICBpZiAoZW52Lmxhbmd1YWdlICE9PSBsYW5ndWFnZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tlblN0YWNrID0gZW52LnRva2VuU3RhY2sgPSBbXTtcbiAgICAgICAgZW52LmNvZGUgPSBlbnYuY29kZS5yZXBsYWNlKHBsYWNlaG9sZGVyUGF0dGVybiwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlRmlsdGVyID09PSAnZnVuY3Rpb24nICYmICFyZXBsYWNlRmlsdGVyKG1hdGNoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpID0gdG9rZW5TdGFjay5sZW5ndGg7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyOyAvLyBDaGVjayBmb3IgZXhpc3Rpbmcgc3RyaW5nc1xuXG4gICAgICAgICAgd2hpbGUgKGVudi5jb2RlLmluZGV4T2YocGxhY2Vob2xkZXIgPSBnZXRQbGFjZWhvbGRlcihsYW5ndWFnZSwgaSkpICE9PSAtMSkge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgIH0gLy8gQ3JlYXRlIGEgc3BhcnNlIGFycmF5XG5cblxuICAgICAgICAgIHRva2VuU3RhY2tbaV0gPSBtYXRjaDtcbiAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgICAgIH0pOyAvLyBTd2l0Y2ggdGhlIGdyYW1tYXIgdG8gbWFya3VwXG5cbiAgICAgICAgZW52LmdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9rZW5pemVQbGFjZWhvbGRlcnM6IHtcbiAgICAgIC8qKlxuICAgICAgICogUmVwbGFjZSBwbGFjZWhvbGRlcnMgd2l0aCBwcm9wZXIgdG9rZW5zIGFmdGVyIHRva2VuaXppbmcuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IGVudiBUaGUgZW52aXJvbm1lbnQgb2YgdGhlIGBhZnRlci10b2tlbml6ZWAgaG9vay5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbGFuZ3VhZ2UgaWQuXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZW52LCBsYW5ndWFnZSkge1xuICAgICAgICBpZiAoZW52Lmxhbmd1YWdlICE9PSBsYW5ndWFnZSB8fCAhZW52LnRva2VuU3RhY2spIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3dpdGNoIHRoZSBncmFtbWFyIGJhY2tcblxuXG4gICAgICAgIGVudi5ncmFtbWFyID0gUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXTtcbiAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVudi50b2tlblN0YWNrKTtcblxuICAgICAgICBmdW5jdGlvbiB3YWxrVG9rZW5zKHRva2Vucykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBhbGwgcGxhY2Vob2xkZXJzIGFyZSByZXBsYWNlZCBhbHJlYWR5XG4gICAgICAgICAgICBpZiAoaiA+PSBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyB8fCB0b2tlbi5jb250ZW50ICYmIHR5cGVvZiB0b2tlbi5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YXIgayA9IGtleXNbal07XG4gICAgICAgICAgICAgIHZhciB0ID0gZW52LnRva2VuU3RhY2tba107XG4gICAgICAgICAgICAgIHZhciBzID0gdHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyA/IHRva2VuIDogdG9rZW4uY29udGVudDtcbiAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0UGxhY2Vob2xkZXIobGFuZ3VhZ2UsIGspO1xuICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzLmluZGV4T2YocGxhY2Vob2xkZXIpO1xuXG4gICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICAgIHZhciBiZWZvcmUgPSBzLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIG1pZGRsZSA9IG5ldyBQcmlzbS5Ub2tlbihsYW5ndWFnZSwgUHJpc20udG9rZW5pemUodCwgZW52LmdyYW1tYXIpLCAnbGFuZ3VhZ2UtJyArIGxhbmd1YWdlLCB0KTtcbiAgICAgICAgICAgICAgICB2YXIgYWZ0ZXIgPSBzLnN1YnN0cmluZyhpbmRleCArIHBsYWNlaG9sZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gW107XG5cbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wdXNoLmFwcGx5KHJlcGxhY2VtZW50LCB3YWxrVG9rZW5zKFtiZWZvcmVdKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucHVzaChtaWRkbGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wdXNoLmFwcGx5KHJlcGxhY2VtZW50LCB3YWxrVG9rZW5zKFthZnRlcl0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgdG9rZW5zLnNwbGljZS5hcHBseSh0b2tlbnMsIFtpLCAxXS5jb25jYXQocmVwbGFjZW1lbnQpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5jb250ZW50XG4gICAgICAgICAgICAvKiAmJiB0eXBlb2YgdG9rZW4uY29udGVudCAhPT0gJ3N0cmluZycgKi9cbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHdhbGtUb2tlbnModG9rZW4uY29udGVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICB9XG5cbiAgICAgICAgd2Fsa1Rva2VucyhlbnYudG9rZW5zKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20taGFuZGxlYmFyc1wiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICBQcmlzbS5sYW5ndWFnZXMuaGFuZGxlYmFycyA9IHtcbiAgICAnY29tbWVudCc6IC9cXHtcXHshW1xcc1xcU10qP1xcfVxcfS8sXG4gICAgJ2RlbGltaXRlcic6IHtcbiAgICAgIHBhdHRlcm46IC9eXFx7XFx7XFx7P3xcXH1cXH1cXH0/JC8sXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ3N0cmluZyc6IC8oW1wiJ10pKD86XFxcXC58KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG4gICAgJ251bWJlcic6IC9cXGIweFtcXGRBLUZhLWZdK1xcYnwoPzpcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86W0VlXVsrLV0/XFxkKyk/LyxcbiAgICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICAgJ2Jsb2NrJzoge1xuICAgICAgcGF0dGVybjogL14oXFxzKig/On5cXHMqKT8pWyNcXC9dXFxTKz8oPz1cXHMqKD86flxccyopPyR8XFxzKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdrZXl3b3JkJ1xuICAgIH0sXG4gICAgJ2JyYWNrZXRzJzoge1xuICAgICAgcGF0dGVybjogL1xcW1teXFxdXStcXF0vLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIHB1bmN0dWF0aW9uOiAvXFxbfFxcXS8sXG4gICAgICAgIHZhcmlhYmxlOiAvW1xcc1xcU10rL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3B1bmN0dWF0aW9uJzogL1shXCIjJSYnOigpKissLlxcLzs8PT5AXFxbXFxcXFxcXV5ge3x9fl0vLFxuICAgICd2YXJpYWJsZSc6IC9bXiFcIiMlJicoKSorLFxcLzs8PT5AXFxbXFxcXFxcXV5ge3x9flxcc10rL1xuICB9O1xuICBQcmlzbS5ob29rcy5hZGQoJ2JlZm9yZS10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICB2YXIgaGFuZGxlYmFyc1BhdHRlcm4gPSAvXFx7XFx7XFx7W1xcc1xcU10rP1xcfVxcfVxcfXxcXHtcXHtbXFxzXFxTXSs/XFx9XFx9L2c7XG4gICAgUHJpc20ubGFuZ3VhZ2VzWydtYXJrdXAtdGVtcGxhdGluZyddLmJ1aWxkUGxhY2Vob2xkZXJzKGVudiwgJ2hhbmRsZWJhcnMnLCBoYW5kbGViYXJzUGF0dGVybik7XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIFByaXNtLmxhbmd1YWdlc1snbWFya3VwLXRlbXBsYXRpbmcnXS50b2tlbml6ZVBsYWNlaG9sZGVycyhlbnYsICdoYW5kbGViYXJzJyk7XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaGJzID0gUHJpc20ubGFuZ3VhZ2VzLmhhbmRsZWJhcnM7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qc29uXCIgKi9cbi8vIGh0dHBzOi8vd3d3Lmpzb24ub3JnL2pzb24tZW4uaHRtbFxuXG5cbnByaXNtLmxhbmd1YWdlcy5qc29uID0ge1xuICAncHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pXCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiKD89XFxzKjopLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIig/IVxccyo6KS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogL1xcL1xcLy4qfFxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnbnVtYmVyJzogLy0/XFxiXFxkKyg/OlxcLlxcZCspPyg/OmVbKy1dP1xcZCspP1xcYi9pLFxuICAncHVuY3R1YXRpb24nOiAvW3t9W1xcXSxdLyxcbiAgJ29wZXJhdG9yJzogLzovLFxuICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICdudWxsJzoge1xuICAgIHBhdHRlcm46IC9cXGJudWxsXFxiLyxcbiAgICBhbGlhczogJ2tleXdvcmQnXG4gIH1cbn07XG5wcmlzbS5sYW5ndWFnZXMud2VibWFuaWZlc3QgPSBwcmlzbS5sYW5ndWFnZXMuanNvbjtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWxlc3NcIiAqL1xuXG4vKiBGSVhNRSA6XG4gOmV4dGVuZCgpIGlzIG5vdCBoYW5kbGVkIHNwZWNpZmljYWxseSA6IGl0cyBoaWdobGlnaHRpbmcgaXMgYnVnZ3kuXG4gTWl4aW4gdXNhZ2UgbXVzdCBiZSBpbnNpZGUgYSBydWxlc2V0IHRvIGJlIGhpZ2hsaWdodGVkLlxuIEF0LXJ1bGVzIChlLmcuIGltcG9ydCkgY29udGFpbmluZyBpbnRlcnBvbGF0aW9ucyBhcmUgYnVnZ3kuXG4gRGV0YWNoZWQgcnVsZXNldHMgYXJlIGhpZ2hsaWdodGVkIGFzIGF0LXJ1bGVzLlxuIEEgY29tbWVudCBiZWZvcmUgYSBtaXhpbiB1c2FnZSBwcmV2ZW50cyB0aGUgbGF0dGVyIHRvIGJlIHByb3Blcmx5IGhpZ2hsaWdodGVkLlxuICovXG5cbnByaXNtLmxhbmd1YWdlcy5sZXNzID0gcHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3NzJywge1xuICAnY29tbWVudCc6IFsvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy8sIHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXC8uKi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XSxcbiAgJ2F0cnVsZSc6IHtcbiAgICBwYXR0ZXJuOiAvQFtcXHctXSg/OlxcKCg/OlteKCl7fV18XFwoW14oKXt9XSpcXCkpKlxcKXxbXigpe307XFxzXXxcXHMrKD8hXFxzKSkqPyg/PVxccypcXHspLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdwdW5jdHVhdGlvbic6IC9bOigpXS9cbiAgICB9XG4gIH0sXG4gIC8vIHNlbGVjdG9ycyBhbmQgbWl4aW5zIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXG4gICdzZWxlY3Rvcic6IHtcbiAgICBwYXR0ZXJuOiAvKD86QFxce1tcXHctXStcXH18W157fTtcXHNAXSkoPzpAXFx7W1xcdy1dK1xcfXxcXCgoPzpbXigpe31dfFxcKFteKCl7fV0qXFwpKSpcXCl8W14oKXt9O0BcXHNdfFxccysoPyFcXHMpKSo/KD89XFxzKlxceykvLFxuICAgIGluc2lkZToge1xuICAgICAgLy8gbWl4aW4gcGFyYW1ldGVyc1xuICAgICAgJ3ZhcmlhYmxlJzogL0ArW1xcdy1dKy9cbiAgICB9XG4gIH0sXG4gICdwcm9wZXJ0eSc6IC8oPzpAXFx7W1xcdy1dK1xcfXxbXFx3LV0pKyg/OlxcK18/KT8oPz1cXHMqOikvLFxuICAnb3BlcmF0b3InOiAvWytcXC0qXFwvXS9cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbGVzcycsICdwcm9wZXJ0eScsIHtcbiAgJ3ZhcmlhYmxlJzogWy8vIFZhcmlhYmxlIGRlY2xhcmF0aW9uICh0aGUgY29sb24gbXVzdCBiZSBjb25zdW1lZCEpXG4gIHtcbiAgICBwYXR0ZXJuOiAvQFtcXHctXStcXHMqOi8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvOi9cbiAgICB9XG4gIH0sIC8vIFZhcmlhYmxlIHVzYWdlXG4gIC9AQD9bXFx3LV0rL10sXG4gICdtaXhpbi11c2FnZSc6IHtcbiAgICBwYXR0ZXJuOiAvKFt7O11cXHMqKVsuI10oPyFcXGQpW1xcdy1dLio/KD89Wyg7XSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfVxufSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYWtlZmlsZVwiICovXG5cbnByaXNtLmxhbmd1YWdlcy5tYWtlZmlsZSA9IHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pIyg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXFxcXFxcclxcbl0pKi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdidWlsdGluLXRhcmdldCc6IHtcbiAgICBwYXR0ZXJuOiAvXFwuW0EtWl1bXjojPVxcc10rKD89XFxzKjooPyE9KSkvLFxuICAgIGFsaWFzOiAnYnVpbHRpbidcbiAgfSxcbiAgJ3RhcmdldCc6IHtcbiAgICBwYXR0ZXJuOiAvXig/OlteOj1cXHNdfFsgXFx0XSsoPyFbXFxzOl0pKSsoPz1cXHMqOig/IT0pKS9tLFxuICAgIGFsaWFzOiAnc3ltYm9sJyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICd2YXJpYWJsZSc6IC9cXCQrKD86KD8hXFwkKVteKCl7fTojPVxcc10rfCg/PVsoe10pKS9cbiAgICB9XG4gIH0sXG4gICd2YXJpYWJsZSc6IC9cXCQrKD86KD8hXFwkKVteKCl7fTojPVxcc10rfFxcKFtAKiU8Xis/XVtERl1cXCl8KD89Wyh7XSkpLyxcbiAgLy8gRGlyZWN0aXZlc1xuICAna2V5d29yZCc6IC8taW5jbHVkZVxcYnxcXGIoPzpkZWZpbmV8ZWxzZXxlbmRlZnxlbmRpZnxleHBvcnR8aWZuP2RlZnxpZm4/ZXF8aW5jbHVkZXxvdmVycmlkZXxwcml2YXRlfHNpbmNsdWRlfHVuZGVmaW5lfHVuZXhwb3J0fHZwYXRoKVxcYi8sXG4gICdmdW5jdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKFxcKCkoPzphYnNwYXRofGFkZHN1ZmZpeHxhbmR8YmFzZW5hbWV8Y2FsbHxkaXJ8ZXJyb3J8ZXZhbHxmaWxlfGZpbHRlcig/Oi1vdXQpP3xmaW5kc3RyaW5nfGZpcnN0d29yZHxmbGF2b3J8Zm9yZWFjaHxndWlsZXxpZnxpbmZvfGpvaW58bGFzdHdvcmR8bG9hZHxub3RkaXJ8b3J8b3JpZ2lufHBhdHN1YnN0fHJlYWxwYXRofHNoZWxsfHNvcnR8c3RyaXB8c3Vic3R8c3VmZml4fHZhbHVlfHdhcm5pbmd8d2lsZGNhcmR8d29yZCg/Omxpc3R8cyk/KSg/PVsgXFx0XSkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ29wZXJhdG9yJzogLyg/Ojo6fFs/OishXSk/PXxbfEBdLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1s6Oygpe31dL1xufTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW9iamVjdGl2ZWNcIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMub2JqZWN0aXZlYyA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2MnLCB7XG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogL0A/XCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwiLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86YXNtfGF1dG98YnJlYWt8Y2FzZXxjaGFyfGNvbnN0fGNvbnRpbnVlfGRlZmF1bHR8ZG98ZG91YmxlfGVsc2V8ZW51bXxleHRlcm58ZmxvYXR8Zm9yfGdvdG98aWZ8aW58aW5saW5lfGludHxsb25nfHJlZ2lzdGVyfHJldHVybnxzZWxmfHNob3J0fHNpZ25lZHxzaXplb2Z8c3RhdGljfHN0cnVjdHxzdXBlcnxzd2l0Y2h8dHlwZWRlZnx0eXBlb2Z8dW5pb258dW5zaWduZWR8dm9pZHx2b2xhdGlsZXx3aGlsZSlcXGJ8KD86QGludGVyZmFjZXxAZW5kfEBpbXBsZW1lbnRhdGlvbnxAcHJvdG9jb2x8QGNsYXNzfEBwdWJsaWN8QHByb3RlY3RlZHxAcHJpdmF0ZXxAcHJvcGVydHl8QHRyeXxAY2F0Y2h8QGZpbmFsbHl8QHRocm93fEBzeW50aGVzaXplfEBkeW5hbWljfEBzZWxlY3RvcilcXGIvLFxuICAnb3BlcmF0b3InOiAvLVstPl0/fFxcK1xcKz98IT0/fDw8Pz0/fD4+Pz0/fD09P3wmJj98XFx8XFx8P3xbfl4lPypcXC9AXS9cbn0pO1xuZGVsZXRlIHByaXNtLmxhbmd1YWdlcy5vYmplY3RpdmVjWydjbGFzcy1uYW1lJ107XG5wcmlzbS5sYW5ndWFnZXMub2JqYyA9IHByaXNtLmxhbmd1YWdlcy5vYmplY3RpdmVjO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tb2NhbWxcIiAqL1xuLy8gaHR0cHM6Ly9vY2FtbC5vcmcvbWFudWFsL2xleC5odG1sXG5cbnByaXNtLmxhbmd1YWdlcy5vY2FtbCA9IHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogL1xcKFxcKltcXHNcXFNdKj9cXCpcXCkvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnY2hhcic6IHtcbiAgICBwYXR0ZXJuOiAvJyg/OlteXFxcXFxcclxcbiddfFxcXFwoPzoufFtveF0/WzAtOWEtZl17MSwzfSkpJy9pLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnc3RyaW5nJzogW3tcbiAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcKD86W1xcc1xcU118XFxyXFxuKXxbXlxcXFxcXHJcXG5cIl0pKlwiLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSwge1xuICAgIHBhdHRlcm46IC9cXHsoW2Etel9dKilcXHxbXFxzXFxTXSo/XFx8XFwxXFx9LyxcbiAgICBncmVlZHk6IHRydWVcbiAgfV0sXG4gICdudW1iZXInOiBbLy8gYmluYXJ5IGFuZCBvY3RhbFxuICAvXFxiKD86MGJbMDFdWzAxX10qfDBvWzAtN11bMC03X10qKVxcYi9pLCAvLyBoZXhhZGVjaW1hbFxuICAvXFxiMHhbYS1mMC05XVthLWYwLTlfXSooPzpcXC5bYS1mMC05X10qKT8oPzpwWystXT9cXGRbXFxkX10qKT8oPyFcXHcpL2ksIC8vIGRlY2ltYWxcbiAgL1xcYlxcZFtcXGRfXSooPzpcXC5bXFxkX10qKT8oPzplWystXT9cXGRbXFxkX10qKT8oPyFcXHcpL2ldLFxuICAnZGlyZWN0aXZlJzoge1xuICAgIHBhdHRlcm46IC9cXEIjXFx3Ky8sXG4gICAgYWxpYXM6ICdwcm9wZXJ0eSdcbiAgfSxcbiAgJ2xhYmVsJzoge1xuICAgIHBhdHRlcm46IC9cXEJ+XFx3Ky8sXG4gICAgYWxpYXM6ICdwcm9wZXJ0eSdcbiAgfSxcbiAgJ3R5cGUtdmFyaWFibGUnOiB7XG4gICAgcGF0dGVybjogL1xcQidcXHcrLyxcbiAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICB9LFxuICAndmFyaWFudCc6IHtcbiAgICBwYXR0ZXJuOiAvYFxcdysvLFxuICAgIGFsaWFzOiAnc3ltYm9sJ1xuICB9LFxuICAvLyBGb3IgdGhlIGxpc3Qgb2Yga2V5d29yZHMgYW5kIG9wZXJhdG9ycyxcbiAgLy8gc2VlOiBodHRwOi8vY2FtbC5pbnJpYS5mci9wdWIvZG9jcy9tYW51YWwtb2NhbWwvbGV4Lmh0bWwjc2VjODRcbiAgJ2tleXdvcmQnOiAvXFxiKD86YXN8YXNzZXJ0fGJlZ2lufGNsYXNzfGNvbnN0cmFpbnR8ZG98ZG9uZXxkb3dudG98ZWxzZXxlbmR8ZXhjZXB0aW9ufGV4dGVybmFsfGZvcnxmdW58ZnVuY3Rpb258ZnVuY3RvcnxpZnxpbnxpbmNsdWRlfGluaGVyaXR8aW5pdGlhbGl6ZXJ8bGF6eXxsZXR8bWF0Y2h8bWV0aG9kfG1vZHVsZXxtdXRhYmxlfG5ld3xub25yZWN8b2JqZWN0fG9mfG9wZW58cHJpdmF0ZXxyZWN8c2lnfHN0cnVjdHx0aGVufHRvfHRyeXx0eXBlfHZhbHx2YWx1ZXx2aXJ0dWFsfHdoZW58d2hlcmV8d2hpbGV8d2l0aClcXGIvLFxuICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICdvcGVyYXRvci1saWtlLXB1bmN0dWF0aW9uJzoge1xuICAgIHBhdHRlcm46IC9cXFtbPD58XXxbPnxdXFxdfFxcezx8PlxcfS8sXG4gICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgfSxcbiAgLy8gQ3VzdG9tIG9wZXJhdG9ycyBhcmUgYWxsb3dlZFxuICAnb3BlcmF0b3InOiAvXFwuWy5+XXw6Wz0+XXxbPTw+QF58JitcXC0qXFwvJCUhP35dWyEkJSYqK1xcLS5cXC86PD0+P0BefH5dKnxcXGIoPzphbmR8YXNyfGxhbmR8bG9yfGxzbHxsc3J8bHhvcnxtb2R8b3IpXFxiLyxcbiAgJ3B1bmN0dWF0aW9uJzogLzs7fDo6fFsoKXt9XFxbXFxdLiw6OyNdfFxcYl9cXGIvXG59O1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tcHl0aG9uXCIgKi9cblxucHJpc20ubGFuZ3VhZ2VzLnB5dGhvbiA9IHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pIy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnc3RyaW5nLWludGVycG9sYXRpb24nOiB7XG4gICAgcGF0dGVybjogLyg/OmZ8ZnJ8cmYpKD86KFwiXCJcInwnJycpW1xcc1xcU10qP1xcMXwoXCJ8JykoPzpcXFxcLnwoPyFcXDIpW15cXFxcXFxyXFxuXSkqXFwyKS9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdpbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICAvLyBcIntcIiA8ZXhwcmVzc2lvbj4gPG9wdGlvbmFsIFwiIXNcIiwgXCIhclwiLCBvciBcIiFhXCI+IDxvcHRpb25hbCBcIjpcIiBmb3JtYXQgc3BlY2lmaWVyPiBcIn1cIlxuICAgICAgICBwYXR0ZXJuOiAvKCg/Ol58W157XSkoPzpcXHtcXHspKilcXHsoPyFcXHspKD86W157fV18XFx7KD8hXFx7KSg/Oltee31dfFxceyg/IVxceykoPzpbXnt9XSkrXFx9KStcXH0pK1xcfS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgICdmb3JtYXQtc3BlYyc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC8oOilbXjooKXt9XSsoPz1cXH0kKS8sXG4gICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnY29udmVyc2lvbi1vcHRpb24nOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvIVtzcmFdKD89Wzp9XSQpLyxcbiAgICAgICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXN0OiBudWxsXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAnc3RyaW5nJzogL1tcXHNcXFNdKy9cbiAgICB9XG4gIH0sXG4gICd0cmlwbGUtcXVvdGVkLXN0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKD86W3J1Yl18YnJ8cmIpPyhcIlwiXCJ8JycnKVtcXHNcXFNdKj9cXDEvaSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdzdHJpbmcnXG4gIH0sXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyg/OltydWJdfGJyfHJiKT8oXCJ8JykoPzpcXFxcLnwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxL2ksXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdmdW5jdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKCg/Ol58XFxzKWRlZlsgXFx0XSspW2EtekEtWl9dXFx3Kig/PVxccypcXCgpL2csXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnY2xhc3MtbmFtZSc6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYmNsYXNzXFxzKylcXHcrL2ksXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnZGVjb3JhdG9yJzoge1xuICAgIHBhdHRlcm46IC8oXltcXHQgXSopQFxcdysoPzpcXC5cXHcrKSovbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiBbJ2Fubm90YXRpb24nLCAncHVuY3R1YXRpb24nXSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vXG4gICAgfVxuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzpfKD89XFxzKjopfGFuZHxhc3xhc3NlcnR8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjbGFzc3xjb250aW51ZXxkZWZ8ZGVsfGVsaWZ8ZWxzZXxleGNlcHR8ZXhlY3xmaW5hbGx5fGZvcnxmcm9tfGdsb2JhbHxpZnxpbXBvcnR8aW58aXN8bGFtYmRhfG1hdGNofG5vbmxvY2FsfG5vdHxvcnxwYXNzfHByaW50fHJhaXNlfHJldHVybnx0cnl8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuICAnYnVpbHRpbic6IC9cXGIoPzpfX2ltcG9ydF9ffGFic3xhbGx8YW55fGFwcGx5fGFzY2lpfGJhc2VzdHJpbmd8YmlufGJvb2x8YnVmZmVyfGJ5dGVhcnJheXxieXRlc3xjYWxsYWJsZXxjaHJ8Y2xhc3NtZXRob2R8Y21wfGNvZXJjZXxjb21waWxlfGNvbXBsZXh8ZGVsYXR0cnxkaWN0fGRpcnxkaXZtb2R8ZW51bWVyYXRlfGV2YWx8ZXhlY2ZpbGV8ZmlsZXxmaWx0ZXJ8ZmxvYXR8Zm9ybWF0fGZyb3plbnNldHxnZXRhdHRyfGdsb2JhbHN8aGFzYXR0cnxoYXNofGhlbHB8aGV4fGlkfGlucHV0fGludHxpbnRlcm58aXNpbnN0YW5jZXxpc3N1YmNsYXNzfGl0ZXJ8bGVufGxpc3R8bG9jYWxzfGxvbmd8bWFwfG1heHxtZW1vcnl2aWV3fG1pbnxuZXh0fG9iamVjdHxvY3R8b3BlbnxvcmR8cG93fHByb3BlcnR5fHJhbmdlfHJhd19pbnB1dHxyZWR1Y2V8cmVsb2FkfHJlcHJ8cmV2ZXJzZWR8cm91bmR8c2V0fHNldGF0dHJ8c2xpY2V8c29ydGVkfHN0YXRpY21ldGhvZHxzdHJ8c3VtfHN1cGVyfHR1cGxlfHR5cGV8dW5pY2hyfHVuaWNvZGV8dmFyc3x4cmFuZ2V8emlwKVxcYi8sXG4gICdib29sZWFuJzogL1xcYig/OkZhbHNlfE5vbmV8VHJ1ZSlcXGIvLFxuICAnbnVtYmVyJzogL1xcYjAoPzpiKD86Xz9bMDFdKSt8byg/Ol8/WzAtN10pK3x4KD86Xz9bYS1mMC05XSkrKVxcYnwoPzpcXGJcXGQrKD86X1xcZCspKig/OlxcLig/OlxcZCsoPzpfXFxkKykqKT8pP3xcXEJcXC5cXGQrKD86X1xcZCspKikoPzplWystXT9cXGQrKD86X1xcZCspKik/aj8oPyFcXHcpL2ksXG4gICdvcGVyYXRvcic6IC9bLSslPV09P3whPXw6PXxcXCpcXCo/PT98XFwvXFwvPz0/fDxbPD0+XT98Pls9Pl0/fFsmfF5+XS8sXG4gICdwdW5jdHVhdGlvbic6IC9be31bXFxdOygpLC46XS9cbn07XG5wcmlzbS5sYW5ndWFnZXMucHl0aG9uWydzdHJpbmctaW50ZXJwb2xhdGlvbiddLmluc2lkZVsnaW50ZXJwb2xhdGlvbiddLmluc2lkZS5yZXN0ID0gcHJpc20ubGFuZ3VhZ2VzLnB5dGhvbjtcbnByaXNtLmxhbmd1YWdlcy5weSA9IHByaXNtLmxhbmd1YWdlcy5weXRob247XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1yZWFzb25cIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMucmVhc29uID0gcHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogL1wiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cXFxcXFxyXFxuXCJdKSpcIi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gIC8vICdjbGFzcy1uYW1lJyBtdXN0IGJlIG1hdGNoZWQgKmFmdGVyKiAnY29uc3RydWN0b3InIGRlZmluZWQgYmVsb3dcbiAgJ2NsYXNzLW5hbWUnOiAvXFxiW0EtWl1cXHcqLyxcbiAgJ2tleXdvcmQnOiAvXFxiKD86YW5kfGFzfGFzc2VydHxiZWdpbnxjbGFzc3xjb25zdHJhaW50fGRvfGRvbmV8ZG93bnRvfGVsc2V8ZW5kfGV4Y2VwdGlvbnxleHRlcm5hbHxmb3J8ZnVufGZ1bmN0aW9ufGZ1bmN0b3J8aWZ8aW58aW5jbHVkZXxpbmhlcml0fGluaXRpYWxpemVyfGxhenl8bGV0fG1ldGhvZHxtb2R1bGV8bXV0YWJsZXxuZXd8bm9ucmVjfG9iamVjdHxvZnxvcGVufG9yfHByaXZhdGV8cmVjfHNpZ3xzdHJ1Y3R8c3dpdGNofHRoZW58dG98dHJ5fHR5cGV8dmFsfHZpcnR1YWx8d2hlbnx3aGlsZXx3aXRoKVxcYi8sXG4gICdvcGVyYXRvcic6IC9cXC57M318Ols6PV18XFx8PnwtPnw9KD86PT0/fD4pP3w8PT98Pj0/fFt8Xj8nIyF+YF18WytcXC0qXFwvXVxcLj98XFxiKD86YXNyfGxhbmR8bG9yfGxzbHxsc3J8bHhvcnxtb2QpXFxiL1xufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdyZWFzb24nLCAnY2xhc3MtbmFtZScsIHtcbiAgJ2NoYXInOiB7XG4gICAgcGF0dGVybjogLycoPzpcXFxceFtcXGRhLWZdezJ9fFxcXFxvWzAtM11bMC03XVswLTddfFxcXFxcXGR7M318XFxcXC58W14nXFxcXFxcclxcbl0pJy8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gIC8vIE5lZ2F0aXZlIGxvb2stYWhlYWQgcHJldmVudHMgZnJvbSBtYXRjaGluZyB0aGluZ3MgbGlrZSBTdHJpbmcuY2FwaXRhbGl6ZVxuICAnY29uc3RydWN0b3InOiAvXFxiW0EtWl1cXHcqXFxiKD8hXFxzKlxcLikvLFxuICAnbGFiZWwnOiB7XG4gICAgcGF0dGVybjogL1xcYlthLXpdXFx3Kig/PTo6KS8sXG4gICAgYWxpYXM6ICdzeW1ib2wnXG4gIH1cbn0pOyAvLyBXZSBjYW4ndCBtYXRjaCBmdW5jdGlvbnMgcHJvcGVydHksIHNvIGxldCdzIG5vdCBldmVuIHRyeS5cblxuZGVsZXRlIHByaXNtLmxhbmd1YWdlcy5yZWFzb24uZnVuY3Rpb247XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1zYXNzXCIgKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICBQcmlzbS5sYW5ndWFnZXMuc2FzcyA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NzcycsIHtcbiAgICAvLyBTYXNzIGNvbW1lbnRzIGRvbid0IG5lZWQgdG8gYmUgY2xvc2VkLCBvbmx5IGluZGVudGVkXG4gICAgJ2NvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvXihbIFxcdF0qKVxcL1tcXC8qXS4qKD86KD86XFxyP1xcbnxcXHIpXFwxWyBcXHRdLispKi9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3Nhc3MnLCAnYXRydWxlJywge1xuICAgIC8vIFdlIHdhbnQgdG8gY29uc3VtZSB0aGUgd2hvbGUgbGluZVxuICAgICdhdHJ1bGUtbGluZSc6IHtcbiAgICAgIC8vIEluY2x1ZGVzIHN1cHBvcnQgZm9yID0gYW5kICsgc2hvcnRjdXRzXG4gICAgICBwYXR0ZXJuOiAvXig/OlsgXFx0XSopW0ArPV0uKy9tLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdhdHJ1bGUnOiAvKD86QFtcXHctXSt8Wys9XSkvXG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5zYXNzLmF0cnVsZTtcbiAgdmFyIHZhcmlhYmxlID0gL1xcJFstXFx3XSt8I1xce1xcJFstXFx3XStcXH0vO1xuICB2YXIgb3BlcmF0b3IgPSBbL1srKlxcLyVdfFs9IV09fDw9P3w+PT98XFxiKD86YW5kfG5vdHxvcilcXGIvLCB7XG4gICAgcGF0dGVybjogLyhcXHMpLSg/PVxccykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV07XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3Nhc3MnLCAncHJvcGVydHknLCB7XG4gICAgLy8gV2Ugd2FudCB0byBjb25zdW1lIHRoZSB3aG9sZSBsaW5lXG4gICAgJ3ZhcmlhYmxlLWxpbmUnOiB7XG4gICAgICBwYXR0ZXJuOiAvXlsgXFx0XSpcXCQuKy9tLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC86LyxcbiAgICAgICAgJ3ZhcmlhYmxlJzogdmFyaWFibGUsXG4gICAgICAgICdvcGVyYXRvcic6IG9wZXJhdG9yXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBXZSB3YW50IHRvIGNvbnN1bWUgdGhlIHdob2xlIGxpbmVcbiAgICAncHJvcGVydHktbGluZSc6IHtcbiAgICAgIHBhdHRlcm46IC9eWyBcXHRdKig/OlteOlxcc10rICo6Lip8OlteOlxcc10uKikvbSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHJvcGVydHknOiBbL1teOlxcc10rKD89XFxzKjopLywge1xuICAgICAgICAgIHBhdHRlcm46IC8oOilbXjpcXHNdKy8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogLzovLFxuICAgICAgICAndmFyaWFibGUnOiB2YXJpYWJsZSxcbiAgICAgICAgJ29wZXJhdG9yJzogb3BlcmF0b3IsXG4gICAgICAgICdpbXBvcnRhbnQnOiBQcmlzbS5sYW5ndWFnZXMuc2Fzcy5pbXBvcnRhbnRcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnNhc3MucHJvcGVydHk7XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMuc2Fzcy5pbXBvcnRhbnQ7IC8vIE5vdyB0aGF0IHdob2xlIGxpbmVzIGZvciBvdGhlciBwYXR0ZXJucyBhcmUgY29uc3VtZWQsXG4gIC8vIHdoYXQncyBsZWZ0IHNob3VsZCBiZSBzZWxlY3RvcnNcblxuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzYXNzJywgJ3B1bmN0dWF0aW9uJywge1xuICAgICdzZWxlY3Rvcic6IHtcbiAgICAgIHBhdHRlcm46IC9eKFsgXFx0XSopXFxTKD86LFteLFxcclxcbl0rfFteLFxcclxcbl0qKSg/OixbXixcXHJcXG5dKykqKD86LCg/Olxccj9cXG58XFxyKVxcMVsgXFx0XStcXFMoPzosW14sXFxyXFxuXSt8W14sXFxyXFxuXSopKD86LFteLFxcclxcbl0rKSopKi9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1zY3NzXCIgKi9cblxuXG5wcmlzbS5sYW5ndWFnZXMuc2NzcyA9IHByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NzcycsIHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pKD86XFwvXFwqW1xcc1xcU10qP1xcKlxcL3xcXC9cXC8uKikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfSxcbiAgJ2F0cnVsZSc6IHtcbiAgICBwYXR0ZXJuOiAvQFtcXHctXSg/OlxcKFteKCldK1xcKXxbXigpXFxzXXxcXHMrKD8hXFxzKSkqPyg/PVxccytbeztdKS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAncnVsZSc6IC9AW1xcdy1dKy8gLy8gU2VlIHJlc3QgYmVsb3dcblxuICAgIH1cbiAgfSxcbiAgLy8gdXJsLCBjb21wYXNzaWZpZWRcbiAgJ3VybCc6IC8oPzpbLWEtel0rLSk/dXJsKD89XFwoKS9pLFxuICAvLyBDU1Mgc2VsZWN0b3IgcmVnZXggaXMgbm90IGFwcHJvcHJpYXRlIGZvciBTYXNzXG4gIC8vIHNpbmNlIHRoZXJlIGNhbiBiZSBsb3QgbW9yZSB0aGluZ3MgKHZhciwgQCBkaXJlY3RpdmUsIG5lc3RpbmcuLilcbiAgLy8gYSBzZWxlY3RvciBtdXN0IHN0YXJ0IGF0IHRoZSBlbmQgb2YgYSBwcm9wZXJ0eSBvciBhZnRlciBhIGJyYWNlIChlbmQgb2Ygb3RoZXIgcnVsZXMgb3IgbmVzdGluZylcbiAgLy8gaXQgY2FuIGNvbnRhaW4gc29tZSBjaGFyYWN0ZXJzIHRoYXQgYXJlbid0IHVzZWQgZm9yIGRlZmluaW5nIHJ1bGVzIG9yIGVuZCBvZiBzZWxlY3RvciwgJiAocGFyZW50IHNlbGVjdG9yKSwgb3IgaW50ZXJwb2xhdGVkIHZhcmlhYmxlXG4gIC8vIHRoZSBlbmQgb2YgYSBzZWxlY3RvciBpcyBmb3VuZCB3aGVuIHRoZXJlIGlzIG5vIHJ1bGVzIGluIGl0ICgge30gb3Ige1xcc30pIG9yIGlmIHRoZXJlIGlzIGEgcHJvcGVydHkgKGJlY2F1c2UgYW4gaW50ZXJwb2xhdGVkIHZhclxuICAvLyBjYW4gXCJwYXNzXCIgYXMgYSBzZWxlY3Rvci0gZS5nOiBwcm9wZXIjeyRlcnR5fSlcbiAgLy8gdGhpcyBvbmUgd2FzIGhhcmQgdG8gZG8sIHNvIHBsZWFzZSBiZSBjYXJlZnVsIGlmIHlvdSBlZGl0IHRoaXMgb25lIDopXG4gICdzZWxlY3Rvcic6IHtcbiAgICAvLyBJbml0aWFsIGxvb2stYWhlYWQgaXMgdXNlZCB0byBwcmV2ZW50IG1hdGNoaW5nIG9mIGJsYW5rIHNlbGVjdG9yc1xuICAgIHBhdHRlcm46IC8oPz1cXFMpW15AO3t9KCldPyg/OlteQDt7fSgpXFxzXXxcXHMrKD8hXFxzKXwjXFx7XFwkWy1cXHddK1xcfSkrKD89XFxzKlxceyg/OlxcfXxcXHN8W159XVteOnt9XSpbOntdW159XSkpLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdwYXJlbnQnOiB7XG4gICAgICAgIHBhdHRlcm46IC8mLyxcbiAgICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgICB9LFxuICAgICAgJ3BsYWNlaG9sZGVyJzogLyVbLVxcd10rLyxcbiAgICAgICd2YXJpYWJsZSc6IC9cXCRbLVxcd10rfCNcXHtcXCRbLVxcd10rXFx9L1xuICAgIH1cbiAgfSxcbiAgJ3Byb3BlcnR5Jzoge1xuICAgIHBhdHRlcm46IC8oPzpbLVxcd118XFwkWy1cXHddfCNcXHtcXCRbLVxcd10rXFx9KSsoPz1cXHMqOikvLFxuICAgIGluc2lkZToge1xuICAgICAgJ3ZhcmlhYmxlJzogL1xcJFstXFx3XSt8I1xce1xcJFstXFx3XStcXH0vXG4gICAgfVxuICB9XG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3Njc3MnLCAnYXRydWxlJywge1xuICAna2V5d29yZCc6IFsvQCg/OmNvbnRlbnR8ZGVidWd8ZWFjaHxlbHNlKD86IGlmKT98ZXh0ZW5kfGZvcnxmb3J3YXJkfGZ1bmN0aW9ufGlmfGltcG9ydHxpbmNsdWRlfG1peGlufHJldHVybnx1c2V8d2Fybnx3aGlsZSlcXGIvaSwge1xuICAgIHBhdHRlcm46IC8oICkoPzpmcm9tfHRocm91Z2gpKD89ICkvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2NzcycsICdpbXBvcnRhbnQnLCB7XG4gIC8vIHZhciBhbmQgaW50ZXJwb2xhdGVkIHZhcnNcbiAgJ3ZhcmlhYmxlJzogL1xcJFstXFx3XSt8I1xce1xcJFstXFx3XStcXH0vXG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3Njc3MnLCAnZnVuY3Rpb24nLCB7XG4gICdtb2R1bGUtbW9kaWZpZXInOiB7XG4gICAgcGF0dGVybjogL1xcYig/OmFzfGhpZGV8c2hvd3x3aXRoKVxcYi9pLFxuICAgIGFsaWFzOiAna2V5d29yZCdcbiAgfSxcbiAgJ3BsYWNlaG9sZGVyJzoge1xuICAgIHBhdHRlcm46IC8lWy1cXHddKy8sXG4gICAgYWxpYXM6ICdzZWxlY3RvcidcbiAgfSxcbiAgJ3N0YXRlbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxCISg/OmRlZmF1bHR8b3B0aW9uYWwpXFxiL2ksXG4gICAgYWxpYXM6ICdrZXl3b3JkJ1xuICB9LFxuICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICdudWxsJzoge1xuICAgIHBhdHRlcm46IC9cXGJudWxsXFxiLyxcbiAgICBhbGlhczogJ2tleXdvcmQnXG4gIH0sXG4gICdvcGVyYXRvcic6IHtcbiAgICBwYXR0ZXJuOiAvKFxccykoPzpbLSsqXFwvJV18Wz0hXT18PD0/fD49P3xhbmR8bm90fG9yKSg/PVxccykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfVxufSk7XG5wcmlzbS5sYW5ndWFnZXMuc2Nzc1snYXRydWxlJ10uaW5zaWRlLnJlc3QgPSBwcmlzbS5sYW5ndWFnZXMuc2Nzcztcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXN0eWx1c1wiICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIHVuaXQgPSB7XG4gICAgcGF0dGVybjogLyhcXGJcXGQrKSg/OiV8W2Etel0rKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9OyAvLyAxMjMgLTEyMyAuMTIzIC0uMTIzIDEyLjMgLTEyLjNcblxuICB2YXIgbnVtYmVyID0ge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcdy4tXSktPyg/OlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfTtcbiAgdmFyIGluc2lkZSA9IHtcbiAgICAnY29tbWVudCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKSg/OlxcL1xcKltcXHNcXFNdKj9cXCpcXC98XFwvXFwvLiopLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICd1cmwnOiB7XG4gICAgICBwYXR0ZXJuOiAvXFxidXJsXFwoKFtcIiddPykuKj9cXDFcXCkvaSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sXG4gICAgJ3N0cmluZyc6IHtcbiAgICAgIHBhdHRlcm46IC8oXCJ8JykoPzooPyFcXDEpW15cXFxcXFxyXFxuXXxcXFxcKD86XFxyXFxufFtcXHNcXFNdKSkqXFwxLyxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sXG4gICAgJ2ludGVycG9sYXRpb24nOiBudWxsLFxuICAgIC8vIFNlZSBiZWxvd1xuICAgICdmdW5jJzogbnVsbCxcbiAgICAvLyBTZWUgYmVsb3dcbiAgICAnaW1wb3J0YW50JzogL1xcQiEoPzppbXBvcnRhbnR8b3B0aW9uYWwpXFxiL2ksXG4gICAgJ2tleXdvcmQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58XFxzKykoPzooPzplbHNlfGZvcnxpZnxyZXR1cm58dW5sZXNzKSg/PVxcc3wkKXxAW1xcdy1dKykvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2hleGNvZGUnOiAvI1tcXGRhLWZdezMsNn0vaSxcbiAgICAnY29sb3InOiBbL1xcYig/OkFsaWNlQmx1ZXxBbnRpcXVlV2hpdGV8QXF1YXxBcXVhbWFyaW5lfEF6dXJlfEJlaWdlfEJpc3F1ZXxCbGFja3xCbGFuY2hlZEFsbW9uZHxCbHVlfEJsdWVWaW9sZXR8QnJvd258QnVybHlXb29kfENhZGV0Qmx1ZXxDaGFydHJldXNlfENob2NvbGF0ZXxDb3JhbHxDb3JuZmxvd2VyQmx1ZXxDb3Juc2lsa3xDcmltc29ufEN5YW58RGFya0JsdWV8RGFya0N5YW58RGFya0dvbGRlblJvZHxEYXJrR3JbYWVdeXxEYXJrR3JlZW58RGFya0toYWtpfERhcmtNYWdlbnRhfERhcmtPbGl2ZUdyZWVufERhcmtPcmFuZ2V8RGFya09yY2hpZHxEYXJrUmVkfERhcmtTYWxtb258RGFya1NlYUdyZWVufERhcmtTbGF0ZUJsdWV8RGFya1NsYXRlR3JbYWVdeXxEYXJrVHVycXVvaXNlfERhcmtWaW9sZXR8RGVlcFBpbmt8RGVlcFNreUJsdWV8RGltR3JbYWVdeXxEb2RnZXJCbHVlfEZpcmVCcmlja3xGbG9yYWxXaGl0ZXxGb3Jlc3RHcmVlbnxGdWNoc2lhfEdhaW5zYm9yb3xHaG9zdFdoaXRlfEdvbGR8R29sZGVuUm9kfEdyW2FlXXl8R3JlZW58R3JlZW5ZZWxsb3d8SG9uZXlEZXd8SG90UGlua3xJbmRpYW5SZWR8SW5kaWdvfEl2b3J5fEtoYWtpfExhdmVuZGVyfExhdmVuZGVyQmx1c2h8TGF3bkdyZWVufExlbW9uQ2hpZmZvbnxMaWdodEJsdWV8TGlnaHRDb3JhbHxMaWdodEN5YW58TGlnaHRHb2xkZW5Sb2RZZWxsb3d8TGlnaHRHclthZV15fExpZ2h0R3JlZW58TGlnaHRQaW5rfExpZ2h0U2FsbW9ufExpZ2h0U2VhR3JlZW58TGlnaHRTa3lCbHVlfExpZ2h0U2xhdGVHclthZV15fExpZ2h0U3RlZWxCbHVlfExpZ2h0WWVsbG93fExpbWV8TGltZUdyZWVufExpbmVufE1hZ2VudGF8TWFyb29ufE1lZGl1bUFxdWFNYXJpbmV8TWVkaXVtQmx1ZXxNZWRpdW1PcmNoaWR8TWVkaXVtUHVycGxlfE1lZGl1bVNlYUdyZWVufE1lZGl1bVNsYXRlQmx1ZXxNZWRpdW1TcHJpbmdHcmVlbnxNZWRpdW1UdXJxdW9pc2V8TWVkaXVtVmlvbGV0UmVkfE1pZG5pZ2h0Qmx1ZXxNaW50Q3JlYW18TWlzdHlSb3NlfE1vY2Nhc2lufE5hdmFqb1doaXRlfE5hdnl8T2xkTGFjZXxPbGl2ZXxPbGl2ZURyYWJ8T3JhbmdlfE9yYW5nZVJlZHxPcmNoaWR8UGFsZUdvbGRlblJvZHxQYWxlR3JlZW58UGFsZVR1cnF1b2lzZXxQYWxlVmlvbGV0UmVkfFBhcGF5YVdoaXB8UGVhY2hQdWZmfFBlcnV8UGlua3xQbHVtfFBvd2RlckJsdWV8UHVycGxlfFJlZHxSb3N5QnJvd258Um95YWxCbHVlfFNhZGRsZUJyb3dufFNhbG1vbnxTYW5keUJyb3dufFNlYUdyZWVufFNlYVNoZWxsfFNpZW5uYXxTaWx2ZXJ8U2t5Qmx1ZXxTbGF0ZUJsdWV8U2xhdGVHclthZV15fFNub3d8U3ByaW5nR3JlZW58U3RlZWxCbHVlfFRhbnxUZWFsfFRoaXN0bGV8VG9tYXRvfFRyYW5zcGFyZW50fFR1cnF1b2lzZXxWaW9sZXR8V2hlYXR8V2hpdGV8V2hpdGVTbW9rZXxZZWxsb3d8WWVsbG93R3JlZW4pXFxiL2ksIHtcbiAgICAgIHBhdHRlcm46IC9cXGIoPzpoc2x8cmdiKVxcKFxccypcXGR7MSwzfVxccyosXFxzKlxcZHsxLDN9JT9cXHMqLFxccypcXGR7MSwzfSU/XFxzKlxcKVxcQnxcXGIoPzpoc2x8cmdiKWFcXChcXHMqXFxkezEsM31cXHMqLFxccypcXGR7MSwzfSU/XFxzKixcXHMqXFxkezEsM30lP1xccyosXFxzKig/OjB8MD9cXC5cXGQrfDEpXFxzKlxcKVxcQi9pLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd1bml0JzogdW5pdCxcbiAgICAgICAgJ251bWJlcic6IG51bWJlcixcbiAgICAgICAgJ2Z1bmN0aW9uJzogL1tcXHctXSsoPz1cXCgpLyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1soKSxdL1xuICAgICAgfVxuICAgIH1dLFxuICAgICdlbnRpdHknOiAvXFxcXFtcXGRhLWZdezEsOH0vaSxcbiAgICAndW5pdCc6IHVuaXQsXG4gICAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAgICdvcGVyYXRvcic6IFsvLyBXZSB3YW50IG5vbi13b3JkIGNoYXJzIGFyb3VuZCBcIi1cIiBiZWNhdXNlIGl0IGlzXG4gICAgLy8gYWNjZXB0ZWQgaW4gcHJvcGVydHkgbmFtZXMuXG4gICAgL358WyshXFwvJTw+Pz1dPT98Wy06XT18XFwqWyo9XT98XFwuezIsM318JiZ8XFx8XFx8fFxcQi1cXEJ8XFxiKD86YW5kfGlufGlzKD86IGF8IGRlZmluZWR8IG5vdHxudCk/fG5vdHxvcilcXGIvXSxcbiAgICAnbnVtYmVyJzogbnVtYmVyLFxuICAgICdwdW5jdHVhdGlvbic6IC9be30oKVxcW1xcXTs6LF0vXG4gIH07XG4gIGluc2lkZVsnaW50ZXJwb2xhdGlvbiddID0ge1xuICAgIHBhdHRlcm46IC9cXHtbXlxcclxcbn06XStcXH0vLFxuICAgIGFsaWFzOiAndmFyaWFibGUnLFxuICAgIGluc2lkZToge1xuICAgICAgJ2RlbGltaXRlcic6IHtcbiAgICAgICAgcGF0dGVybjogL15cXHt8XFx9JC8sXG4gICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICB9LFxuICAgICAgcmVzdDogaW5zaWRlXG4gICAgfVxuICB9O1xuICBpbnNpZGVbJ2Z1bmMnXSA9IHtcbiAgICBwYXR0ZXJuOiAvW1xcdy1dK1xcKFteKV0qXFwpLiovLFxuICAgIGluc2lkZToge1xuICAgICAgJ2Z1bmN0aW9uJzogL15bXihdKy8sXG4gICAgICByZXN0OiBpbnNpZGVcbiAgICB9XG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5zdHlsdXMgPSB7XG4gICAgJ2F0cnVsZS1kZWNsYXJhdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXlsgXFx0XSopQC4rL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdhdHJ1bGUnOiAvXkBbXFx3LV0rLyxcbiAgICAgICAgcmVzdDogaW5zaWRlXG4gICAgICB9XG4gICAgfSxcbiAgICAndmFyaWFibGUtZGVjbGFyYXRpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0qKVtcXHckLV0rXFxzKi4/PVsgXFx0XSooPzpcXHtbXnt9XSpcXH18XFxTLip8JCkvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3ZhcmlhYmxlJzogL15cXFMrLyxcbiAgICAgICAgcmVzdDogaW5zaWRlXG4gICAgICB9XG4gICAgfSxcbiAgICAnc3RhdGVtZW50Jzoge1xuICAgICAgcGF0dGVybjogLyheWyBcXHRdKikoPzplbHNlfGZvcnxpZnxyZXR1cm58dW5sZXNzKVsgXFx0XS4rL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdrZXl3b3JkJzogL15cXFMrLyxcbiAgICAgICAgcmVzdDogaW5zaWRlXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBBIHByb3BlcnR5L3ZhbHVlIHBhaXIgY2Fubm90IGVuZCB3aXRoIGEgY29tbWEgb3IgYSBicmFjZVxuICAgIC8vIEl0IGNhbm5vdCBoYXZlIGluZGVudGVkIGNvbnRlbnQgdW5sZXNzIGl0IGVuZGVkIHdpdGggYSBzZW1pY29sb25cbiAgICAncHJvcGVydHktZGVjbGFyYXRpb24nOiB7XG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58XFx7KShbIFxcdF0qKSkoPzpbXFx3LV18XFx7W159XFxyXFxuXStcXH0pKyg/Olxccyo6XFxzKnxbIFxcdF0rKSg/IVxccylbXntcXHJcXG5dKig/Ojt8W157XFxyXFxuLF0kKD8hKD86XFxyP1xcbnxcXHIpKD86XFx7fFxcMlsgXFx0XSkpKS9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAncHJvcGVydHknOiB7XG4gICAgICAgICAgcGF0dGVybjogL15bXlxcczpdKy8sXG4gICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAnaW50ZXJwb2xhdGlvbic6IGluc2lkZS5pbnRlcnBvbGF0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXN0OiBpbnNpZGVcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEEgc2VsZWN0b3IgY2FuIGNvbnRhaW4gcGFyZW50aGVzZXMgb25seSBhcyBwYXJ0IG9mIGEgcHNldWRvLWVsZW1lbnRcbiAgICAvLyBJdCBjYW4gc3BhbiBtdWx0aXBsZSBsaW5lcy5cbiAgICAvLyBJdCBtdXN0IGVuZCB3aXRoIGEgY29tbWEgb3IgYW4gYWNjb2xhZGUgb3IgaGF2ZSBpbmRlbnRlZCBjb250ZW50LlxuICAgICdzZWxlY3Rvcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXlsgXFx0XSopKD86KD89XFxTKSg/Oltee31cXHJcXG46KCldfDo6P1tcXHctXSsoPzpcXChbXilcXHJcXG5dKlxcKXwoPyFbXFx3LV0pKXxcXHtbXn1cXHJcXG5dK1xcfSkrKSg/Oig/Olxccj9cXG58XFxyKSg/OlxcMSg/Oig/PVxcUykoPzpbXnt9XFxyXFxuOigpXXw6Oj9bXFx3LV0rKD86XFwoW14pXFxyXFxuXSpcXCl8KD8hW1xcdy1dKSl8XFx7W159XFxyXFxuXStcXH0pKykpKSooPzosJHxcXHt8KD89KD86XFxyP1xcbnxcXHIpKD86XFx7fFxcMVsgXFx0XSkpKS9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnaW50ZXJwb2xhdGlvbic6IGluc2lkZS5pbnRlcnBvbGF0aW9uLFxuICAgICAgICAnY29tbWVudCc6IGluc2lkZS5jb21tZW50LFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvW3t9LF0vXG4gICAgICB9XG4gICAgfSxcbiAgICAnZnVuYyc6IGluc2lkZS5mdW5jLFxuICAgICdzdHJpbmcnOiBpbnNpZGUuc3RyaW5nLFxuICAgICdjb21tZW50Jzoge1xuICAgICAgcGF0dGVybjogLyhefFteXFxcXF0pKD86XFwvXFwqW1xcc1xcU10qP1xcKlxcL3xcXC9cXC8uKikvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sXG4gICAgJ2ludGVycG9sYXRpb24nOiBpbnNpZGUuaW50ZXJwb2xhdGlvbixcbiAgICAncHVuY3R1YXRpb24nOiAvW3t9KClcXFtcXF07Oi5dL1xuICB9O1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tdHN4XCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciB0eXBlc2NyaXB0ID0gUHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdCk7XG4gIFByaXNtLmxhbmd1YWdlcy50c3ggPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdqc3gnLCB0eXBlc2NyaXB0KTsgLy8gZG9lc24ndCB3b3JrIHdpdGggVFMgYmVjYXVzZSBUUyBpcyB0b28gY29tcGxleFxuXG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHN4WydwYXJhbWV0ZXInXTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy50c3hbJ2xpdGVyYWwtcHJvcGVydHknXTsgLy8gVGhpcyB3aWxsIHByZXZlbnQgY29sbGlzaW9ucyBiZXR3ZWVuIFRTWCB0YWdzIGFuZCBUUyBnZW5lcmljIHR5cGVzLlxuICAvLyBJZGVhIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9rYXJsaG9ya3lcbiAgLy8gRGlzY3Vzc2lvbjogaHR0cHM6Ly9naXRodWIuY29tL1ByaXNtSlMvcHJpc20vaXNzdWVzLzI1OTQjaXNzdWVjb21tZW50LTcxMDY2NjkyOFxuXG4gIHZhciB0YWcgPSBQcmlzbS5sYW5ndWFnZXMudHN4LnRhZztcbiAgdGFnLnBhdHRlcm4gPSBSZWdFeHAoLyhefFteXFx3JF18KD89PFxcLykpLy5zb3VyY2UgKyAnKD86JyArIHRhZy5wYXR0ZXJuLnNvdXJjZSArICcpJywgdGFnLnBhdHRlcm4uZmxhZ3MpO1xuICB0YWcubG9va2JlaGluZCA9IHRydWU7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS13YXNtXCIgKi9cblxuXG5wcmlzbS5sYW5ndWFnZXMud2FzbSA9IHtcbiAgJ2NvbW1lbnQnOiBbL1xcKDtbXFxzXFxTXSo/O1xcKS8sIHtcbiAgICBwYXR0ZXJuOiAvOzsuKi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH1dLFxuICAnc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC9cIig/OlxcXFxbXFxzXFxTXXxbXlwiXFxcXF0pKlwiLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2tleXdvcmQnOiBbe1xuICAgIHBhdHRlcm46IC9cXGIoPzphbGlnbnxvZmZzZXQpPS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAnb3BlcmF0b3InOiAvPS9cbiAgICB9XG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvXFxiKD86KD86ZjMyfGY2NHxpMzJ8aTY0KSg/OlxcLig/OmFic3xhZGR8YW5kfGNlaWx8Y2x6fGNvbnN0fGNvbnZlcnRfW3N1XVxcL2koPzozMnw2NCl8Y29weXNpZ258Y3R6fGRlbW90ZVxcL2Y2NHxkaXYoPzpfW3N1XSk/fGVxej98ZXh0ZW5kX1tzdV1cXC9pMzJ8Zmxvb3J8Z2UoPzpfW3N1XSk/fGd0KD86X1tzdV0pP3xsZSg/Ol9bc3VdKT98bG9hZCg/Oig/Ojh8MTZ8MzIpX1tzdV0pP3xsdCg/Ol9bc3VdKT98bWF4fG1pbnxtdWx8bmVnP3xuZWFyZXN0fG9yfHBvcGNudHxwcm9tb3RlXFwvZjMyfHJlaW50ZXJwcmV0XFwvW2ZpXSg/OjMyfDY0KXxyZW1fW3N1XXxyb3RbbHJdfHNobHxzaHJfW3N1XXxzcXJ0fHN0b3JlKD86OHwxNnwzMik/fHN1Ynx0cnVuYyg/Ol9bc3VdXFwvZig/OjMyfDY0KSk/fHdyYXBcXC9pNjR8eG9yKSk/fG1lbW9yeVxcLig/Omdyb3d8c2l6ZSkpXFxiLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdwdW5jdHVhdGlvbic6IC9cXC4vXG4gICAgfVxuICB9LCAvXFxiKD86YW55ZnVuY3xibG9ja3xicig/Ol9pZnxfdGFibGUpP3xjYWxsKD86X2luZGlyZWN0KT98ZGF0YXxkcm9wfGVsZW18ZWxzZXxlbmR8ZXhwb3J0fGZ1bmN8Z2V0Xyg/Omdsb2JhbHxsb2NhbCl8Z2xvYmFsfGlmfGltcG9ydHxsb2NhbHxsb29wfG1lbW9yeXxtb2R1bGV8bXV0fG5vcHxvZmZzZXR8cGFyYW18cmVzdWx0fHJldHVybnxzZWxlY3R8c2V0Xyg/Omdsb2JhbHxsb2NhbCl8c3RhcnR8dGFibGV8dGVlX2xvY2FsfHRoZW58dHlwZXx1bnJlYWNoYWJsZSlcXGIvXSxcbiAgJ3ZhcmlhYmxlJzogL1xcJFtcXHchIyQlJicqK1xcLS4vOjw9Pj9AXFxcXF5gfH5dKy8sXG4gICdudW1iZXInOiAvWystXT9cXGIoPzpcXGQoPzpfP1xcZCkqKD86XFwuXFxkKD86Xz9cXGQpKik/KD86W2VFXVsrLV0/XFxkKD86Xz9cXGQpKik/fDB4W1xcZGEtZkEtRl0oPzpfP1tcXGRhLWZBLUZdKSooPzpcXC5bXFxkYS1mQS1GXSg/Ol8/W1xcZGEtZkEtRF0pKik/KD86W3BQXVsrLV0/XFxkKD86Xz9cXGQpKik/KVxcYnxcXGJpbmZcXGJ8XFxibmFuKD86OjB4W1xcZGEtZkEtRl0oPzpfP1tcXGRhLWZBLURdKSopP1xcYi8sXG4gICdwdW5jdHVhdGlvbic6IC9bKCldL1xufTtcblxuZXhwb3J0IGRlZmF1bHQgcHJpc207XG4iLCIvLyBEdW90b25lIERhcmtcbi8vIEF1dGhvcjogU2ltdXJhaSwgYWRhcHRlZCBmcm9tIER1b1RvbmUgdGhlbWVzIGZvciBBdG9tIChodHRwOi8vc2ltdXJhaS5jb20vcHJvamVjdHMvMjAxNi8wMS8wMS9kdW90b25lLXRoZW1lcylcbi8vIENvbnZlcnNpb246IEJyYW0gZGUgSGFhbiAoaHR0cDovL2F0ZWxpZXJicmFtLmdpdGh1Yi5pby9CYXNlMlRvbmUtcHJpc20vb3V0cHV0L3ByaXNtL3ByaXNtLWJhc2UydG9uZS1ldmVuaW5nLWRhcmsuY3NzKVxuLy8gR2VuZXJhdGVkIHdpdGggQmFzZTE2IEJ1aWxkZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9iYXNlMTYtYnVpbGRlci9iYXNlMTYtYnVpbGRlcilcbnZhciB0aGVtZSA9IHtcbiAgcGxhaW46IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzJhMjczNFwiLFxuICAgIGNvbG9yOiBcIiM5YTg2ZmRcIlxuICB9LFxuICBzdHlsZXM6IFt7XG4gICAgdHlwZXM6IFtcImNvbW1lbnRcIiwgXCJwcm9sb2dcIiwgXCJkb2N0eXBlXCIsIFwiY2RhdGFcIiwgXCJwdW5jdHVhdGlvblwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiIzZjNjc4M1wiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcIm5hbWVzcGFjZVwiXSxcbiAgICBzdHlsZToge1xuICAgICAgb3BhY2l0eTogMC43XG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcInRhZ1wiLCBcIm9wZXJhdG9yXCIsIFwibnVtYmVyXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjZTA5MTQyXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wicHJvcGVydHlcIiwgXCJmdW5jdGlvblwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiIzlhODZmZFwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcInRhZy1pZFwiLCBcInNlbGVjdG9yXCIsIFwiYXRydWxlLWlkXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjZWVlYmZmXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiYXR0ci1uYW1lXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjYzRiOWZlXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiYm9vbGVhblwiLCBcInN0cmluZ1wiLCBcImVudGl0eVwiLCBcInVybFwiLCBcImF0dHItdmFsdWVcIiwgXCJrZXl3b3JkXCIsIFwiY29udHJvbFwiLCBcImRpcmVjdGl2ZVwiLCBcInVuaXRcIiwgXCJzdGF0ZW1lbnRcIiwgXCJyZWdleFwiLCBcImF0LXJ1bGVcIiwgXCJwbGFjZWhvbGRlclwiLCBcInZhcmlhYmxlXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjZmZjYzk5XCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiZGVsZXRlZFwiXSxcbiAgICBzdHlsZToge1xuICAgICAgdGV4dERlY29yYXRpb25MaW5lOiBcImxpbmUtdGhyb3VnaFwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcImluc2VydGVkXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICB0ZXh0RGVjb3JhdGlvbkxpbmU6IFwidW5kZXJsaW5lXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiaXRhbGljXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiaW1wb3J0YW50XCIsIFwiYm9sZFwiXSxcbiAgICBzdHlsZToge1xuICAgICAgZm9udFdlaWdodDogXCJib2xkXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiaW1wb3J0YW50XCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjYzRiOWZlXCJcbiAgICB9XG4gIH1dXG59O1xuXG5leHBvcnQgZGVmYXVsdCB0aGVtZTtcbiIsImltcG9ydCBwcmlzbSBmcm9tICcuLi9wcmlzbS9pbmRleC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFByaXNtIH0gZnJvbSAnLi4vcHJpc20vaW5kZXguanMnO1xuaW1wb3J0IHRoZW1lIGZyb20gJy4uL3RoZW1lcy9kdW90b25lRGFyayc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5cbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIC8vICRGbG93Rml4TWVcbiAgUHJpc206IHByaXNtLFxuICB0aGVtZTogdGhlbWVcbn07XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgbmV3bGluZVJlID0gL1xcclxcbnxcXHJ8XFxuLzsgLy8gRW1wdHkgbGluZXMgbmVlZCB0byBjb250YWluIGEgc2luZ2xlIGVtcHR5IHRva2VuLCBkZW5vdGVkIHdpdGggeyBlbXB0eTogdHJ1ZSB9XG5cbnZhciBub3JtYWxpemVFbXB0eUxpbmVzID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgbGluZS5wdXNoKHtcbiAgICAgIHR5cGVzOiBbXCJwbGFpblwiXSxcbiAgICAgIGNvbnRlbnQ6IFwiXFxuXCIsXG4gICAgICBlbXB0eTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKGxpbmUubGVuZ3RoID09PSAxICYmIGxpbmVbMF0uY29udGVudCA9PT0gXCJcIikge1xuICAgIGxpbmVbMF0uY29udGVudCA9IFwiXFxuXCI7XG4gICAgbGluZVswXS5lbXB0eSA9IHRydWU7XG4gIH1cbn07XG5cbnZhciBhcHBlbmRUeXBlcyA9IGZ1bmN0aW9uICh0eXBlcywgYWRkKSB7XG4gIHZhciB0eXBlc1NpemUgPSB0eXBlcy5sZW5ndGg7XG5cbiAgaWYgKHR5cGVzU2l6ZSA+IDAgJiYgdHlwZXNbdHlwZXNTaXplIC0gMV0gPT09IGFkZCkge1xuICAgIHJldHVybiB0eXBlcztcbiAgfVxuXG4gIHJldHVybiB0eXBlcy5jb25jYXQoYWRkKTtcbn07IC8vIFRha2VzIGFuIGFycmF5IG9mIFByaXNtJ3MgdG9rZW5zIGFuZCBncm91cHMgdGhlbSBieSBsaW5lLCB0dXJuaW5nIHBsYWluXG4vLyBzdHJpbmdzIGludG8gdG9rZW5zIGFzIHdlbGwuIFRva2VucyBjYW4gYmVjb21lIHJlY3Vyc2l2ZSBpbiBzb21lIGNhc2VzLFxuLy8gd2hpY2ggbWVhbnMgdGhhdCB0aGVpciB0eXBlcyBhcmUgY29uY2F0ZW5hdGVkLiBQbGFpbi1zdHJpbmcgdG9rZW5zIGhvd2V2ZXJcbi8vIGFyZSBhbHdheXMgb2YgdHlwZSBcInBsYWluXCIuXG4vLyBUaGlzIGlzIG5vdCByZWN1cnNpdmUgdG8gYXZvaWQgZXhjZWVkaW5nIHRoZSBjYWxsLXN0YWNrIGxpbWl0LCBzaW5jZSBpdCdzIHVuY2xlYXJcbi8vIGhvdyBuZXN0ZWQgUHJpc20ncyB0b2tlbnMgY2FuIGJlY29tZVxuXG5cbnZhciBub3JtYWxpemVUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zKSB7XG4gIHZhciB0eXBlQXJyU3RhY2sgPSBbW11dO1xuICB2YXIgdG9rZW5BcnJTdGFjayA9IFt0b2tlbnNdO1xuICB2YXIgdG9rZW5BcnJJbmRleFN0YWNrID0gWzBdO1xuICB2YXIgdG9rZW5BcnJTaXplU3RhY2sgPSBbdG9rZW5zLmxlbmd0aF07XG4gIHZhciBpID0gMDtcbiAgdmFyIHN0YWNrSW5kZXggPSAwO1xuICB2YXIgY3VycmVudExpbmUgPSBbXTtcbiAgdmFyIGFjYyA9IFtjdXJyZW50TGluZV07XG5cbiAgd2hpbGUgKHN0YWNrSW5kZXggPiAtMSkge1xuICAgIHdoaWxlICgoaSA9IHRva2VuQXJySW5kZXhTdGFja1tzdGFja0luZGV4XSsrKSA8IHRva2VuQXJyU2l6ZVN0YWNrW3N0YWNrSW5kZXhdKSB7XG4gICAgICB2YXIgY29udGVudCA9IHZvaWQgMDtcbiAgICAgIHZhciB0eXBlcyA9IHR5cGVBcnJTdGFja1tzdGFja0luZGV4XTtcbiAgICAgIHZhciB0b2tlbkFyciA9IHRva2VuQXJyU3RhY2tbc3RhY2tJbmRleF07XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbkFycltpXTsgLy8gRGV0ZXJtaW5lIGNvbnRlbnQgYW5kIGFwcGVuZCB0eXBlIHRvIHR5cGVzIGlmIG5lY2Vzc2FyeVxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHR5cGVzID0gc3RhY2tJbmRleCA+IDAgPyB0eXBlcyA6IFtcInBsYWluXCJdO1xuICAgICAgICBjb250ZW50ID0gdG9rZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlcyA9IGFwcGVuZFR5cGVzKHR5cGVzLCB0b2tlbi50eXBlKTtcblxuICAgICAgICBpZiAodG9rZW4uYWxpYXMpIHtcbiAgICAgICAgICB0eXBlcyA9IGFwcGVuZFR5cGVzKHR5cGVzLCB0b2tlbi5hbGlhcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZW50ID0gdG9rZW4uY29udGVudDtcbiAgICAgIH0gLy8gSWYgdG9rZW4uY29udGVudCBpcyBhbiBhcnJheSwgaW5jcmVhc2UgdGhlIHN0YWNrIGRlcHRoIGFuZCByZXBlYXQgdGhpcyB3aGlsZS1sb29wXG5cblxuICAgICAgaWYgKHR5cGVvZiBjb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN0YWNrSW5kZXgrKztcbiAgICAgICAgdHlwZUFyclN0YWNrLnB1c2godHlwZXMpO1xuICAgICAgICB0b2tlbkFyclN0YWNrLnB1c2goY29udGVudCk7XG4gICAgICAgIHRva2VuQXJySW5kZXhTdGFjay5wdXNoKDApO1xuICAgICAgICB0b2tlbkFyclNpemVTdGFjay5wdXNoKGNvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIFNwbGl0IGJ5IG5ld2xpbmVzXG5cblxuICAgICAgdmFyIHNwbGl0QnlOZXdsaW5lcyA9IGNvbnRlbnQuc3BsaXQobmV3bGluZVJlKTtcbiAgICAgIHZhciBuZXdsaW5lQ291bnQgPSBzcGxpdEJ5TmV3bGluZXMubGVuZ3RoO1xuICAgICAgY3VycmVudExpbmUucHVzaCh7XG4gICAgICAgIHR5cGVzOiB0eXBlcyxcbiAgICAgICAgY29udGVudDogc3BsaXRCeU5ld2xpbmVzWzBdXG4gICAgICB9KTsgLy8gQ3JlYXRlIGEgbmV3IGxpbmUgZm9yIGVhY2ggc3RyaW5nIG9uIGEgbmV3IGxpbmVcblxuICAgICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgbmV3bGluZUNvdW50OyBpJDErKykge1xuICAgICAgICBub3JtYWxpemVFbXB0eUxpbmVzKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgYWNjLnB1c2goY3VycmVudExpbmUgPSBbXSk7XG4gICAgICAgIGN1cnJlbnRMaW5lLnB1c2goe1xuICAgICAgICAgIHR5cGVzOiB0eXBlcyxcbiAgICAgICAgICBjb250ZW50OiBzcGxpdEJ5TmV3bGluZXNbaSQxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIERlY3JlYXRlIHRoZSBzdGFjayBkZXB0aFxuXG5cbiAgICBzdGFja0luZGV4LS07XG4gICAgdHlwZUFyclN0YWNrLnBvcCgpO1xuICAgIHRva2VuQXJyU3RhY2sucG9wKCk7XG4gICAgdG9rZW5BcnJJbmRleFN0YWNrLnBvcCgpO1xuICAgIHRva2VuQXJyU2l6ZVN0YWNrLnBvcCgpO1xuICB9XG5cbiAgbm9ybWFsaXplRW1wdHlMaW5lcyhjdXJyZW50TGluZSk7XG4gIHJldHVybiBhY2M7XG59O1xuXG52YXIgdGhlbWVUb0RpY3QgPSBmdW5jdGlvbiAodGhlbWUsIGxhbmd1YWdlKSB7XG4gIHZhciBwbGFpbiA9IHRoZW1lLnBsYWluOyAvLyAkRmxvd0ZpeE1lXG5cbiAgdmFyIGJhc2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgdGhlbWVEaWN0ID0gdGhlbWUuc3R5bGVzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB0aGVtZUVudHJ5KSB7XG4gICAgdmFyIGxhbmd1YWdlcyA9IHRoZW1lRW50cnkubGFuZ3VhZ2VzO1xuICAgIHZhciBzdHlsZSA9IHRoZW1lRW50cnkuc3R5bGU7XG5cbiAgICBpZiAobGFuZ3VhZ2VzICYmICFsYW5ndWFnZXMuaW5jbHVkZXMobGFuZ3VhZ2UpKSB7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH1cblxuICAgIHRoZW1lRW50cnkudHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgdmFyIGFjY1N0eWxlID0gX2V4dGVuZHMoe30sIGFjY1t0eXBlXSwgc3R5bGUpO1xuXG4gICAgICBhY2NbdHlwZV0gPSBhY2NTdHlsZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBiYXNlKTsgLy8gJEZsb3dGaXhNZVxuXG4gIHRoZW1lRGljdC5yb290ID0gcGxhaW47IC8vICRGbG93Rml4TWVcblxuICB0aGVtZURpY3QucGxhaW4gPSBfZXh0ZW5kcyh7fSwgcGxhaW4sIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGVtZURpY3Q7XG59O1xuXG5mdW5jdGlvbiBvYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgdmFyIHRhcmdldCA9IHt9O1xuXG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykgJiYgZXhjbHVkZS5pbmRleE9mKGspID09PSAtMSkgdGFyZ2V0W2tdID0gb2JqW2tdO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBIaWdobGlnaHQgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKENvbXBvbmVudCkge1xuICBmdW5jdGlvbiBIaWdobGlnaHQoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChsZW4tLSkgYXJnc1tsZW5dID0gYXJndW1lbnRzW2xlbl07XG5cbiAgICBDb21wb25lbnQuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRUaGVtZURpY3RcIiwgZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICBpZiAodGhpcyQxLnRoZW1lRGljdCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLnRoZW1lID09PSB0aGlzJDEucHJldlRoZW1lICYmIHByb3BzLmxhbmd1YWdlID09PSB0aGlzJDEucHJldkxhbmd1YWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzJDEudGhlbWVEaWN0O1xuICAgICAgfVxuXG4gICAgICB0aGlzJDEucHJldlRoZW1lID0gcHJvcHMudGhlbWU7XG4gICAgICB0aGlzJDEucHJldkxhbmd1YWdlID0gcHJvcHMubGFuZ3VhZ2U7XG4gICAgICB2YXIgdGhlbWVEaWN0ID0gcHJvcHMudGhlbWUgPyB0aGVtZVRvRGljdChwcm9wcy50aGVtZSwgcHJvcHMubGFuZ3VhZ2UpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXMkMS50aGVtZURpY3QgPSB0aGVtZURpY3Q7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRMaW5lUHJvcHNcIiwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gcmVmLmNsYXNzTmFtZTtcbiAgICAgIHZhciBzdHlsZSA9IHJlZi5zdHlsZTtcbiAgICAgIHZhciByZXN0JDEgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhyZWYsIFtcImtleVwiLCBcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwibGluZVwiXSk7XG4gICAgICB2YXIgcmVzdCA9IHJlc3QkMTtcblxuICAgICAgdmFyIG91dHB1dCA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJ0b2tlbi1saW5lXCIsXG4gICAgICAgIHN0eWxlOiB1bmRlZmluZWQsXG4gICAgICAgIGtleTogdW5kZWZpbmVkXG4gICAgICB9KTtcblxuICAgICAgdmFyIHRoZW1lRGljdCA9IHRoaXMkMS5nZXRUaGVtZURpY3QodGhpcyQxLnByb3BzKTtcblxuICAgICAgaWYgKHRoZW1lRGljdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5zdHlsZSA9IHRoZW1lRGljdC5wbGFpbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0LnN0eWxlID0gb3V0cHV0LnN0eWxlICE9PSB1bmRlZmluZWQgPyBfZXh0ZW5kcyh7fSwgb3V0cHV0LnN0eWxlLCBzdHlsZSkgOiBzdHlsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5rZXkgPSBrZXk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgb3V0cHV0LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFN0eWxlRm9yVG9rZW5cIiwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIHR5cGVzID0gcmVmLnR5cGVzO1xuICAgICAgdmFyIGVtcHR5ID0gcmVmLmVtcHR5O1xuICAgICAgdmFyIHR5cGVzU2l6ZSA9IHR5cGVzLmxlbmd0aDtcbiAgICAgIHZhciB0aGVtZURpY3QgPSB0aGlzJDEuZ2V0VGhlbWVEaWN0KHRoaXMkMS5wcm9wcyk7XG5cbiAgICAgIGlmICh0aGVtZURpY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmICh0eXBlc1NpemUgPT09IDEgJiYgdHlwZXNbMF0gPT09IFwicGxhaW5cIikge1xuICAgICAgICByZXR1cm4gZW1wdHkgPyB7XG4gICAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIlxuICAgICAgICB9IDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmICh0eXBlc1NpemUgPT09IDEgJiYgIWVtcHR5KSB7XG4gICAgICAgIHJldHVybiB0aGVtZURpY3RbdHlwZXNbMF1dO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmFzZVN0eWxlID0gZW1wdHkgPyB7XG4gICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJcbiAgICAgIH0gOiB7fTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICB2YXIgdHlwZVN0eWxlcyA9IHR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhlbWVEaWN0W3R5cGVdO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsIFtiYXNlU3R5bGVdLmNvbmNhdCh0eXBlU3R5bGVzKSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRUb2tlblByb3BzXCIsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHJlZi5jbGFzc05hbWU7XG4gICAgICB2YXIgc3R5bGUgPSByZWYuc3R5bGU7XG4gICAgICB2YXIgdG9rZW4gPSByZWYudG9rZW47XG4gICAgICB2YXIgcmVzdCQxID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmVmLCBbXCJrZXlcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcInRva2VuXCJdKTtcbiAgICAgIHZhciByZXN0ID0gcmVzdCQxO1xuXG4gICAgICB2YXIgb3V0cHV0ID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInRva2VuIFwiICsgdG9rZW4udHlwZXMuam9pbihcIiBcIiksXG4gICAgICAgIGNoaWxkcmVuOiB0b2tlbi5jb250ZW50LFxuICAgICAgICBzdHlsZTogdGhpcyQxLmdldFN0eWxlRm9yVG9rZW4odG9rZW4pLFxuICAgICAgICBrZXk6IHVuZGVmaW5lZFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5zdHlsZSA9IG91dHB1dC5zdHlsZSAhPT0gdW5kZWZpbmVkID8gX2V4dGVuZHMoe30sIG91dHB1dC5zdHlsZSwgc3R5bGUpIDogc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQua2V5ID0ga2V5O1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIG91dHB1dC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b2tlbml6ZVwiLCBmdW5jdGlvbiAoUHJpc20sIGNvZGUsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG4gICAgICB2YXIgZW52ID0ge1xuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICBncmFtbWFyOiBncmFtbWFyLFxuICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICAgIHRva2VuczogW11cbiAgICAgIH07XG4gICAgICBQcmlzbS5ob29rcy5ydW4oXCJiZWZvcmUtdG9rZW5pemVcIiwgZW52KTtcbiAgICAgIHZhciB0b2tlbnMgPSBlbnYudG9rZW5zID0gUHJpc20udG9rZW5pemUoZW52LmNvZGUsIGVudi5ncmFtbWFyLCBlbnYubGFuZ3VhZ2UpO1xuICAgICAgUHJpc20uaG9va3MucnVuKFwiYWZ0ZXItdG9rZW5pemVcIiwgZW52KTtcbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoQ29tcG9uZW50KSBIaWdobGlnaHQuX19wcm90b19fID0gQ29tcG9uZW50O1xuICBIaWdobGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDb21wb25lbnQgJiYgQ29tcG9uZW50LnByb3RvdHlwZSk7XG4gIEhpZ2hsaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIaWdobGlnaHQ7XG5cbiAgSGlnaGxpZ2h0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIFByaXNtID0gcmVmLlByaXNtO1xuICAgIHZhciBsYW5ndWFnZSA9IHJlZi5sYW5ndWFnZTtcbiAgICB2YXIgY29kZSA9IHJlZi5jb2RlO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgdGhlbWVEaWN0ID0gdGhpcy5nZXRUaGVtZURpY3QodGhpcy5wcm9wcyk7XG4gICAgdmFyIGdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuICAgIHZhciBtaXhlZFRva2VucyA9IGdyYW1tYXIgIT09IHVuZGVmaW5lZCA/IHRoaXMudG9rZW5pemUoUHJpc20sIGNvZGUsIGdyYW1tYXIsIGxhbmd1YWdlKSA6IFtjb2RlXTtcbiAgICB2YXIgdG9rZW5zID0gbm9ybWFsaXplVG9rZW5zKG1peGVkVG9rZW5zKTtcbiAgICByZXR1cm4gY2hpbGRyZW4oe1xuICAgICAgdG9rZW5zOiB0b2tlbnMsXG4gICAgICBjbGFzc05hbWU6IFwicHJpc20tY29kZSBsYW5ndWFnZS1cIiArIGxhbmd1YWdlLFxuICAgICAgc3R5bGU6IHRoZW1lRGljdCAhPT0gdW5kZWZpbmVkID8gdGhlbWVEaWN0LnJvb3QgOiB7fSxcbiAgICAgIGdldExpbmVQcm9wczogdGhpcy5nZXRMaW5lUHJvcHMsXG4gICAgICBnZXRUb2tlblByb3BzOiB0aGlzLmdldFRva2VuUHJvcHNcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gSGlnaGxpZ2h0O1xufShDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBIaWdobGlnaHQ7XG5leHBvcnQgeyBkZWZhdWx0UHJvcHMgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3Mpw\n")},AqCL:function(module,exports){eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanM/MDJhMCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIl0sIm1hcHBpbmdzIjoiQUFBQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCQyxLQUFLLENBQUNDLE9BQU4sSUFBaUIsVUFBVUMsR0FBVixFQUFlO0FBQy9DLFNBQU9DLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCSixHQUEvQixLQUF1QyxnQkFBOUM7QUFDRCxDQUZEIiwiZmlsZSI6IkFxQ0wuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///AqCL\n")},MgzW:function(module,exports,__webpack_require__){"use strict";eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n/* eslint-disable no-unused-vars */\n\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n  if (val === null || val === undefined) {\n    throw new TypeError('Object.assign cannot be called with null or undefined');\n  }\n\n  return Object(val);\n}\n\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign) {\n      return false;\n    } // Detect buggy property enumeration order in older V8 versions.\n    // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\n\n    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\n\n    test1[5] = 'de';\n\n    if (Object.getOwnPropertyNames(test1)[0] === '5') {\n      return false;\n    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n    var test2 = {};\n\n    for (var i = 0; i < 10; i++) {\n      test2['_' + String.fromCharCode(i)] = i;\n    }\n\n    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n      return test2[n];\n    });\n\n    if (order2.join('') !== '0123456789') {\n      return false;\n    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n    var test3 = {};\n    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n      test3[letter] = letter;\n    });\n\n    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    // We don't expect any of the above to throw, but better to be safe.\n    return false;\n  }\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n  var from;\n  var to = toObject(target);\n  var symbols;\n\n  for (var s = 1; s < arguments.length; s++) {\n    from = Object(arguments[s]);\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n\n    if (getOwnPropertySymbols) {\n      symbols = getOwnPropertySymbols(from);\n\n      for (var i = 0; i < symbols.length; i++) {\n        if (propIsEnumerable.call(from, symbols[i])) {\n          to[symbols[i]] = from[symbols[i]];\n        }\n      }\n    }\n  }\n\n  return to;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8zMjBjIl0sIm5hbWVzIjpbImdldE93blByb3BlcnR5U3ltYm9scyIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwicHJvdG90eXBlIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJ2YWwiLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiLCJzaG91bGRVc2VOYXRpdmUiLCJhc3NpZ24iLCJ0ZXN0MSIsIlN0cmluZyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ0ZXN0MiIsImkiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJtYXAiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJmb3JFYWNoIiwibGV0dGVyIiwia2V5cyIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0YXJnZXQiLCJzb3VyY2UiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImtleSIsImNhbGwiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFYTtBQUNiOztBQUNBLElBQUlBLHFCQUFxQixHQUFHQyxNQUFNLENBQUNELHFCQUFuQztBQUNBLElBQUlFLGNBQWMsR0FBR0QsTUFBTSxDQUFDRSxTQUFQLENBQWlCRCxjQUF0QztBQUNBLElBQUlFLGdCQUFnQixHQUFHSCxNQUFNLENBQUNFLFNBQVAsQ0FBaUJFLG9CQUF4Qzs7QUFFQSxTQUFTQyxRQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUN0QixNQUFJQSxHQUFHLEtBQUssSUFBUixJQUFnQkEsR0FBRyxLQUFLQyxTQUE1QixFQUF1QztBQUN0QyxVQUFNLElBQUlDLFNBQUosQ0FBYyx1REFBZCxDQUFOO0FBQ0E7O0FBRUQsU0FBT1IsTUFBTSxDQUFDTSxHQUFELENBQWI7QUFDQTs7QUFFRCxTQUFTRyxlQUFULEdBQTJCO0FBQzFCLE1B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QUE2QztBQUM1Q2lCLFlBQUUsQ0FBQ0MsT0FBTyxDQUFDbEIsQ0FBRCxDQUFSLENBQUYsR0FBaUJnQixJQUFJLENBQUNFLE9BQU8sQ0FBQ2xCLENBQUQsQ0FBUixDQUFyQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFNBQU9pQixFQUFQO0FBQ0EsQ0F6QkQiLCJmaWxlIjoiTWd6Vy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///MgzW\n")},Q2Ig:function(module,exports,__webpack_require__){eval("exports.nextTick = function nextTick(fn) {\n  var args = Array.prototype.slice.call(arguments);\n  args.shift();\n  setTimeout(function () {\n    fn.apply(null, args);\n  }, 0);\n};\n\nexports.platform = exports.arch = exports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n  throw new Error('No such module. (Possibly not yet loaded)');\n};\n\n(function () {\n  var cwd = '/';\n  var path;\n\n  exports.cwd = function () {\n    return cwd;\n  };\n\n  exports.chdir = function (dir) {\n    if (!path) path = __webpack_require__(\"33yf\");\n    cwd = path.resolve(dir, cwd);\n  };\n})();\n\nexports.exit = exports.kill = exports.umask = exports.dlopen = exports.uptime = exports.memoryUsage = exports.uvCounters = function () {};\n\nexports.features = {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbW9jay9wcm9jZXNzLmpzPzQzNjIiXSwibmFtZXMiOlsiZXhwb3J0cyIsIm5leHRUaWNrIiwiZm4iLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJzaGlmdCIsInNldFRpbWVvdXQiLCJhcHBseSIsInBsYXRmb3JtIiwiYXJjaCIsImV4ZWNQYXRoIiwidGl0bGUiLCJwaWQiLCJicm93c2VyIiwiZW52IiwiYXJndiIsImJpbmRpbmciLCJuYW1lIiwiRXJyb3IiLCJjd2QiLCJwYXRoIiwiY2hkaXIiLCJkaXIiLCJyZXF1aXJlIiwicmVzb2x2ZSIsImV4aXQiLCJraWxsIiwidW1hc2siLCJkbG9wZW4iLCJ1cHRpbWUiLCJtZW1vcnlVc2FnZSIsInV2Q291bnRlcnMiLCJmZWF0dXJlcyJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU8sQ0FBQ0MsUUFBUixHQUFtQixTQUFTQSxRQUFULENBQWtCQyxFQUFsQixFQUFzQjtBQUNyQyxNQUFJQyxJQUFJLEdBQUdDLEtBQUssQ0FBQ0MsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0JDLElBQXRCLENBQTJCQyxTQUEzQixDQUFYO0FBQ0FMLE1BQUksQ0FBQ00sS0FBTDtBQUNBQyxZQUFVLENBQUMsWUFBWTtBQUNuQlIsTUFBRSxDQUFDUyxLQUFILENBQVMsSUFBVCxFQUFlUixJQUFmO0FBQ0gsR0FGUyxFQUVQLENBRk8sQ0FBVjtBQUdILENBTkQ7O0FBUUFILE9BQU8sQ0FBQ1ksUUFBUixHQUFtQlosT0FBTyxDQUFDYSxJQUFSLEdBQ25CYixPQUFPLENBQUNjLFFBQVIsR0FBbUJkLE9BQU8sQ0FBQ2UsS0FBUixHQUFnQixTQURuQztBQUVBZixPQUFPLENBQUNnQixHQUFSLEdBQWMsQ0FBZDtBQUNBaEIsT0FBTyxDQUFDaUIsT0FBUixHQUFrQixJQUFsQjtBQUNBakIsT0FBTyxDQUFDa0IsR0FBUixHQUFjLEVBQWQ7QUFDQWxCLE9BQU8sQ0FBQ21CLElBQVIsR0FBZSxFQUFmOztBQUVBbkIsT0FBTyxDQUFDb0IsT0FBUixHQUFrQixVQUFVQyxJQUFWLEVBQWdCO0FBQ2pDLFFBQU0sSUFBSUMsS0FBSixDQUFVLDJDQUFWLENBQU47QUFDQSxDQUZEOztBQUlBLENBQUMsWUFBWTtBQUNULE1BQUlDLEdBQUcsR0FBRyxHQUFWO0FBQ0EsTUFBSUMsSUFBSjs7QUFDQXhCLFNBQU8sQ0FBQ3VCLEdBQVIsR0FBYyxZQUFZO0FBQUUsV0FBT0EsR0FBUDtBQUFZLEdBQXhDOztBQUNBdkIsU0FBTyxDQUFDeUIsS0FBUixHQUFnQixVQUFVQyxHQUFWLEVBQWU7QUFDM0IsUUFBSSxDQUFDRixJQUFMLEVBQVdBLElBQUksR0FBR0csbUJBQU8sQ0FBQyxNQUFELENBQWQ7QUFDWEosT0FBRyxHQUFHQyxJQUFJLENBQUNJLE9BQUwsQ0FBYUYsR0FBYixFQUFrQkgsR0FBbEIsQ0FBTjtBQUNILEdBSEQ7QUFJSCxDQVJEOztBQVVBdkIsT0FBTyxDQUFDNkIsSUFBUixHQUFlN0IsT0FBTyxDQUFDOEIsSUFBUixHQUNmOUIsT0FBTyxDQUFDK0IsS0FBUixHQUFnQi9CLE9BQU8sQ0FBQ2dDLE1BQVIsR0FDaEJoQyxPQUFPLENBQUNpQyxNQUFSLEdBQWlCakMsT0FBTyxDQUFDa0MsV0FBUixHQUNqQmxDLE9BQU8sQ0FBQ21DLFVBQVIsR0FBcUIsWUFBVyxDQUFFLENBSGxDOztBQUlBbkMsT0FBTyxDQUFDb0MsUUFBUixHQUFtQixFQUFuQiIsImZpbGUiOiJRMklnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5uZXh0VGljayA9IGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGFyZ3Muc2hpZnQoKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgMCk7XG59O1xuXG5leHBvcnRzLnBsYXRmb3JtID0gZXhwb3J0cy5hcmNoID0gXG5leHBvcnRzLmV4ZWNQYXRoID0gZXhwb3J0cy50aXRsZSA9ICdicm93c2VyJztcbmV4cG9ydHMucGlkID0gMTtcbmV4cG9ydHMuYnJvd3NlciA9IHRydWU7XG5leHBvcnRzLmVudiA9IHt9O1xuZXhwb3J0cy5hcmd2ID0gW107XG5cbmV4cG9ydHMuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBtb2R1bGUuIChQb3NzaWJseSBub3QgeWV0IGxvYWRlZCknKVxufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3dkID0gJy8nO1xuICAgIHZhciBwYXRoO1xuICAgIGV4cG9ydHMuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY3dkIH07XG4gICAgZXhwb3J0cy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgaWYgKCFwYXRoKSBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuICAgICAgICBjd2QgPSBwYXRoLnJlc29sdmUoZGlyLCBjd2QpO1xuICAgIH07XG59KSgpO1xuXG5leHBvcnRzLmV4aXQgPSBleHBvcnRzLmtpbGwgPSBcbmV4cG9ydHMudW1hc2sgPSBleHBvcnRzLmRsb3BlbiA9IFxuZXhwb3J0cy51cHRpbWUgPSBleHBvcnRzLm1lbW9yeVVzYWdlID0gXG5leHBvcnRzLnV2Q291bnRlcnMgPSBmdW5jdGlvbigpIHt9O1xuZXhwb3J0cy5mZWF0dXJlcyA9IHt9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///Q2Ig\n")},WbBG:function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\nmodule.exports = ReactPropTypesSecret;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/NTliMCJdLCJuYW1lcyI6WyJSZWFjdFByb3BUeXBlc1NlY3JldCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVhOztBQUViLElBQUlBLG9CQUFvQixHQUFHLDhDQUEzQjtBQUVBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJGLG9CQUFqQiIsImZpbGUiOiJXYkJHLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///WbBG\n")},Wxvo:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export QRCodeCanvas */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return QRCodeSVG; });\n/* unused harmony export default */\n/* harmony import */ var _home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("fWQN");\n/* harmony import */ var _home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("mtLc");\n/* harmony import */ var _home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("rAM+");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("kM82");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols) {\n    var _iterator = Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(__getOwnPropSymbols(b)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return a;\n};\n\nvar __objRest = function __objRest(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols) {\n    var _iterator2 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(__getOwnPropSymbols(source)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var prop = _step2.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return target;\n}; // src/index.tsx\n\n\n // src/third-party/qrcodegen/index.ts\n\n/**\n * @license QR Code generator library (TypeScript)\n * Copyright (c) Project Nayuki.\n * SPDX-License-Identifier: MIT\n */\n\nvar qrcodegen;\n\n(function (qrcodegen2) {\n  var _QrCode = /*#__PURE__*/function () {\n    function _QrCode(version, errorCorrectionLevel, dataCodewords, msk) {\n      Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, _QrCode);\n\n      this.version = version;\n      this.errorCorrectionLevel = errorCorrectionLevel;\n      this.modules = [];\n      this.isFunction = [];\n      if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION) throw new RangeError("Version value out of range");\n      if (msk < -1 || msk > 7) throw new RangeError("Mask value out of range");\n      this.size = version * 4 + 17;\n      var row = [];\n\n      for (var i = 0; i < this.size; i++) {\n        row.push(false);\n      }\n\n      for (var _i = 0; _i < this.size; _i++) {\n        this.modules.push(row.slice());\n        this.isFunction.push(row.slice());\n      }\n\n      this.drawFunctionPatterns();\n      var allCodewords = this.addEccAndInterleave(dataCodewords);\n      this.drawCodewords(allCodewords);\n\n      if (msk == -1) {\n        var minPenalty = 1e9;\n\n        for (var _i2 = 0; _i2 < 8; _i2++) {\n          this.applyMask(_i2);\n          this.drawFormatBits(_i2);\n          var penalty = this.getPenaltyScore();\n\n          if (penalty < minPenalty) {\n            msk = _i2;\n            minPenalty = penalty;\n          }\n\n          this.applyMask(_i2);\n        }\n      }\n\n      assert(0 <= msk && msk <= 7);\n      this.mask = msk;\n      this.applyMask(msk);\n      this.drawFormatBits(msk);\n      this.isFunction = [];\n    }\n\n    Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_QrCode, [{\n      key: "getModule",\n      value: function getModule(x, y) {\n        return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n      }\n    }, {\n      key: "getModules",\n      value: function getModules() {\n        return this.modules;\n      }\n    }, {\n      key: "drawFunctionPatterns",\n      value: function drawFunctionPatterns() {\n        for (var i = 0; i < this.size; i++) {\n          this.setFunctionModule(6, i, i % 2 == 0);\n          this.setFunctionModule(i, 6, i % 2 == 0);\n        }\n\n        this.drawFinderPattern(3, 3);\n        this.drawFinderPattern(this.size - 4, 3);\n        this.drawFinderPattern(3, this.size - 4);\n        var alignPatPos = this.getAlignmentPatternPositions();\n        var numAlign = alignPatPos.length;\n\n        for (var _i3 = 0; _i3 < numAlign; _i3++) {\n          for (var j = 0; j < numAlign; j++) {\n            if (!(_i3 == 0 && j == 0 || _i3 == 0 && j == numAlign - 1 || _i3 == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[_i3], alignPatPos[j]);\n          }\n        }\n\n        this.drawFormatBits(0);\n        this.drawVersion();\n      }\n    }, {\n      key: "drawFormatBits",\n      value: function drawFormatBits(mask) {\n        var data = this.errorCorrectionLevel.formatBits << 3 | mask;\n        var rem = data;\n\n        for (var i = 0; i < 10; i++) {\n          rem = rem << 1 ^ (rem >>> 9) * 1335;\n        }\n\n        var bits = (data << 10 | rem) ^ 21522;\n        assert(bits >>> 15 == 0);\n\n        for (var _i4 = 0; _i4 <= 5; _i4++) {\n          this.setFunctionModule(8, _i4, getBit(bits, _i4));\n        }\n\n        this.setFunctionModule(8, 7, getBit(bits, 6));\n        this.setFunctionModule(8, 8, getBit(bits, 7));\n        this.setFunctionModule(7, 8, getBit(bits, 8));\n\n        for (var _i5 = 9; _i5 < 15; _i5++) {\n          this.setFunctionModule(14 - _i5, 8, getBit(bits, _i5));\n        }\n\n        for (var _i6 = 0; _i6 < 8; _i6++) {\n          this.setFunctionModule(this.size - 1 - _i6, 8, getBit(bits, _i6));\n        }\n\n        for (var _i7 = 8; _i7 < 15; _i7++) {\n          this.setFunctionModule(8, this.size - 15 + _i7, getBit(bits, _i7));\n        }\n\n        this.setFunctionModule(8, this.size - 8, true);\n      }\n    }, {\n      key: "drawVersion",\n      value: function drawVersion() {\n        if (this.version < 7) return;\n        var rem = this.version;\n\n        for (var i = 0; i < 12; i++) {\n          rem = rem << 1 ^ (rem >>> 11) * 7973;\n        }\n\n        var bits = this.version << 12 | rem;\n        assert(bits >>> 18 == 0);\n\n        for (var _i8 = 0; _i8 < 18; _i8++) {\n          var color = getBit(bits, _i8);\n          var a = this.size - 11 + _i8 % 3;\n          var b = Math.floor(_i8 / 3);\n          this.setFunctionModule(a, b, color);\n          this.setFunctionModule(b, a, color);\n        }\n      }\n    }, {\n      key: "drawFinderPattern",\n      value: function drawFinderPattern(x, y) {\n        for (var dy = -4; dy <= 4; dy++) {\n          for (var dx = -4; dx <= 4; dx++) {\n            var dist = Math.max(Math.abs(dx), Math.abs(dy));\n            var xx = x + dx;\n            var yy = y + dy;\n            if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n          }\n        }\n      }\n    }, {\n      key: "drawAlignmentPattern",\n      value: function drawAlignmentPattern(x, y) {\n        for (var dy = -2; dy <= 2; dy++) {\n          for (var dx = -2; dx <= 2; dx++) {\n            this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n          }\n        }\n      }\n    }, {\n      key: "setFunctionModule",\n      value: function setFunctionModule(x, y, isDark) {\n        this.modules[y][x] = isDark;\n        this.isFunction[y][x] = true;\n      }\n    }, {\n      key: "addEccAndInterleave",\n      value: function addEccAndInterleave(data) {\n        var ver = this.version;\n        var ecl = this.errorCorrectionLevel;\n        if (data.length != _QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError("Invalid argument");\n        var numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n        var blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n        var rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);\n        var numShortBlocks = numBlocks - rawCodewords % numBlocks;\n        var shortBlockLen = Math.floor(rawCodewords / numBlocks);\n        var blocks = [];\n\n        var rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);\n\n        for (var i = 0, k = 0; i < numBlocks; i++) {\n          var dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n          k += dat.length;\n\n          var ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n\n          if (i < numShortBlocks) dat.push(0);\n          blocks.push(dat.concat(ecc));\n        }\n\n        var result = [];\n\n        var _loop = function _loop(_i9) {\n          blocks.forEach(function (block, j) {\n            if (_i9 != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[_i9]);\n          });\n        };\n\n        for (var _i9 = 0; _i9 < blocks[0].length; _i9++) {\n          _loop(_i9);\n        }\n\n        assert(result.length == rawCodewords);\n        return result;\n      }\n    }, {\n      key: "drawCodewords",\n      value: function drawCodewords(data) {\n        if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");\n        var i = 0;\n\n        for (var right = this.size - 1; right >= 1; right -= 2) {\n          if (right == 6) right = 5;\n\n          for (var vert = 0; vert < this.size; vert++) {\n            for (var j = 0; j < 2; j++) {\n              var x = right - j;\n              var upward = (right + 1 & 2) == 0;\n              var y = upward ? this.size - 1 - vert : vert;\n\n              if (!this.isFunction[y][x] && i < data.length * 8) {\n                this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n                i++;\n              }\n            }\n          }\n        }\n\n        assert(i == data.length * 8);\n      }\n    }, {\n      key: "applyMask",\n      value: function applyMask(mask) {\n        if (mask < 0 || mask > 7) throw new RangeError("Mask value out of range");\n\n        for (var y = 0; y < this.size; y++) {\n          for (var x = 0; x < this.size; x++) {\n            var invert = void 0;\n\n            switch (mask) {\n              case 0:\n                invert = (x + y) % 2 == 0;\n                break;\n\n              case 1:\n                invert = y % 2 == 0;\n                break;\n\n              case 2:\n                invert = x % 3 == 0;\n                break;\n\n              case 3:\n                invert = (x + y) % 3 == 0;\n                break;\n\n              case 4:\n                invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n                break;\n\n              case 5:\n                invert = x * y % 2 + x * y % 3 == 0;\n                break;\n\n              case 6:\n                invert = (x * y % 2 + x * y % 3) % 2 == 0;\n                break;\n\n              case 7:\n                invert = ((x + y) % 2 + x * y % 3) % 2 == 0;\n                break;\n\n              default:\n                throw new Error("Unreachable");\n            }\n\n            if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];\n          }\n        }\n      }\n    }, {\n      key: "getPenaltyScore",\n      value: function getPenaltyScore() {\n        var result = 0;\n\n        for (var y = 0; y < this.size; y++) {\n          var runColor = false;\n          var runX = 0;\n          var runHistory = [0, 0, 0, 0, 0, 0, 0];\n\n          for (var x = 0; x < this.size; x++) {\n            if (this.modules[y][x] == runColor) {\n              runX++;\n              if (runX == 5) result += _QrCode.PENALTY_N1;else if (runX > 5) result++;\n            } else {\n              this.finderPenaltyAddHistory(runX, runHistory);\n              if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n              runColor = this.modules[y][x];\n              runX = 1;\n            }\n          }\n\n          result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;\n        }\n\n        for (var _x = 0; _x < this.size; _x++) {\n          var _runColor = false;\n          var runY = 0;\n          var _runHistory = [0, 0, 0, 0, 0, 0, 0];\n\n          for (var _y = 0; _y < this.size; _y++) {\n            if (this.modules[_y][_x] == _runColor) {\n              runY++;\n              if (runY == 5) result += _QrCode.PENALTY_N1;else if (runY > 5) result++;\n            } else {\n              this.finderPenaltyAddHistory(runY, _runHistory);\n              if (!_runColor) result += this.finderPenaltyCountPatterns(_runHistory) * _QrCode.PENALTY_N3;\n              _runColor = this.modules[_y][_x];\n              runY = 1;\n            }\n          }\n\n          result += this.finderPenaltyTerminateAndCount(_runColor, runY, _runHistory) * _QrCode.PENALTY_N3;\n        }\n\n        for (var _y2 = 0; _y2 < this.size - 1; _y2++) {\n          for (var _x2 = 0; _x2 < this.size - 1; _x2++) {\n            var color = this.modules[_y2][_x2];\n            if (color == this.modules[_y2][_x2 + 1] && color == this.modules[_y2 + 1][_x2] && color == this.modules[_y2 + 1][_x2 + 1]) result += _QrCode.PENALTY_N2;\n          }\n        }\n\n        var dark = 0;\n\n        var _iterator3 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(this.modules),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var row = _step3.value;\n            dark = row.reduce(function (sum, color) {\n              return sum + (color ? 1 : 0);\n            }, dark);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        var total = this.size * this.size;\n        var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n        assert(0 <= k && k <= 9);\n        result += k * _QrCode.PENALTY_N4;\n        assert(0 <= result && result <= 2568888);\n        return result;\n      }\n    }, {\n      key: "getAlignmentPatternPositions",\n      value: function getAlignmentPatternPositions() {\n        if (this.version == 1) return [];else {\n          var numAlign = Math.floor(this.version / 7) + 2;\n          var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n          var result = [6];\n\n          for (var pos = this.size - 7; result.length < numAlign; pos -= step) {\n            result.splice(1, 0, pos);\n          }\n\n          return result;\n        }\n      }\n    }, {\n      key: "finderPenaltyCountPatterns",\n      value: function finderPenaltyCountPatterns(runHistory) {\n        var n = runHistory[1];\n        assert(n <= this.size * 3);\n        var core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n        return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n      }\n    }, {\n      key: "finderPenaltyTerminateAndCount",\n      value: function finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n        if (currentRunColor) {\n          this.finderPenaltyAddHistory(currentRunLength, runHistory);\n          currentRunLength = 0;\n        }\n\n        currentRunLength += this.size;\n        this.finderPenaltyAddHistory(currentRunLength, runHistory);\n        return this.finderPenaltyCountPatterns(runHistory);\n      }\n    }, {\n      key: "finderPenaltyAddHistory",\n      value: function finderPenaltyAddHistory(currentRunLength, runHistory) {\n        if (runHistory[0] == 0) currentRunLength += this.size;\n        runHistory.pop();\n        runHistory.unshift(currentRunLength);\n      }\n    }], [{\n      key: "encodeText",\n      value: function encodeText(text, ecl) {\n        var segs = qrcodegen2.QrSegment.makeSegments(text);\n        return _QrCode.encodeSegments(segs, ecl);\n      }\n    }, {\n      key: "encodeBinary",\n      value: function encodeBinary(data, ecl) {\n        var seg = qrcodegen2.QrSegment.makeBytes(data);\n        return _QrCode.encodeSegments([seg], ecl);\n      }\n    }, {\n      key: "encodeSegments",\n      value: function encodeSegments(segs, ecl) {\n        var minVersion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var maxVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 40;\n        var mask = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n        var boostEcl = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n        if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError("Invalid value");\n        var version;\n        var dataUsedBits;\n\n        for (version = minVersion;; version++) {\n          var dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;\n          var usedBits = QrSegment.getTotalBits(segs, version);\n\n          if (usedBits <= dataCapacityBits2) {\n            dataUsedBits = usedBits;\n            break;\n          }\n\n          if (version >= maxVersion) throw new RangeError("Data too long");\n        }\n\n        for (var _i10 = 0, _arr = [_QrCode.Ecc.MEDIUM, _QrCode.Ecc.QUARTILE, _QrCode.Ecc.HIGH]; _i10 < _arr.length; _i10++) {\n          var newEcl = _arr[_i10];\n          if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;\n        }\n\n        var bb = [];\n\n        var _iterator4 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(segs),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var seg = _step4.value;\n            appendBits(seg.mode.modeBits, 4, bb);\n            appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n\n            var _iterator5 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(seg.getData()),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var b = _step5.value;\n                bb.push(b);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        assert(bb.length == dataUsedBits);\n        var dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;\n        assert(bb.length <= dataCapacityBits);\n        appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n        appendBits(0, (8 - bb.length % 8) % 8, bb);\n        assert(bb.length % 8 == 0);\n\n        for (var padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17) {\n          appendBits(padByte, 8, bb);\n        }\n\n        var dataCodewords = [];\n\n        while (dataCodewords.length * 8 < bb.length) {\n          dataCodewords.push(0);\n        }\n\n        bb.forEach(function (b, i) {\n          return dataCodewords[i >>> 3] |= b << 7 - (i & 7);\n        });\n        return new _QrCode(version, ecl, dataCodewords, mask);\n      }\n    }, {\n      key: "getNumRawDataModules",\n      value: function getNumRawDataModules(ver) {\n        if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION) throw new RangeError("Version number out of range");\n        var result = (16 * ver + 128) * ver + 64;\n\n        if (ver >= 2) {\n          var numAlign = Math.floor(ver / 7) + 2;\n          result -= (25 * numAlign - 10) * numAlign - 55;\n          if (ver >= 7) result -= 36;\n        }\n\n        assert(208 <= result && result <= 29648);\n        return result;\n      }\n    }, {\n      key: "getNumDataCodewords",\n      value: function getNumDataCodewords(ver, ecl) {\n        return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n      }\n    }, {\n      key: "reedSolomonComputeDivisor",\n      value: function reedSolomonComputeDivisor(degree) {\n        if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");\n        var result = [];\n\n        for (var i = 0; i < degree - 1; i++) {\n          result.push(0);\n        }\n\n        result.push(1);\n        var root = 1;\n\n        for (var _i11 = 0; _i11 < degree; _i11++) {\n          for (var j = 0; j < result.length; j++) {\n            result[j] = _QrCode.reedSolomonMultiply(result[j], root);\n            if (j + 1 < result.length) result[j] ^= result[j + 1];\n          }\n\n          root = _QrCode.reedSolomonMultiply(root, 2);\n        }\n\n        return result;\n      }\n    }, {\n      key: "reedSolomonComputeRemainder",\n      value: function reedSolomonComputeRemainder(data, divisor) {\n        var result = divisor.map(function (_) {\n          return 0;\n        });\n\n        var _iterator6 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(data),\n            _step6;\n\n        try {\n          var _loop2 = function _loop2() {\n            var b = _step6.value;\n            var factor = b ^ result.shift();\n            result.push(0);\n            divisor.forEach(function (coef, i) {\n              return result[i] ^= _QrCode.reedSolomonMultiply(coef, factor);\n            });\n          };\n\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            _loop2();\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        return result;\n      }\n    }, {\n      key: "reedSolomonMultiply",\n      value: function reedSolomonMultiply(x, y) {\n        if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError("Byte out of range");\n        var z = 0;\n\n        for (var i = 7; i >= 0; i--) {\n          z = z << 1 ^ (z >>> 7) * 285;\n          z ^= (y >>> i & 1) * x;\n        }\n\n        assert(z >>> 8 == 0);\n        return z;\n      }\n    }]);\n\n    return _QrCode;\n  }();\n\n  var QrCode = _QrCode;\n  QrCode.MIN_VERSION = 1;\n  QrCode.MAX_VERSION = 40;\n  QrCode.PENALTY_N1 = 3;\n  QrCode.PENALTY_N2 = 3;\n  QrCode.PENALTY_N3 = 40;\n  QrCode.PENALTY_N4 = 10;\n  QrCode.ECC_CODEWORDS_PER_BLOCK = [[-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]];\n  QrCode.NUM_ERROR_CORRECTION_BLOCKS = [[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]];\n  qrcodegen2.QrCode = QrCode;\n\n  function appendBits(val, len, bb) {\n    if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError("Value out of range");\n\n    for (var i = len - 1; i >= 0; i--) {\n      bb.push(val >>> i & 1);\n    }\n  }\n\n  function getBit(x, i) {\n    return (x >>> i & 1) != 0;\n  }\n\n  function assert(cond) {\n    if (!cond) throw new Error("Assertion error");\n  }\n\n  var _QrSegment = /*#__PURE__*/function () {\n    function _QrSegment(mode, numChars, bitData) {\n      Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, _QrSegment);\n\n      this.mode = mode;\n      this.numChars = numChars;\n      this.bitData = bitData;\n      if (numChars < 0) throw new RangeError("Invalid argument");\n      this.bitData = bitData.slice();\n    }\n\n    Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_QrSegment, [{\n      key: "getData",\n      value: function getData() {\n        return this.bitData.slice();\n      }\n    }], [{\n      key: "makeBytes",\n      value: function makeBytes(data) {\n        var bb = [];\n\n        var _iterator7 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(data),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var b = _step7.value;\n            appendBits(b, 8, bb);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);\n      }\n    }, {\n      key: "makeNumeric",\n      value: function makeNumeric(digits) {\n        if (!_QrSegment.isNumeric(digits)) throw new RangeError("String contains non-numeric characters");\n        var bb = [];\n\n        for (var i = 0; i < digits.length;) {\n          var n = Math.min(digits.length - i, 3);\n          appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);\n          i += n;\n        }\n\n        return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);\n      }\n    }, {\n      key: "makeAlphanumeric",\n      value: function makeAlphanumeric(text) {\n        if (!_QrSegment.isAlphanumeric(text)) throw new RangeError("String contains unencodable characters in alphanumeric mode");\n        var bb = [];\n        var i;\n\n        for (i = 0; i + 2 <= text.length; i += 2) {\n          var temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n          temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n          appendBits(temp, 11, bb);\n        }\n\n        if (i < text.length) appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n        return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);\n      }\n    }, {\n      key: "makeSegments",\n      value: function makeSegments(text) {\n        if (text == "") return [];else if (_QrSegment.isNumeric(text)) return [_QrSegment.makeNumeric(text)];else if (_QrSegment.isAlphanumeric(text)) return [_QrSegment.makeAlphanumeric(text)];else return [_QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))];\n      }\n    }, {\n      key: "makeEci",\n      value: function makeEci(assignVal) {\n        var bb = [];\n        if (assignVal < 0) throw new RangeError("ECI assignment value out of range");else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);else if (assignVal < 1 << 14) {\n          appendBits(2, 2, bb);\n          appendBits(assignVal, 14, bb);\n        } else if (assignVal < 1e6) {\n          appendBits(6, 3, bb);\n          appendBits(assignVal, 21, bb);\n        } else throw new RangeError("ECI assignment value out of range");\n        return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);\n      }\n    }, {\n      key: "isNumeric",\n      value: function isNumeric(text) {\n        return _QrSegment.NUMERIC_REGEX.test(text);\n      }\n    }, {\n      key: "isAlphanumeric",\n      value: function isAlphanumeric(text) {\n        return _QrSegment.ALPHANUMERIC_REGEX.test(text);\n      }\n    }, {\n      key: "getTotalBits",\n      value: function getTotalBits(segs, version) {\n        var result = 0;\n\n        var _iterator8 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(segs),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var seg = _step8.value;\n            var ccbits = seg.mode.numCharCountBits(version);\n            if (seg.numChars >= 1 << ccbits) return Infinity;\n            result += 4 + ccbits + seg.bitData.length;\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n\n        return result;\n      }\n    }, {\n      key: "toUtf8ByteArray",\n      value: function toUtf8ByteArray(str) {\n        str = encodeURI(str);\n        var result = [];\n\n        for (var i = 0; i < str.length; i++) {\n          if (str.charAt(i) != "%") result.push(str.charCodeAt(i));else {\n            result.push(parseInt(str.substr(i + 1, 2), 16));\n            i += 2;\n          }\n        }\n\n        return result;\n      }\n    }]);\n\n    return _QrSegment;\n  }();\n\n  var QrSegment = _QrSegment;\n  QrSegment.NUMERIC_REGEX = /^[0-9]*$/;\n  QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\n  QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";\n  qrcodegen2.QrSegment = QrSegment;\n})(qrcodegen || (qrcodegen = {}));\n\n(function (qrcodegen2) {\n  var QrCode;\n\n  (function (QrCode2) {\n    var _Ecc = function _Ecc(ordinal, formatBits) {\n      Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, _Ecc);\n\n      this.ordinal = ordinal;\n      this.formatBits = formatBits;\n    };\n\n    var Ecc = _Ecc;\n    Ecc.LOW = new _Ecc(0, 1);\n    Ecc.MEDIUM = new _Ecc(1, 0);\n    Ecc.QUARTILE = new _Ecc(2, 3);\n    Ecc.HIGH = new _Ecc(3, 2);\n    QrCode2.Ecc = Ecc;\n  })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));\n})(qrcodegen || (qrcodegen = {}));\n\n(function (qrcodegen2) {\n  var QrSegment;\n\n  (function (QrSegment2) {\n    var _Mode = /*#__PURE__*/function () {\n      function _Mode(modeBits, numBitsCharCount) {\n        Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(this, _Mode);\n\n        this.modeBits = modeBits;\n        this.numBitsCharCount = numBitsCharCount;\n      }\n\n      Object(_home_runner_work_fast_ui_fast_ui_node_modules_umijs_babel_preset_umi_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_Mode, [{\n        key: "numCharCountBits",\n        value: function numCharCountBits(ver) {\n          return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n        }\n      }]);\n\n      return _Mode;\n    }();\n\n    var Mode = _Mode;\n    Mode.NUMERIC = new _Mode(1, [10, 12, 14]);\n    Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);\n    Mode.BYTE = new _Mode(4, [8, 16, 16]);\n    Mode.KANJI = new _Mode(8, [8, 10, 12]);\n    Mode.ECI = new _Mode(7, [0, 0, 0]);\n    QrSegment2.Mode = Mode;\n  })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));\n})(qrcodegen || (qrcodegen = {}));\n\nvar qrcodegen_default = qrcodegen; // src/index.tsx\n\n/**\n * @license qrcode.react\n * Copyright (c) Paul O\'Shannessy\n * SPDX-License-Identifier: ISC\n */\n\nvar ERROR_LEVEL_MAP = {\n  L: qrcodegen_default.QrCode.Ecc.LOW,\n  M: qrcodegen_default.QrCode.Ecc.MEDIUM,\n  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,\n  H: qrcodegen_default.QrCode.Ecc.HIGH\n};\nvar DEFAULT_PROPS = {\n  size: 128,\n  level: "L",\n  bgColor: "#FFFFFF",\n  fgColor: "#000000",\n  includeMargin: false\n};\nvar MARGIN_SIZE = 4;\nvar DEFAULT_IMG_SCALE = 0.1;\n\nfunction generatePath(modules) {\n  var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ops = [];\n  modules.forEach(function (row, y) {\n    var start = null;\n    row.forEach(function (cell, x) {\n      if (!cell && start !== null) {\n        ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));\n        start = null;\n        return;\n      }\n\n      if (x === row.length - 1) {\n        if (!cell) {\n          return;\n        }\n\n        if (start === null) {\n          ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));\n        } else {\n          ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));\n        }\n\n        return;\n      }\n\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join("");\n}\n\nfunction excavateModules(modules, excavation) {\n  return modules.slice().map(function (row, y) {\n    if (y < excavation.y || y >= excavation.y + excavation.h) {\n      return row;\n    }\n\n    return row.map(function (cell, x) {\n      if (x < excavation.x || x >= excavation.x + excavation.w) {\n        return cell;\n      }\n\n      return false;\n    });\n  });\n}\n\nfunction getImageSettings(props, cells) {\n  var imageSettings = props.imageSettings,\n      size = props.size,\n      includeMargin = props.includeMargin;\n\n  if (imageSettings == null) {\n    return null;\n  }\n\n  var margin = includeMargin ? MARGIN_SIZE : 0;\n  var numCells = cells.length + margin * 2;\n  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  var scale = numCells / size;\n  var w = (imageSettings.width || defaultSize) * scale;\n  var h = (imageSettings.height || defaultSize) * scale;\n  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n  var excavation = null;\n\n  if (imageSettings.excavate) {\n    var floorX = Math.floor(x);\n    var floorY = Math.floor(y);\n    var ceilW = Math.ceil(w + x - floorX);\n    var ceilH = Math.ceil(h + y - floorY);\n    excavation = {\n      x: floorX,\n      y: floorY,\n      w: ceilW,\n      h: ceilH\n    };\n  }\n\n  return {\n    x: x,\n    y: y,\n    h: h,\n    w: w,\n    excavation: excavation\n  };\n}\n\nvar SUPPORTS_PATH2D = function () {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}();\n\nfunction QRCodeCanvas(props) {\n  var _canvas = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])(null);\n\n  var _image = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])(null);\n\n  function update() {\n    var value2 = props.value,\n        size2 = props.size,\n        level2 = props.level,\n        bgColor2 = props.bgColor,\n        fgColor2 = props.fgColor,\n        includeMargin2 = props.includeMargin;\n\n    if (_canvas.current != null) {\n      var canvas = _canvas.current;\n      var ctx = canvas.getContext("2d");\n\n      if (!ctx) {\n        return;\n      }\n\n      var cells = qrcodegen_default.QrCode.encodeText(value2, ERROR_LEVEL_MAP[level2]).getModules();\n      var margin = includeMargin2 ? MARGIN_SIZE : 0;\n      var numCells = cells.length + margin * 2;\n      var calculatedImageSettings = getImageSettings(props, cells);\n      var image = _image.current;\n      var haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n\n      if (haveImageToRender) {\n        if (calculatedImageSettings.excavation != null) {\n          cells = excavateModules(cells, calculatedImageSettings.excavation);\n        }\n      }\n\n      var pixelRatio = window.devicePixelRatio || 1;\n      canvas.height = canvas.width = size2 * pixelRatio;\n      var scale = size2 / numCells * pixelRatio;\n      ctx.scale(scale, scale);\n      ctx.fillStyle = bgColor2;\n      ctx.fillRect(0, 0, numCells, numCells);\n      ctx.fillStyle = fgColor2;\n\n      if (SUPPORTS_PATH2D) {\n        ctx.fill(new Path2D(generatePath(cells, margin)));\n      } else {\n        cells.forEach(function (row, rdx) {\n          row.forEach(function (cell, cdx) {\n            if (cell) {\n              ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n            }\n          });\n        });\n      }\n\n      if (haveImageToRender) {\n        ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n      }\n    }\n  }\n\n  Object(react__WEBPACK_IMPORTED_MODULE_3__["useEffect"])(function () {\n    update();\n  });\n\n  var _a = props,\n      value = _a.value,\n      size = _a.size,\n      level = _a.level,\n      bgColor = _a.bgColor,\n      fgColor = _a.fgColor,\n      style = _a.style,\n      includeMargin = _a.includeMargin,\n      imageSettings = _a.imageSettings,\n      otherProps = __objRest(_a, ["value", "size", "level", "bgColor", "fgColor", "style", "includeMargin", "imageSettings"]);\n\n  var canvasStyle = __spreadValues({\n    height: size,\n    width: size\n  }, style);\n\n  var img = null;\n  var imgSrc = imageSettings == null ? void 0 : imageSettings.src;\n\n  if (imgSrc != null) {\n    img = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("img", {\n      src: imgSrc,\n      key: imgSrc,\n      style: {\n        display: "none"\n      },\n      onLoad: function onLoad() {\n        update();\n      },\n      ref: _image\n    });\n  }\n\n  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_3___default.a.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("canvas", __spreadValues({\n    style: canvasStyle,\n    height: size,\n    width: size,\n    ref: _canvas\n  }, otherProps)), img);\n}\n\nQRCodeCanvas.defaultProps = DEFAULT_PROPS;\n\nfunction QRCodeSVG(props) {\n  var _a = props,\n      value = _a.value,\n      size = _a.size,\n      level = _a.level,\n      bgColor = _a.bgColor,\n      fgColor = _a.fgColor,\n      includeMargin = _a.includeMargin,\n      imageSettings = _a.imageSettings,\n      otherProps = __objRest(_a, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"]);\n\n  var cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n  var margin = includeMargin ? MARGIN_SIZE : 0;\n  var numCells = cells.length + margin * 2;\n  var calculatedImageSettings = getImageSettings(props, cells);\n  var image = null;\n\n  if (imageSettings != null && calculatedImageSettings != null) {\n    if (calculatedImageSettings.excavation != null) {\n      cells = excavateModules(cells, calculatedImageSettings.excavation);\n    }\n\n    image = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("image", {\n      xlinkHref: imageSettings.src,\n      height: calculatedImageSettings.h,\n      width: calculatedImageSettings.w,\n      x: calculatedImageSettings.x + margin,\n      y: calculatedImageSettings.y + margin,\n      preserveAspectRatio: "none"\n    });\n  }\n\n  var fgPath = generatePath(cells, margin);\n  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("svg", __spreadValues({\n    shapeRendering: "crispEdges",\n    height: size,\n    width: size,\n    viewBox: "0 0 ".concat(numCells, " ").concat(numCells)\n  }, otherProps), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("path", {\n    fill: bgColor,\n    d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z")\n  }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("path", {\n    fill: fgColor,\n    d: fgPath\n  }), image);\n}\n\nQRCodeSVG.defaultProps = DEFAULT_PROPS;\n\nvar QRCode = function QRCode(props) {\n  var _a = props,\n      renderAs = _a.renderAs,\n      otherProps = __objRest(_a, ["renderAs"]);\n\n  if (renderAs === "svg") {\n    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(QRCodeSVG, __spreadValues({}, otherProps));\n  }\n\n  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(QRCodeCanvas, __spreadValues({}, otherProps));\n};\n\nQRCode.defaultProps = __spreadValues({\n  renderAs: "canvas"\n}, DEFAULT_PROPS);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXJjb2RlLnJlYWN0L2xpYi9lc20vaW5kZXguanM/NWIxYiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fcHJvcElzRW51bSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3NwcmVhZFZhbHVlcyIsImEiLCJiIiwicHJvcCIsImNhbGwiLCJfX29ialJlc3QiLCJzb3VyY2UiLCJleGNsdWRlIiwidGFyZ2V0IiwiaW5kZXhPZiIsInFyY29kZWdlbiIsInFyY29kZWdlbjIiLCJfUXJDb2RlIiwidmVyc2lvbiIsImVycm9yQ29ycmVjdGlvbkxldmVsIiwiZGF0YUNvZGV3b3JkcyIsIm1zayIsIm1vZHVsZXMiLCJpc0Z1bmN0aW9uIiwiTUlOX1ZFUlNJT04iLCJNQVhfVkVSU0lPTiIsIlJhbmdlRXJyb3IiLCJzaXplIiwicm93IiwiaSIsInB1c2giLCJzbGljZSIsImRyYXdGdW5jdGlvblBhdHRlcm5zIiwiYWxsQ29kZXdvcmRzIiwiYWRkRWNjQW5kSW50ZXJsZWF2ZSIsImRyYXdDb2Rld29yZHMiLCJtaW5QZW5hbHR5IiwiYXBwbHlNYXNrIiwiZHJhd0Zvcm1hdEJpdHMiLCJwZW5hbHR5IiwiZ2V0UGVuYWx0eVNjb3JlIiwiYXNzZXJ0IiwibWFzayIsIngiLCJ5Iiwic2V0RnVuY3Rpb25Nb2R1bGUiLCJkcmF3RmluZGVyUGF0dGVybiIsImFsaWduUGF0UG9zIiwiZ2V0QWxpZ25tZW50UGF0dGVyblBvc2l0aW9ucyIsIm51bUFsaWduIiwibGVuZ3RoIiwiaiIsImRyYXdBbGlnbm1lbnRQYXR0ZXJuIiwiZHJhd1ZlcnNpb24iLCJkYXRhIiwiZm9ybWF0Qml0cyIsInJlbSIsImJpdHMiLCJnZXRCaXQiLCJjb2xvciIsIk1hdGgiLCJmbG9vciIsImR5IiwiZHgiLCJkaXN0IiwibWF4IiwiYWJzIiwieHgiLCJ5eSIsImlzRGFyayIsInZlciIsImVjbCIsImdldE51bURhdGFDb2Rld29yZHMiLCJudW1CbG9ja3MiLCJOVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1MiLCJvcmRpbmFsIiwiYmxvY2tFY2NMZW4iLCJFQ0NfQ09ERVdPUkRTX1BFUl9CTE9DSyIsInJhd0NvZGV3b3JkcyIsImdldE51bVJhd0RhdGFNb2R1bGVzIiwibnVtU2hvcnRCbG9ja3MiLCJzaG9ydEJsb2NrTGVuIiwiYmxvY2tzIiwicnNEaXYiLCJyZWVkU29sb21vbkNvbXB1dGVEaXZpc29yIiwiayIsImRhdCIsImVjYyIsInJlZWRTb2xvbW9uQ29tcHV0ZVJlbWFpbmRlciIsImNvbmNhdCIsInJlc3VsdCIsImZvckVhY2giLCJibG9jayIsInJpZ2h0IiwidmVydCIsInVwd2FyZCIsImludmVydCIsIkVycm9yIiwicnVuQ29sb3IiLCJydW5YIiwicnVuSGlzdG9yeSIsIlBFTkFMVFlfTjEiLCJmaW5kZXJQZW5hbHR5QWRkSGlzdG9yeSIsImZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zIiwiUEVOQUxUWV9OMyIsImZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudCIsInJ1blkiLCJQRU5BTFRZX04yIiwiZGFyayIsInJlZHVjZSIsInN1bSIsInRvdGFsIiwiY2VpbCIsIlBFTkFMVFlfTjQiLCJzdGVwIiwicG9zIiwic3BsaWNlIiwibiIsImNvcmUiLCJjdXJyZW50UnVuQ29sb3IiLCJjdXJyZW50UnVuTGVuZ3RoIiwicG9wIiwidW5zaGlmdCIsInRleHQiLCJzZWdzIiwiUXJTZWdtZW50IiwibWFrZVNlZ21lbnRzIiwiZW5jb2RlU2VnbWVudHMiLCJzZWciLCJtYWtlQnl0ZXMiLCJtaW5WZXJzaW9uIiwibWF4VmVyc2lvbiIsImJvb3N0RWNsIiwiZGF0YVVzZWRCaXRzIiwiZGF0YUNhcGFjaXR5Qml0czIiLCJ1c2VkQml0cyIsImdldFRvdGFsQml0cyIsIkVjYyIsIk1FRElVTSIsIlFVQVJUSUxFIiwiSElHSCIsIm5ld0VjbCIsImJiIiwiYXBwZW5kQml0cyIsIm1vZGUiLCJtb2RlQml0cyIsIm51bUNoYXJzIiwibnVtQ2hhckNvdW50Qml0cyIsImdldERhdGEiLCJkYXRhQ2FwYWNpdHlCaXRzIiwibWluIiwicGFkQnl0ZSIsImRlZ3JlZSIsInJvb3QiLCJyZWVkU29sb21vbk11bHRpcGx5IiwiZGl2aXNvciIsIm1hcCIsIl8iLCJmYWN0b3IiLCJzaGlmdCIsImNvZWYiLCJ6IiwiUXJDb2RlIiwidmFsIiwibGVuIiwiY29uZCIsIl9RclNlZ21lbnQiLCJiaXREYXRhIiwiTW9kZSIsIkJZVEUiLCJkaWdpdHMiLCJpc051bWVyaWMiLCJwYXJzZUludCIsInN1YnN0ciIsIk5VTUVSSUMiLCJpc0FscGhhbnVtZXJpYyIsInRlbXAiLCJBTFBIQU5VTUVSSUNfQ0hBUlNFVCIsImNoYXJBdCIsIkFMUEhBTlVNRVJJQyIsIm1ha2VOdW1lcmljIiwibWFrZUFscGhhbnVtZXJpYyIsInRvVXRmOEJ5dGVBcnJheSIsImFzc2lnblZhbCIsIkVDSSIsIk5VTUVSSUNfUkVHRVgiLCJ0ZXN0IiwiQUxQSEFOVU1FUklDX1JFR0VYIiwiY2NiaXRzIiwiSW5maW5pdHkiLCJzdHIiLCJlbmNvZGVVUkkiLCJjaGFyQ29kZUF0IiwiUXJDb2RlMiIsIl9FY2MiLCJMT1ciLCJRclNlZ21lbnQyIiwiX01vZGUiLCJudW1CaXRzQ2hhckNvdW50IiwiS0FOSkkiLCJxcmNvZGVnZW5fZGVmYXVsdCIsIkVSUk9SX0xFVkVMX01BUCIsIkwiLCJNIiwiUSIsIkgiLCJERUZBVUxUX1BST1BTIiwibGV2ZWwiLCJiZ0NvbG9yIiwiZmdDb2xvciIsImluY2x1ZGVNYXJnaW4iLCJNQVJHSU5fU0laRSIsIkRFRkFVTFRfSU1HX1NDQUxFIiwiZ2VuZXJhdGVQYXRoIiwibWFyZ2luIiwib3BzIiwic3RhcnQiLCJjZWxsIiwiam9pbiIsImV4Y2F2YXRlTW9kdWxlcyIsImV4Y2F2YXRpb24iLCJoIiwidyIsImdldEltYWdlU2V0dGluZ3MiLCJwcm9wcyIsImNlbGxzIiwiaW1hZ2VTZXR0aW5ncyIsIm51bUNlbGxzIiwiZGVmYXVsdFNpemUiLCJzY2FsZSIsIndpZHRoIiwiaGVpZ2h0IiwiZXhjYXZhdGUiLCJmbG9vclgiLCJmbG9vclkiLCJjZWlsVyIsImNlaWxIIiwiU1VQUE9SVFNfUEFUSDJEIiwiUGF0aDJEIiwiYWRkUGF0aCIsImUiLCJRUkNvZGVDYW52YXMiLCJfY2FudmFzIiwidXNlUmVmIiwiX2ltYWdlIiwidXBkYXRlIiwidmFsdWUyIiwic2l6ZTIiLCJsZXZlbDIiLCJiZ0NvbG9yMiIsImZnQ29sb3IyIiwiaW5jbHVkZU1hcmdpbjIiLCJjdXJyZW50IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImVuY29kZVRleHQiLCJnZXRNb2R1bGVzIiwiY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MiLCJpbWFnZSIsImhhdmVJbWFnZVRvUmVuZGVyIiwiY29tcGxldGUiLCJuYXR1cmFsSGVpZ2h0IiwibmF0dXJhbFdpZHRoIiwicGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImZpbGwiLCJyZHgiLCJjZHgiLCJkcmF3SW1hZ2UiLCJ1c2VFZmZlY3QiLCJfYSIsInN0eWxlIiwib3RoZXJQcm9wcyIsImNhbnZhc1N0eWxlIiwiaW1nIiwiaW1nU3JjIiwic3JjIiwiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwiZGlzcGxheSIsIm9uTG9hZCIsInJlZiIsIkZyYWdtZW50IiwiZGVmYXVsdFByb3BzIiwiUVJDb2RlU1ZHIiwieGxpbmtIcmVmIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsImZnUGF0aCIsInNoYXBlUmVuZGVyaW5nIiwidmlld0JveCIsImQiLCJRUkNvZGUiLCJyZW5kZXJBcyJdLCJt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RUFBeUcsRUFBekcsRUFBNkcsRUFBN0csRUFBaUgsRUFBakgsRUFBcUgsRUFBckgsRUFBeUgsRUFBekgsRUFBNkgsRUFBN0gsRUFBaUksRUFBakksRUFBcUksRUFBckksRUFBeUksRUFBekksRUFBNkksRUFBN0ksRUFBaUosRUFBakosRUFBcUosRUFBckosRUFBeUosRUFBekosRUFBNkosRUFBN0osRUFBaUssRUFBakssQ0FGK0IsRUFHL0IsQ0FBQyxDQUFDLENBQUYsRUFBSyxFQUFMLEVBQVMsRUFBVCxFQUFhLEVBQWIsRUFBaUIsRUFBakIsRUFBcUIsRUFBckIsRUFBeUIsRUFBekIsRUFBNkIsRUFBN0IsRUFBaUMsRUFBakMsRUFBcUMsRUFBckMsRUFBeUMsRUFBekMsRUFBNkMsRUFBN0MsRUFBaUQsRUFBakQsRUFBcUQsRUFBckQsRUFBeUQsRUFBekQsRUFBNkQsRUFBN0QsRUFBaUUsRUFBakUsRUFBcUUsRUFBckUsRUFBeUUsRUFBekUsRUFBNkUsRUFBN0UsRUFBaUYsRUFBakYsRUFBcUYsRUFBckYsRUFBeUYsRUFBekYsRUFBNkYsRUFBN0YsRUFBaUcsRUFBakcsRUFBcUcsRUFBckcsRUFBeUcsRUFBekcsRUFBNkcsRUFBN0csRUFBaUgsRUFBakgsRUFBcUgsRUFBckgsRUFBeUgsRUFBekgsRUFBNkgsRUFBN0gsRUFBaUksRUFBakksRUFBcUksRUFBckksRUFBeUksRUFBekksRUFBNkksRUFBN0ksRUFBaUosRUFBakosRUFBcUosRUFBckosRUFBeUosRUFBekosRUFBNkosRUFBN0osRUFBaUssRUFBakssQ0FIK0IsRUFJL0IsQ0FBQyxDQUFDLENBQUYsRUFBSyxFQUFMLEVBQVMsRUFBVCxFQUFhLEVBQWIsRUFBaUIsRUFBakIsRUFBcUIsRUFBckIsRUFBeUIsRUFBekIsRUFBNkIsRUFBN0IsRUFBaUMsRUFBakMsRUFBcUMsRUFBckMsRUFBeUMsRUFBekMsRUFBNkMsRUFBN0MsRUFBaUQsRUFBakQsRUFBcUQsRUFBckQsRUFBeUQsRUFBekQsRUFBNkQsRUFBN0QsRUFBaUUsRUFBakUsRUFBcUUs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QWMsQ0FBQztBQUFFbVMsVUFBUSxFQUFFO0FBQVosQ0FBRCxFQUF5QjFGLGFBQXpCLENBQXBDIiwiZmlsZSI6Ild4dm8uanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLy8gc3JjL2luZGV4LnRzeFxuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy90aGlyZC1wYXJ0eS9xcmNvZGVnZW4vaW5kZXgudHNcbi8qKlxuICogQGxpY2Vuc2UgUVIgQ29kZSBnZW5lcmF0b3IgbGlicmFyeSAoVHlwZVNjcmlwdClcbiAqIENvcHlyaWdodCAoYykgUHJvamVjdCBOYXl1a2kuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4gKi9cbnZhciBxcmNvZGVnZW47XG4oKHFyY29kZWdlbjIpID0+IHtcbiAgY29uc3QgX1FyQ29kZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgZGF0YUNvZGV3b3JkcywgbXNrKSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9IGVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgICAgdGhpcy5tb2R1bGVzID0gW107XG4gICAgICB0aGlzLmlzRnVuY3Rpb24gPSBbXTtcbiAgICAgIGlmICh2ZXJzaW9uIDwgX1FyQ29kZS5NSU5fVkVSU0lPTiB8fCB2ZXJzaW9uID4gX1FyQ29kZS5NQVhfVkVSU0lPTilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJWZXJzaW9uIHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGlmIChtc2sgPCAtMSB8fCBtc2sgPiA3KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hc2sgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgdGhpcy5zaXplID0gdmVyc2lvbiAqIDQgKyAxNztcbiAgICAgIGxldCByb3cgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspXG4gICAgICAgIHJvdy5wdXNoKGZhbHNlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzLnB1c2gocm93LnNsaWNlKCkpO1xuICAgICAgICB0aGlzLmlzRnVuY3Rpb24ucHVzaChyb3cuc2xpY2UoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdGdW5jdGlvblBhdHRlcm5zKCk7XG4gICAgICBjb25zdCBhbGxDb2Rld29yZHMgPSB0aGlzLmFkZEVjY0FuZEludGVybGVhdmUoZGF0YUNvZGV3b3Jkcyk7XG4gICAgICB0aGlzLmRyYXdDb2Rld29yZHMoYWxsQ29kZXdvcmRzKTtcbiAgICAgIGlmIChtc2sgPT0gLTEpIHtcbiAgICAgICAgbGV0IG1pblBlbmFsdHkgPSAxZTk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hcHBseU1hc2soaSk7XG4gICAgICAgICAgdGhpcy5kcmF3Rm9ybWF0Qml0cyhpKTtcbiAgICAgICAgICBjb25zdCBwZW5hbHR5ID0gdGhpcy5nZXRQZW5hbHR5U2NvcmUoKTtcbiAgICAgICAgICBpZiAocGVuYWx0eSA8IG1pblBlbmFsdHkpIHtcbiAgICAgICAgICAgIG1zayA9IGk7XG4gICAgICAgICAgICBtaW5QZW5hbHR5ID0gcGVuYWx0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hcHBseU1hc2soaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzc2VydCgwIDw9IG1zayAmJiBtc2sgPD0gNyk7XG4gICAgICB0aGlzLm1hc2sgPSBtc2s7XG4gICAgICB0aGlzLmFwcGx5TWFzayhtc2spO1xuICAgICAgdGhpcy5kcmF3Rm9ybWF0Qml0cyhtc2spO1xuICAgICAgdGhpcy5pc0Z1bmN0aW9uID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVUZXh0KHRleHQsIGVjbCkge1xuICAgICAgY29uc3Qgc2VncyA9IHFyY29kZWdlbjIuUXJTZWdtZW50Lm1ha2VTZWdtZW50cyh0ZXh0KTtcbiAgICAgIHJldHVybiBfUXJDb2RlLmVuY29kZVNlZ21lbnRzKHNlZ3MsIGVjbCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVCaW5hcnkoZGF0YSwgZWNsKSB7XG4gICAgICBjb25zdCBzZWcgPSBxcmNvZGVnZW4yLlFyU2VnbWVudC5tYWtlQnl0ZXMoZGF0YSk7XG4gICAgICByZXR1cm4gX1FyQ29kZS5lbmNvZGVTZWdtZW50cyhbc2VnXSwgZWNsKTtcbiAgICB9XG4gICAgc3RhdGljIGVuY29kZVNlZ21lbnRzKHNlZ3MsIGVjbCwgbWluVmVyc2lvbiA9IDEsIG1heFZlcnNpb24gPSA0MCwgbWFzayA9IC0xLCBib29zdEVjbCA9IHRydWUpIHtcbiAgICAgIGlmICghKF9RckNvZGUuTUlOX1ZFUlNJT04gPD0gbWluVmVyc2lvbiAmJiBtaW5WZXJzaW9uIDw9IG1heFZlcnNpb24gJiYgbWF4VmVyc2lvbiA8PSBfUXJDb2RlLk1BWF9WRVJTSU9OKSB8fCBtYXNrIDwgLTEgfHwgbWFzayA+IDcpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB2YWx1ZVwiKTtcbiAgICAgIGxldCB2ZXJzaW9uO1xuICAgICAgbGV0IGRhdGFVc2VkQml0cztcbiAgICAgIGZvciAodmVyc2lvbiA9IG1pblZlcnNpb247IDsgdmVyc2lvbisrKSB7XG4gICAgICAgIGNvbnN0IGRhdGFDYXBhY2l0eUJpdHMyID0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIGVjbCkgKiA4O1xuICAgICAgICBjb25zdCB1c2VkQml0cyA9IFFyU2VnbWVudC5nZXRUb3RhbEJpdHMoc2VncywgdmVyc2lvbik7XG4gICAgICAgIGlmICh1c2VkQml0cyA8PSBkYXRhQ2FwYWNpdHlCaXRzMikge1xuICAgICAgICAgIGRhdGFVc2VkQml0cyA9IHVzZWRCaXRzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uID49IG1heFZlcnNpb24pXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRhIHRvbyBsb25nXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuZXdFY2wgb2YgW19RckNvZGUuRWNjLk1FRElVTSwgX1FyQ29kZS5FY2MuUVVBUlRJTEUsIF9RckNvZGUuRWNjLkhJR0hdKSB7XG4gICAgICAgIGlmIChib29zdEVjbCAmJiBkYXRhVXNlZEJpdHMgPD0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIG5ld0VjbCkgKiA4KVxuICAgICAgICAgIGVjbCA9IG5ld0VjbDtcbiAgICAgIH1cbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBhcHBlbmRCaXRzKHNlZy5tb2RlLm1vZGVCaXRzLCA0LCBiYik7XG4gICAgICAgIGFwcGVuZEJpdHMoc2VnLm51bUNoYXJzLCBzZWcubW9kZS5udW1DaGFyQ291bnRCaXRzKHZlcnNpb24pLCBiYik7XG4gICAgICAgIGZvciAoY29uc3QgYiBvZiBzZWcuZ2V0RGF0YSgpKVxuICAgICAgICAgIGJiLnB1c2goYik7XG4gICAgICB9XG4gICAgICBhc3NlcnQoYmIubGVuZ3RoID09IGRhdGFVc2VkQml0cyk7XG4gICAgICBjb25zdCBkYXRhQ2FwYWNpdHlCaXRzID0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIGVjbCkgKiA4O1xuICAgICAgYXNzZXJ0KGJiLmxlbmd0aCA8PSBkYXRhQ2FwYWNpdHlCaXRzKTtcbiAgICAgIGFwcGVuZEJpdHMoMCwgTWF0aC5taW4oNCwgZGF0YUNhcGFjaXR5Qml0cyAtIGJiLmxlbmd0aCksIGJiKTtcbiAgICAgIGFwcGVuZEJpdHMoMCwgKDggLSBiYi5sZW5ndGggJSA4KSAlIDgsIGJiKTtcbiAgICAgIGFzc2VydChiYi5sZW5ndGggJSA4ID09IDApO1xuICAgICAgZm9yIChsZXQgcGFkQnl0ZSA9IDIzNjsgYmIubGVuZ3RoIDwgZGF0YUNhcGFjaXR5Qml0czsgcGFkQnl0ZSBePSAyMzYgXiAxNylcbiAgICAgICAgYXBwZW5kQml0cyhwYWRCeXRlLCA4LCBiYik7XG4gICAgICBsZXQgZGF0YUNvZGV3b3JkcyA9IFtdO1xuICAgICAgd2hpbGUgKGRhdGFDb2Rld29yZHMubGVuZ3RoICogOCA8IGJiLmxlbmd0aClcbiAgICAgICAgZGF0YUNvZGV3b3Jkcy5wdXNoKDApO1xuICAgICAgYmIuZm9yRWFjaCgoYiwgaSkgPT4gZGF0YUNvZGV3b3Jkc1tpID4+PiAzXSB8PSBiIDw8IDcgLSAoaSAmIDcpKTtcbiAgICAgIHJldHVybiBuZXcgX1FyQ29kZSh2ZXJzaW9uLCBlY2wsIGRhdGFDb2Rld29yZHMsIG1hc2spO1xuICAgIH1cbiAgICBnZXRNb2R1bGUoeCwgeSkge1xuICAgICAgcmV0dXJuIDAgPD0geCAmJiB4IDwgdGhpcy5zaXplICYmIDAgPD0geSAmJiB5IDwgdGhpcy5zaXplICYmIHRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICB9XG4gICAgZ2V0TW9kdWxlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZXM7XG4gICAgfVxuICAgIGRyYXdGdW5jdGlvblBhdHRlcm5zKCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDYsIGksIGkgJSAyID09IDApO1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKGksIDYsIGkgJSAyID09IDApO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3RmluZGVyUGF0dGVybigzLCAzKTtcbiAgICAgIHRoaXMuZHJhd0ZpbmRlclBhdHRlcm4odGhpcy5zaXplIC0gNCwgMyk7XG4gICAgICB0aGlzLmRyYXdGaW5kZXJQYXR0ZXJuKDMsIHRoaXMuc2l6ZSAtIDQpO1xuICAgICAgY29uc3QgYWxpZ25QYXRQb3MgPSB0aGlzLmdldEFsaWdubWVudFBhdHRlcm5Qb3NpdGlvbnMoKTtcbiAgICAgIGNvbnN0IG51bUFsaWduID0gYWxpZ25QYXRQb3MubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BbGlnbjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQWxpZ247IGorKykge1xuICAgICAgICAgIGlmICghKGkgPT0gMCAmJiBqID09IDAgfHwgaSA9PSAwICYmIGogPT0gbnVtQWxpZ24gLSAxIHx8IGkgPT0gbnVtQWxpZ24gLSAxICYmIGogPT0gMCkpXG4gICAgICAgICAgICB0aGlzLmRyYXdBbGlnbm1lbnRQYXR0ZXJuKGFsaWduUGF0UG9zW2ldLCBhbGlnblBhdFBvc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMoMCk7XG4gICAgICB0aGlzLmRyYXdWZXJzaW9uKCk7XG4gICAgfVxuICAgIGRyYXdGb3JtYXRCaXRzKG1hc2spIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsLmZvcm1hdEJpdHMgPDwgMyB8IG1hc2s7XG4gICAgICBsZXQgcmVtID0gZGF0YTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKylcbiAgICAgICAgcmVtID0gcmVtIDw8IDEgXiAocmVtID4+PiA5KSAqIDEzMzU7XG4gICAgICBjb25zdCBiaXRzID0gKGRhdGEgPDwgMTAgfCByZW0pIF4gMjE1MjI7XG4gICAgICBhc3NlcnQoYml0cyA+Pj4gMTUgPT0gMCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSA1OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgaSwgZ2V0Qml0KGJpdHMsIGkpKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgNywgZ2V0Qml0KGJpdHMsIDYpKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgOCwgZ2V0Qml0KGJpdHMsIDcpKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoNywgOCwgZ2V0Qml0KGJpdHMsIDgpKTtcbiAgICAgIGZvciAobGV0IGkgPSA5OyBpIDwgMTU7IGkrKylcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSgxNCAtIGksIDgsIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKylcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh0aGlzLnNpemUgLSAxIC0gaSwgOCwgZ2V0Qml0KGJpdHMsIGkpKTtcbiAgICAgIGZvciAobGV0IGkgPSA4OyBpIDwgMTU7IGkrKylcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCB0aGlzLnNpemUgLSAxNSArIGksIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIHRoaXMuc2l6ZSAtIDgsIHRydWUpO1xuICAgIH1cbiAgICBkcmF3VmVyc2lvbigpIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPCA3KVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgcmVtID0gdGhpcy52ZXJzaW9uO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKVxuICAgICAgICByZW0gPSByZW0gPDwgMSBeIChyZW0gPj4+IDExKSAqIDc5NzM7XG4gICAgICBjb25zdCBiaXRzID0gdGhpcy52ZXJzaW9uIDw8IDEyIHwgcmVtO1xuICAgICAgYXNzZXJ0KGJpdHMgPj4+IDE4ID09IDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxODsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Qml0KGJpdHMsIGkpO1xuICAgICAgICBjb25zdCBhID0gdGhpcy5zaXplIC0gMTEgKyBpICUgMztcbiAgICAgICAgY29uc3QgYiA9IE1hdGguZmxvb3IoaSAvIDMpO1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKGEsIGIsIGNvbG9yKTtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShiLCBhLCBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGRyYXdGaW5kZXJQYXR0ZXJuKHgsIHkpIHtcbiAgICAgIGZvciAobGV0IGR5ID0gLTQ7IGR5IDw9IDQ7IGR5KyspIHtcbiAgICAgICAgZm9yIChsZXQgZHggPSAtNDsgZHggPD0gNDsgZHgrKykge1xuICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSk7XG4gICAgICAgICAgY29uc3QgeHggPSB4ICsgZHg7XG4gICAgICAgICAgY29uc3QgeXkgPSB5ICsgZHk7XG4gICAgICAgICAgaWYgKDAgPD0geHggJiYgeHggPCB0aGlzLnNpemUgJiYgMCA8PSB5eSAmJiB5eSA8IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoeHgsIHl5LCBkaXN0ICE9IDIgJiYgZGlzdCAhPSA0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkcmF3QWxpZ25tZW50UGF0dGVybih4LCB5KSB7XG4gICAgICBmb3IgKGxldCBkeSA9IC0yOyBkeSA8PSAyOyBkeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGR4ID0gLTI7IGR4IDw9IDI7IGR4KyspXG4gICAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh4ICsgZHgsIHkgKyBkeSwgTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpICE9IDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRGdW5jdGlvbk1vZHVsZSh4LCB5LCBpc0RhcmspIHtcbiAgICAgIHRoaXMubW9kdWxlc1t5XVt4XSA9IGlzRGFyaztcbiAgICAgIHRoaXMuaXNGdW5jdGlvblt5XVt4XSA9IHRydWU7XG4gICAgfVxuICAgIGFkZEVjY0FuZEludGVybGVhdmUoZGF0YSkge1xuICAgICAgY29uc3QgdmVyID0gdGhpcy52ZXJzaW9uO1xuICAgICAgY29uc3QgZWNsID0gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPSBfUXJDb2RlLmdldE51bURhdGFDb2Rld29yZHModmVyLCBlY2wpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gICAgICBjb25zdCBudW1CbG9ja3MgPSBfUXJDb2RlLk5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLU1tlY2wub3JkaW5hbF1bdmVyXTtcbiAgICAgIGNvbnN0IGJsb2NrRWNjTGVuID0gX1FyQ29kZS5FQ0NfQ09ERVdPUkRTX1BFUl9CTE9DS1tlY2wub3JkaW5hbF1bdmVyXTtcbiAgICAgIGNvbnN0IHJhd0NvZGV3b3JkcyA9IE1hdGguZmxvb3IoX1FyQ29kZS5nZXROdW1SYXdEYXRhTW9kdWxlcyh2ZXIpIC8gOCk7XG4gICAgICBjb25zdCBudW1TaG9ydEJsb2NrcyA9IG51bUJsb2NrcyAtIHJhd0NvZGV3b3JkcyAlIG51bUJsb2NrcztcbiAgICAgIGNvbnN0IHNob3J0QmxvY2tMZW4gPSBNYXRoLmZsb29yKHJhd0NvZGV3b3JkcyAvIG51bUJsb2Nrcyk7XG4gICAgICBsZXQgYmxvY2tzID0gW107XG4gICAgICBjb25zdCByc0RpdiA9IF9RckNvZGUucmVlZFNvbG9tb25Db21wdXRlRGl2aXNvcihibG9ja0VjY0xlbik7XG4gICAgICBmb3IgKGxldCBpID0gMCwgayA9IDA7IGkgPCBudW1CbG9ja3M7IGkrKykge1xuICAgICAgICBsZXQgZGF0ID0gZGF0YS5zbGljZShrLCBrICsgc2hvcnRCbG9ja0xlbiAtIGJsb2NrRWNjTGVuICsgKGkgPCBudW1TaG9ydEJsb2NrcyA/IDAgOiAxKSk7XG4gICAgICAgIGsgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgZWNjID0gX1FyQ29kZS5yZWVkU29sb21vbkNvbXB1dGVSZW1haW5kZXIoZGF0LCByc0Rpdik7XG4gICAgICAgIGlmIChpIDwgbnVtU2hvcnRCbG9ja3MpXG4gICAgICAgICAgZGF0LnB1c2goMCk7XG4gICAgICAgIGJsb2Nrcy5wdXNoKGRhdC5jb25jYXQoZWNjKSk7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2Nrc1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGopID0+IHtcbiAgICAgICAgICBpZiAoaSAhPSBzaG9ydEJsb2NrTGVuIC0gYmxvY2tFY2NMZW4gfHwgaiA+PSBudW1TaG9ydEJsb2NrcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJsb2NrW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhc3NlcnQocmVzdWx0Lmxlbmd0aCA9PSByYXdDb2Rld29yZHMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZHJhd0NvZGV3b3JkcyhkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggIT0gTWF0aC5mbG9vcihfUXJDb2RlLmdldE51bVJhd0RhdGFNb2R1bGVzKHRoaXMudmVyc2lvbikgLyA4KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgcmlnaHQgPSB0aGlzLnNpemUgLSAxOyByaWdodCA+PSAxOyByaWdodCAtPSAyKSB7XG4gICAgICAgIGlmIChyaWdodCA9PSA2KVxuICAgICAgICAgIHJpZ2h0ID0gNTtcbiAgICAgICAgZm9yIChsZXQgdmVydCA9IDA7IHZlcnQgPCB0aGlzLnNpemU7IHZlcnQrKykge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gcmlnaHQgLSBqO1xuICAgICAgICAgICAgY29uc3QgdXB3YXJkID0gKHJpZ2h0ICsgMSAmIDIpID09IDA7XG4gICAgICAgICAgICBjb25zdCB5ID0gdXB3YXJkID8gdGhpcy5zaXplIC0gMSAtIHZlcnQgOiB2ZXJ0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRnVuY3Rpb25beV1beF0gJiYgaSA8IGRhdGEubGVuZ3RoICogOCkge1xuICAgICAgICAgICAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSBnZXRCaXQoZGF0YVtpID4+PiAzXSwgNyAtIChpICYgNykpO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA9PSBkYXRhLmxlbmd0aCAqIDgpO1xuICAgIH1cbiAgICBhcHBseU1hc2sobWFzaykge1xuICAgICAgaWYgKG1hc2sgPCAwIHx8IG1hc2sgPiA3KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hc2sgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgICAgbGV0IGludmVydDtcbiAgICAgICAgICBzd2l0Y2ggKG1hc2spIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKyB5KSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGludmVydCA9IHkgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBpbnZlcnQgPSB4ICUgMyA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKyB5KSAlIDMgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGludmVydCA9IChNYXRoLmZsb29yKHggLyAzKSArIE1hdGguZmxvb3IoeSAvIDIpKSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGludmVydCA9IHggKiB5ICUgMiArIHggKiB5ICUgMyA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKiB5ICUgMiArIHggKiB5ICUgMykgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBpbnZlcnQgPSAoKHggKyB5KSAlIDIgKyB4ICogeSAlIDMpICUgMiA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuaXNGdW5jdGlvblt5XVt4XSAmJiBpbnZlcnQpXG4gICAgICAgICAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSAhdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdldFBlbmFsdHlTY29yZSgpIHtcbiAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICBsZXQgcnVuQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJ1blggPSAwO1xuICAgICAgICBsZXQgcnVuSGlzdG9yeSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemU7IHgrKykge1xuICAgICAgICAgIGlmICh0aGlzLm1vZHVsZXNbeV1beF0gPT0gcnVuQ29sb3IpIHtcbiAgICAgICAgICAgIHJ1blgrKztcbiAgICAgICAgICAgIGlmIChydW5YID09IDUpXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBfUXJDb2RlLlBFTkFMVFlfTjE7XG4gICAgICAgICAgICBlbHNlIGlmIChydW5YID4gNSlcbiAgICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkocnVuWCwgcnVuSGlzdG9yeSk7XG4gICAgICAgICAgICBpZiAoIXJ1bkNvbG9yKVxuICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSAqIF9RckNvZGUuUEVOQUxUWV9OMztcbiAgICAgICAgICAgIHJ1bkNvbG9yID0gdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICAgICAgcnVuWCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChydW5Db2xvciwgcnVuWCwgcnVuSGlzdG9yeSkgKiBfUXJDb2RlLlBFTkFMVFlfTjM7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgIGxldCBydW5Db2xvciA9IGZhbHNlO1xuICAgICAgICBsZXQgcnVuWSA9IDA7XG4gICAgICAgIGxldCBydW5IaXN0b3J5ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZTsgeSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kdWxlc1t5XVt4XSA9PSBydW5Db2xvcikge1xuICAgICAgICAgICAgcnVuWSsrO1xuICAgICAgICAgICAgaWYgKHJ1blkgPT0gNSlcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IF9RckNvZGUuUEVOQUxUWV9OMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1blkgPiA1KVxuICAgICAgICAgICAgICByZXN1bHQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShydW5ZLCBydW5IaXN0b3J5KTtcbiAgICAgICAgICAgIGlmICghcnVuQ29sb3IpXG4gICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpICogX1FyQ29kZS5QRU5BTFRZX04zO1xuICAgICAgICAgICAgcnVuQ29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgICAgICBydW5ZID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMuZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KHJ1bkNvbG9yLCBydW5ZLCBydW5IaXN0b3J5KSAqIF9RckNvZGUuUEVOQUxUWV9OMztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplIC0gMTsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplIC0gMTsgeCsrKSB7XG4gICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgICAgaWYgKGNvbG9yID09IHRoaXMubW9kdWxlc1t5XVt4ICsgMV0gJiYgY29sb3IgPT0gdGhpcy5tb2R1bGVzW3kgKyAxXVt4XSAmJiBjb2xvciA9PSB0aGlzLm1vZHVsZXNbeSArIDFdW3ggKyAxXSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBfUXJDb2RlLlBFTkFMVFlfTjI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBkYXJrID0gMDtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRoaXMubW9kdWxlcylcbiAgICAgICAgZGFyayA9IHJvdy5yZWR1Y2UoKHN1bSwgY29sb3IpID0+IHN1bSArIChjb2xvciA/IDEgOiAwKSwgZGFyayk7XG4gICAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZTtcbiAgICAgIGNvbnN0IGsgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZGFyayAqIDIwIC0gdG90YWwgKiAxMCkgLyB0b3RhbCkgLSAxO1xuICAgICAgYXNzZXJ0KDAgPD0gayAmJiBrIDw9IDkpO1xuICAgICAgcmVzdWx0ICs9IGsgKiBfUXJDb2RlLlBFTkFMVFlfTjQ7XG4gICAgICBhc3NlcnQoMCA8PSByZXN1bHQgJiYgcmVzdWx0IDw9IDI1Njg4ODgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0QWxpZ25tZW50UGF0dGVyblBvc2l0aW9ucygpIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPT0gMSlcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG51bUFsaWduID0gTWF0aC5mbG9vcih0aGlzLnZlcnNpb24gLyA3KSArIDI7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnZlcnNpb24gPT0gMzIgPyAyNiA6IE1hdGguY2VpbCgodGhpcy52ZXJzaW9uICogNCArIDQpIC8gKG51bUFsaWduICogMiAtIDIpKSAqIDI7XG4gICAgICAgIGxldCByZXN1bHQgPSBbNl07XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuc2l6ZSAtIDc7IHJlc3VsdC5sZW5ndGggPCBudW1BbGlnbjsgcG9zIC09IHN0ZXApXG4gICAgICAgICAgcmVzdWx0LnNwbGljZSgxLCAwLCBwb3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSB7XG4gICAgICBpZiAodmVyIDwgX1FyQ29kZS5NSU5fVkVSU0lPTiB8fCB2ZXIgPiBfUXJDb2RlLk1BWF9WRVJTSU9OKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlZlcnNpb24gbnVtYmVyIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGxldCByZXN1bHQgPSAoMTYgKiB2ZXIgKyAxMjgpICogdmVyICsgNjQ7XG4gICAgICBpZiAodmVyID49IDIpIHtcbiAgICAgICAgY29uc3QgbnVtQWxpZ24gPSBNYXRoLmZsb29yKHZlciAvIDcpICsgMjtcbiAgICAgICAgcmVzdWx0IC09ICgyNSAqIG51bUFsaWduIC0gMTApICogbnVtQWxpZ24gLSA1NTtcbiAgICAgICAgaWYgKHZlciA+PSA3KVxuICAgICAgICAgIHJlc3VsdCAtPSAzNjtcbiAgICAgIH1cbiAgICAgIGFzc2VydCgyMDggPD0gcmVzdWx0ICYmIHJlc3VsdCA8PSAyOTY0OCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXIsIGVjbCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoX1FyQ29kZS5nZXROdW1SYXdEYXRhTW9kdWxlcyh2ZXIpIC8gOCkgLSBfUXJDb2RlLkVDQ19DT0RFV09SRFNfUEVSX0JMT0NLW2VjbC5vcmRpbmFsXVt2ZXJdICogX1FyQ29kZS5OVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1NbZWNsLm9yZGluYWxdW3Zlcl07XG4gICAgfVxuICAgIHN0YXRpYyByZWVkU29sb21vbkNvbXB1dGVEaXZpc29yKGRlZ3JlZSkge1xuICAgICAgaWYgKGRlZ3JlZSA8IDEgfHwgZGVncmVlID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRlZ3JlZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZSAtIDE7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICByZXN1bHQucHVzaCgxKTtcbiAgICAgIGxldCByb290ID0gMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVncmVlOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZXN1bHRbal0gPSBfUXJDb2RlLnJlZWRTb2xvbW9uTXVsdGlwbHkocmVzdWx0W2pdLCByb290KTtcbiAgICAgICAgICBpZiAoaiArIDEgPCByZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgcmVzdWx0W2pdIF49IHJlc3VsdFtqICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IF9RckNvZGUucmVlZFNvbG9tb25NdWx0aXBseShyb290LCAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyByZWVkU29sb21vbkNvbXB1dGVSZW1haW5kZXIoZGF0YSwgZGl2aXNvcikge1xuICAgICAgbGV0IHJlc3VsdCA9IGRpdmlzb3IubWFwKChfKSA9PiAwKTtcbiAgICAgIGZvciAoY29uc3QgYiBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IGIgXiByZXN1bHQuc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICAgIGRpdmlzb3IuZm9yRWFjaCgoY29lZiwgaSkgPT4gcmVzdWx0W2ldIF49IF9RckNvZGUucmVlZFNvbG9tb25NdWx0aXBseShjb2VmLCBmYWN0b3IpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyByZWVkU29sb21vbk11bHRpcGx5KHgsIHkpIHtcbiAgICAgIGlmICh4ID4+PiA4ICE9IDAgfHwgeSA+Pj4gOCAhPSAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ5dGUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgbGV0IHogPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDc7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHogPSB6IDw8IDEgXiAoeiA+Pj4gNykgKiAyODU7XG4gICAgICAgIHogXj0gKHkgPj4+IGkgJiAxKSAqIHg7XG4gICAgICB9XG4gICAgICBhc3NlcnQoeiA+Pj4gOCA9PSAwKTtcbiAgICAgIHJldHVybiB6O1xuICAgIH1cbiAgICBmaW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSB7XG4gICAgICBjb25zdCBuID0gcnVuSGlzdG9yeVsxXTtcbiAgICAgIGFzc2VydChuIDw9IHRoaXMuc2l6ZSAqIDMpO1xuICAgICAgY29uc3QgY29yZSA9IG4gPiAwICYmIHJ1bkhpc3RvcnlbMl0gPT0gbiAmJiBydW5IaXN0b3J5WzNdID09IG4gKiAzICYmIHJ1bkhpc3RvcnlbNF0gPT0gbiAmJiBydW5IaXN0b3J5WzVdID09IG47XG4gICAgICByZXR1cm4gKGNvcmUgJiYgcnVuSGlzdG9yeVswXSA+PSBuICogNCAmJiBydW5IaXN0b3J5WzZdID49IG4gPyAxIDogMCkgKyAoY29yZSAmJiBydW5IaXN0b3J5WzZdID49IG4gKiA0ICYmIHJ1bkhpc3RvcnlbMF0gPj0gbiA/IDEgOiAwKTtcbiAgICB9XG4gICAgZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KGN1cnJlbnRSdW5Db2xvciwgY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSkge1xuICAgICAgaWYgKGN1cnJlbnRSdW5Db2xvcikge1xuICAgICAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KGN1cnJlbnRSdW5MZW5ndGgsIHJ1bkhpc3RvcnkpO1xuICAgICAgICBjdXJyZW50UnVuTGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSdW5MZW5ndGggKz0gdGhpcy5zaXplO1xuICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpO1xuICAgIH1cbiAgICBmaW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KSB7XG4gICAgICBpZiAocnVuSGlzdG9yeVswXSA9PSAwKVxuICAgICAgICBjdXJyZW50UnVuTGVuZ3RoICs9IHRoaXMuc2l6ZTtcbiAgICAgIHJ1bkhpc3RvcnkucG9wKCk7XG4gICAgICBydW5IaXN0b3J5LnVuc2hpZnQoY3VycmVudFJ1bkxlbmd0aCk7XG4gICAgfVxuICB9O1xuICBsZXQgUXJDb2RlID0gX1FyQ29kZTtcbiAgUXJDb2RlLk1JTl9WRVJTSU9OID0gMTtcbiAgUXJDb2RlLk1BWF9WRVJTSU9OID0gNDA7XG4gIFFyQ29kZS5QRU5BTFRZX04xID0gMztcbiAgUXJDb2RlLlBFTkFMVFlfTjIgPSAzO1xuICBRckNvZGUuUEVOQUxUWV9OMyA9IDQwO1xuICBRckNvZGUuUEVOQUxUWV9ONCA9IDEwO1xuICBRckNvZGUuRUNDX0NPREVXT1JEU19QRVJfQkxPQ0sgPSBbXG4gICAgWy0xLCA3LCAxMCwgMTUsIDIwLCAyNiwgMTgsIDIwLCAyNCwgMzAsIDE4LCAyMCwgMjQsIDI2LCAzMCwgMjIsIDI0LCAyOCwgMzAsIDI4LCAyOCwgMjgsIDI4LCAzMCwgMzAsIDI2LCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICBbLTEsIDEwLCAxNiwgMjYsIDE4LCAyNCwgMTYsIDE4LCAyMiwgMjIsIDI2LCAzMCwgMjIsIDIyLCAyNCwgMjQsIDI4LCAyOCwgMjYsIDI2LCAyNiwgMjYsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4XSxcbiAgICBbLTEsIDEzLCAyMiwgMTgsIDI2LCAxOCwgMjQsIDE4LCAyMiwgMjAsIDI0LCAyOCwgMjYsIDI0LCAyMCwgMzAsIDI0LCAyOCwgMjgsIDI2LCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICBbLTEsIDE3LCAyOCwgMjIsIDE2LCAyMiwgMjgsIDI2LCAyNiwgMjQsIDI4LCAyNCwgMjgsIDIyLCAyNCwgMjQsIDMwLCAyOCwgMjgsIDI2LCAyOCwgMzAsIDI0LCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXVxuICBdO1xuICBRckNvZGUuTlVNX0VSUk9SX0NPUlJFQ1RJT05fQkxPQ0tTID0gW1xuICAgIFstMSwgMSwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgNCwgNCwgNCwgNCwgNCwgNiwgNiwgNiwgNiwgNywgOCwgOCwgOSwgOSwgMTAsIDEyLCAxMiwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAxOSwgMjAsIDIxLCAyMiwgMjQsIDI1XSxcbiAgICBbLTEsIDEsIDEsIDEsIDIsIDIsIDQsIDQsIDQsIDUsIDUsIDUsIDgsIDksIDksIDEwLCAxMCwgMTEsIDEzLCAxNCwgMTYsIDE3LCAxNywgMTgsIDIwLCAyMSwgMjMsIDI1LCAyNiwgMjgsIDI5LCAzMSwgMzMsIDM1LCAzNywgMzgsIDQwLCA0MywgNDUsIDQ3LCA0OV0sXG4gICAgWy0xLCAxLCAxLCAyLCAyLCA0LCA0LCA2LCA2LCA4LCA4LCA4LCAxMCwgMTIsIDE2LCAxMiwgMTcsIDE2LCAxOCwgMjEsIDIwLCAyMywgMjMsIDI1LCAyNywgMjksIDM0LCAzNCwgMzUsIDM4LCA0MCwgNDMsIDQ1LCA0OCwgNTEsIDUzLCA1NiwgNTksIDYyLCA2NSwgNjhdLFxuICAgIFstMSwgMSwgMSwgMiwgNCwgNCwgNCwgNSwgNiwgOCwgOCwgMTEsIDExLCAxNiwgMTYsIDE4LCAxNiwgMTksIDIxLCAyNSwgMjUsIDI1LCAzNCwgMzAsIDMyLCAzNSwgMzcsIDQwLCA0MiwgNDUsIDQ4LCA1MSwgNTQsIDU3LCA2MCwgNjMsIDY2LCA3MCwgNzQsIDc3LCA4MV1cbiAgXTtcbiAgcXJjb2RlZ2VuMi5RckNvZGUgPSBRckNvZGU7XG4gIGZ1bmN0aW9uIGFwcGVuZEJpdHModmFsLCBsZW4sIGJiKSB7XG4gICAgaWYgKGxlbiA8IDAgfHwgbGVuID4gMzEgfHwgdmFsID4+PiBsZW4gIT0gMClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGJiLnB1c2godmFsID4+PiBpICYgMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Qml0KHgsIGkpIHtcbiAgICByZXR1cm4gKHggPj4+IGkgJiAxKSAhPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2VydChjb25kKSB7XG4gICAgaWYgKCFjb25kKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGVycm9yXCIpO1xuICB9XG4gIGNvbnN0IF9RclNlZ21lbnQgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IobW9kZSwgbnVtQ2hhcnMsIGJpdERhdGEpIHtcbiAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLm51bUNoYXJzID0gbnVtQ2hhcnM7XG4gICAgICB0aGlzLmJpdERhdGEgPSBiaXREYXRhO1xuICAgICAgaWYgKG51bUNoYXJzIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgdGhpcy5iaXREYXRhID0gYml0RGF0YS5zbGljZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZUJ5dGVzKGRhdGEpIHtcbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgZm9yIChjb25zdCBiIG9mIGRhdGEpXG4gICAgICAgIGFwcGVuZEJpdHMoYiwgOCwgYmIpO1xuICAgICAgcmV0dXJuIG5ldyBfUXJTZWdtZW50KF9RclNlZ21lbnQuTW9kZS5CWVRFLCBkYXRhLmxlbmd0aCwgYmIpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZU51bWVyaWMoZGlnaXRzKSB7XG4gICAgICBpZiAoIV9RclNlZ21lbnQuaXNOdW1lcmljKGRpZ2l0cykpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU3RyaW5nIGNvbnRhaW5zIG5vbi1udW1lcmljIGNoYXJhY3RlcnNcIik7XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlnaXRzLmxlbmd0aDsgKSB7XG4gICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihkaWdpdHMubGVuZ3RoIC0gaSwgMyk7XG4gICAgICAgIGFwcGVuZEJpdHMocGFyc2VJbnQoZGlnaXRzLnN1YnN0cihpLCBuKSwgMTApLCBuICogMyArIDEsIGJiKTtcbiAgICAgICAgaSArPSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBfUXJTZWdtZW50KF9RclNlZ21lbnQuTW9kZS5OVU1FUklDLCBkaWdpdHMubGVuZ3RoLCBiYik7XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlQWxwaGFudW1lcmljKHRleHQpIHtcbiAgICAgIGlmICghX1FyU2VnbWVudC5pc0FscGhhbnVtZXJpYyh0ZXh0KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTdHJpbmcgY29udGFpbnMgdW5lbmNvZGFibGUgY2hhcmFjdGVycyBpbiBhbHBoYW51bWVyaWMgbW9kZVwiKTtcbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgbGV0IGk7XG4gICAgICBmb3IgKGkgPSAwOyBpICsgMiA8PSB0ZXh0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCB0ZW1wID0gX1FyU2VnbWVudC5BTFBIQU5VTUVSSUNfQ0hBUlNFVC5pbmRleE9mKHRleHQuY2hhckF0KGkpKSAqIDQ1O1xuICAgICAgICB0ZW1wICs9IF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpICsgMSkpO1xuICAgICAgICBhcHBlbmRCaXRzKHRlbXAsIDExLCBiYik7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IHRleHQubGVuZ3RoKVxuICAgICAgICBhcHBlbmRCaXRzKF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpKSksIDYsIGJiKTtcbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuQUxQSEFOVU1FUklDLCB0ZXh0Lmxlbmd0aCwgYmIpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZVNlZ21lbnRzKHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09IFwiXCIpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGVsc2UgaWYgKF9RclNlZ21lbnQuaXNOdW1lcmljKHRleHQpKVxuICAgICAgICByZXR1cm4gW19RclNlZ21lbnQubWFrZU51bWVyaWModGV4dCldO1xuICAgICAgZWxzZSBpZiAoX1FyU2VnbWVudC5pc0FscGhhbnVtZXJpYyh0ZXh0KSlcbiAgICAgICAgcmV0dXJuIFtfUXJTZWdtZW50Lm1ha2VBbHBoYW51bWVyaWModGV4dCldO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gW19RclNlZ21lbnQubWFrZUJ5dGVzKF9RclNlZ21lbnQudG9VdGY4Qnl0ZUFycmF5KHRleHQpKV07XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlRWNpKGFzc2lnblZhbCkge1xuICAgICAgbGV0IGJiID0gW107XG4gICAgICBpZiAoYXNzaWduVmFsIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFQ0kgYXNzaWdubWVudCB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBlbHNlIGlmIChhc3NpZ25WYWwgPCAxIDw8IDcpXG4gICAgICAgIGFwcGVuZEJpdHMoYXNzaWduVmFsLCA4LCBiYik7XG4gICAgICBlbHNlIGlmIChhc3NpZ25WYWwgPCAxIDw8IDE0KSB7XG4gICAgICAgIGFwcGVuZEJpdHMoMiwgMiwgYmIpO1xuICAgICAgICBhcHBlbmRCaXRzKGFzc2lnblZhbCwgMTQsIGJiKTtcbiAgICAgIH0gZWxzZSBpZiAoYXNzaWduVmFsIDwgMWU2KSB7XG4gICAgICAgIGFwcGVuZEJpdHMoNiwgMywgYmIpO1xuICAgICAgICBhcHBlbmRCaXRzKGFzc2lnblZhbCwgMjEsIGJiKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVDSSBhc3NpZ25tZW50IHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuRUNJLCAwLCBiYik7XG4gICAgfVxuICAgIHN0YXRpYyBpc051bWVyaWModGV4dCkge1xuICAgICAgcmV0dXJuIF9RclNlZ21lbnQuTlVNRVJJQ19SRUdFWC50ZXN0KHRleHQpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNBbHBoYW51bWVyaWModGV4dCkge1xuICAgICAgcmV0dXJuIF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX1JFR0VYLnRlc3QodGV4dCk7XG4gICAgfVxuICAgIGdldERhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iaXREYXRhLnNsaWNlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUb3RhbEJpdHMoc2VncywgdmVyc2lvbikge1xuICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGNvbnN0IGNjYml0cyA9IHNlZy5tb2RlLm51bUNoYXJDb3VudEJpdHModmVyc2lvbik7XG4gICAgICAgIGlmIChzZWcubnVtQ2hhcnMgPj0gMSA8PCBjY2JpdHMpXG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICByZXN1bHQgKz0gNCArIGNjYml0cyArIHNlZy5iaXREYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyB0b1V0ZjhCeXRlQXJyYXkoc3RyKSB7XG4gICAgICBzdHIgPSBlbmNvZGVVUkkoc3RyKTtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KGkpICE9IFwiJVwiKVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc3RyLnN1YnN0cihpICsgMSwgMiksIDE2KSk7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbiAgbGV0IFFyU2VnbWVudCA9IF9RclNlZ21lbnQ7XG4gIFFyU2VnbWVudC5OVU1FUklDX1JFR0VYID0gL15bMC05XSokLztcbiAgUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19SRUdFWCA9IC9eW0EtWjAtOSAkJSorLlxcLzotXSokLztcbiAgUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19DSEFSU0VUID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogJCUqKy0uLzpcIjtcbiAgcXJjb2RlZ2VuMi5RclNlZ21lbnQgPSBRclNlZ21lbnQ7XG59KShxcmNvZGVnZW4gfHwgKHFyY29kZWdlbiA9IHt9KSk7XG4oKHFyY29kZWdlbjIpID0+IHtcbiAgbGV0IFFyQ29kZTtcbiAgKChRckNvZGUyKSA9PiB7XG4gICAgY29uc3QgX0VjYyA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9yZGluYWwsIGZvcm1hdEJpdHMpIHtcbiAgICAgICAgdGhpcy5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICAgICAgdGhpcy5mb3JtYXRCaXRzID0gZm9ybWF0Qml0cztcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBFY2MgPSBfRWNjO1xuICAgIEVjYy5MT1cgPSBuZXcgX0VjYygwLCAxKTtcbiAgICBFY2MuTUVESVVNID0gbmV3IF9FY2MoMSwgMCk7XG4gICAgRWNjLlFVQVJUSUxFID0gbmV3IF9FY2MoMiwgMyk7XG4gICAgRWNjLkhJR0ggPSBuZXcgX0VjYygzLCAyKTtcbiAgICBRckNvZGUyLkVjYyA9IEVjYztcbiAgfSkoUXJDb2RlID0gcXJjb2RlZ2VuMi5RckNvZGUgfHwgKHFyY29kZWdlbjIuUXJDb2RlID0ge30pKTtcbn0pKHFyY29kZWdlbiB8fCAocXJjb2RlZ2VuID0ge30pKTtcbigocXJjb2RlZ2VuMikgPT4ge1xuICBsZXQgUXJTZWdtZW50O1xuICAoKFFyU2VnbWVudDIpID0+IHtcbiAgICBjb25zdCBfTW9kZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1vZGVCaXRzLCBudW1CaXRzQ2hhckNvdW50KSB7XG4gICAgICAgIHRoaXMubW9kZUJpdHMgPSBtb2RlQml0cztcbiAgICAgICAgdGhpcy5udW1CaXRzQ2hhckNvdW50ID0gbnVtQml0c0NoYXJDb3VudDtcbiAgICAgIH1cbiAgICAgIG51bUNoYXJDb3VudEJpdHModmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bUJpdHNDaGFyQ291bnRbTWF0aC5mbG9vcigodmVyICsgNykgLyAxNyldO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IE1vZGUgPSBfTW9kZTtcbiAgICBNb2RlLk5VTUVSSUMgPSBuZXcgX01vZGUoMSwgWzEwLCAxMiwgMTRdKTtcbiAgICBNb2RlLkFMUEhBTlVNRVJJQyA9IG5ldyBfTW9kZSgyLCBbOSwgMTEsIDEzXSk7XG4gICAgTW9kZS5CWVRFID0gbmV3IF9Nb2RlKDQsIFs4LCAxNiwgMTZdKTtcbiAgICBNb2RlLktBTkpJID0gbmV3IF9Nb2RlKDgsIFs4LCAxMCwgMTJdKTtcbiAgICBNb2RlLkVDSSA9IG5ldyBfTW9kZSg3LCBbMCwgMCwgMF0pO1xuICAgIFFyU2VnbWVudDIuTW9kZSA9IE1vZGU7XG4gIH0pKFFyU2VnbWVudCA9IHFyY29kZWdlbjIuUXJTZWdtZW50IHx8IChxcmNvZGVnZW4yLlFyU2VnbWVudCA9IHt9KSk7XG59KShxcmNvZGVnZW4gfHwgKHFyY29kZWdlbiA9IHt9KSk7XG52YXIgcXJjb2RlZ2VuX2RlZmF1bHQgPSBxcmNvZGVnZW47XG5cbi8vIHNyYy9pbmRleC50c3hcbi8qKlxuICogQGxpY2Vuc2UgcXJjb2RlLnJlYWN0XG4gKiBDb3B5cmlnaHQgKGMpIFBhdWwgTydTaGFubmVzc3lcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBJU0NcbiAqL1xudmFyIEVSUk9SX0xFVkVMX01BUCA9IHtcbiAgTDogcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLkVjYy5MT1csXG4gIE06IHFyY29kZWdlbl9kZWZhdWx0LlFyQ29kZS5FY2MuTUVESVVNLFxuICBROiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuRWNjLlFVQVJUSUxFLFxuICBIOiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuRWNjLkhJR0hcbn07XG52YXIgREVGQVVMVF9QUk9QUyA9IHtcbiAgc2l6ZTogMTI4LFxuICBsZXZlbDogXCJMXCIsXG4gIGJnQ29sb3I6IFwiI0ZGRkZGRlwiLFxuICBmZ0NvbG9yOiBcIiMwMDAwMDBcIixcbiAgaW5jbHVkZU1hcmdpbjogZmFsc2Vcbn07XG52YXIgTUFSR0lOX1NJWkUgPSA0O1xudmFyIERFRkFVTFRfSU1HX1NDQUxFID0gMC4xO1xuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG1vZHVsZXMsIG1hcmdpbiA9IDApIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihyb3csIHkpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIHgpIHtcbiAgICAgIGlmICghY2VsbCAmJiBzdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBvcHMucHVzaChgTSR7c3RhcnQgKyBtYXJnaW59ICR7eSArIG1hcmdpbn1oJHt4IC0gc3RhcnR9djFIJHtzdGFydCArIG1hcmdpbn16YCk7XG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHggPT09IHJvdy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICBvcHMucHVzaChgTSR7eCArIG1hcmdpbn0sJHt5ICsgbWFyZ2lufSBoMXYxSCR7eCArIG1hcmdpbn16YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BzLnB1c2goYE0ke3N0YXJ0ICsgbWFyZ2lufSwke3kgKyBtYXJnaW59IGgke3ggKyAxIC0gc3RhcnR9djFIJHtzdGFydCArIG1hcmdpbn16YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNlbGwgJiYgc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgc3RhcnQgPSB4O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9wcy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZXhjYXZhdGVNb2R1bGVzKG1vZHVsZXMsIGV4Y2F2YXRpb24pIHtcbiAgcmV0dXJuIG1vZHVsZXMuc2xpY2UoKS5tYXAoKHJvdywgeSkgPT4ge1xuICAgIGlmICh5IDwgZXhjYXZhdGlvbi55IHx8IHkgPj0gZXhjYXZhdGlvbi55ICsgZXhjYXZhdGlvbi5oKSB7XG4gICAgICByZXR1cm4gcm93O1xuICAgIH1cbiAgICByZXR1cm4gcm93Lm1hcCgoY2VsbCwgeCkgPT4ge1xuICAgICAgaWYgKHggPCBleGNhdmF0aW9uLnggfHwgeCA+PSBleGNhdmF0aW9uLnggKyBleGNhdmF0aW9uLncpIHtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0SW1hZ2VTZXR0aW5ncyhwcm9wcywgY2VsbHMpIHtcbiAgY29uc3QgeyBpbWFnZVNldHRpbmdzLCBzaXplLCBpbmNsdWRlTWFyZ2luIH0gPSBwcm9wcztcbiAgaWYgKGltYWdlU2V0dGluZ3MgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IG1hcmdpbiA9IGluY2x1ZGVNYXJnaW4gPyBNQVJHSU5fU0laRSA6IDA7XG4gIGNvbnN0IG51bUNlbGxzID0gY2VsbHMubGVuZ3RoICsgbWFyZ2luICogMjtcbiAgY29uc3QgZGVmYXVsdFNpemUgPSBNYXRoLmZsb29yKHNpemUgKiBERUZBVUxUX0lNR19TQ0FMRSk7XG4gIGNvbnN0IHNjYWxlID0gbnVtQ2VsbHMgLyBzaXplO1xuICBjb25zdCB3ID0gKGltYWdlU2V0dGluZ3Mud2lkdGggfHwgZGVmYXVsdFNpemUpICogc2NhbGU7XG4gIGNvbnN0IGggPSAoaW1hZ2VTZXR0aW5ncy5oZWlnaHQgfHwgZGVmYXVsdFNpemUpICogc2NhbGU7XG4gIGNvbnN0IHggPSBpbWFnZVNldHRpbmdzLnggPT0gbnVsbCA/IGNlbGxzLmxlbmd0aCAvIDIgLSB3IC8gMiA6IGltYWdlU2V0dGluZ3MueCAqIHNjYWxlO1xuICBjb25zdCB5ID0gaW1hZ2VTZXR0aW5ncy55ID09IG51bGwgPyBjZWxscy5sZW5ndGggLyAyIC0gaCAvIDIgOiBpbWFnZVNldHRpbmdzLnkgKiBzY2FsZTtcbiAgbGV0IGV4Y2F2YXRpb24gPSBudWxsO1xuICBpZiAoaW1hZ2VTZXR0aW5ncy5leGNhdmF0ZSkge1xuICAgIGxldCBmbG9vclggPSBNYXRoLmZsb29yKHgpO1xuICAgIGxldCBmbG9vclkgPSBNYXRoLmZsb29yKHkpO1xuICAgIGxldCBjZWlsVyA9IE1hdGguY2VpbCh3ICsgeCAtIGZsb29yWCk7XG4gICAgbGV0IGNlaWxIID0gTWF0aC5jZWlsKGggKyB5IC0gZmxvb3JZKTtcbiAgICBleGNhdmF0aW9uID0geyB4OiBmbG9vclgsIHk6IGZsb29yWSwgdzogY2VpbFcsIGg6IGNlaWxIIH07XG4gIH1cbiAgcmV0dXJuIHsgeCwgeSwgaCwgdywgZXhjYXZhdGlvbiB9O1xufVxudmFyIFNVUFBPUlRTX1BBVEgyRCA9IGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIG5ldyBQYXRoMkQoKS5hZGRQYXRoKG5ldyBQYXRoMkQoKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KCk7XG5mdW5jdGlvbiBRUkNvZGVDYW52YXMocHJvcHMpIHtcbiAgY29uc3QgX2NhbnZhcyA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgX2ltYWdlID0gdXNlUmVmKG51bGwpO1xuICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgY29uc3QgeyB2YWx1ZTogdmFsdWUyLCBzaXplOiBzaXplMiwgbGV2ZWw6IGxldmVsMiwgYmdDb2xvcjogYmdDb2xvcjIsIGZnQ29sb3I6IGZnQ29sb3IyLCBpbmNsdWRlTWFyZ2luOiBpbmNsdWRlTWFyZ2luMiB9ID0gcHJvcHM7XG4gICAgaWYgKF9jYW52YXMuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBfY2FudmFzLmN1cnJlbnQ7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGNlbGxzID0gcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLmVuY29kZVRleHQodmFsdWUyLCBFUlJPUl9MRVZFTF9NQVBbbGV2ZWwyXSkuZ2V0TW9kdWxlcygpO1xuICAgICAgY29uc3QgbWFyZ2luID0gaW5jbHVkZU1hcmdpbjIgPyBNQVJHSU5fU0laRSA6IDA7XG4gICAgICBjb25zdCBudW1DZWxscyA9IGNlbGxzLmxlbmd0aCArIG1hcmdpbiAqIDI7XG4gICAgICBjb25zdCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyA9IGdldEltYWdlU2V0dGluZ3MocHJvcHMsIGNlbGxzKTtcbiAgICAgIGNvbnN0IGltYWdlID0gX2ltYWdlLmN1cnJlbnQ7XG4gICAgICBjb25zdCBoYXZlSW1hZ2VUb1JlbmRlciA9IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzICE9IG51bGwgJiYgaW1hZ2UgIT09IG51bGwgJiYgaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbEhlaWdodCAhPT0gMCAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDA7XG4gICAgICBpZiAoaGF2ZUltYWdlVG9SZW5kZXIpIHtcbiAgICAgICAgaWYgKGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmV4Y2F2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIGNlbGxzID0gZXhjYXZhdGVNb2R1bGVzKGNlbGxzLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoID0gc2l6ZTIgKiBwaXhlbFJhdGlvO1xuICAgICAgY29uc3Qgc2NhbGUgPSBzaXplMiAvIG51bUNlbGxzICogcGl4ZWxSYXRpbztcbiAgICAgIGN0eC5zY2FsZShzY2FsZSwgc2NhbGUpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3IyO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIG51bUNlbGxzLCBudW1DZWxscyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmdDb2xvcjI7XG4gICAgICBpZiAoU1VQUE9SVFNfUEFUSDJEKSB7XG4gICAgICAgIGN0eC5maWxsKG5ldyBQYXRoMkQoZ2VuZXJhdGVQYXRoKGNlbGxzLCBtYXJnaW4pKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxscy5mb3JFYWNoKGZ1bmN0aW9uKHJvdywgcmR4KSB7XG4gICAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24oY2VsbCwgY2R4KSB7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoY2R4ICsgbWFyZ2luLCByZHggKyBtYXJnaW4sIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXZlSW1hZ2VUb1JlbmRlcikge1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy54ICsgbWFyZ2luLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy55ICsgbWFyZ2luLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy53LCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG4gIGNvbnN0IF9hID0gcHJvcHMsIHtcbiAgICB2YWx1ZSxcbiAgICBzaXplLFxuICAgIGxldmVsLFxuICAgIGJnQ29sb3IsXG4gICAgZmdDb2xvcixcbiAgICBzdHlsZSxcbiAgICBpbmNsdWRlTWFyZ2luLFxuICAgIGltYWdlU2V0dGluZ3NcbiAgfSA9IF9hLCBvdGhlclByb3BzID0gX19vYmpSZXN0KF9hLCBbXG4gICAgXCJ2YWx1ZVwiLFxuICAgIFwic2l6ZVwiLFxuICAgIFwibGV2ZWxcIixcbiAgICBcImJnQ29sb3JcIixcbiAgICBcImZnQ29sb3JcIixcbiAgICBcInN0eWxlXCIsXG4gICAgXCJpbmNsdWRlTWFyZ2luXCIsXG4gICAgXCJpbWFnZVNldHRpbmdzXCJcbiAgXSk7XG4gIGNvbnN0IGNhbnZhc1N0eWxlID0gX19zcHJlYWRWYWx1ZXMoeyBoZWlnaHQ6IHNpemUsIHdpZHRoOiBzaXplIH0sIHN0eWxlKTtcbiAgbGV0IGltZyA9IG51bGw7XG4gIGxldCBpbWdTcmMgPSBpbWFnZVNldHRpbmdzID09IG51bGwgPyB2b2lkIDAgOiBpbWFnZVNldHRpbmdzLnNyYztcbiAgaWYgKGltZ1NyYyAhPSBudWxsKSB7XG4gICAgaW1nID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwge1xuICAgICAgc3JjOiBpbWdTcmMsXG4gICAgICBrZXk6IGltZ1NyYyxcbiAgICAgIHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICBvbkxvYWQ6ICgpID0+IHtcbiAgICAgICAgdXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgcmVmOiBfaW1hZ2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIF9fc3ByZWFkVmFsdWVzKHtcbiAgICBzdHlsZTogY2FudmFzU3R5bGUsXG4gICAgaGVpZ2h0OiBzaXplLFxuICAgIHdpZHRoOiBzaXplLFxuICAgIHJlZjogX2NhbnZhc1xuICB9LCBvdGhlclByb3BzKSksIGltZyk7XG59XG5RUkNvZGVDYW52YXMuZGVmYXVsdFByb3BzID0gREVGQVVMVF9QUk9QUztcbmZ1bmN0aW9uIFFSQ29kZVNWRyhwcm9wcykge1xuICBjb25zdCBfYSA9IHByb3BzLCB7XG4gICAgdmFsdWUsXG4gICAgc2l6ZSxcbiAgICBsZXZlbCxcbiAgICBiZ0NvbG9yLFxuICAgIGZnQ29sb3IsXG4gICAgaW5jbHVkZU1hcmdpbixcbiAgICBpbWFnZVNldHRpbmdzXG4gIH0gPSBfYSwgb3RoZXJQcm9wcyA9IF9fb2JqUmVzdChfYSwgW1xuICAgIFwidmFsdWVcIixcbiAgICBcInNpemVcIixcbiAgICBcImxldmVsXCIsXG4gICAgXCJiZ0NvbG9yXCIsXG4gICAgXCJmZ0NvbG9yXCIsXG4gICAgXCJpbmNsdWRlTWFyZ2luXCIsXG4gICAgXCJpbWFnZVNldHRpbmdzXCJcbiAgXSk7XG4gIGxldCBjZWxscyA9IHFyY29kZWdlbl9kZWZhdWx0LlFyQ29kZS5lbmNvZGVUZXh0KHZhbHVlLCBFUlJPUl9MRVZFTF9NQVBbbGV2ZWxdKS5nZXRNb2R1bGVzKCk7XG4gIGNvbnN0IG1hcmdpbiA9IGluY2x1ZGVNYXJnaW4gPyBNQVJHSU5fU0laRSA6IDA7XG4gIGNvbnN0IG51bUNlbGxzID0gY2VsbHMubGVuZ3RoICsgbWFyZ2luICogMjtcbiAgY29uc3QgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgPSBnZXRJbWFnZVNldHRpbmdzKHByb3BzLCBjZWxscyk7XG4gIGxldCBpbWFnZSA9IG51bGw7XG4gIGlmIChpbWFnZVNldHRpbmdzICE9IG51bGwgJiYgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgIT0gbnVsbCkge1xuICAgIGlmIChjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uICE9IG51bGwpIHtcbiAgICAgIGNlbGxzID0gZXhjYXZhdGVNb2R1bGVzKGNlbGxzLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uKTtcbiAgICB9XG4gICAgaW1hZ2UgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImltYWdlXCIsIHtcbiAgICAgIHhsaW5rSHJlZjogaW1hZ2VTZXR0aW5ncy5zcmMsXG4gICAgICBoZWlnaHQ6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmgsXG4gICAgICB3aWR0aDogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MudyxcbiAgICAgIHg6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnggKyBtYXJnaW4sXG4gICAgICB5OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy55ICsgbWFyZ2luLFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCBmZ1BhdGggPSBnZW5lcmF0ZVBhdGgoY2VsbHMsIG1hcmdpbik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfX3NwcmVhZFZhbHVlcyh7XG4gICAgc2hhcGVSZW5kZXJpbmc6IFwiY3Jpc3BFZGdlc1wiLFxuICAgIGhlaWdodDogc2l6ZSxcbiAgICB3aWR0aDogc2l6ZSxcbiAgICB2aWV3Qm94OiBgMCAwICR7bnVtQ2VsbHN9ICR7bnVtQ2VsbHN9YFxuICB9LCBvdGhlclByb3BzKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBmaWxsOiBiZ0NvbG9yLFxuICAgIGQ6IGBNMCwwIGgke251bUNlbGxzfXYke251bUNlbGxzfUgwemBcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZmlsbDogZmdDb2xvcixcbiAgICBkOiBmZ1BhdGhcbiAgfSksIGltYWdlKTtcbn1cblFSQ29kZVNWRy5kZWZhdWx0UHJvcHMgPSBERUZBVUxUX1BST1BTO1xudmFyIFFSQ29kZSA9IChwcm9wcykgPT4ge1xuICBjb25zdCBfYSA9IHByb3BzLCB7IHJlbmRlckFzIH0gPSBfYSwgb3RoZXJQcm9wcyA9IF9fb2JqUmVzdChfYSwgW1wicmVuZGVyQXNcIl0pO1xuICBpZiAocmVuZGVyQXMgPT09IFwic3ZnXCIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUVJDb2RlU1ZHLCBfX3NwcmVhZFZhbHVlcyh7fSwgb3RoZXJQcm9wcykpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChRUkNvZGVDYW52YXMsIF9fc3ByZWFkVmFsdWVzKHt9LCBvdGhlclByb3BzKSk7XG59O1xuUVJDb2RlLmRlZmF1bHRQcm9wcyA9IF9fc3ByZWFkVmFsdWVzKHsgcmVuZGVyQXM6IFwiY2FudmFzXCIgfSwgREVGQVVMVF9QUk9QUyk7XG5leHBvcnQge1xuICBRUkNvZGVDYW52YXMsXG4gIFFSQ29kZVNWRyxcbiAgUVJDb2RlIGFzIGRlZmF1bHRcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///Wxvo\n')},qHiR:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJpc21qcy90aGVtZXMvcHJpc20uY3NzPzI2NmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoicUhpUi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///qHiR\n")},vRGJ:function(module,exports,__webpack_require__){eval("var isarray = __webpack_require__(\"AqCL\");\n/**\n * Expose `pathToRegexp`.\n */\n\n\nmodule.exports = pathToRegexp;\nmodule.exports.parse = parse;\nmodule.exports.compile = compile;\nmodule.exports.tokensToFunction = tokensToFunction;\nmodule.exports.tokensToRegExp = tokensToRegExp;\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\n\nvar PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.\n// This allows the user to escape special characters that won't transform.\n'(\\\\\\\\.)', // Match Express-style parameters and un-named parameters with a prefix\n// and optional suffixes. Matches appear as:\n//\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n'([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\n\nfunction parse(str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length; // Ignore already escaped sequences.\n\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7]; // Push the current path onto the tokens.\n\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n    });\n  } // Match any characters still remaining.\n\n\n  if (index < str.length) {\n    path += str.substr(index);\n  } // If the path exists, push it onto the end.\n\n\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens;\n}\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\n\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\n\n\nfunction encodeURIComponentPretty(str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\n\n\nfunction encodeAsterisk(str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\n\nfunction tokensToFunction(tokens, options) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length); // Compile all the patterns before compilation.\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue;\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined');\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path;\n  };\n}\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\n\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\n\n\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\n\n\nfunction attachKeys(re, keys) {\n  re.keys = keys;\n  return re;\n}\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\n\n\nfunction flags(options) {\n  return options && options.sensitive ? '' : 'i';\n}\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\n\n\nfunction arrayToRegexp(path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n  return attachKeys(regexp, keys);\n}\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\n\n\nfunction tokensToRegExp(tokens, keys, options) {\n  if (!isarray(keys)) {\n    options =\n    /** @type {!Object} */\n    keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = ''; // Iterate over the tokens and create our regexp string.\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter; // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\n\n\nfunction pathToRegexp(path, keys, options) {\n  if (!isarray(keys)) {\n    options =\n    /** @type {!Object} */\n    keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path,\n    /** @type {!Array} */\n    keys);\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(\n    /** @type {!Array} */\n    path,\n    /** @type {!Array} */\n    keys, options);\n  }\n\n  return stringToRegexp(\n  /** @type {string} */\n  path,\n  /** @type {!Array} */\n  keys, options);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanM/YmQxMSJdLCJuYW1lcyI6WyJpc2FycmF5IiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJwYXRoVG9SZWdleHAiLCJwYXJzZSIsImNvbXBpbGUiLCJ0b2tlbnNUb0Z1bmN0aW9uIiwidG9rZW5zVG9SZWdFeHAiLCJQQVRIX1JFR0VYUCIsIlJlZ0V4cCIsImpvaW4iLCJzdHIiLCJvcHRpb25zIiwidG9rZW5zIiwia2V5IiwiaW5kZXgiLCJwYXRoIiwiZGVmYXVsdERlbGltaXRlciIsImRlbGltaXRlciIsInJlcyIsImV4ZWMiLCJtIiwiZXNjYXBlZCIsIm9mZnNldCIsInNsaWNlIiwibGVuZ3RoIiwibmV4dCIsInByZWZpeCIsIm5hbWUiLCJjYXB0dXJlIiwiZ3JvdXAiLCJtb2RpZmllciIsImFzdGVyaXNrIiwicHVzaCIsInBhcnRpYWwiLCJyZXBlYXQiLCJvcHRpb25hbCIsInBhdHRlcm4iLCJlc2NhcGVHcm91cCIsImVzY2FwZVN0cmluZyIsInN1YnN0ciIsImVuY29kZVVSSUNvbXBvbmVudFByZXR0eSIsImVuY29kZVVSSSIsInJlcGxhY2UiLCJjIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJlbmNvZGVBc3RlcmlzayIsIm1hdGNoZXMiLCJBcnJheSIsImkiLCJmbGFncyIsIm9iaiIsIm9wdHMiLCJkYXRhIiwiZW5jb2RlIiwicHJldHR5IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidG9rZW4iLCJ2YWx1ZSIsInNlZ21lbnQiLCJUeXBlRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiaiIsInRlc3QiLCJhdHRhY2hLZXlzIiwicmUiLCJrZXlzIiwic2Vuc2l0aXZlIiwicmVnZXhwVG9SZWdleHAiLCJncm91cHMiLCJzb3VyY2UiLCJtYXRjaCIsImFycmF5VG9SZWdleHAiLCJwYXJ0cyIsInJlZ2V4cCIsInN0cmluZ1RvUmVnZXhw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JylcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gcGF0aFRvUmVnZXhwXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlXG5tb2R1bGUuZXhwb3J0cy5jb21waWxlID0gY29tcGlsZVxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9GdW5jdGlvbiA9IHRva2Vuc1RvRnVuY3Rpb25cbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvUmVnRXhwID0gdG9rZW5zVG9SZWdFeHBcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKVxuXG4vKipcbiAqIFBhcnNlIGEgc3RyaW5nIGZvciB0aGUgcmF3IHRva2Vucy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnNcbiAqIEByZXR1cm4geyFBcnJheX1cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHN0ciwgb3B0aW9ucykge1xuICB2YXIgdG9rZW5zID0gW11cbiAgdmFyIGtleSA9IDBcbiAgdmFyIGluZGV4ID0gMFxuICB2YXIgcGF0aCA9ICcnXG4gIHZhciBkZWZhdWx0RGVsaW1pdGVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlbGltaXRlciB8fCAnLydcbiAgdmFyIHJlc1xuXG4gIHdoaWxlICgocmVzID0gUEFUSF9SRUdFWFAuZXhlYyhzdHIpKSAhPSBudWxsKSB7XG4gICAgdmFyIG0gPSByZXNbMF1cbiAgICB2YXIgZXNjYXBlZCA9IHJlc1sxXVxuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXhcbiAgICBwYXRoICs9IHN0ci5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbS5sZW5ndGhcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBzdHJbaW5kZXhdXG4gICAgdmFyIHByZWZpeCA9IHJlc1syXVxuICAgIHZhciBuYW1lID0gcmVzWzNdXG4gICAgdmFyIGNhcHR1cmUgPSByZXNbNF1cbiAgICB2YXIgZ3JvdXAgPSByZXNbNV1cbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl1cbiAgICB2YXIgYXN0ZXJpc2sgPSByZXNbN11cblxuICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgcGF0aCBvbnRvIHRoZSB0b2tlbnMuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gICAgICBwYXRoID0gJydcbiAgICB9XG5cbiAgICB2YXIgcGFydGlhbCA9IHByZWZpeCAhPSBudWxsICYmIG5leHQgIT0gbnVsbCAmJiBuZXh0ICE9PSBwcmVmaXhcbiAgICB2YXIgcmVwZWF0ID0gbW9kaWZpZXIgPT09ICcrJyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonXG4gICAgdmFyIGRlbGltaXRlciA9IHJlc1syXSB8fCBkZWZhdWx0RGVsaW1pdGVyXG4gICAgdmFyIHBhdHRlcm4gPSBjYXB0dXJlIHx8IGdyb3VwXG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pXG4gIH1cblxuICAvLyBNYXRjaCBhbnkgY2hhcmFjdGVycyBzdGlsbCByZW1haW5pbmcuXG4gIGlmIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBwYXRoICs9IHN0ci5zdWJzdHIoaW5kZXgpXG4gIH1cblxuICAvLyBJZiB0aGUgcGF0aCBleGlzdHMsIHB1c2ggaXQgb250byB0aGUgZW5kLlxuICBpZiAocGF0aCkge1xuICAgIHRva2Vucy5wdXNoKHBhdGgpXG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aClcblxuICAvLyBDb21waWxlIGFsbCB0aGUgcGF0dGVybnMgYmVmb3JlIGNvbXBpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgdG9rZW5zW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgbWF0Y2hlc1tpXSA9IG5ldyBSZWdFeHAoJ14oPzonICsgdG9rZW5zW2ldLnBhdHRlcm4gKyAnKSQnLCBmbGFncyhvcHRpb25zKSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJydcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fVxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fVxuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuXG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXVxuICAgICAgdmFyIHNlZ21lbnRcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKVxuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKVxuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXNcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5zZW5zaXRpdmUgPyAnJyA6ICdpJ1xufVxuXG4vKipcbiAqIFB1bGwgb3V0IGtleXMgZnJvbSBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiByZWdleHBUb1JlZ2V4cCAocGF0aCwga2V5cykge1xuICAvLyBVc2UgYSBuZWdhdGl2ZSBsb29rYWhlYWQgdG8gbWF0Y2ggb25seSBjYXB0dXJpbmcgZ3JvdXBzLlxuICB2YXIgZ3JvdXBzID0gcGF0aC5zb3VyY2UubWF0Y2goL1xcKCg/IVxcPykvZylcblxuICBpZiAoZ3JvdXBzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHByZWZpeDogbnVsbCxcbiAgICAgICAgZGVsaW1pdGVyOiBudWxsLFxuICAgICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAgIHJlcGVhdDogZmFsc2UsXG4gICAgICAgIHBhcnRpYWw6IGZhbHNlLFxuICAgICAgICBhc3RlcmlzazogZmFsc2UsXG4gICAgICAgIHBhdHRlcm46IG51bGxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFydHMucHVzaChwYXRoVG9SZWdleHAocGF0aFtpXSwga2V5cywgb3B0aW9ucykuc291cmNlKVxuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoJyg/OicgKyBwYXJ0cy5qb2luKCd8JykgKyAnKScsIGZsYWdzKG9wdGlvbnMpKVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0XG4gIHZhciBlbmQgPSBvcHRpb25zLmVuZCAhPT0gZmFsc2VcbiAgdmFyIHJvdXRlID0gJydcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJvdXRlICs9IGVzY2FwZVN0cmluZyh0b2tlbilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZWZpeCA9IGVzY2FwZVN0cmluZyh0b2tlbi5wcmVmaXgpXG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJ1xuXG4gICAgICBrZXlzLnB1c2godG9rZW4pXG5cbiAgICAgIGlmICh0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgY2FwdHVyZSArPSAnKD86JyArIHByZWZpeCArIGNhcHR1cmUgKyAnKSonXG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpPydcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSdcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWxpbWl0ZXIgPSBlc2NhcGVTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nKVxuICB2YXIgZW5kc1dpdGhEZWxpbWl0ZXIgPSByb3V0ZS5zbGljZSgtZGVsaW1pdGVyLmxlbmd0aCkgPT09IGRlbGltaXRlclxuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nXG4gIH1cblxuICBpZiAoZW5kKSB7XG4gICAgcm91dGUgKz0gJyQnXG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gbm9uLWVuZGluZyBtb2RlLCB3ZSBuZWVkIHRoZSBjYXB0dXJpbmcgZ3JvdXBzIHRvIG1hdGNoIGFzIG11Y2ggYXNcbiAgICAvLyBwb3NzaWJsZSBieSB1c2luZyBhIHBvc2l0aXZlIGxvb2thaGVhZCB0byB0aGUgZW5kIG9yIG5leHQgcGF0aCBzZWdtZW50LlxuICAgIHJvdXRlICs9IHN0cmljdCAmJiBlbmRzV2l0aERlbGltaXRlciA/ICcnIDogJyg/PScgKyBkZWxpbWl0ZXIgKyAnfCQpJ1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///vRGJ\n")},"wd/R":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js\n//! version : 2.29.3\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n;\n\n(function (global, factory) {\n   true ? module.exports = factory() : undefined;\n})(this, function () {\n  'use strict';\n\n  var hookCallback;\n\n  function hooks() {\n    return hookCallback.apply(null, arguments);\n  } // This is done to register the method called with moment()\n  // without creating circular dependencies.\n\n\n  function setHookCallback(callback) {\n    hookCallback = callback;\n  }\n\n  function isArray(input) {\n    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n  }\n\n  function isObject(input) {\n    // IE8 will treat undefined and null as object if it wasn't for\n    // input != null\n    return input != null && Object.prototype.toString.call(input) === '[object Object]';\n  }\n\n  function hasOwnProp(a, b) {\n    return Object.prototype.hasOwnProperty.call(a, b);\n  }\n\n  function isObjectEmpty(obj) {\n    if (Object.getOwnPropertyNames) {\n      return Object.getOwnPropertyNames(obj).length === 0;\n    } else {\n      var k;\n\n      for (k in obj) {\n        if (hasOwnProp(obj, k)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  function isUndefined(input) {\n    return input === void 0;\n  }\n\n  function isNumber(input) {\n    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n  }\n\n  function isDate(input) {\n    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n  }\n\n  function map(arr, fn) {\n    var res = [],\n        i,\n        arrLen = arr.length;\n\n    for (i = 0; i < arrLen; ++i) {\n      res.push(fn(arr[i], i));\n    }\n\n    return res;\n  }\n\n  function extend(a, b) {\n    for (var i in b) {\n      if (hasOwnProp(b, i)) {\n        a[i] = b[i];\n      }\n    }\n\n    if (hasOwnProp(b, 'toString')) {\n      a.toString = b.toString;\n    }\n\n    if (hasOwnProp(b, 'valueOf')) {\n      a.valueOf = b.valueOf;\n    }\n\n    return a;\n  }\n\n  function createUTC(input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, true).utc();\n  }\n\n  function defaultParsingFlags() {\n    // We need to deep clone this object.\n    return {\n      empty: false,\n      unusedTokens: [],\n      unusedInput: [],\n      overflow: -2,\n      charsLeftOver: 0,\n      nullInput: false,\n      invalidEra: null,\n      invalidMonth: null,\n      invalidFormat: false,\n      userInvalidated: false,\n      iso: false,\n      parsedDateParts: [],\n      era: null,\n      meridiem: null,\n      rfc2822: false,\n      weekdayMismatch: false\n    };\n  }\n\n  function getParsingFlags(m) {\n    if (m._pf == null) {\n      m._pf = defaultParsingFlags();\n    }\n\n    return m._pf;\n  }\n\n  var some;\n\n  if (Array.prototype.some) {\n    some = Array.prototype.some;\n  } else {\n    some = function some(fun) {\n      var t = Object(this),\n          len = t.length >>> 0,\n          i;\n\n      for (i = 0; i < len; i++) {\n        if (i in t && fun.call(this, t[i], i, t)) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  }\n\n  function isValid(m) {\n    if (m._isValid == null) {\n      var flags = getParsingFlags(m),\n          parsedParts = some.call(flags.parsedDateParts, function (i) {\n        return i != null;\n      }),\n          isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);\n\n      if (m._strict) {\n        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;\n      }\n\n      if (Object.isFrozen == null || !Object.isFrozen(m)) {\n        m._isValid = isNowValid;\n      } else {\n        return isNowValid;\n      }\n    }\n\n    return m._isValid;\n  }\n\n  function createInvalid(flags) {\n    var m = createUTC(NaN);\n\n    if (flags != null) {\n      extend(getParsingFlags(m), flags);\n    } else {\n      getParsingFlags(m).userInvalidated = true;\n    }\n\n    return m;\n  } // Plugins that add properties should also add the key here (null value),\n  // so we can properly clone ourselves.\n\n\n  var momentProperties = hooks.momentProperties = [],\n      updateInProgress = false;\n\n  function copyConfig(to, from) {\n    var i,\n        prop,\n        val,\n        momentPropertiesLen = momentProperties.length;\n\n    if (!isUndefined(from._isAMomentObject)) {\n      to._isAMomentObject = from._isAMomentObject;\n    }\n\n    if (!isUndefined(from._i)) {\n      to._i = from._i;\n    }\n\n    if (!isUndefined(from._f)) {\n      to._f = from._f;\n    }\n\n    if (!isUndefined(from._l)) {\n      to._l = from._l;\n    }\n\n    if (!isUndefined(from._strict)) {\n      to._strict = from._strict;\n    }\n\n    if (!isUndefined(from._tzm)) {\n      to._tzm = from._tzm;\n    }\n\n    if (!isUndefined(from._isUTC)) {\n      to._isUTC = from._isUTC;\n    }\n\n    if (!isUndefined(from._offset)) {\n      to._offset = from._offset;\n    }\n\n    if (!isUndefined(from._pf)) {\n      to._pf = getParsingFlags(from);\n    }\n\n    if (!isUndefined(from._locale)) {\n      to._locale = from._locale;\n    }\n\n    if (momentPropertiesLen > 0) {\n      for (i = 0; i < momentPropertiesLen; i++) {\n        prop = momentProperties[i];\n        val = from[prop];\n\n        if (!isUndefined(val)) {\n          to[prop] = val;\n        }\n      }\n    }\n\n    return to;\n  } // Moment prototype object\n\n\n  function Moment(config) {\n    copyConfig(this, config);\n    this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n\n    if (!this.isValid()) {\n      this._d = new Date(NaN);\n    } // Prevent infinite loop in case updateOffset creates new moment\n    // objects.\n\n\n    if (updateInProgress === false) {\n      updateInProgress = true;\n      hooks.updateOffset(this);\n      updateInProgress = false;\n    }\n  }\n\n  function isMoment(obj) {\n    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;\n  }\n\n  function warn(msg) {\n    if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {\n      console.warn('Deprecation warning: ' + msg);\n    }\n  }\n\n  function deprecate(msg, fn) {\n    var firstTime = true;\n    return extend(function () {\n      if (hooks.deprecationHandler != null) {\n        hooks.deprecationHandler(null, msg);\n      }\n\n      if (firstTime) {\n        var args = [],\n            arg,\n            i,\n            key,\n            argLen = arguments.length;\n\n        for (i = 0; i < argLen; i++) {\n          arg = '';\n\n          if (typeof arguments[i] === 'object') {\n            arg += '\\n[' + i + '] ';\n\n            for (key in arguments[0]) {\n              if (hasOwnProp(arguments[0], key)) {\n                arg += key + ': ' + arguments[0][key] + ', ';\n              }\n            }\n\n            arg = arg.slice(0, -2); // Remove trailing comma and space\n          } else {\n            arg = arguments[i];\n          }\n\n          args.push(arg);\n        }\n\n        warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + new Error().stack);\n        firstTime = false;\n      }\n\n      return fn.apply(this, arguments);\n    }, fn);\n  }\n\n  var deprecations = {};\n\n  function deprecateSimple(name, msg) {\n    if (hooks.deprecationHandler != null) {\n      hooks.deprecationHandler(name, msg);\n    }\n\n    if (!deprecations[name]) {\n      warn(msg);\n      deprecations[name] = true;\n    }\n  }\n\n  hooks.suppressDeprecationWarnings = false;\n  hooks.deprecationHandler = null;\n\n  function isFunction(input) {\n    return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n  }\n\n  function set(config) {\n    var prop, i;\n\n    for (i in config) {\n      if (hasOwnProp(config, i)) {\n        prop = config[i];\n\n        if (isFunction(prop)) {\n          this[i] = prop;\n        } else {\n          this['_' + i] = prop;\n        }\n      }\n    }\n\n    this._config = config; // Lenient ordinal parsing accepts just a number in addition to\n    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n\n    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\\d{1,2}/.source);\n  }\n\n  function mergeConfigs(parentConfig, childConfig) {\n    var res = extend({}, parentConfig),\n        prop;\n\n    for (prop in childConfig) {\n      if (hasOwnProp(childConfig, prop)) {\n        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n          res[prop] = {};\n          extend(res[prop], parentConfig[prop]);\n          extend(res[prop], childConfig[prop]);\n        } else if (childConfig[prop] != null) {\n          res[prop] = childConfig[prop];\n        } else {\n          delete res[prop];\n        }\n      }\n    }\n\n    for (prop in parentConfig) {\n      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {\n        // make sure changes to properties don't modify parent config\n        res[prop] = extend({}, res[prop]);\n      }\n    }\n\n    return res;\n  }\n\n  function Locale(config) {\n    if (config != null) {\n      this.set(config);\n    }\n  }\n\n  var keys;\n\n  if (Object.keys) {\n    keys = Object.keys;\n  } else {\n    keys = function keys(obj) {\n      var i,\n          res = [];\n\n      for (i in obj) {\n        if (hasOwnProp(obj, i)) {\n          res.push(i);\n        }\n      }\n\n      return res;\n    };\n  }\n\n  var defaultCalendar = {\n    sameDay: '[Today at] LT',\n    nextDay: '[Tomorrow at] LT',\n    nextWeek: 'dddd [at] LT',\n    lastDay: '[Yesterday at] LT',\n    lastWeek: '[Last] dddd [at] LT',\n    sameElse: 'L'\n  };\n\n  function calendar(key, mom, now) {\n    var output = this._calendar[key] || this._calendar['sameElse'];\n    return isFunction(output) ? output.call(mom, now) : output;\n  }\n\n  function zeroFill(number, targetLength, forceSign) {\n    var absNumber = '' + Math.abs(number),\n        zerosToFill = targetLength - absNumber.length,\n        sign = number >= 0;\n    return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n  }\n\n  var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,\n      localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,\n      formatFunctions = {},\n      formatTokenFunctions = {}; // token:    'M'\n  // padded:   ['MM', 2]\n  // ordinal:  'Mo'\n  // callback: function () { this.month() + 1 }\n\n  function addFormatToken(token, padded, ordinal, callback) {\n    var func = callback;\n\n    if (typeof callback === 'string') {\n      func = function func() {\n        return this[callback]();\n      };\n    }\n\n    if (token) {\n      formatTokenFunctions[token] = func;\n    }\n\n    if (padded) {\n      formatTokenFunctions[padded[0]] = function () {\n        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n      };\n    }\n\n    if (ordinal) {\n      formatTokenFunctions[ordinal] = function () {\n        return this.localeData().ordinal(func.apply(this, arguments), token);\n      };\n    }\n  }\n\n  function removeFormattingTokens(input) {\n    if (input.match(/\\[[\\s\\S]/)) {\n      return input.replace(/^\\[|\\]$/g, '');\n    }\n\n    return input.replace(/\\\\/g, '');\n  }\n\n  function makeFormatFunction(format) {\n    var array = format.match(formattingTokens),\n        i,\n        length;\n\n    for (i = 0, length = array.length; i < length; i++) {\n      if (formatTokenFunctions[array[i]]) {\n        array[i] = formatTokenFunctions[array[i]];\n      } else {\n        array[i] = removeFormattingTokens(array[i]);\n      }\n    }\n\n    return function (mom) {\n      var output = '',\n          i;\n\n      for (i = 0; i < length; i++) {\n        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n      }\n\n      return output;\n    };\n  } // format date using native date object\n\n\n  function formatMoment(m, format) {\n    if (!m.isValid()) {\n      return m.localeData().invalidDate();\n    }\n\n    format = expandFormat(format, m.localeData());\n    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n    return formatFunctions[format](m);\n  }\n\n  function expandFormat(format, locale) {\n    var i = 5;\n\n    function replaceLongDateFormatTokens(input) {\n      return locale.longDateFormat(input) || input;\n    }\n\n    localFormattingTokens.lastIndex = 0;\n\n    while (i >= 0 && localFormattingTokens.test(format)) {\n      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n      localFormattingTokens.lastIndex = 0;\n      i -= 1;\n    }\n\n    return format;\n  }\n\n  var defaultLongDateFormat = {\n    LTS: 'h:mm:ss A',\n    LT: 'h:mm A',\n    L: 'MM/DD/YYYY',\n    LL: 'MMMM D, YYYY',\n    LLL: 'MMMM D, YYYY h:mm A',\n    LLLL: 'dddd, MMMM D, YYYY h:mm A'\n  };\n\n  function longDateFormat(key) {\n    var format = this._longDateFormat[key],\n        formatUpper = this._longDateFormat[key.toUpperCase()];\n\n    if (format || !formatUpper) {\n      return format;\n    }\n\n    this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {\n      if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {\n        return tok.slice(1);\n      }\n\n      return tok;\n    }).join('');\n    return this._longDateFormat[key];\n  }\n\n  var defaultInvalidDate = 'Invalid date';\n\n  function invalidDate() {\n    return this._invalidDate;\n  }\n\n  var defaultOrdinal = '%d',\n      defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n  function ordinal(number) {\n    return this._ordinal.replace('%d', number);\n  }\n\n  var defaultRelativeTime = {\n    future: 'in %s',\n    past: '%s ago',\n    s: 'a few seconds',\n    ss: '%d seconds',\n    m: 'a minute',\n    mm: '%d minutes',\n    h: 'an hour',\n    hh: '%d hours',\n    d: 'a day',\n    dd: '%d days',\n    w: 'a week',\n    ww: '%d weeks',\n    M: 'a month',\n    MM: '%d months',\n    y: 'a year',\n    yy: '%d years'\n  };\n\n  function relativeTime(number, withoutSuffix, string, isFuture) {\n    var output = this._relativeTime[string];\n    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);\n  }\n\n  function pastFuture(diff, output) {\n    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n    return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n  }\n\n  var aliases = {};\n\n  function addUnitAlias(unit, shorthand) {\n    var lowerCase = unit.toLowerCase();\n    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n  }\n\n  function normalizeUnits(units) {\n    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n  }\n\n  function normalizeObjectUnits(inputObject) {\n    var normalizedInput = {},\n        normalizedProp,\n        prop;\n\n    for (prop in inputObject) {\n      if (hasOwnProp(inputObject, prop)) {\n        normalizedProp = normalizeUnits(prop);\n\n        if (normalizedProp) {\n          normalizedInput[normalizedProp] = inputObject[prop];\n        }\n      }\n    }\n\n    return normalizedInput;\n  }\n\n  var priorities = {};\n\n  function addUnitPriority(unit, priority) {\n    priorities[unit] = priority;\n  }\n\n  function getPrioritizedUnits(unitsObj) {\n    var units = [],\n        u;\n\n    for (u in unitsObj) {\n      if (hasOwnProp(unitsObj, u)) {\n        units.push({\n          unit: u,\n          priority: priorities[u]\n        });\n      }\n    }\n\n    units.sort(function (a, b) {\n      return a.priority - b.priority;\n    });\n    return units;\n  }\n\n  function isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n  }\n\n  function absFloor(number) {\n    if (number < 0) {\n      // -0 -> 0\n      return Math.ceil(number) || 0;\n    } else {\n      return Math.floor(number);\n    }\n  }\n\n  function toInt(argumentForCoercion) {\n    var coercedNumber = +argumentForCoercion,\n        value = 0;\n\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n      value = absFloor(coercedNumber);\n    }\n\n    return value;\n  }\n\n  function makeGetSet(unit, keepTime) {\n    return function (value) {\n      if (value != null) {\n        set$1(this, unit, value);\n        hooks.updateOffset(this, keepTime);\n        return this;\n      } else {\n        return get(this, unit);\n      }\n    };\n  }\n\n  function get(mom, unit) {\n    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n  }\n\n  function set$1(mom, unit, value) {\n    if (mom.isValid() && !isNaN(value)) {\n      if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n        value = toInt(value);\n\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n      } else {\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n      }\n    }\n  } // MOMENTS\n\n\n  function stringGet(units) {\n    units = normalizeUnits(units);\n\n    if (isFunction(this[units])) {\n      return this[units]();\n    }\n\n    return this;\n  }\n\n  function stringSet(units, value) {\n    if (typeof units === 'object') {\n      units = normalizeObjectUnits(units);\n      var prioritized = getPrioritizedUnits(units),\n          i,\n          prioritizedLen = prioritized.length;\n\n      for (i = 0; i < prioritizedLen; i++) {\n        this[prioritized[i].unit](units[prioritized[i].unit]);\n      }\n    } else {\n      units = normalizeUnits(units);\n\n      if (isFunction(this[units])) {\n        return this[units](value);\n      }\n    }\n\n    return this;\n  }\n\n  var match1 = /\\d/,\n      //       0 - 9\n  match2 = /\\d\\d/,\n      //      00 - 99\n  match3 = /\\d{3}/,\n      //     000 - 999\n  match4 = /\\d{4}/,\n      //    0000 - 9999\n  match6 = /[+-]?\\d{6}/,\n      // -999999 - 999999\n  match1to2 = /\\d\\d?/,\n      //       0 - 99\n  match3to4 = /\\d\\d\\d\\d?/,\n      //     999 - 9999\n  match5to6 = /\\d\\d\\d\\d\\d\\d?/,\n      //   99999 - 999999\n  match1to3 = /\\d{1,3}/,\n      //       0 - 999\n  match1to4 = /\\d{1,4}/,\n      //       0 - 9999\n  match1to6 = /[+-]?\\d{1,6}/,\n      // -999999 - 999999\n  matchUnsigned = /\\d+/,\n      //       0 - inf\n  matchSigned = /[+-]?\\d+/,\n      //    -inf - inf\n  matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi,\n      // +00:00 -00:00 +0000 -0000 or Z\n  matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi,\n      // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n  matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/,\n      // 123456789 123456789.123\n  // any word (or two) characters or numbers including two/three word month in arabic.\n  // includes scottish gaelic two word and hyphenated months\n  matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i,\n      regexes;\n  regexes = {};\n\n  function addRegexToken(token, regex, strictRegex) {\n    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n      return isStrict && strictRegex ? strictRegex : regex;\n    };\n  }\n\n  function getParseRegexForToken(token, config) {\n    if (!hasOwnProp(regexes, token)) {\n      return new RegExp(unescapeFormat(token));\n    }\n\n    return regexes[token](config._strict, config._locale);\n  } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n\n\n  function unescapeFormat(s) {\n    return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n      return p1 || p2 || p3 || p4;\n    }));\n  }\n\n  function regexEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  }\n\n  var tokens = {};\n\n  function addParseToken(token, callback) {\n    var i,\n        func = callback,\n        tokenLen;\n\n    if (typeof token === 'string') {\n      token = [token];\n    }\n\n    if (isNumber(callback)) {\n      func = function func(input, array) {\n        array[callback] = toInt(input);\n      };\n    }\n\n    tokenLen = token.length;\n\n    for (i = 0; i < tokenLen; i++) {\n      tokens[token[i]] = func;\n    }\n  }\n\n  function addWeekParseToken(token, callback) {\n    addParseToken(token, function (input, array, config, token) {\n      config._w = config._w || {};\n      callback(input, config._w, config, token);\n    });\n  }\n\n  function addTimeToArrayFromToken(token, input, config) {\n    if (input != null && hasOwnProp(tokens, token)) {\n      tokens[token](input, config._a, config, token);\n    }\n  }\n\n  var YEAR = 0,\n      MONTH = 1,\n      DATE = 2,\n      HOUR = 3,\n      MINUTE = 4,\n      SECOND = 5,\n      MILLISECOND = 6,\n      WEEK = 7,\n      WEEKDAY = 8;\n\n  function mod(n, x) {\n    return (n % x + x) % x;\n  }\n\n  var indexOf;\n\n  if (Array.prototype.indexOf) {\n    indexOf = Array.prototype.indexOf;\n  } else {\n    indexOf = function indexOf(o) {\n      // I know\n      var i;\n\n      for (i = 0; i < this.length; ++i) {\n        if (this[i] === o) {\n          return i;\n        }\n      }\n\n      return -1;\n    };\n  }\n\n  function daysInMonth(year, month) {\n    if (isNaN(year) || isNaN(month)) {\n      return NaN;\n    }\n\n    var modMonth = mod(month, 12);\n    year += (month - modMonth) / 12;\n    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;\n  } // FORMATTING\n\n\n  addFormatToken('M', ['MM', 2], 'Mo', function () {\n    return this.month() + 1;\n  });\n  addFormatToken('MMM', 0, 0, function (format) {\n    return this.localeData().monthsShort(this, format);\n  });\n  addFormatToken('MMMM', 0, 0, function (format) {\n    return this.localeData().months(this, format);\n  }); // ALIASES\n\n  addUnitAlias('month', 'M'); // PRIORITY\n\n  addUnitPriority('month', 8); // PARSING\n\n  addRegexToken('M', match1to2);\n  addRegexToken('MM', match1to2, match2);\n  addRegexToken('MMM', function (isStrict, locale) {\n    return locale.monthsShortRegex(isStrict);\n  });\n  addRegexToken('MMMM', function (isStrict, locale) {\n    return locale.monthsRegex(isStrict);\n  });\n  addParseToken(['M', 'MM'], function (input, array) {\n    array[MONTH] = toInt(input) - 1;\n  });\n  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n    var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.\n\n\n    if (month != null) {\n      array[MONTH] = month;\n    } else {\n      getParsingFlags(config).invalidMonth = input;\n    }\n  }); // LOCALES\n\n  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n      defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n      MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/,\n      defaultMonthsShortRegex = matchWord,\n      defaultMonthsRegex = matchWord;\n\n  function localeMonths(m, format) {\n    if (!m) {\n      return isArray(this._months) ? this._months : this._months['standalone'];\n    }\n\n    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n  }\n\n  function localeMonthsShort(m, format) {\n    if (!m) {\n      return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];\n    }\n\n    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n  }\n\n  function handleStrictParse(monthName, format, strict) {\n    var i,\n        ii,\n        mom,\n        llc = monthName.toLocaleLowerCase();\n\n    if (!this._monthsParse) {\n      // this is not used\n      this._monthsParse = [];\n      this._longMonthsParse = [];\n      this._shortMonthsParse = [];\n\n      for (i = 0; i < 12; ++i) {\n        mom = createUTC([2000, i]);\n        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n      }\n    }\n\n    if (strict) {\n      if (format === 'MMM') {\n        ii = indexOf.call(this._shortMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._longMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    } else {\n      if (format === 'MMM') {\n        ii = indexOf.call(this._shortMonthsParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._longMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._longMonthsParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._shortMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    }\n  }\n\n  function localeMonthsParse(monthName, format, strict) {\n    var i, mom, regex;\n\n    if (this._monthsParseExact) {\n      return handleStrictParse.call(this, monthName, format, strict);\n    }\n\n    if (!this._monthsParse) {\n      this._monthsParse = [];\n      this._longMonthsParse = [];\n      this._shortMonthsParse = [];\n    } // TODO: add sorting\n    // Sorting makes sure if one month (or abbr) is a prefix of another\n    // see sorting in computeMonthsParse\n\n\n    for (i = 0; i < 12; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, i]);\n\n      if (strict && !this._longMonthsParse[i]) {\n        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n      }\n\n      if (!strict && !this._monthsParse[i]) {\n        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n      } // test the regex\n\n\n      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n        return i;\n      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n        return i;\n      } else if (!strict && this._monthsParse[i].test(monthName)) {\n        return i;\n      }\n    }\n  } // MOMENTS\n\n\n  function setMonth(mom, value) {\n    var dayOfMonth;\n\n    if (!mom.isValid()) {\n      // No op\n      return mom;\n    }\n\n    if (typeof value === 'string') {\n      if (/^\\d+$/.test(value)) {\n        value = toInt(value);\n      } else {\n        value = mom.localeData().monthsParse(value); // TODO: Another silent failure?\n\n        if (!isNumber(value)) {\n          return mom;\n        }\n      }\n    }\n\n    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n\n    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n\n    return mom;\n  }\n\n  function getSetMonth(value) {\n    if (value != null) {\n      setMonth(this, value);\n      hooks.updateOffset(this, true);\n      return this;\n    } else {\n      return get(this, 'Month');\n    }\n  }\n\n  function getDaysInMonth() {\n    return daysInMonth(this.year(), this.month());\n  }\n\n  function monthsShortRegex(isStrict) {\n    if (this._monthsParseExact) {\n      if (!hasOwnProp(this, '_monthsRegex')) {\n        computeMonthsParse.call(this);\n      }\n\n      if (isStrict) {\n        return this._monthsShortStrictRegex;\n      } else {\n        return this._monthsShortRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_monthsShortRegex')) {\n        this._monthsShortRegex = defaultMonthsShortRegex;\n      }\n\n      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;\n    }\n  }\n\n  function monthsRegex(isStrict) {\n    if (this._monthsParseExact) {\n      if (!hasOwnProp(this, '_monthsRegex')) {\n        computeMonthsParse.call(this);\n      }\n\n      if (isStrict) {\n        return this._monthsStrictRegex;\n      } else {\n        return this._monthsRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_monthsRegex')) {\n        this._monthsRegex = defaultMonthsRegex;\n      }\n\n      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;\n    }\n  }\n\n  function computeMonthsParse() {\n    function cmpLenRev(a, b) {\n      return b.length - a.length;\n    }\n\n    var shortPieces = [],\n        longPieces = [],\n        mixedPieces = [],\n        i,\n        mom;\n\n    for (i = 0; i < 12; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, i]);\n      shortPieces.push(this.monthsShort(mom, ''));\n      longPieces.push(this.months(mom, ''));\n      mixedPieces.push(this.months(mom, ''));\n      mixedPieces.push(this.monthsShort(mom, ''));\n    } // Sorting makes sure if one month (or abbr) is a prefix of another it\n    // will match the longer piece.\n\n\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n\n    for (i = 0; i < 12; i++) {\n      shortPieces[i] = regexEscape(shortPieces[i]);\n      longPieces[i] = regexEscape(longPieces[i]);\n    }\n\n    for (i = 0; i < 24; i++) {\n      mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n\n    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._monthsShortRegex = this._monthsRegex;\n    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n  } // FORMATTING\n\n\n  addFormatToken('Y', 0, 0, function () {\n    var y = this.year();\n    return y <= 9999 ? zeroFill(y, 4) : '+' + y;\n  });\n  addFormatToken(0, ['YY', 2], 0, function () {\n    return this.year() % 100;\n  });\n  addFormatToken(0, ['YYYY', 4], 0, 'year');\n  addFormatToken(0, ['YYYYY', 5], 0, 'year');\n  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES\n\n  addUnitAlias('year', 'y'); // PRIORITIES\n\n  addUnitPriority('year', 1); // PARSING\n\n  addRegexToken('Y', matchSigned);\n  addRegexToken('YY', match1to2, match2);\n  addRegexToken('YYYY', match1to4, match4);\n  addRegexToken('YYYYY', match1to6, match6);\n  addRegexToken('YYYYYY', match1to6, match6);\n  addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n  addParseToken('YYYY', function (input, array) {\n    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n  });\n  addParseToken('YY', function (input, array) {\n    array[YEAR] = hooks.parseTwoDigitYear(input);\n  });\n  addParseToken('Y', function (input, array) {\n    array[YEAR] = parseInt(input, 10);\n  }); // HELPERS\n\n  function daysInYear(year) {\n    return isLeapYear(year) ? 366 : 365;\n  } // HOOKS\n\n\n  hooks.parseTwoDigitYear = function (input) {\n    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n  }; // MOMENTS\n\n\n  var getSetYear = makeGetSet('FullYear', true);\n\n  function getIsLeapYear() {\n    return isLeapYear(this.year());\n  }\n\n  function createDate(y, m, d, h, M, s, ms) {\n    // can't just apply() to create a date:\n    // https://stackoverflow.com/q/181348\n    var date; // the date constructor remaps years 0-99 to 1900-1999\n\n    if (y < 100 && y >= 0) {\n      // preserve leap years using a full 400 year cycle, then reset\n      date = new Date(y + 400, m, d, h, M, s, ms);\n\n      if (isFinite(date.getFullYear())) {\n        date.setFullYear(y);\n      }\n    } else {\n      date = new Date(y, m, d, h, M, s, ms);\n    }\n\n    return date;\n  }\n\n  function createUTCDate(y) {\n    var date, args; // the Date.UTC function remaps years 0-99 to 1900-1999\n\n    if (y < 100 && y >= 0) {\n      args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset\n\n      args[0] = y + 400;\n      date = new Date(Date.UTC.apply(null, args));\n\n      if (isFinite(date.getUTCFullYear())) {\n        date.setUTCFullYear(y);\n      }\n    } else {\n      date = new Date(Date.UTC.apply(null, arguments));\n    }\n\n    return date;\n  } // start-of-first-week - start-of-year\n\n\n  function firstWeekOffset(year, dow, doy) {\n    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n    fwd = 7 + dow - doy,\n        // first-week day local weekday -- which local weekday is fwd\n    fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n    return -fwdlw + fwd - 1;\n  } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n\n\n  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n    var localWeekday = (7 + weekday - dow) % 7,\n        weekOffset = firstWeekOffset(year, dow, doy),\n        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n        resYear,\n        resDayOfYear;\n\n    if (dayOfYear <= 0) {\n      resYear = year - 1;\n      resDayOfYear = daysInYear(resYear) + dayOfYear;\n    } else if (dayOfYear > daysInYear(year)) {\n      resYear = year + 1;\n      resDayOfYear = dayOfYear - daysInYear(year);\n    } else {\n      resYear = year;\n      resDayOfYear = dayOfYear;\n    }\n\n    return {\n      year: resYear,\n      dayOfYear: resDayOfYear\n    };\n  }\n\n  function weekOfYear(mom, dow, doy) {\n    var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n        resWeek,\n        resYear;\n\n    if (week < 1) {\n      resYear = mom.year() - 1;\n      resWeek = week + weeksInYear(resYear, dow, doy);\n    } else if (week > weeksInYear(mom.year(), dow, doy)) {\n      resWeek = week - weeksInYear(mom.year(), dow, doy);\n      resYear = mom.year() + 1;\n    } else {\n      resYear = mom.year();\n      resWeek = week;\n    }\n\n    return {\n      week: resWeek,\n      year: resYear\n    };\n  }\n\n  function weeksInYear(year, dow, doy) {\n    var weekOffset = firstWeekOffset(year, dow, doy),\n        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n  } // FORMATTING\n\n\n  addFormatToken('w', ['ww', 2], 'wo', 'week');\n  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES\n\n  addUnitAlias('week', 'w');\n  addUnitAlias('isoWeek', 'W'); // PRIORITIES\n\n  addUnitPriority('week', 5);\n  addUnitPriority('isoWeek', 5); // PARSING\n\n  addRegexToken('w', match1to2);\n  addRegexToken('ww', match1to2, match2);\n  addRegexToken('W', match1to2);\n  addRegexToken('WW', match1to2, match2);\n  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n    week[token.substr(0, 1)] = toInt(input);\n  }); // HELPERS\n  // LOCALES\n\n  function localeWeek(mom) {\n    return weekOfYear(mom, this._week.dow, this._week.doy).week;\n  }\n\n  var defaultLocaleWeek = {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 6th is the first week of the year.\n\n  };\n\n  function localeFirstDayOfWeek() {\n    return this._week.dow;\n  }\n\n  function localeFirstDayOfYear() {\n    return this._week.doy;\n  } // MOMENTS\n\n\n  function getSetWeek(input) {\n    var week = this.localeData().week(this);\n    return input == null ? week : this.add((input - week) * 7, 'd');\n  }\n\n  function getSetISOWeek(input) {\n    var week = weekOfYear(this, 1, 4).week;\n    return input == null ? week : this.add((input - week) * 7, 'd');\n  } // FORMATTING\n\n\n  addFormatToken('d', 0, 'do', 'day');\n  addFormatToken('dd', 0, 0, function (format) {\n    return this.localeData().weekdaysMin(this, format);\n  });\n  addFormatToken('ddd', 0, 0, function (format) {\n    return this.localeData().weekdaysShort(this, format);\n  });\n  addFormatToken('dddd', 0, 0, function (format) {\n    return this.localeData().weekdays(this, format);\n  });\n  addFormatToken('e', 0, 0, 'weekday');\n  addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES\n\n  addUnitAlias('day', 'd');\n  addUnitAlias('weekday', 'e');\n  addUnitAlias('isoWeekday', 'E'); // PRIORITY\n\n  addUnitPriority('day', 11);\n  addUnitPriority('weekday', 11);\n  addUnitPriority('isoWeekday', 11); // PARSING\n\n  addRegexToken('d', match1to2);\n  addRegexToken('e', match1to2);\n  addRegexToken('E', match1to2);\n  addRegexToken('dd', function (isStrict, locale) {\n    return locale.weekdaysMinRegex(isStrict);\n  });\n  addRegexToken('ddd', function (isStrict, locale) {\n    return locale.weekdaysShortRegex(isStrict);\n  });\n  addRegexToken('dddd', function (isStrict, locale) {\n    return locale.weekdaysRegex(isStrict);\n  });\n  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n    var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid\n\n\n    if (weekday != null) {\n      week.d = weekday;\n    } else {\n      getParsingFlags(config).invalidWeekday = input;\n    }\n  });\n  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n    week[token] = toInt(input);\n  }); // HELPERS\n\n  function parseWeekday(input, locale) {\n    if (typeof input !== 'string') {\n      return input;\n    }\n\n    if (!isNaN(input)) {\n      return parseInt(input, 10);\n    }\n\n    input = locale.weekdaysParse(input);\n\n    if (typeof input === 'number') {\n      return input;\n    }\n\n    return null;\n  }\n\n  function parseIsoWeekday(input, locale) {\n    if (typeof input === 'string') {\n      return locale.weekdaysParse(input) % 7 || 7;\n    }\n\n    return isNaN(input) ? null : input;\n  } // LOCALES\n\n\n  function shiftWeekdays(ws, n) {\n    return ws.slice(n, 7).concat(ws.slice(0, n));\n  }\n\n  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n      defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n      defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n      defaultWeekdaysRegex = matchWord,\n      defaultWeekdaysShortRegex = matchWord,\n      defaultWeekdaysMinRegex = matchWord;\n\n  function localeWeekdays(m, format) {\n    var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];\n    return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;\n  }\n\n  function localeWeekdaysShort(m) {\n    return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n  }\n\n  function localeWeekdaysMin(m) {\n    return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n  }\n\n  function handleStrictParse$1(weekdayName, format, strict) {\n    var i,\n        ii,\n        mom,\n        llc = weekdayName.toLocaleLowerCase();\n\n    if (!this._weekdaysParse) {\n      this._weekdaysParse = [];\n      this._shortWeekdaysParse = [];\n      this._minWeekdaysParse = [];\n\n      for (i = 0; i < 7; ++i) {\n        mom = createUTC([2000, 1]).day(i);\n        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n      }\n    }\n\n    if (strict) {\n      if (format === 'dddd') {\n        ii = indexOf.call(this._weekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else if (format === 'ddd') {\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    } else {\n      if (format === 'dddd') {\n        ii = indexOf.call(this._weekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else if (format === 'ddd') {\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._weekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._weekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    }\n  }\n\n  function localeWeekdaysParse(weekdayName, format, strict) {\n    var i, mom, regex;\n\n    if (this._weekdaysParseExact) {\n      return handleStrictParse$1.call(this, weekdayName, format, strict);\n    }\n\n    if (!this._weekdaysParse) {\n      this._weekdaysParse = [];\n      this._minWeekdaysParse = [];\n      this._shortWeekdaysParse = [];\n      this._fullWeekdaysParse = [];\n    }\n\n    for (i = 0; i < 7; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, 1]).day(i);\n\n      if (strict && !this._fullWeekdaysParse[i]) {\n        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\n        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\n        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\n      }\n\n      if (!this._weekdaysParse[i]) {\n        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n      } // test the regex\n\n\n      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n        return i;\n      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n        return i;\n      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n        return i;\n      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n        return i;\n      }\n    }\n  } // MOMENTS\n\n\n  function getSetDayOfWeek(input) {\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    }\n\n    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n\n    if (input != null) {\n      input = parseWeekday(input, this.localeData());\n      return this.add(input - day, 'd');\n    } else {\n      return day;\n    }\n  }\n\n  function getSetLocaleDayOfWeek(input) {\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    }\n\n    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n    return input == null ? weekday : this.add(input - weekday, 'd');\n  }\n\n  function getSetISODayOfWeek(input) {\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    } // behaves the same as moment#day except\n    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n    // as a setter, sunday should belong to the previous week.\n\n\n    if (input != null) {\n      var weekday = parseIsoWeekday(input, this.localeData());\n      return this.day(this.day() % 7 ? weekday : weekday - 7);\n    } else {\n      return this.day() || 7;\n    }\n  }\n\n  function weekdaysRegex(isStrict) {\n    if (this._weekdaysParseExact) {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        computeWeekdaysParse.call(this);\n      }\n\n      if (isStrict) {\n        return this._weekdaysStrictRegex;\n      } else {\n        return this._weekdaysRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        this._weekdaysRegex = defaultWeekdaysRegex;\n      }\n\n      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;\n    }\n  }\n\n  function weekdaysShortRegex(isStrict) {\n    if (this._weekdaysParseExact) {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        computeWeekdaysParse.call(this);\n      }\n\n      if (isStrict) {\n        return this._weekdaysShortStrictRegex;\n      } else {\n        return this._weekdaysShortRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n        this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n      }\n\n      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n    }\n  }\n\n  function weekdaysMinRegex(isStrict) {\n    if (this._weekdaysParseExact) {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        computeWeekdaysParse.call(this);\n      }\n\n      if (isStrict) {\n        return this._weekdaysMinStrictRegex;\n      } else {\n        return this._weekdaysMinRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n        this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n      }\n\n      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n    }\n  }\n\n  function computeWeekdaysParse() {\n    function cmpLenRev(a, b) {\n      return b.length - a.length;\n    }\n\n    var minPieces = [],\n        shortPieces = [],\n        longPieces = [],\n        mixedPieces = [],\n        i,\n        mom,\n        minp,\n        shortp,\n        longp;\n\n    for (i = 0; i < 7; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, 1]).day(i);\n      minp = regexEscape(this.weekdaysMin(mom, ''));\n      shortp = regexEscape(this.weekdaysShort(mom, ''));\n      longp = regexEscape(this.weekdays(mom, ''));\n      minPieces.push(minp);\n      shortPieces.push(shortp);\n      longPieces.push(longp);\n      mixedPieces.push(minp);\n      mixedPieces.push(shortp);\n      mixedPieces.push(longp);\n    } // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n    // will match the longer piece.\n\n\n    minPieces.sort(cmpLenRev);\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._weekdaysShortRegex = this._weekdaysRegex;\n    this._weekdaysMinRegex = this._weekdaysRegex;\n    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n  } // FORMATTING\n\n\n  function hFormat() {\n    return this.hours() % 12 || 12;\n  }\n\n  function kFormat() {\n    return this.hours() || 24;\n  }\n\n  addFormatToken('H', ['HH', 2], 0, 'hour');\n  addFormatToken('h', ['hh', 2], 0, hFormat);\n  addFormatToken('k', ['kk', 2], 0, kFormat);\n  addFormatToken('hmm', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n  });\n  addFormatToken('hmmss', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n  });\n  addFormatToken('Hmm', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2);\n  });\n  addFormatToken('Hmmss', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n  });\n\n  function meridiem(token, lowercase) {\n    addFormatToken(token, 0, 0, function () {\n      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n    });\n  }\n\n  meridiem('a', true);\n  meridiem('A', false); // ALIASES\n\n  addUnitAlias('hour', 'h'); // PRIORITY\n\n  addUnitPriority('hour', 13); // PARSING\n\n  function matchMeridiem(isStrict, locale) {\n    return locale._meridiemParse;\n  }\n\n  addRegexToken('a', matchMeridiem);\n  addRegexToken('A', matchMeridiem);\n  addRegexToken('H', match1to2);\n  addRegexToken('h', match1to2);\n  addRegexToken('k', match1to2);\n  addRegexToken('HH', match1to2, match2);\n  addRegexToken('hh', match1to2, match2);\n  addRegexToken('kk', match1to2, match2);\n  addRegexToken('hmm', match3to4);\n  addRegexToken('hmmss', match5to6);\n  addRegexToken('Hmm', match3to4);\n  addRegexToken('Hmmss', match5to6);\n  addParseToken(['H', 'HH'], HOUR);\n  addParseToken(['k', 'kk'], function (input, array, config) {\n    var kInput = toInt(input);\n    array[HOUR] = kInput === 24 ? 0 : kInput;\n  });\n  addParseToken(['a', 'A'], function (input, array, config) {\n    config._isPm = config._locale.isPM(input);\n    config._meridiem = input;\n  });\n  addParseToken(['h', 'hh'], function (input, array, config) {\n    array[HOUR] = toInt(input);\n    getParsingFlags(config).bigHour = true;\n  });\n  addParseToken('hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n    getParsingFlags(config).bigHour = true;\n  });\n  addParseToken('hmmss', function (input, array, config) {\n    var pos1 = input.length - 4,\n        pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n    getParsingFlags(config).bigHour = true;\n  });\n  addParseToken('Hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n  });\n  addParseToken('Hmmss', function (input, array, config) {\n    var pos1 = input.length - 4,\n        pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n  }); // LOCALES\n\n  function localeIsPM(input) {\n    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n    // Using charAt should be more compatible.\n    return (input + '').toLowerCase().charAt(0) === 'p';\n  }\n\n  var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i,\n      // Setting the hour should keep the time, because the user explicitly\n  // specified which hour they want. So trying to maintain the same hour (in\n  // a new timezone) makes sense. Adding/subtracting hours does not follow\n  // this rule.\n  getSetHour = makeGetSet('Hours', true);\n\n  function localeMeridiem(hours, minutes, isLower) {\n    if (hours > 11) {\n      return isLower ? 'pm' : 'PM';\n    } else {\n      return isLower ? 'am' : 'AM';\n    }\n  }\n\n  var baseConfig = {\n    calendar: defaultCalendar,\n    longDateFormat: defaultLongDateFormat,\n    invalidDate: defaultInvalidDate,\n    ordinal: defaultOrdinal,\n    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n    relativeTime: defaultRelativeTime,\n    months: defaultLocaleMonths,\n    monthsShort: defaultLocaleMonthsShort,\n    week: defaultLocaleWeek,\n    weekdays: defaultLocaleWeekdays,\n    weekdaysMin: defaultLocaleWeekdaysMin,\n    weekdaysShort: defaultLocaleWeekdaysShort,\n    meridiemParse: defaultLocaleMeridiemParse\n  }; // internal storage for locale config files\n\n  var locales = {},\n      localeFamilies = {},\n      globalLocale;\n\n  function commonPrefix(arr1, arr2) {\n    var i,\n        minl = Math.min(arr1.length, arr2.length);\n\n    for (i = 0; i < minl; i += 1) {\n      if (arr1[i] !== arr2[i]) {\n        return i;\n      }\n    }\n\n    return minl;\n  }\n\n  function normalizeLocale(key) {\n    return key ? key.toLowerCase().replace('_', '-') : key;\n  } // pick the locale from the array\n  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n\n\n  function chooseLocale(names) {\n    var i = 0,\n        j,\n        next,\n        locale,\n        split;\n\n    while (i < names.length) {\n      split = normalizeLocale(names[i]).split('-');\n      j = split.length;\n      next = normalizeLocale(names[i + 1]);\n      next = next ? next.split('-') : null;\n\n      while (j > 0) {\n        locale = loadLocale(split.slice(0, j).join('-'));\n\n        if (locale) {\n          return locale;\n        }\n\n        if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {\n          //the next array item is better than a shallower substring of this one\n          break;\n        }\n\n        j--;\n      }\n\n      i++;\n    }\n\n    return globalLocale;\n  }\n\n  function isLocaleNameSane(name) {\n    // Prevent names that look like filesystem paths, i.e contain '/' or '\\'\n    return name.match('^[^/\\\\\\\\]*$') != null;\n  }\n\n  function loadLocale(name) {\n    var oldLocale = null,\n        aliasedRequire; // TODO: Find a better way to register and load all the locales in Node\n\n    if (locales[name] === undefined && typeof module !== 'undefined' && module && module.exports && isLocaleNameSane(name)) {\n      try {\n        oldLocale = globalLocale._abbr;\n        aliasedRequire = require;\n        __webpack_require__(\"RnhZ\")(\"./\" + name);\n        getSetGlobalLocale(oldLocale);\n      } catch (e) {\n        // mark as not found to avoid repeating expensive file require call causing high CPU\n        // when trying to find en-US, en_US, en-us for every format call\n        locales[name] = null; // null means not found\n      }\n    }\n\n    return locales[name];\n  } // This function will load locale and then set the global locale.  If\n  // no arguments are passed in, it will simply return the current global\n  // locale key.\n\n\n  function getSetGlobalLocale(key, values) {\n    var data;\n\n    if (key) {\n      if (isUndefined(values)) {\n        data = getLocale(key);\n      } else {\n        data = defineLocale(key, values);\n      }\n\n      if (data) {\n        // moment.duration._locale = moment._locale = data;\n        globalLocale = data;\n      } else {\n        if (typeof console !== 'undefined' && console.warn) {\n          //warn user if arguments are passed but the locale could not be set\n          console.warn('Locale ' + key + ' not found. Did you forget to load it?');\n        }\n      }\n    }\n\n    return globalLocale._abbr;\n  }\n\n  function defineLocale(name, config) {\n    if (config !== null) {\n      var locale,\n          parentConfig = baseConfig;\n      config.abbr = name;\n\n      if (locales[name] != null) {\n        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n        parentConfig = locales[name]._config;\n      } else if (config.parentLocale != null) {\n        if (locales[config.parentLocale] != null) {\n          parentConfig = locales[config.parentLocale]._config;\n        } else {\n          locale = loadLocale(config.parentLocale);\n\n          if (locale != null) {\n            parentConfig = locale._config;\n          } else {\n            if (!localeFamilies[config.parentLocale]) {\n              localeFamilies[config.parentLocale] = [];\n            }\n\n            localeFamilies[config.parentLocale].push({\n              name: name,\n              config: config\n            });\n            return null;\n          }\n        }\n      }\n\n      locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n      if (localeFamilies[name]) {\n        localeFamilies[name].forEach(function (x) {\n          defineLocale(x.name, x.config);\n        });\n      } // backwards compat for now: also set the locale\n      // make sure we set the locale AFTER all child locales have been\n      // created, so we won't end up with the child locale set.\n\n\n      getSetGlobalLocale(name);\n      return locales[name];\n    } else {\n      // useful for testing\n      delete locales[name];\n      return null;\n    }\n  }\n\n  function updateLocale(name, config) {\n    if (config != null) {\n      var locale,\n          tmpLocale,\n          parentConfig = baseConfig;\n\n      if (locales[name] != null && locales[name].parentLocale != null) {\n        // Update existing child locale in-place to avoid memory-leaks\n        locales[name].set(mergeConfigs(locales[name]._config, config));\n      } else {\n        // MERGE\n        tmpLocale = loadLocale(name);\n\n        if (tmpLocale != null) {\n          parentConfig = tmpLocale._config;\n        }\n\n        config = mergeConfigs(parentConfig, config);\n\n        if (tmpLocale == null) {\n          // updateLocale is called for creating a new locale\n          // Set abbr so it will have a name (getters return\n          // undefined otherwise).\n          config.abbr = name;\n        }\n\n        locale = new Locale(config);\n        locale.parentLocale = locales[name];\n        locales[name] = locale;\n      } // backwards compat for now: also set the locale\n\n\n      getSetGlobalLocale(name);\n    } else {\n      // pass null for config to unupdate, useful for tests\n      if (locales[name] != null) {\n        if (locales[name].parentLocale != null) {\n          locales[name] = locales[name].parentLocale;\n\n          if (name === getSetGlobalLocale()) {\n            getSetGlobalLocale(name);\n          }\n        } else if (locales[name] != null) {\n          delete locales[name];\n        }\n      }\n    }\n\n    return locales[name];\n  } // returns locale data\n\n\n  function getLocale(key) {\n    var locale;\n\n    if (key && key._locale && key._locale._abbr) {\n      key = key._locale._abbr;\n    }\n\n    if (!key) {\n      return globalLocale;\n    }\n\n    if (!isArray(key)) {\n      //short-circuit everything else\n      locale = loadLocale(key);\n\n      if (locale) {\n        return locale;\n      }\n\n      key = [key];\n    }\n\n    return chooseLocale(key);\n  }\n\n  function listLocales() {\n    return keys(locales);\n  }\n\n  function checkOverflow(m) {\n    var overflow,\n        a = m._a;\n\n    if (a && getParsingFlags(m).overflow === -2) {\n      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;\n\n      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n        overflow = DATE;\n      }\n\n      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n        overflow = WEEK;\n      }\n\n      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n        overflow = WEEKDAY;\n      }\n\n      getParsingFlags(m).overflow = overflow;\n    }\n\n    return m;\n  } // iso 8601 regex\n  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n\n\n  var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n      basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n      tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/,\n      isoDates = [['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/], ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/], ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/], ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false], ['YYYY-DDD', /\\d{4}-\\d{3}/], ['YYYY-MM', /\\d{4}-\\d\\d/, false], ['YYYYYYMMDD', /[+-]\\d{10}/], ['YYYYMMDD', /\\d{8}/], ['GGGG[W]WWE', /\\d{4}W\\d{3}/], ['GGGG[W]WW', /\\d{4}W\\d{2}/, false], ['YYYYDDD', /\\d{7}/], ['YYYYMM', /\\d{6}/, false], ['YYYY', /\\d{4}/, false]],\n      // iso time formats and regexes\n  isoTimes = [['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/], ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/], ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/], ['HH:mm', /\\d\\d:\\d\\d/], ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/], ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/], ['HHmmss', /\\d\\d\\d\\d\\d\\d/], ['HHmm', /\\d\\d\\d\\d/], ['HH', /\\d\\d/]],\n      aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i,\n      // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n  rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/,\n      obsOffsets = {\n    UT: 0,\n    GMT: 0,\n    EDT: -4 * 60,\n    EST: -5 * 60,\n    CDT: -5 * 60,\n    CST: -6 * 60,\n    MDT: -6 * 60,\n    MST: -7 * 60,\n    PDT: -7 * 60,\n    PST: -8 * 60\n  }; // date from iso format\n\n  function configFromISO(config) {\n    var i,\n        l,\n        string = config._i,\n        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n        allowTime,\n        dateFormat,\n        timeFormat,\n        tzFormat,\n        isoDatesLen = isoDates.length,\n        isoTimesLen = isoTimes.length;\n\n    if (match) {\n      getParsingFlags(config).iso = true;\n\n      for (i = 0, l = isoDatesLen; i < l; i++) {\n        if (isoDates[i][1].exec(match[1])) {\n          dateFormat = isoDates[i][0];\n          allowTime = isoDates[i][2] !== false;\n          break;\n        }\n      }\n\n      if (dateFormat == null) {\n        config._isValid = false;\n        return;\n      }\n\n      if (match[3]) {\n        for (i = 0, l = isoTimesLen; i < l; i++) {\n          if (isoTimes[i][1].exec(match[3])) {\n            // match[2] should be 'T' or space\n            timeFormat = (match[2] || ' ') + isoTimes[i][0];\n            break;\n          }\n        }\n\n        if (timeFormat == null) {\n          config._isValid = false;\n          return;\n        }\n      }\n\n      if (!allowTime && timeFormat != null) {\n        config._isValid = false;\n        return;\n      }\n\n      if (match[4]) {\n        if (tzRegex.exec(match[4])) {\n          tzFormat = 'Z';\n        } else {\n          config._isValid = false;\n          return;\n        }\n      }\n\n      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n      configFromStringAndFormat(config);\n    } else {\n      config._isValid = false;\n    }\n  }\n\n  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n    var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];\n\n    if (secondStr) {\n      result.push(parseInt(secondStr, 10));\n    }\n\n    return result;\n  }\n\n  function untruncateYear(yearStr) {\n    var year = parseInt(yearStr, 10);\n\n    if (year <= 49) {\n      return 2000 + year;\n    } else if (year <= 999) {\n      return 1900 + year;\n    }\n\n    return year;\n  }\n\n  function preprocessRFC2822(s) {\n    // Remove comments and folding whitespace and replace multiple-spaces with a single space\n    return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n  }\n\n  function checkWeekday(weekdayStr, parsedInput, config) {\n    if (weekdayStr) {\n      // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\n      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n          weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n\n      if (weekdayProvided !== weekdayActual) {\n        getParsingFlags(config).weekdayMismatch = true;\n        config._isValid = false;\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function calculateOffset(obsOffset, militaryOffset, numOffset) {\n    if (obsOffset) {\n      return obsOffsets[obsOffset];\n    } else if (militaryOffset) {\n      // the only allowed military tz is Z\n      return 0;\n    } else {\n      var hm = parseInt(numOffset, 10),\n          m = hm % 100,\n          h = (hm - m) / 100;\n      return h * 60 + m;\n    }\n  } // date and time from ref 2822 format\n\n\n  function configFromRFC2822(config) {\n    var match = rfc2822.exec(preprocessRFC2822(config._i)),\n        parsedArray;\n\n    if (match) {\n      parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n\n      if (!checkWeekday(match[1], parsedArray, config)) {\n        return;\n      }\n\n      config._a = parsedArray;\n      config._tzm = calculateOffset(match[8], match[9], match[10]);\n      config._d = createUTCDate.apply(null, config._a);\n\n      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n      getParsingFlags(config).rfc2822 = true;\n    } else {\n      config._isValid = false;\n    }\n  } // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\n\n\n  function configFromString(config) {\n    var matched = aspNetJsonRegex.exec(config._i);\n\n    if (matched !== null) {\n      config._d = new Date(+matched[1]);\n      return;\n    }\n\n    configFromISO(config);\n\n    if (config._isValid === false) {\n      delete config._isValid;\n    } else {\n      return;\n    }\n\n    configFromRFC2822(config);\n\n    if (config._isValid === false) {\n      delete config._isValid;\n    } else {\n      return;\n    }\n\n    if (config._strict) {\n      config._isValid = false;\n    } else {\n      // Final attempt, use Input Fallback\n      hooks.createFromInputFallback(config);\n    }\n  }\n\n  hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {\n    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n  }); // Pick the first defined of two or three arguments.\n\n  function defaults(a, b, c) {\n    if (a != null) {\n      return a;\n    }\n\n    if (b != null) {\n      return b;\n    }\n\n    return c;\n  }\n\n  function currentDateArray(config) {\n    // hooks is actually the exported moment object\n    var nowValue = new Date(hooks.now());\n\n    if (config._useUTC) {\n      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n    }\n\n    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n  } // convert an array to a date.\n  // the array should mirror the parameters below\n  // note: all values past the year are optional and will default to the lowest possible value.\n  // [year, month, day , hour, minute, second, millisecond]\n\n\n  function configFromArray(config) {\n    var i,\n        date,\n        input = [],\n        currentDate,\n        expectedWeekday,\n        yearToUse;\n\n    if (config._d) {\n      return;\n    }\n\n    currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays\n\n    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n      dayOfYearFromWeekInfo(config);\n    } //if the day of the year is set, figure out what it is\n\n\n    if (config._dayOfYear != null) {\n      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n        getParsingFlags(config)._overflowDayOfYear = true;\n      }\n\n      date = createUTCDate(yearToUse, 0, config._dayOfYear);\n      config._a[MONTH] = date.getUTCMonth();\n      config._a[DATE] = date.getUTCDate();\n    } // Default to current date.\n    // * if no year, month, day of month are given, default to today\n    // * if day of month is given, default month and year\n    // * if month is given, default only year\n    // * if year is given, don't default anything\n\n\n    for (i = 0; i < 3 && config._a[i] == null; ++i) {\n      config._a[i] = input[i] = currentDate[i];\n    } // Zero out whatever was not defaulted, including time\n\n\n    for (; i < 7; i++) {\n      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];\n    } // Check for 24:00:00.000\n\n\n    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {\n      config._nextDay = true;\n      config._a[HOUR] = 0;\n    }\n\n    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed\n    // with parseZone.\n\n    if (config._tzm != null) {\n      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n    }\n\n    if (config._nextDay) {\n      config._a[HOUR] = 24;\n    } // check for mismatching day of week\n\n\n    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n      getParsingFlags(config).weekdayMismatch = true;\n    }\n  }\n\n  function dayOfYearFromWeekInfo(config) {\n    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;\n    w = config._w;\n\n    if (w.GG != null || w.W != null || w.E != null) {\n      dow = 1;\n      doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on\n      // how we interpret now (local, utc, fixed offset). So create\n      // a now version of current config (take local/utc/offset flags, and\n      // create now).\n\n      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n      week = defaults(w.W, 1);\n      weekday = defaults(w.E, 1);\n\n      if (weekday < 1 || weekday > 7) {\n        weekdayOverflow = true;\n      }\n    } else {\n      dow = config._locale._week.dow;\n      doy = config._locale._week.doy;\n      curWeek = weekOfYear(createLocal(), dow, doy);\n      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.\n\n      week = defaults(w.w, curWeek.week);\n\n      if (w.d != null) {\n        // weekday -- low day numbers are considered next week\n        weekday = w.d;\n\n        if (weekday < 0 || weekday > 6) {\n          weekdayOverflow = true;\n        }\n      } else if (w.e != null) {\n        // local weekday -- counting starts from beginning of week\n        weekday = w.e + dow;\n\n        if (w.e < 0 || w.e > 6) {\n          weekdayOverflow = true;\n        }\n      } else {\n        // default to beginning of week\n        weekday = dow;\n      }\n    }\n\n    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n      getParsingFlags(config)._overflowWeeks = true;\n    } else if (weekdayOverflow != null) {\n      getParsingFlags(config)._overflowWeekday = true;\n    } else {\n      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n      config._a[YEAR] = temp.year;\n      config._dayOfYear = temp.dayOfYear;\n    }\n  } // constant that refers to the ISO standard\n\n\n  hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form\n\n\n  hooks.RFC_2822 = function () {}; // date from string and format string\n\n\n  function configFromStringAndFormat(config) {\n    // TODO: Move this to another part of the creation flow to prevent circular deps\n    if (config._f === hooks.ISO_8601) {\n      configFromISO(config);\n      return;\n    }\n\n    if (config._f === hooks.RFC_2822) {\n      configFromRFC2822(config);\n      return;\n    }\n\n    config._a = [];\n    getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`\n\n    var string = '' + config._i,\n        i,\n        parsedInput,\n        tokens,\n        token,\n        skipped,\n        stringLength = string.length,\n        totalParsedInputLength = 0,\n        era,\n        tokenLen;\n    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n    tokenLen = tokens.length;\n\n    for (i = 0; i < tokenLen; i++) {\n      token = tokens[i];\n      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n\n      if (parsedInput) {\n        skipped = string.substr(0, string.indexOf(parsedInput));\n\n        if (skipped.length > 0) {\n          getParsingFlags(config).unusedInput.push(skipped);\n        }\n\n        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n        totalParsedInputLength += parsedInput.length;\n      } // don't parse if it's not a known token\n\n\n      if (formatTokenFunctions[token]) {\n        if (parsedInput) {\n          getParsingFlags(config).empty = false;\n        } else {\n          getParsingFlags(config).unusedTokens.push(token);\n        }\n\n        addTimeToArrayFromToken(token, parsedInput, config);\n      } else if (config._strict && !parsedInput) {\n        getParsingFlags(config).unusedTokens.push(token);\n      }\n    } // add remaining unparsed input length to the string\n\n\n    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n\n    if (string.length > 0) {\n      getParsingFlags(config).unusedInput.push(string);\n    } // clear _12h flag if hour is <= 12\n\n\n    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {\n      getParsingFlags(config).bigHour = undefined;\n    }\n\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n    getParsingFlags(config).meridiem = config._meridiem; // handle meridiem\n\n    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem); // handle era\n\n    era = getParsingFlags(config).era;\n\n    if (era !== null) {\n      config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n    }\n\n    configFromArray(config);\n    checkOverflow(config);\n  }\n\n  function meridiemFixWrap(locale, hour, meridiem) {\n    var isPm;\n\n    if (meridiem == null) {\n      // nothing to do\n      return hour;\n    }\n\n    if (locale.meridiemHour != null) {\n      return locale.meridiemHour(hour, meridiem);\n    } else if (locale.isPM != null) {\n      // Fallback\n      isPm = locale.isPM(meridiem);\n\n      if (isPm && hour < 12) {\n        hour += 12;\n      }\n\n      if (!isPm && hour === 12) {\n        hour = 0;\n      }\n\n      return hour;\n    } else {\n      // this is not supposed to happen\n      return hour;\n    }\n  } // date from string and array of format strings\n\n\n  function configFromStringAndArray(config) {\n    var tempConfig,\n        bestMoment,\n        scoreToBeat,\n        i,\n        currentScore,\n        validFormatFound,\n        bestFormatIsValid = false,\n        configfLen = config._f.length;\n\n    if (configfLen === 0) {\n      getParsingFlags(config).invalidFormat = true;\n      config._d = new Date(NaN);\n      return;\n    }\n\n    for (i = 0; i < configfLen; i++) {\n      currentScore = 0;\n      validFormatFound = false;\n      tempConfig = copyConfig({}, config);\n\n      if (config._useUTC != null) {\n        tempConfig._useUTC = config._useUTC;\n      }\n\n      tempConfig._f = config._f[i];\n      configFromStringAndFormat(tempConfig);\n\n      if (isValid(tempConfig)) {\n        validFormatFound = true;\n      } // if there is any input that was not parsed add a penalty for that format\n\n\n      currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens\n\n      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n      getParsingFlags(tempConfig).score = currentScore;\n\n      if (!bestFormatIsValid) {\n        if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {\n          scoreToBeat = currentScore;\n          bestMoment = tempConfig;\n\n          if (validFormatFound) {\n            bestFormatIsValid = true;\n          }\n        }\n      } else {\n        if (currentScore < scoreToBeat) {\n          scoreToBeat = currentScore;\n          bestMoment = tempConfig;\n        }\n      }\n    }\n\n    extend(config, bestMoment || tempConfig);\n  }\n\n  function configFromObject(config) {\n    if (config._d) {\n      return;\n    }\n\n    var i = normalizeObjectUnits(config._i),\n        dayOrDate = i.day === undefined ? i.date : i.day;\n    config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n      return obj && parseInt(obj, 10);\n    });\n    configFromArray(config);\n  }\n\n  function createFromConfig(config) {\n    var res = new Moment(checkOverflow(prepareConfig(config)));\n\n    if (res._nextDay) {\n      // Adding is smart enough around DST\n      res.add(1, 'd');\n      res._nextDay = undefined;\n    }\n\n    return res;\n  }\n\n  function prepareConfig(config) {\n    var input = config._i,\n        format = config._f;\n    config._locale = config._locale || getLocale(config._l);\n\n    if (input === null || format === undefined && input === '') {\n      return createInvalid({\n        nullInput: true\n      });\n    }\n\n    if (typeof input === 'string') {\n      config._i = input = config._locale.preparse(input);\n    }\n\n    if (isMoment(input)) {\n      return new Moment(checkOverflow(input));\n    } else if (isDate(input)) {\n      config._d = input;\n    } else if (isArray(format)) {\n      configFromStringAndArray(config);\n    } else if (format) {\n      configFromStringAndFormat(config);\n    } else {\n      configFromInput(config);\n    }\n\n    if (!isValid(config)) {\n      config._d = null;\n    }\n\n    return config;\n  }\n\n  function configFromInput(config) {\n    var input = config._i;\n\n    if (isUndefined(input)) {\n      config._d = new Date(hooks.now());\n    } else if (isDate(input)) {\n      config._d = new Date(input.valueOf());\n    } else if (typeof input === 'string') {\n      configFromString(config);\n    } else if (isArray(input)) {\n      config._a = map(input.slice(0), function (obj) {\n        return parseInt(obj, 10);\n      });\n      configFromArray(config);\n    } else if (isObject(input)) {\n      configFromObject(config);\n    } else if (isNumber(input)) {\n      // from milliseconds\n      config._d = new Date(input);\n    } else {\n      hooks.createFromInputFallback(config);\n    }\n  }\n\n  function createLocalOrUTC(input, format, locale, strict, isUTC) {\n    var c = {};\n\n    if (format === true || format === false) {\n      strict = format;\n      format = undefined;\n    }\n\n    if (locale === true || locale === false) {\n      strict = locale;\n      locale = undefined;\n    }\n\n    if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {\n      input = undefined;\n    } // object construction must be done this way.\n    // https://github.com/moment/moment/issues/1423\n\n\n    c._isAMomentObject = true;\n    c._useUTC = c._isUTC = isUTC;\n    c._l = locale;\n    c._i = input;\n    c._f = format;\n    c._strict = strict;\n    return createFromConfig(c);\n  }\n\n  function createLocal(input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, false);\n  }\n\n  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {\n    var other = createLocal.apply(null, arguments);\n\n    if (this.isValid() && other.isValid()) {\n      return other < this ? this : other;\n    } else {\n      return createInvalid();\n    }\n  }),\n      prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {\n    var other = createLocal.apply(null, arguments);\n\n    if (this.isValid() && other.isValid()) {\n      return other > this ? this : other;\n    } else {\n      return createInvalid();\n    }\n  }); // Pick a moment m from moments so that m[fn](other) is true for all\n  // other. This relies on the function fn to be transitive.\n  //\n  // moments should either be an array of moment objects or an array, whose\n  // first element is an array of moment objects.\n\n  function pickBy(fn, moments) {\n    var res, i;\n\n    if (moments.length === 1 && isArray(moments[0])) {\n      moments = moments[0];\n    }\n\n    if (!moments.length) {\n      return createLocal();\n    }\n\n    res = moments[0];\n\n    for (i = 1; i < moments.length; ++i) {\n      if (!moments[i].isValid() || moments[i][fn](res)) {\n        res = moments[i];\n      }\n    }\n\n    return res;\n  } // TODO: Use [].sort instead?\n\n\n  function min() {\n    var args = [].slice.call(arguments, 0);\n    return pickBy('isBefore', args);\n  }\n\n  function max() {\n    var args = [].slice.call(arguments, 0);\n    return pickBy('isAfter', args);\n  }\n\n  var now = function now() {\n    return Date.now ? Date.now() : +new Date();\n  };\n\n  var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\n  function isDurationValid(m) {\n    var key,\n        unitHasDecimal = false,\n        i,\n        orderLen = ordering.length;\n\n    for (key in m) {\n      if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n        return false;\n      }\n    }\n\n    for (i = 0; i < orderLen; ++i) {\n      if (m[ordering[i]]) {\n        if (unitHasDecimal) {\n          return false; // only allow non-integers for smallest unit\n        }\n\n        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n          unitHasDecimal = true;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function isValid$1() {\n    return this._isValid;\n  }\n\n  function createInvalid$1() {\n    return createDuration(NaN);\n  }\n\n  function Duration(duration) {\n    var normalizedInput = normalizeObjectUnits(duration),\n        years = normalizedInput.year || 0,\n        quarters = normalizedInput.quarter || 0,\n        months = normalizedInput.month || 0,\n        weeks = normalizedInput.week || normalizedInput.isoWeek || 0,\n        days = normalizedInput.day || 0,\n        hours = normalizedInput.hour || 0,\n        minutes = normalizedInput.minute || 0,\n        seconds = normalizedInput.second || 0,\n        milliseconds = normalizedInput.millisecond || 0;\n    this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove\n\n    this._milliseconds = +milliseconds + seconds * 1e3 + // 1000\n    minutes * 6e4 + // 1000 * 60\n    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n    // Because of dateAddRemove treats 24 hours as different from a\n    // day when working around DST, we need to store them separately\n\n    this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing\n    // which months you are are talking about, so we have to store\n    // it separately.\n\n    this._months = +months + quarters * 3 + years * 12;\n    this._data = {};\n    this._locale = getLocale();\n\n    this._bubble();\n  }\n\n  function isDuration(obj) {\n    return obj instanceof Duration;\n  }\n\n  function absRound(number) {\n    if (number < 0) {\n      return Math.round(-1 * number) * -1;\n    } else {\n      return Math.round(number);\n    }\n  } // compare two arrays, return the number of differences\n\n\n  function compareArrays(array1, array2, dontConvert) {\n    var len = Math.min(array1.length, array2.length),\n        lengthDiff = Math.abs(array1.length - array2.length),\n        diffs = 0,\n        i;\n\n    for (i = 0; i < len; i++) {\n      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {\n        diffs++;\n      }\n    }\n\n    return diffs + lengthDiff;\n  } // FORMATTING\n\n\n  function offset(token, separator) {\n    addFormatToken(token, 0, 0, function () {\n      var offset = this.utcOffset(),\n          sign = '+';\n\n      if (offset < 0) {\n        offset = -offset;\n        sign = '-';\n      }\n\n      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);\n    });\n  }\n\n  offset('Z', ':');\n  offset('ZZ', ''); // PARSING\n\n  addRegexToken('Z', matchShortOffset);\n  addRegexToken('ZZ', matchShortOffset);\n  addParseToken(['Z', 'ZZ'], function (input, array, config) {\n    config._useUTC = true;\n    config._tzm = offsetFromString(matchShortOffset, input);\n  }); // HELPERS\n  // timezone chunker\n  // '+10:00' > ['10',  '00']\n  // '-1530'  > ['-15', '30']\n\n  var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n  function offsetFromString(matcher, string) {\n    var matches = (string || '').match(matcher),\n        chunk,\n        parts,\n        minutes;\n\n    if (matches === null) {\n      return null;\n    }\n\n    chunk = matches[matches.length - 1] || [];\n    parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n    minutes = +(parts[1] * 60) + toInt(parts[2]);\n    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;\n  } // Return a moment from input, that is local/utc/zone equivalent to model.\n\n\n  function cloneWithOffset(input, model) {\n    var res, diff;\n\n    if (model._isUTC) {\n      res = model.clone();\n      diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.\n\n      res._d.setTime(res._d.valueOf() + diff);\n\n      hooks.updateOffset(res, false);\n      return res;\n    } else {\n      return createLocal(input).local();\n    }\n  }\n\n  function getDateOffset(m) {\n    // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n    // https://github.com/moment/moment/pull/1871\n    return -Math.round(m._d.getTimezoneOffset());\n  } // HOOKS\n  // This function will be called whenever a moment is mutated.\n  // It is intended to keep the offset in sync with the timezone.\n\n\n  hooks.updateOffset = function () {}; // MOMENTS\n  // keepLocalTime = true means only change the timezone, without\n  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--\x3e\n  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n  // +0200, so we adjust the time as needed, to be valid.\n  //\n  // Keeping the time actually adds/subtracts (one hour)\n  // from the actual represented time. That is why we call updateOffset\n  // a second time. In case it wants us to change the offset again\n  // _changeInProgress == true case, then we have to adjust, because\n  // there is no such time in the given timezone.\n\n\n  function getSetOffset(input, keepLocalTime, keepMinutes) {\n    var offset = this._offset || 0,\n        localAdjust;\n\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    }\n\n    if (input != null) {\n      if (typeof input === 'string') {\n        input = offsetFromString(matchShortOffset, input);\n\n        if (input === null) {\n          return this;\n        }\n      } else if (Math.abs(input) < 16 && !keepMinutes) {\n        input = input * 60;\n      }\n\n      if (!this._isUTC && keepLocalTime) {\n        localAdjust = getDateOffset(this);\n      }\n\n      this._offset = input;\n      this._isUTC = true;\n\n      if (localAdjust != null) {\n        this.add(localAdjust, 'm');\n      }\n\n      if (offset !== input) {\n        if (!keepLocalTime || this._changeInProgress) {\n          addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n        } else if (!this._changeInProgress) {\n          this._changeInProgress = true;\n          hooks.updateOffset(this, true);\n          this._changeInProgress = null;\n        }\n      }\n\n      return this;\n    } else {\n      return this._isUTC ? offset : getDateOffset(this);\n    }\n  }\n\n  function getSetZone(input, keepLocalTime) {\n    if (input != null) {\n      if (typeof input !== 'string') {\n        input = -input;\n      }\n\n      this.utcOffset(input, keepLocalTime);\n      return this;\n    } else {\n      return -this.utcOffset();\n    }\n  }\n\n  function setOffsetToUTC(keepLocalTime) {\n    return this.utcOffset(0, keepLocalTime);\n  }\n\n  function setOffsetToLocal(keepLocalTime) {\n    if (this._isUTC) {\n      this.utcOffset(0, keepLocalTime);\n      this._isUTC = false;\n\n      if (keepLocalTime) {\n        this.subtract(getDateOffset(this), 'm');\n      }\n    }\n\n    return this;\n  }\n\n  function setOffsetToParsedOffset() {\n    if (this._tzm != null) {\n      this.utcOffset(this._tzm, false, true);\n    } else if (typeof this._i === 'string') {\n      var tZone = offsetFromString(matchOffset, this._i);\n\n      if (tZone != null) {\n        this.utcOffset(tZone);\n      } else {\n        this.utcOffset(0, true);\n      }\n    }\n\n    return this;\n  }\n\n  function hasAlignedHourOffset(input) {\n    if (!this.isValid()) {\n      return false;\n    }\n\n    input = input ? createLocal(input).utcOffset() : 0;\n    return (this.utcOffset() - input) % 60 === 0;\n  }\n\n  function isDaylightSavingTime() {\n    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();\n  }\n\n  function isDaylightSavingTimeShifted() {\n    if (!isUndefined(this._isDSTShifted)) {\n      return this._isDSTShifted;\n    }\n\n    var c = {},\n        other;\n    copyConfig(c, this);\n    c = prepareConfig(c);\n\n    if (c._a) {\n      other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n    } else {\n      this._isDSTShifted = false;\n    }\n\n    return this._isDSTShifted;\n  }\n\n  function isLocal() {\n    return this.isValid() ? !this._isUTC : false;\n  }\n\n  function isUtcOffset() {\n    return this.isValid() ? this._isUTC : false;\n  }\n\n  function isUtc() {\n    return this.isValid() ? this._isUTC && this._offset === 0 : false;\n  } // ASP.NET json date format regex\n\n\n  var aspNetRegex = /^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/,\n      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n  // and further modified to allow for strings containing both week and day\n  isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n  function createDuration(input, key) {\n    var duration = input,\n        // matching against regexp is expensive, do it on demand\n    match = null,\n        sign,\n        ret,\n        diffRes;\n\n    if (isDuration(input)) {\n      duration = {\n        ms: input._milliseconds,\n        d: input._days,\n        M: input._months\n      };\n    } else if (isNumber(input) || !isNaN(+input)) {\n      duration = {};\n\n      if (key) {\n        duration[key] = +input;\n      } else {\n        duration.milliseconds = +input;\n      }\n    } else if (match = aspNetRegex.exec(input)) {\n      sign = match[1] === '-' ? -1 : 1;\n      duration = {\n        y: 0,\n        d: toInt(match[DATE]) * sign,\n        h: toInt(match[HOUR]) * sign,\n        m: toInt(match[MINUTE]) * sign,\n        s: toInt(match[SECOND]) * sign,\n        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n\n      };\n    } else if (match = isoRegex.exec(input)) {\n      sign = match[1] === '-' ? -1 : 1;\n      duration = {\n        y: parseIso(match[2], sign),\n        M: parseIso(match[3], sign),\n        w: parseIso(match[4], sign),\n        d: parseIso(match[5], sign),\n        h: parseIso(match[6], sign),\n        m: parseIso(match[7], sign),\n        s: parseIso(match[8], sign)\n      };\n    } else if (duration == null) {\n      // checks for null or undefined\n      duration = {};\n    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n      duration = {};\n      duration.ms = diffRes.milliseconds;\n      duration.M = diffRes.months;\n    }\n\n    ret = new Duration(duration);\n\n    if (isDuration(input) && hasOwnProp(input, '_locale')) {\n      ret._locale = input._locale;\n    }\n\n    if (isDuration(input) && hasOwnProp(input, '_isValid')) {\n      ret._isValid = input._isValid;\n    }\n\n    return ret;\n  }\n\n  createDuration.fn = Duration.prototype;\n  createDuration.invalid = createInvalid$1;\n\n  function parseIso(inp, sign) {\n    // We'd normally use ~~inp for this, but unfortunately it also\n    // converts floats to ints.\n    // inp may be undefined, so careful calling replace on it.\n    var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it\n\n    return (isNaN(res) ? 0 : res) * sign;\n  }\n\n  function positiveMomentsDifference(base, other) {\n    var res = {};\n    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;\n\n    if (base.clone().add(res.months, 'M').isAfter(other)) {\n      --res.months;\n    }\n\n    res.milliseconds = +other - +base.clone().add(res.months, 'M');\n    return res;\n  }\n\n  function momentsDifference(base, other) {\n    var res;\n\n    if (!(base.isValid() && other.isValid())) {\n      return {\n        milliseconds: 0,\n        months: 0\n      };\n    }\n\n    other = cloneWithOffset(other, base);\n\n    if (base.isBefore(other)) {\n      res = positiveMomentsDifference(base, other);\n    } else {\n      res = positiveMomentsDifference(other, base);\n      res.milliseconds = -res.milliseconds;\n      res.months = -res.months;\n    }\n\n    return res;\n  } // TODO: remove 'name' arg after deprecation is removed\n\n\n  function createAdder(direction, name) {\n    return function (val, period) {\n      var dur, tmp; //invert the arguments, but complain about it\n\n      if (period !== null && !isNaN(+period)) {\n        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n        tmp = val;\n        val = period;\n        period = tmp;\n      }\n\n      dur = createDuration(val, period);\n      addSubtract(this, dur, direction);\n      return this;\n    };\n  }\n\n  function addSubtract(mom, duration, isAdding, updateOffset) {\n    var milliseconds = duration._milliseconds,\n        days = absRound(duration._days),\n        months = absRound(duration._months);\n\n    if (!mom.isValid()) {\n      // No op\n      return;\n    }\n\n    updateOffset = updateOffset == null ? true : updateOffset;\n\n    if (months) {\n      setMonth(mom, get(mom, 'Month') + months * isAdding);\n    }\n\n    if (days) {\n      set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n    }\n\n    if (milliseconds) {\n      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n    }\n\n    if (updateOffset) {\n      hooks.updateOffset(mom, days || months);\n    }\n  }\n\n  var add = createAdder(1, 'add'),\n      subtract = createAdder(-1, 'subtract');\n\n  function isString(input) {\n    return typeof input === 'string' || input instanceof String;\n  } // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined\n\n\n  function isMomentInput(input) {\n    return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;\n  }\n\n  function isMomentInputObject(input) {\n    var objectTest = isObject(input) && !isObjectEmpty(input),\n        propertyTest = false,\n        properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],\n        i,\n        property,\n        propertyLen = properties.length;\n\n    for (i = 0; i < propertyLen; i += 1) {\n      property = properties[i];\n      propertyTest = propertyTest || hasOwnProp(input, property);\n    }\n\n    return objectTest && propertyTest;\n  }\n\n  function isNumberOrStringArray(input) {\n    var arrayTest = isArray(input),\n        dataTypeTest = false;\n\n    if (arrayTest) {\n      dataTypeTest = input.filter(function (item) {\n        return !isNumber(item) && isString(input);\n      }).length === 0;\n    }\n\n    return arrayTest && dataTypeTest;\n  }\n\n  function isCalendarSpec(input) {\n    var objectTest = isObject(input) && !isObjectEmpty(input),\n        propertyTest = false,\n        properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],\n        i,\n        property;\n\n    for (i = 0; i < properties.length; i += 1) {\n      property = properties[i];\n      propertyTest = propertyTest || hasOwnProp(input, property);\n    }\n\n    return objectTest && propertyTest;\n  }\n\n  function getCalendarFormat(myMoment, now) {\n    var diff = myMoment.diff(now, 'days', true);\n    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';\n  }\n\n  function calendar$1(time, formats) {\n    // Support for single parameter, formats only overload to the calendar function\n    if (arguments.length === 1) {\n      if (!arguments[0]) {\n        time = undefined;\n        formats = undefined;\n      } else if (isMomentInput(arguments[0])) {\n        time = arguments[0];\n        formats = undefined;\n      } else if (isCalendarSpec(arguments[0])) {\n        formats = arguments[0];\n        time = undefined;\n      }\n    } // We want to compare the start of today, vs this.\n    // Getting start-of-today depends on whether we're local/utc/offset or not.\n\n\n    var now = time || createLocal(),\n        sod = cloneWithOffset(now, this).startOf('day'),\n        format = hooks.calendarFormat(this, sod) || 'sameElse',\n        output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n  }\n\n  function clone() {\n    return new Moment(this);\n  }\n\n  function isAfter(input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n\n    if (!(this.isValid() && localInput.isValid())) {\n      return false;\n    }\n\n    units = normalizeUnits(units) || 'millisecond';\n\n    if (units === 'millisecond') {\n      return this.valueOf() > localInput.valueOf();\n    } else {\n      return localInput.valueOf() < this.clone().startOf(units).valueOf();\n    }\n  }\n\n  function isBefore(input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n\n    if (!(this.isValid() && localInput.isValid())) {\n      return false;\n    }\n\n    units = normalizeUnits(units) || 'millisecond';\n\n    if (units === 'millisecond') {\n      return this.valueOf() < localInput.valueOf();\n    } else {\n      return this.clone().endOf(units).valueOf() < localInput.valueOf();\n    }\n  }\n\n  function isBetween(from, to, units, inclusivity) {\n    var localFrom = isMoment(from) ? from : createLocal(from),\n        localTo = isMoment(to) ? to : createLocal(to);\n\n    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n      return false;\n    }\n\n    inclusivity = inclusivity || '()';\n    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));\n  }\n\n  function isSame(input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input),\n        inputMs;\n\n    if (!(this.isValid() && localInput.isValid())) {\n      return false;\n    }\n\n    units = normalizeUnits(units) || 'millisecond';\n\n    if (units === 'millisecond') {\n      return this.valueOf() === localInput.valueOf();\n    } else {\n      inputMs = localInput.valueOf();\n      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n    }\n  }\n\n  function isSameOrAfter(input, units) {\n    return this.isSame(input, units) || this.isAfter(input, units);\n  }\n\n  function isSameOrBefore(input, units) {\n    return this.isSame(input, units) || this.isBefore(input, units);\n  }\n\n  function diff(input, units, asFloat) {\n    var that, zoneDelta, output;\n\n    if (!this.isValid()) {\n      return NaN;\n    }\n\n    that = cloneWithOffset(input, this);\n\n    if (!that.isValid()) {\n      return NaN;\n    }\n\n    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n    units = normalizeUnits(units);\n\n    switch (units) {\n      case 'year':\n        output = monthDiff(this, that) / 12;\n        break;\n\n      case 'month':\n        output = monthDiff(this, that);\n        break;\n\n      case 'quarter':\n        output = monthDiff(this, that) / 3;\n        break;\n\n      case 'second':\n        output = (this - that) / 1e3;\n        break;\n      // 1000\n\n      case 'minute':\n        output = (this - that) / 6e4;\n        break;\n      // 1000 * 60\n\n      case 'hour':\n        output = (this - that) / 36e5;\n        break;\n      // 1000 * 60 * 60\n\n      case 'day':\n        output = (this - that - zoneDelta) / 864e5;\n        break;\n      // 1000 * 60 * 60 * 24, negate dst\n\n      case 'week':\n        output = (this - that - zoneDelta) / 6048e5;\n        break;\n      // 1000 * 60 * 60 * 24 * 7, negate dst\n\n      default:\n        output = this - that;\n    }\n\n    return asFloat ? output : absFloor(output);\n  }\n\n  function monthDiff(a, b) {\n    if (a.date() < b.date()) {\n      // end-of-month calculations work correct when the start month has more\n      // days than the end month.\n      return -monthDiff(b, a);\n    } // difference in months\n\n\n    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),\n        // b is in (anchor - 1 month, anchor + 1 month)\n    anchor = a.clone().add(wholeMonthDiff, 'months'),\n        anchor2,\n        adjust;\n\n    if (b - anchor < 0) {\n      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month\n\n      adjust = (b - anchor) / (anchor - anchor2);\n    } else {\n      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month\n\n      adjust = (b - anchor) / (anchor2 - anchor);\n    } //check for negative zero, return zero if negative zero\n\n\n    return -(wholeMonthDiff + adjust) || 0;\n  }\n\n  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n  function toString() {\n    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n  }\n\n  function toISOString(keepOffset) {\n    if (!this.isValid()) {\n      return null;\n    }\n\n    var utc = keepOffset !== true,\n        m = utc ? this.clone().utc() : this;\n\n    if (m.year() < 0 || m.year() > 9999) {\n      return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n\n    if (isFunction(Date.prototype.toISOString)) {\n      // native implementation is ~50x faster, use it when we can\n      if (utc) {\n        return this.toDate().toISOString();\n      } else {\n        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\n      }\n    }\n\n    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n  }\n  /**\n   * Return a human readable representation of a moment that can\n   * also be evaluated to get a new moment which is the same\n   *\n   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n   */\n\n\n  function inspect() {\n    if (!this.isValid()) {\n      return 'moment.invalid(/* ' + this._i + ' */)';\n    }\n\n    var func = 'moment',\n        zone = '',\n        prefix,\n        year,\n        datetime,\n        suffix;\n\n    if (!this.isLocal()) {\n      func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n      zone = 'Z';\n    }\n\n    prefix = '[' + func + '(\"]';\n    year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';\n    datetime = '-MM-DD[T]HH:mm:ss.SSS';\n    suffix = zone + '[\")]';\n    return this.format(prefix + year + datetime + suffix);\n  }\n\n  function format(inputString) {\n    if (!inputString) {\n      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n    }\n\n    var output = formatMoment(this, inputString);\n    return this.localeData().postformat(output);\n  }\n\n  function from(time, withoutSuffix) {\n    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n      return createDuration({\n        to: this,\n        from: time\n      }).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n      return this.localeData().invalidDate();\n    }\n  }\n\n  function fromNow(withoutSuffix) {\n    return this.from(createLocal(), withoutSuffix);\n  }\n\n  function to(time, withoutSuffix) {\n    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n      return createDuration({\n        from: this,\n        to: time\n      }).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n      return this.localeData().invalidDate();\n    }\n  }\n\n  function toNow(withoutSuffix) {\n    return this.to(createLocal(), withoutSuffix);\n  } // If passed a locale key, it will set the locale for this\n  // instance.  Otherwise, it will return the locale configuration\n  // variables for this instance.\n\n\n  function locale(key) {\n    var newLocaleData;\n\n    if (key === undefined) {\n      return this._locale._abbr;\n    } else {\n      newLocaleData = getLocale(key);\n\n      if (newLocaleData != null) {\n        this._locale = newLocaleData;\n      }\n\n      return this;\n    }\n  }\n\n  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {\n    if (key === undefined) {\n      return this.localeData();\n    } else {\n      return this.locale(key);\n    }\n  });\n\n  function localeData() {\n    return this._locale;\n  }\n\n  var MS_PER_SECOND = 1000,\n      MS_PER_MINUTE = 60 * MS_PER_SECOND,\n      MS_PER_HOUR = 60 * MS_PER_MINUTE,\n      MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):\n\n  function mod$1(dividend, divisor) {\n    return (dividend % divisor + divisor) % divisor;\n  }\n\n  function localStartOfDate(y, m, d) {\n    // the date constructor remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0) {\n      // preserve leap years using a full 400 year cycle, then reset\n      return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n    } else {\n      return new Date(y, m, d).valueOf();\n    }\n  }\n\n  function utcStartOfDate(y, m, d) {\n    // Date.UTC remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0) {\n      // preserve leap years using a full 400 year cycle, then reset\n      return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n    } else {\n      return Date.UTC(y, m, d);\n    }\n  }\n\n  function startOf(units) {\n    var time, startOfDate;\n    units = normalizeUnits(units);\n\n    if (units === undefined || units === 'millisecond' || !this.isValid()) {\n      return this;\n    }\n\n    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n    switch (units) {\n      case 'year':\n        time = startOfDate(this.year(), 0, 1);\n        break;\n\n      case 'quarter':\n        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);\n        break;\n\n      case 'month':\n        time = startOfDate(this.year(), this.month(), 1);\n        break;\n\n      case 'week':\n        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());\n        break;\n\n      case 'isoWeek':\n        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));\n        break;\n\n      case 'day':\n      case 'date':\n        time = startOfDate(this.year(), this.month(), this.date());\n        break;\n\n      case 'hour':\n        time = this._d.valueOf();\n        time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);\n        break;\n\n      case 'minute':\n        time = this._d.valueOf();\n        time -= mod$1(time, MS_PER_MINUTE);\n        break;\n\n      case 'second':\n        time = this._d.valueOf();\n        time -= mod$1(time, MS_PER_SECOND);\n        break;\n    }\n\n    this._d.setTime(time);\n\n    hooks.updateOffset(this, true);\n    return this;\n  }\n\n  function endOf(units) {\n    var time, startOfDate;\n    units = normalizeUnits(units);\n\n    if (units === undefined || units === 'millisecond' || !this.isValid()) {\n      return this;\n    }\n\n    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n    switch (units) {\n      case 'year':\n        time = startOfDate(this.year() + 1, 0, 1) - 1;\n        break;\n\n      case 'quarter':\n        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;\n        break;\n\n      case 'month':\n        time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n        break;\n\n      case 'week':\n        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;\n        break;\n\n      case 'isoWeek':\n        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;\n        break;\n\n      case 'day':\n      case 'date':\n        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n        break;\n\n      case 'hour':\n        time = this._d.valueOf();\n        time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;\n        break;\n\n      case 'minute':\n        time = this._d.valueOf();\n        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n        break;\n\n      case 'second':\n        time = this._d.valueOf();\n        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n        break;\n    }\n\n    this._d.setTime(time);\n\n    hooks.updateOffset(this, true);\n    return this;\n  }\n\n  function valueOf() {\n    return this._d.valueOf() - (this._offset || 0) * 60000;\n  }\n\n  function unix() {\n    return Math.floor(this.valueOf() / 1000);\n  }\n\n  function toDate() {\n    return new Date(this.valueOf());\n  }\n\n  function toArray() {\n    var m = this;\n    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n  }\n\n  function toObject() {\n    var m = this;\n    return {\n      years: m.year(),\n      months: m.month(),\n      date: m.date(),\n      hours: m.hours(),\n      minutes: m.minutes(),\n      seconds: m.seconds(),\n      milliseconds: m.milliseconds()\n    };\n  }\n\n  function toJSON() {\n    // new Date(NaN).toJSON() === null\n    return this.isValid() ? this.toISOString() : null;\n  }\n\n  function isValid$2() {\n    return isValid(this);\n  }\n\n  function parsingFlags() {\n    return extend({}, getParsingFlags(this));\n  }\n\n  function invalidAt() {\n    return getParsingFlags(this).overflow;\n  }\n\n  function creationData() {\n    return {\n      input: this._i,\n      format: this._f,\n      locale: this._locale,\n      isUTC: this._isUTC,\n      strict: this._strict\n    };\n  }\n\n  addFormatToken('N', 0, 0, 'eraAbbr');\n  addFormatToken('NN', 0, 0, 'eraAbbr');\n  addFormatToken('NNN', 0, 0, 'eraAbbr');\n  addFormatToken('NNNN', 0, 0, 'eraName');\n  addFormatToken('NNNNN', 0, 0, 'eraNarrow');\n  addFormatToken('y', ['y', 1], 'yo', 'eraYear');\n  addFormatToken('y', ['yy', 2], 0, 'eraYear');\n  addFormatToken('y', ['yyy', 3], 0, 'eraYear');\n  addFormatToken('y', ['yyyy', 4], 0, 'eraYear');\n  addRegexToken('N', matchEraAbbr);\n  addRegexToken('NN', matchEraAbbr);\n  addRegexToken('NNN', matchEraAbbr);\n  addRegexToken('NNNN', matchEraName);\n  addRegexToken('NNNNN', matchEraNarrow);\n  addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {\n    var era = config._locale.erasParse(input, token, config._strict);\n\n    if (era) {\n      getParsingFlags(config).era = era;\n    } else {\n      getParsingFlags(config).invalidEra = input;\n    }\n  });\n  addRegexToken('y', matchUnsigned);\n  addRegexToken('yy', matchUnsigned);\n  addRegexToken('yyy', matchUnsigned);\n  addRegexToken('yyyy', matchUnsigned);\n  addRegexToken('yo', matchEraYearOrdinal);\n  addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);\n  addParseToken(['yo'], function (input, array, config, token) {\n    var match;\n\n    if (config._locale._eraYearOrdinalRegex) {\n      match = input.match(config._locale._eraYearOrdinalRegex);\n    }\n\n    if (config._locale.eraYearOrdinalParse) {\n      array[YEAR] = config._locale.eraYearOrdinalParse(input, match);\n    } else {\n      array[YEAR] = parseInt(input, 10);\n    }\n  });\n\n  function localeEras(m, format) {\n    var i,\n        l,\n        date,\n        eras = this._eras || getLocale('en')._eras;\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      switch (typeof eras[i].since) {\n        case 'string':\n          // truncate time\n          date = hooks(eras[i].since).startOf('day');\n          eras[i].since = date.valueOf();\n          break;\n      }\n\n      switch (typeof eras[i].until) {\n        case 'undefined':\n          eras[i].until = +Infinity;\n          break;\n\n        case 'string':\n          // truncate time\n          date = hooks(eras[i].until).startOf('day').valueOf();\n          eras[i].until = date.valueOf();\n          break;\n      }\n    }\n\n    return eras;\n  }\n\n  function localeErasParse(eraName, format, strict) {\n    var i,\n        l,\n        eras = this.eras(),\n        name,\n        abbr,\n        narrow;\n    eraName = eraName.toUpperCase();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      name = eras[i].name.toUpperCase();\n      abbr = eras[i].abbr.toUpperCase();\n      narrow = eras[i].narrow.toUpperCase();\n\n      if (strict) {\n        switch (format) {\n          case 'N':\n          case 'NN':\n          case 'NNN':\n            if (abbr === eraName) {\n              return eras[i];\n            }\n\n            break;\n\n          case 'NNNN':\n            if (name === eraName) {\n              return eras[i];\n            }\n\n            break;\n\n          case 'NNNNN':\n            if (narrow === eraName) {\n              return eras[i];\n            }\n\n            break;\n        }\n      } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {\n        return eras[i];\n      }\n    }\n  }\n\n  function localeErasConvertYear(era, year) {\n    var dir = era.since <= era.until ? +1 : -1;\n\n    if (year === undefined) {\n      return hooks(era.since).year();\n    } else {\n      return hooks(era.since).year() + (year - era.offset) * dir;\n    }\n  }\n\n  function getEraName() {\n    var i,\n        l,\n        val,\n        eras = this.localeData().eras();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      // truncate time\n      val = this.clone().startOf('day').valueOf();\n\n      if (eras[i].since <= val && val <= eras[i].until) {\n        return eras[i].name;\n      }\n\n      if (eras[i].until <= val && val <= eras[i].since) {\n        return eras[i].name;\n      }\n    }\n\n    return '';\n  }\n\n  function getEraNarrow() {\n    var i,\n        l,\n        val,\n        eras = this.localeData().eras();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      // truncate time\n      val = this.clone().startOf('day').valueOf();\n\n      if (eras[i].since <= val && val <= eras[i].until) {\n        return eras[i].narrow;\n      }\n\n      if (eras[i].until <= val && val <= eras[i].since) {\n        return eras[i].narrow;\n      }\n    }\n\n    return '';\n  }\n\n  function getEraAbbr() {\n    var i,\n        l,\n        val,\n        eras = this.localeData().eras();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      // truncate time\n      val = this.clone().startOf('day').valueOf();\n\n      if (eras[i].since <= val && val <= eras[i].until) {\n        return eras[i].abbr;\n      }\n\n      if (eras[i].until <= val && val <= eras[i].since) {\n        return eras[i].abbr;\n      }\n    }\n\n    return '';\n  }\n\n  function getEraYear() {\n    var i,\n        l,\n        dir,\n        val,\n        eras = this.localeData().eras();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      dir = eras[i].since <= eras[i].until ? +1 : -1; // truncate time\n\n      val = this.clone().startOf('day').valueOf();\n\n      if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {\n        return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;\n      }\n    }\n\n    return this.year();\n  }\n\n  function erasNameRegex(isStrict) {\n    if (!hasOwnProp(this, '_erasNameRegex')) {\n      computeErasParse.call(this);\n    }\n\n    return isStrict ? this._erasNameRegex : this._erasRegex;\n  }\n\n  function erasAbbrRegex(isStrict) {\n    if (!hasOwnProp(this, '_erasAbbrRegex')) {\n      computeErasParse.call(this);\n    }\n\n    return isStrict ? this._erasAbbrRegex : this._erasRegex;\n  }\n\n  function erasNarrowRegex(isStrict) {\n    if (!hasOwnProp(this, '_erasNarrowRegex')) {\n      computeErasParse.call(this);\n    }\n\n    return isStrict ? this._erasNarrowRegex : this._erasRegex;\n  }\n\n  function matchEraAbbr(isStrict, locale) {\n    return locale.erasAbbrRegex(isStrict);\n  }\n\n  function matchEraName(isStrict, locale) {\n    return locale.erasNameRegex(isStrict);\n  }\n\n  function matchEraNarrow(isStrict, locale) {\n    return locale.erasNarrowRegex(isStrict);\n  }\n\n  function matchEraYearOrdinal(isStrict, locale) {\n    return locale._eraYearOrdinalRegex || matchUnsigned;\n  }\n\n  function computeErasParse() {\n    var abbrPieces = [],\n        namePieces = [],\n        narrowPieces = [],\n        mixedPieces = [],\n        i,\n        l,\n        eras = this.eras();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      namePieces.push(regexEscape(eras[i].name));\n      abbrPieces.push(regexEscape(eras[i].abbr));\n      narrowPieces.push(regexEscape(eras[i].narrow));\n      mixedPieces.push(regexEscape(eras[i].name));\n      mixedPieces.push(regexEscape(eras[i].abbr));\n      mixedPieces.push(regexEscape(eras[i].narrow));\n    }\n\n    this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');\n    this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');\n    this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');\n  } // FORMATTING\n\n\n  addFormatToken(0, ['gg', 2], 0, function () {\n    return this.weekYear() % 100;\n  });\n  addFormatToken(0, ['GG', 2], 0, function () {\n    return this.isoWeekYear() % 100;\n  });\n\n  function addWeekYearFormatToken(token, getter) {\n    addFormatToken(0, [token, token.length], 0, getter);\n  }\n\n  addWeekYearFormatToken('gggg', 'weekYear');\n  addWeekYearFormatToken('ggggg', 'weekYear');\n  addWeekYearFormatToken('GGGG', 'isoWeekYear');\n  addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES\n\n  addUnitAlias('weekYear', 'gg');\n  addUnitAlias('isoWeekYear', 'GG'); // PRIORITY\n\n  addUnitPriority('weekYear', 1);\n  addUnitPriority('isoWeekYear', 1); // PARSING\n\n  addRegexToken('G', matchSigned);\n  addRegexToken('g', matchSigned);\n  addRegexToken('GG', match1to2, match2);\n  addRegexToken('gg', match1to2, match2);\n  addRegexToken('GGGG', match1to4, match4);\n  addRegexToken('gggg', match1to4, match4);\n  addRegexToken('GGGGG', match1to6, match6);\n  addRegexToken('ggggg', match1to6, match6);\n  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n    week[token.substr(0, 2)] = toInt(input);\n  });\n  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n    week[token] = hooks.parseTwoDigitYear(input);\n  }); // MOMENTS\n\n  function getSetWeekYear(input) {\n    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);\n  }\n\n  function getSetISOWeekYear(input) {\n    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);\n  }\n\n  function getISOWeeksInYear() {\n    return weeksInYear(this.year(), 1, 4);\n  }\n\n  function getISOWeeksInISOWeekYear() {\n    return weeksInYear(this.isoWeekYear(), 1, 4);\n  }\n\n  function getWeeksInYear() {\n    var weekInfo = this.localeData()._week;\n\n    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n  }\n\n  function getWeeksInWeekYear() {\n    var weekInfo = this.localeData()._week;\n\n    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\n  }\n\n  function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n    var weeksTarget;\n\n    if (input == null) {\n      return weekOfYear(this, dow, doy).year;\n    } else {\n      weeksTarget = weeksInYear(input, dow, doy);\n\n      if (week > weeksTarget) {\n        week = weeksTarget;\n      }\n\n      return setWeekAll.call(this, input, week, weekday, dow, doy);\n    }\n  }\n\n  function setWeekAll(weekYear, week, weekday, dow, doy) {\n    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n    this.year(date.getUTCFullYear());\n    this.month(date.getUTCMonth());\n    this.date(date.getUTCDate());\n    return this;\n  } // FORMATTING\n\n\n  addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES\n\n  addUnitAlias('quarter', 'Q'); // PRIORITY\n\n  addUnitPriority('quarter', 7); // PARSING\n\n  addRegexToken('Q', match1);\n  addParseToken('Q', function (input, array) {\n    array[MONTH] = (toInt(input) - 1) * 3;\n  }); // MOMENTS\n\n  function getSetQuarter(input) {\n    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n  } // FORMATTING\n\n\n  addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES\n\n  addUnitAlias('date', 'D'); // PRIORITY\n\n  addUnitPriority('date', 9); // PARSING\n\n  addRegexToken('D', match1to2);\n  addRegexToken('DD', match1to2, match2);\n  addRegexToken('Do', function (isStrict, locale) {\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;\n  });\n  addParseToken(['D', 'DD'], DATE);\n  addParseToken('Do', function (input, array) {\n    array[DATE] = toInt(input.match(match1to2)[0]);\n  }); // MOMENTS\n\n  var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING\n\n  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES\n\n  addUnitAlias('dayOfYear', 'DDD'); // PRIORITY\n\n  addUnitPriority('dayOfYear', 4); // PARSING\n\n  addRegexToken('DDD', match1to3);\n  addRegexToken('DDDD', match3);\n  addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n    config._dayOfYear = toInt(input);\n  }); // HELPERS\n  // MOMENTS\n\n  function getSetDayOfYear(input) {\n    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');\n  } // FORMATTING\n\n\n  addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES\n\n  addUnitAlias('minute', 'm'); // PRIORITY\n\n  addUnitPriority('minute', 14); // PARSING\n\n  addRegexToken('m', match1to2);\n  addRegexToken('mm', match1to2, match2);\n  addParseToken(['m', 'mm'], MINUTE); // MOMENTS\n\n  var getSetMinute = makeGetSet('Minutes', false); // FORMATTING\n\n  addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES\n\n  addUnitAlias('second', 's'); // PRIORITY\n\n  addUnitPriority('second', 15); // PARSING\n\n  addRegexToken('s', match1to2);\n  addRegexToken('ss', match1to2, match2);\n  addParseToken(['s', 'ss'], SECOND); // MOMENTS\n\n  var getSetSecond = makeGetSet('Seconds', false); // FORMATTING\n\n  addFormatToken('S', 0, 0, function () {\n    return ~~(this.millisecond() / 100);\n  });\n  addFormatToken(0, ['SS', 2], 0, function () {\n    return ~~(this.millisecond() / 10);\n  });\n  addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n  addFormatToken(0, ['SSSS', 4], 0, function () {\n    return this.millisecond() * 10;\n  });\n  addFormatToken(0, ['SSSSS', 5], 0, function () {\n    return this.millisecond() * 100;\n  });\n  addFormatToken(0, ['SSSSSS', 6], 0, function () {\n    return this.millisecond() * 1000;\n  });\n  addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n    return this.millisecond() * 10000;\n  });\n  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n    return this.millisecond() * 100000;\n  });\n  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n    return this.millisecond() * 1000000;\n  }); // ALIASES\n\n  addUnitAlias('millisecond', 'ms'); // PRIORITY\n\n  addUnitPriority('millisecond', 16); // PARSING\n\n  addRegexToken('S', match1to3, match1);\n  addRegexToken('SS', match1to3, match2);\n  addRegexToken('SSS', match1to3, match3);\n  var token, getSetMillisecond;\n\n  for (token = 'SSSS'; token.length <= 9; token += 'S') {\n    addRegexToken(token, matchUnsigned);\n  }\n\n  function parseMs(input, array) {\n    array[MILLISECOND] = toInt(('0.' + input) * 1000);\n  }\n\n  for (token = 'S'; token.length <= 9; token += 'S') {\n    addParseToken(token, parseMs);\n  }\n\n  getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING\n\n  addFormatToken('z', 0, 0, 'zoneAbbr');\n  addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS\n\n  function getZoneAbbr() {\n    return this._isUTC ? 'UTC' : '';\n  }\n\n  function getZoneName() {\n    return this._isUTC ? 'Coordinated Universal Time' : '';\n  }\n\n  var proto = Moment.prototype;\n  proto.add = add;\n  proto.calendar = calendar$1;\n  proto.clone = clone;\n  proto.diff = diff;\n  proto.endOf = endOf;\n  proto.format = format;\n  proto.from = from;\n  proto.fromNow = fromNow;\n  proto.to = to;\n  proto.toNow = toNow;\n  proto.get = stringGet;\n  proto.invalidAt = invalidAt;\n  proto.isAfter = isAfter;\n  proto.isBefore = isBefore;\n  proto.isBetween = isBetween;\n  proto.isSame = isSame;\n  proto.isSameOrAfter = isSameOrAfter;\n  proto.isSameOrBefore = isSameOrBefore;\n  proto.isValid = isValid$2;\n  proto.lang = lang;\n  proto.locale = locale;\n  proto.localeData = localeData;\n  proto.max = prototypeMax;\n  proto.min = prototypeMin;\n  proto.parsingFlags = parsingFlags;\n  proto.set = stringSet;\n  proto.startOf = startOf;\n  proto.subtract = subtract;\n  proto.toArray = toArray;\n  proto.toObject = toObject;\n  proto.toDate = toDate;\n  proto.toISOString = toISOString;\n  proto.inspect = inspect;\n\n  if (typeof Symbol !== 'undefined' && Symbol[\"for\"] != null) {\n    proto[Symbol[\"for\"]('nodejs.util.inspect.custom')] = function () {\n      return 'Moment<' + this.format() + '>';\n    };\n  }\n\n  proto.toJSON = toJSON;\n  proto.toString = toString;\n  proto.unix = unix;\n  proto.valueOf = valueOf;\n  proto.creationData = creationData;\n  proto.eraName = getEraName;\n  proto.eraNarrow = getEraNarrow;\n  proto.eraAbbr = getEraAbbr;\n  proto.eraYear = getEraYear;\n  proto.year = getSetYear;\n  proto.isLeapYear = getIsLeapYear;\n  proto.weekYear = getSetWeekYear;\n  proto.isoWeekYear = getSetISOWeekYear;\n  proto.quarter = proto.quarters = getSetQuarter;\n  proto.month = getSetMonth;\n  proto.daysInMonth = getDaysInMonth;\n  proto.week = proto.weeks = getSetWeek;\n  proto.isoWeek = proto.isoWeeks = getSetISOWeek;\n  proto.weeksInYear = getWeeksInYear;\n  proto.weeksInWeekYear = getWeeksInWeekYear;\n  proto.isoWeeksInYear = getISOWeeksInYear;\n  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;\n  proto.date = getSetDayOfMonth;\n  proto.day = proto.days = getSetDayOfWeek;\n  proto.weekday = getSetLocaleDayOfWeek;\n  proto.isoWeekday = getSetISODayOfWeek;\n  proto.dayOfYear = getSetDayOfYear;\n  proto.hour = proto.hours = getSetHour;\n  proto.minute = proto.minutes = getSetMinute;\n  proto.second = proto.seconds = getSetSecond;\n  proto.millisecond = proto.milliseconds = getSetMillisecond;\n  proto.utcOffset = getSetOffset;\n  proto.utc = setOffsetToUTC;\n  proto.local = setOffsetToLocal;\n  proto.parseZone = setOffsetToParsedOffset;\n  proto.hasAlignedHourOffset = hasAlignedHourOffset;\n  proto.isDST = isDaylightSavingTime;\n  proto.isLocal = isLocal;\n  proto.isUtcOffset = isUtcOffset;\n  proto.isUtc = isUtc;\n  proto.isUTC = isUtc;\n  proto.zoneAbbr = getZoneAbbr;\n  proto.zoneName = getZoneName;\n  proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n  proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n  proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n  proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n  proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\n  function createUnix(input) {\n    return createLocal(input * 1000);\n  }\n\n  function createInZone() {\n    return createLocal.apply(null, arguments).parseZone();\n  }\n\n  function preParsePostFormat(string) {\n    return string;\n  }\n\n  var proto$1 = Locale.prototype;\n  proto$1.calendar = calendar;\n  proto$1.longDateFormat = longDateFormat;\n  proto$1.invalidDate = invalidDate;\n  proto$1.ordinal = ordinal;\n  proto$1.preparse = preParsePostFormat;\n  proto$1.postformat = preParsePostFormat;\n  proto$1.relativeTime = relativeTime;\n  proto$1.pastFuture = pastFuture;\n  proto$1.set = set;\n  proto$1.eras = localeEras;\n  proto$1.erasParse = localeErasParse;\n  proto$1.erasConvertYear = localeErasConvertYear;\n  proto$1.erasAbbrRegex = erasAbbrRegex;\n  proto$1.erasNameRegex = erasNameRegex;\n  proto$1.erasNarrowRegex = erasNarrowRegex;\n  proto$1.months = localeMonths;\n  proto$1.monthsShort = localeMonthsShort;\n  proto$1.monthsParse = localeMonthsParse;\n  proto$1.monthsRegex = monthsRegex;\n  proto$1.monthsShortRegex = monthsShortRegex;\n  proto$1.week = localeWeek;\n  proto$1.firstDayOfYear = localeFirstDayOfYear;\n  proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n  proto$1.weekdays = localeWeekdays;\n  proto$1.weekdaysMin = localeWeekdaysMin;\n  proto$1.weekdaysShort = localeWeekdaysShort;\n  proto$1.weekdaysParse = localeWeekdaysParse;\n  proto$1.weekdaysRegex = weekdaysRegex;\n  proto$1.weekdaysShortRegex = weekdaysShortRegex;\n  proto$1.weekdaysMinRegex = weekdaysMinRegex;\n  proto$1.isPM = localeIsPM;\n  proto$1.meridiem = localeMeridiem;\n\n  function get$1(format, index, field, setter) {\n    var locale = getLocale(),\n        utc = createUTC().set(setter, index);\n    return locale[field](utc, format);\n  }\n\n  function listMonthsImpl(format, index, field) {\n    if (isNumber(format)) {\n      index = format;\n      format = undefined;\n    }\n\n    format = format || '';\n\n    if (index != null) {\n      return get$1(format, index, field, 'month');\n    }\n\n    var i,\n        out = [];\n\n    for (i = 0; i < 12; i++) {\n      out[i] = get$1(format, i, field, 'month');\n    }\n\n    return out;\n  } // ()\n  // (5)\n  // (fmt, 5)\n  // (fmt)\n  // (true)\n  // (true, 5)\n  // (true, fmt, 5)\n  // (true, fmt)\n\n\n  function listWeekdaysImpl(localeSorted, format, index, field) {\n    if (typeof localeSorted === 'boolean') {\n      if (isNumber(format)) {\n        index = format;\n        format = undefined;\n      }\n\n      format = format || '';\n    } else {\n      format = localeSorted;\n      index = format;\n      localeSorted = false;\n\n      if (isNumber(format)) {\n        index = format;\n        format = undefined;\n      }\n\n      format = format || '';\n    }\n\n    var locale = getLocale(),\n        shift = localeSorted ? locale._week.dow : 0,\n        i,\n        out = [];\n\n    if (index != null) {\n      return get$1(format, (index + shift) % 7, field, 'day');\n    }\n\n    for (i = 0; i < 7; i++) {\n      out[i] = get$1(format, (i + shift) % 7, field, 'day');\n    }\n\n    return out;\n  }\n\n  function listMonths(format, index) {\n    return listMonthsImpl(format, index, 'months');\n  }\n\n  function listMonthsShort(format, index) {\n    return listMonthsImpl(format, index, 'monthsShort');\n  }\n\n  function listWeekdays(localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n  }\n\n  function listWeekdaysShort(localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n  }\n\n  function listWeekdaysMin(localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n  }\n\n  getSetGlobalLocale('en', {\n    eras: [{\n      since: '0001-01-01',\n      until: +Infinity,\n      offset: 1,\n      name: 'Anno Domini',\n      narrow: 'AD',\n      abbr: 'AD'\n    }, {\n      since: '0000-12-31',\n      until: -Infinity,\n      offset: 1,\n      name: 'Before Christ',\n      narrow: 'BC',\n      abbr: 'BC'\n    }],\n    dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n    ordinal: function ordinal(number) {\n      var b = number % 10,\n          output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';\n      return number + output;\n    }\n  }); // Side effect imports\n\n  hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n  hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n  var mathAbs = Math.abs;\n\n  function abs() {\n    var data = this._data;\n    this._milliseconds = mathAbs(this._milliseconds);\n    this._days = mathAbs(this._days);\n    this._months = mathAbs(this._months);\n    data.milliseconds = mathAbs(data.milliseconds);\n    data.seconds = mathAbs(data.seconds);\n    data.minutes = mathAbs(data.minutes);\n    data.hours = mathAbs(data.hours);\n    data.months = mathAbs(data.months);\n    data.years = mathAbs(data.years);\n    return this;\n  }\n\n  function addSubtract$1(duration, input, value, direction) {\n    var other = createDuration(input, value);\n    duration._milliseconds += direction * other._milliseconds;\n    duration._days += direction * other._days;\n    duration._months += direction * other._months;\n    return duration._bubble();\n  } // supports only 2.0-style add(1, 's') or add(duration)\n\n\n  function add$1(input, value) {\n    return addSubtract$1(this, input, value, 1);\n  } // supports only 2.0-style subtract(1, 's') or subtract(duration)\n\n\n  function subtract$1(input, value) {\n    return addSubtract$1(this, input, value, -1);\n  }\n\n  function absCeil(number) {\n    if (number < 0) {\n      return Math.floor(number);\n    } else {\n      return Math.ceil(number);\n    }\n  }\n\n  function bubble() {\n    var milliseconds = this._milliseconds,\n        days = this._days,\n        months = this._months,\n        data = this._data,\n        seconds,\n        minutes,\n        hours,\n        years,\n        monthsFromDays; // if we have a mix of positive and negative values, bubble down first\n    // check: https://github.com/moment/moment/issues/2166\n\n    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {\n      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n      days = 0;\n      months = 0;\n    } // The following code bubbles up values, see the tests for\n    // examples of what that means.\n\n\n    data.milliseconds = milliseconds % 1000;\n    seconds = absFloor(milliseconds / 1000);\n    data.seconds = seconds % 60;\n    minutes = absFloor(seconds / 60);\n    data.minutes = minutes % 60;\n    hours = absFloor(minutes / 60);\n    data.hours = hours % 24;\n    days += absFloor(hours / 24); // convert days to months\n\n    monthsFromDays = absFloor(daysToMonths(days));\n    months += monthsFromDays;\n    days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year\n\n    years = absFloor(months / 12);\n    months %= 12;\n    data.days = days;\n    data.months = months;\n    data.years = years;\n    return this;\n  }\n\n  function daysToMonths(days) {\n    // 400 years have 146097 days (taking into account leap year rules)\n    // 400 years have 12 months === 4800\n    return days * 4800 / 146097;\n  }\n\n  function monthsToDays(months) {\n    // the reverse of daysToMonths\n    return months * 146097 / 4800;\n  }\n\n  function as(units) {\n    if (!this.isValid()) {\n      return NaN;\n    }\n\n    var days,\n        months,\n        milliseconds = this._milliseconds;\n    units = normalizeUnits(units);\n\n    if (units === 'month' || units === 'quarter' || units === 'year') {\n      days = this._days + milliseconds / 864e5;\n      months = this._months + daysToMonths(days);\n\n      switch (units) {\n        case 'month':\n          return months;\n\n        case 'quarter':\n          return months / 3;\n\n        case 'year':\n          return months / 12;\n      }\n    } else {\n      // handle milliseconds separately because of floating point math errors (issue #1867)\n      days = this._days + Math.round(monthsToDays(this._months));\n\n      switch (units) {\n        case 'week':\n          return days / 7 + milliseconds / 6048e5;\n\n        case 'day':\n          return days + milliseconds / 864e5;\n\n        case 'hour':\n          return days * 24 + milliseconds / 36e5;\n\n        case 'minute':\n          return days * 1440 + milliseconds / 6e4;\n\n        case 'second':\n          return days * 86400 + milliseconds / 1000;\n        // Math.floor prevents floating point math errors here\n\n        case 'millisecond':\n          return Math.floor(days * 864e5) + milliseconds;\n\n        default:\n          throw new Error('Unknown unit ' + units);\n      }\n    }\n  } // TODO: Use this.as('ms')?\n\n\n  function valueOf$1() {\n    if (!this.isValid()) {\n      return NaN;\n    }\n\n    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;\n  }\n\n  function makeAs(alias) {\n    return function () {\n      return this.as(alias);\n    };\n  }\n\n  var asMilliseconds = makeAs('ms'),\n      asSeconds = makeAs('s'),\n      asMinutes = makeAs('m'),\n      asHours = makeAs('h'),\n      asDays = makeAs('d'),\n      asWeeks = makeAs('w'),\n      asMonths = makeAs('M'),\n      asQuarters = makeAs('Q'),\n      asYears = makeAs('y');\n\n  function clone$1() {\n    return createDuration(this);\n  }\n\n  function get$2(units) {\n    units = normalizeUnits(units);\n    return this.isValid() ? this[units + 's']() : NaN;\n  }\n\n  function makeGetter(name) {\n    return function () {\n      return this.isValid() ? this._data[name] : NaN;\n    };\n  }\n\n  var milliseconds = makeGetter('milliseconds'),\n      seconds = makeGetter('seconds'),\n      minutes = makeGetter('minutes'),\n      hours = makeGetter('hours'),\n      days = makeGetter('days'),\n      months = makeGetter('months'),\n      years = makeGetter('years');\n\n  function weeks() {\n    return absFloor(this.days() / 7);\n  }\n\n  var round = Math.round,\n      thresholds = {\n    ss: 44,\n    // a few seconds to seconds\n    s: 45,\n    // seconds to minute\n    m: 45,\n    // minutes to hour\n    h: 22,\n    // hours to day\n    d: 26,\n    // days to month/week\n    w: null,\n    // weeks to month\n    M: 11 // months to year\n\n  }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n\n  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n  }\n\n  function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {\n    var duration = createDuration(posNegDuration).abs(),\n        seconds = round(duration.as('s')),\n        minutes = round(duration.as('m')),\n        hours = round(duration.as('h')),\n        days = round(duration.as('d')),\n        months = round(duration.as('M')),\n        weeks = round(duration.as('w')),\n        years = round(duration.as('y')),\n        a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];\n\n    if (thresholds.w != null) {\n      a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];\n    }\n\n    a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];\n    a[2] = withoutSuffix;\n    a[3] = +posNegDuration > 0;\n    a[4] = locale;\n    return substituteTimeAgo.apply(null, a);\n  } // This function allows you to set the rounding function for relative time strings\n\n\n  function getSetRelativeTimeRounding(roundingFunction) {\n    if (roundingFunction === undefined) {\n      return round;\n    }\n\n    if (typeof roundingFunction === 'function') {\n      round = roundingFunction;\n      return true;\n    }\n\n    return false;\n  } // This function allows you to set a threshold for relative time strings\n\n\n  function getSetRelativeTimeThreshold(threshold, limit) {\n    if (thresholds[threshold] === undefined) {\n      return false;\n    }\n\n    if (limit === undefined) {\n      return thresholds[threshold];\n    }\n\n    thresholds[threshold] = limit;\n\n    if (threshold === 's') {\n      thresholds.ss = limit - 1;\n    }\n\n    return true;\n  }\n\n  function humanize(argWithSuffix, argThresholds) {\n    if (!this.isValid()) {\n      return this.localeData().invalidDate();\n    }\n\n    var withSuffix = false,\n        th = thresholds,\n        locale,\n        output;\n\n    if (typeof argWithSuffix === 'object') {\n      argThresholds = argWithSuffix;\n      argWithSuffix = false;\n    }\n\n    if (typeof argWithSuffix === 'boolean') {\n      withSuffix = argWithSuffix;\n    }\n\n    if (typeof argThresholds === 'object') {\n      th = Object.assign({}, thresholds, argThresholds);\n\n      if (argThresholds.s != null && argThresholds.ss == null) {\n        th.ss = argThresholds.s - 1;\n      }\n    }\n\n    locale = this.localeData();\n    output = relativeTime$1(this, !withSuffix, th, locale);\n\n    if (withSuffix) {\n      output = locale.pastFuture(+this, output);\n    }\n\n    return locale.postformat(output);\n  }\n\n  var abs$1 = Math.abs;\n\n  function sign(x) {\n    return (x > 0) - (x < 0) || +x;\n  }\n\n  function toISOString$1() {\n    // for ISO strings we do not use the normal bubbling rules:\n    //  * milliseconds bubble up until they become hours\n    //  * days do not bubble at all\n    //  * months bubble up until they become years\n    // This is because there is no context-free conversion between hours and days\n    // (think of clock changes)\n    // and also not between days and months (28-31 days per month)\n    if (!this.isValid()) {\n      return this.localeData().invalidDate();\n    }\n\n    var seconds = abs$1(this._milliseconds) / 1000,\n        days = abs$1(this._days),\n        months = abs$1(this._months),\n        minutes,\n        hours,\n        years,\n        s,\n        total = this.asSeconds(),\n        totalSign,\n        ymSign,\n        daysSign,\n        hmsSign;\n\n    if (!total) {\n      // this is the same as C#'s (Noda) and python (isodate)...\n      // but not other JS (goog.date)\n      return 'P0D';\n    } // 3600 seconds -> 60 minutes -> 1 hour\n\n\n    minutes = absFloor(seconds / 60);\n    hours = absFloor(minutes / 60);\n    seconds %= 60;\n    minutes %= 60; // 12 months -> 1 year\n\n    years = absFloor(months / 12);\n    months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n\n    s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n    totalSign = total < 0 ? '-' : '';\n    ymSign = sign(this._months) !== sign(total) ? '-' : '';\n    daysSign = sign(this._days) !== sign(total) ? '-' : '';\n    hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n    return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');\n  }\n\n  var proto$2 = Duration.prototype;\n  proto$2.isValid = isValid$1;\n  proto$2.abs = abs;\n  proto$2.add = add$1;\n  proto$2.subtract = subtract$1;\n  proto$2.as = as;\n  proto$2.asMilliseconds = asMilliseconds;\n  proto$2.asSeconds = asSeconds;\n  proto$2.asMinutes = asMinutes;\n  proto$2.asHours = asHours;\n  proto$2.asDays = asDays;\n  proto$2.asWeeks = asWeeks;\n  proto$2.asMonths = asMonths;\n  proto$2.asQuarters = asQuarters;\n  proto$2.asYears = asYears;\n  proto$2.valueOf = valueOf$1;\n  proto$2._bubble = bubble;\n  proto$2.clone = clone$1;\n  proto$2.get = get$2;\n  proto$2.milliseconds = milliseconds;\n  proto$2.seconds = seconds;\n  proto$2.minutes = minutes;\n  proto$2.hours = hours;\n  proto$2.days = days;\n  proto$2.weeks = weeks;\n  proto$2.months = months;\n  proto$2.years = years;\n  proto$2.humanize = humanize;\n  proto$2.toISOString = toISOString$1;\n  proto$2.toString = toISOString$1;\n  proto$2.toJSON = toISOString$1;\n  proto$2.locale = locale;\n  proto$2.localeData = localeData;\n  proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n  proto$2.lang = lang; // FORMATTING\n\n  addFormatToken('X', 0, 0, 'unix');\n  addFormatToken('x', 0, 0, 'valueOf'); // PARSING\n\n  addRegexToken('x', matchSigned);\n  addRegexToken('X', matchTimestamp);\n  addParseToken('X', function (input, array, config) {\n    config._d = new Date(parseFloat(input) * 1000);\n  });\n  addParseToken('x', function (input, array, config) {\n    config._d = new Date(toInt(input));\n  }); //! moment.js\n\n  hooks.version = '2.29.3';\n  setHookCallback(createLocal);\n  hooks.fn = proto;\n  hooks.min = min;\n  hooks.max = max;\n  hooks.now = now;\n  hooks.utc = createUTC;\n  hooks.unix = createUnix;\n  hooks.months = listMonths;\n  hooks.isDate = isDate;\n  hooks.locale = getSetGlobalLocale;\n  hooks.invalid = createInvalid;\n  hooks.duration = createDuration;\n  hooks.isMoment = isMoment;\n  hooks.weekdays = listWeekdays;\n  hooks.parseZone = createInZone;\n  hooks.localeData = getLocale;\n  hooks.isDuration = isDuration;\n  hooks.monthsShort = listMonthsShort;\n  hooks.weekdaysMin = listWeekdaysMin;\n  hooks.defineLocale = defineLocale;\n  hooks.updateLocale = updateLocale;\n  hooks.locales = listLocales;\n  hooks.weekdaysShort = listWeekdaysShort;\n  hooks.normalizeUnits = normalizeUnits;\n  hooks.relativeTimeRounding = getSetRelativeTimeRounding;\n  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n  hooks.calendarFormat = getCalendarFormat;\n  hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats\n\n  hooks.HTML5_FMT = {\n    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',\n    // <input type=\"datetime-local\" />\n    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',\n    // <input type=\"datetime-local\" step=\"1\" />\n    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',\n    // <input type=\"datetime-local\" step=\"0.001\" />\n    DATE: 'YYYY-MM-DD',\n    // <input type=\"date\" />\n    TIME: 'HH:mm',\n    // <input type=\"time\" />\n    TIME_SECONDS: 'HH:mm:ss',\n    // <input type=\"time\" step=\"1\" />\n    TIME_MS: 'HH:mm:ss.SSS',\n    // <input type=\"time\" step=\"0.001\" />\n    WEEK: 'GGGG-[W]WW',\n    // <input type=\"week\" />\n    MONTH: 'YYYY-MM' // <input type=\"month\" />\n\n  };\n  return hooks;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"hOG+\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcz9jMWRmIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiaG9va0NhbGxiYWNrIiwiaG9va3MiLCJhcHBseSIsImFyZ3VtZW50cyIsInNldEhvb2tDYWxsYmFjayIsImNhbGxiYWNrIiwiaXNBcnJheSIsImlucHV0IiwiQXJyYXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc09iamVjdCIsImhhc093blByb3AiLCJhIiwiYiIsImhhc093blByb3BlcnR5IiwiaXNPYmplY3RFbXB0eSIsIm9iaiIsImdldE93blByb3BlcnR5TmFtZXMiLCJsZW5ndGgiLCJrIiwiaXNVbmRlZmluZWQiLCJpc051bWJlciIsImlzRGF0ZSIsIkRhdGUiLCJtYXAiLCJhcnIiLCJmbiIsInJlcyIsImkiLCJhcnJMZW4iLCJwdXNoIiwiZXh0ZW5kIiwidmFsdWVPZiIsImNyZWF0ZVVUQyIsImZvcm1hdCIsImxvY2FsZSIsInN0cmljdCIsImNyZWF0ZUxvY2FsT3JVVEMiLCJ1dGMiLCJkZWZhdWx0UGFyc2luZ0ZsYWdzIiwiZW1wdHkiLCJ1bnVzZWRUb2tlbnMiLCJ1bnVzZWRJbnB1dCIsIm92ZXJmbG93IiwiY2hhcnNMZWZ0T3ZlciIsIm51bGxJbnB1dCIsImludmFsaWRFcmEiLCJpbnZhbGlkTW9udGgiLCJpbnZhbGlkRm9ybWF0IiwidXNlckludmFsaWRhdGVkIiwiaXNvIiwicGFyc2VkRGF0ZVBhcnRzIiwiZXJhIiwibWVyaWRpZW0iLCJyZmMyODIyIiwid2Vla2RheU1pc21hdGNoIiwiZ2V0UGFyc2luZ0ZsYWdzIiwibSIsIl9wZiIsInNvbWUiLCJmdW4iLCJ0IiwibGVuIiwiaXNWYWxpZCIsIl9pc1ZhbGlkIiwiZmxhZ3MiLCJwYXJzZWRQYXJ0cyIsImlzTm93VmFsaWQiLCJpc05hTiIsIl9kIiwiZ2V0VGltZSIsImludmFsaWRXZWVrZGF5IiwiX3N0cmljdCIsImJpZ0hvdXIiLCJ1bmRlZmluZWQiLCJpc0Zyb3plbiIsImNyZWF0ZUludmFsaWQiLCJOYU4iLCJtb21lbnRQcm9wZXJ0aWVzIiwidXBkYXRlSW5Qcm9ncmVzcyIsImNvcHlDb25maWciLCJ0byIsImZyb20iLCJwcm9wIiwidmFsIiwibW9tZW50UHJvcGVydGllc0xlbiIsIl9pc0FNb21lbnRPYmplY3QiLCJfaSIsIl9mIiwiX2wiLCJfdHptIiwiX2lzVVRDIiwiX29mZnNldCIsIl9sb2NhbGUiLCJNb21lbnQiLCJjb25maWciLCJ1cGRhdGVPZmZzZXQiLCJpc01vbWVudCIsIndhcm4iLCJtc2ciLCJzdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MiLCJjb25zb2xlIiwiZGVwcmVjYXRlIiwiZmlyc3RUaW1lIiwiZGVwcmVjYXRpb25IYW5kbGVyIiwiYXJncyIsImFyZyIsImtleSIsImFyZ0xlbiIsInNsaWNlIiwiam9pbiIsIkVycm9yIiwic3RhY2siLCJkZXByZWNhdGlvbnMiLCJkZXByZWNhdGVTaW1wbGUiLCJuYW1lIiwiaXNGdW5jdGlvbiIsIkZ1bmN0aW9uIiwic2V0IiwiX2NvbmZpZyIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCIsIlJlZ0V4cCIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwic291cmNlIiwiX29yZGluYWxQYXJzZSIsIm1lcmdlQ29uZmlncyIsInBhcmVudENvbmZpZyIsImNoaWxkQ29uZmlnIiwiTG9jYWxlIiwia2V5cyIsImRlZmF1bHRDYWxlbmRhciIsInNhbWVEYXkiLCJuZXh0RGF5IiwibmV4dFdlZWsiLCJsYXN0RGF5IiwibGFzdFdlZWsiLCJzYW1lRWxzZSIsImNhbGVuZGFyIiwibW9tIiwibm93Iiwib3V0cHV0IiwiX2NhbGVuZGFyIiwiemVyb0ZpbGwiLCJudW1iZXIiLCJ0YXJnZXRMZW5ndGgiLCJmb3JjZVNpZ24iLCJhYnNOdW1iZXIiLCJNYXRoIiwiYWJzIiwiemVyb3NUb0ZpbGwiLCJzaWduIiwicG93IiwibWF4Iiwic3Vic3RyIiwiZm9ybWF0dGluZ1Rva2VucyIsImxvY2FsRm9ybWF0dGluZ1Rva2VucyIsImZvcm1hdEZ1bmN0aW9ucyIsImZvcm1hdFRva2VuRnVuY3Rpb25zIiwiYWRkRm9ybWF0VG9rZW4iLCJ0b2tlbiIsInBhZGRlZCIsIm9yZGluYWwiLCJmdW5jIiwibG9jYWxlRGF0YSIsInJlbW92ZUZvcm1hdHRpbmdUb2tlbnMiLCJtYXRjaCIsInJlcGxhY2UiLCJtYWtlRm9ybWF0RnVuY3Rpb24iLCJhcnJheSIsImZvcm1hdE1vbWVudCIsImludmFsaWREYXRlIiwiZXhwYW5kRm9ybWF0IiwicmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zIiwibG9uZ0RhdGVGb3JtYXQiLCJsYXN0SW5kZXgiLCJ0ZXN0IiwiZGVmYXVsdExvbmdEYXRlRm9ybWF0IiwiTFRTIiwiTFQiLCJMIiwiTEwiLCJMTEwiLCJMTExMIiwiX2xvbmdEYXRlRm9ybWF0IiwiZm9ybWF0VXBwZXIiLCJ0b1VwcGVyQ2FzZSIsInRvayIsImRlZmF1bHRJbnZhbGlkRGF0ZSIsIl9pbnZhbGlkRGF0ZSIsImRlZmF1bHRPcmRpbmFsIiwiZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJfb3JkaW5hbCIsImRlZmF1bHRSZWxhdGl2ZVRpbWUiLCJmdXR1cmUiLCJwYXN0IiwicyIsInNzIiwibW0iLCJoIiwiaGgiLCJkIiwiZGQiLCJ3Iiwid3ciLCJNIiwiTU0iLCJ5IiwieXkiLCJyZWxhdGl2ZVRpbWUiLCJ3aXRob3V0U3VmZml4Iiwic3RyaW5nIiwiaXNGdXR1cmUiLCJfcmVsYXRpdmVUaW1lIiwicGFzdEZ1dHVyZSIsImRpZmYiLCJhbGlhc2VzIiwiYWRkVW5pdEFsaWFzIiwidW5pdCIsInNob3J0aGFuZCIsImxvd2VyQ2FzZSIsInRvTG93ZXJDYXNlIiwibm9ybWFsaXplVW5pdHMiLCJ1bml0cyIsIm5vcm1hbGl6ZU9iamVjdFVuaXRzIiwiaW5wdXRPYmplY3QiLCJub3JtYWxpemVkSW5wdXQiLCJub3JtYWxpemVkUHJvcCIsInByaW9yaXRpZXMiLCJhZGRVbml0UHJpb3JpdHkiLCJwcmlvcml0eSIsImdldFByaW9yaXRpemVkVW5pdHMiLCJ1bml0c09iaiIsInUiLCJzb3J0IiwiaXNMZWFwWWVhciIsInllYXIiLCJhYnNGbG9vciIsImNlaWwiLCJmbG9vciIsInRvSW50IiwiYXJndW1lbnRGb3JDb2VyY2lvbiIsImNvZXJjZWROdW1iZXIiLCJ2YWx1ZSIsImlzRmluaXRlIiwibWFrZUdldFNldCIsImtlZXBUaW1lIiwic2V0JDEiLCJnZXQiLCJtb250aCIsImRhdGUiLCJkYXlzSW5Nb250aCIsInN0cmluZ0dldCIsInN0cmluZ1NldCIsInByaW9yaXRpemVkIiwicHJpb3JpdGl6ZWRMZW4iLCJtYXRjaDEiLCJtYXRjaDIiLCJtYXRjaDMiLCJtYXRjaDQiLCJtYXRjaDYiLCJtYXRjaDF0bzIiLCJtYXRjaDN0bzQiLCJtYXRjaDV0bzYiLCJtYXRjaDF0bzMiLCJtYXRjaDF0bzQiLCJtYXRjaDF0bzYiLCJtYXRjaFVuc2lnbmVkIiwibWF0Y2hTaWduZWQiLCJtYXRjaE9mZnNldCIsIm1hdGNoU2hvcnRPZmZzZXQiLCJtYXRjaFRpbWVzdGFtcCIsIm1hdGNoV29yZCIsInJlZ2V4ZXMiLCJhZGRSZWdleFRva2VuIiwicmVnZXgiLCJzdHJpY3RSZWdleCIsImlzU3RyaWN0IiwiZ2V0UGFyc2VSZWdleEZvclRva2VuIiwidW5lc2NhcGVGb3JtYXQiLCJyZWdleEVzY2FwZSIsIm1hdGNoZWQiLCJwMSIsInAyIiwicDMiLCJwNCIsInRva2VucyIsImFkZFBhcnNlVG9rZW4iLCJ0b2tlbkxlbiIsImFkZFdlZWtQYXJzZVRva2VuIiwiX3ciLCJhZGRUaW1lVG9BcnJheUZyb21Ub2tlbiIsIl9hIiwiWUVBUiIsIk1PTlRIIiwiREFURSIsIkhPVVIiLCJNSU5VVEUiLCJTRUNPTkQiLCJNSUxMSVNFQ09ORCIsIldFRUsiLCJXRUVLREFZIiwibW9kIiwibiIsIngiLCJpbmRleE9mIiwibyIsIm1vZE1vbnRoIiwibW9udGhzU2hvcnQiLCJtb250aHMiLCJtb250aHNTaG9ydFJlZ2V4IiwibW9udGhzUmVnZXgiLCJtb250aHNQYXJzZSIsImRlZmF1bHRMb2NhbGVNb250aHMiLCJzcGxpdCIsImRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCIsIk1PTlRIU19JTl9GT1JNQVQiLCJkZWZhdWx0TW9udGhzU2hvcnRSZWdleCIsImRlZmF1bHRNb250aHNSZWdleCIsImxvY2FsZU1vbnRocyIsIl9tb250aHMiLCJpc0Zvcm1hdCIsImxvY2FsZU1vbnRoc1Nob3J0IiwiX21vbnRoc1Nob3J0IiwiaGFuZGxlU3RyaWN0UGFyc2UiLCJtb250aE5hbWUiLCJpaSIsImxsYyIsInRvTG9jYWxlTG93ZXJDYXNlIiwiX21vbnRoc1BhcnNlIiwiX2xvbmdNb250aHNQYXJzZSIsIl9zaG9ydE1vbnRoc1BhcnNlIiwibG9jYWxlTW9udGhzUGFyc2UiLCJfbW9udGhzUGFyc2VFeGFjdCIsInNldE1vbnRoIiwiZGF5T2ZNb250aCIsIm1pbiIsImdldFNldE1vbnRoIiwiZ2V0RGF5c0luTW9udGgiLCJjb21wdXRlTW9udGhzUGFyc2UiLCJfbW9udGhzU2hvcnRTdHJpY3RSZWdleCIsIl9tb250aHNTaG9ydFJlZ2V4IiwiX21vbnRoc1N0cmljdFJlZ2V4IiwiX21vbnRoc1JlZ2V4IiwiY21wTGVuUmV2Iiwic2hvcnRQaWVjZXMiLCJsb25nUGllY2VzIiwibWl4ZWRQaWVjZXMiLCJwYXJzZVR3b0RpZ2l0WWVhciIsInBhcnNlSW50IiwiZGF5c0luWWVhciIsImdldFNldFllYXIiLCJnZXRJc0xlYXBZZWFyIiwiY3JlYXRlRGF0ZSIsIm1zIiwiZ2V0RnVsbFllYXIiLCJzZXRGdWxsWWVhciIsImNyZWF0ZVVUQ0RhdGUiLCJVVEMiLCJnZXRVVENGdWxsWWVhciIsInNldFVUQ0Z1bGxZZWFyIiwiZmlyc3RXZWVrT2Zmc2V0IiwiZG93IiwiZG95IiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXlPZlllYXJGcm9tV2Vla3MiLCJ3ZWVrIiwid2Vla2RheSIsImxvY2FsV2Vla2RheSIsIndlZWtPZmZzZXQiLCJkYXlPZlllYXIiLCJyZXNZZWFyIiwicmVzRGF5T2ZZZWFyIiwid2Vla09mWWVhciIsInJlc1dlZWsiLCJ3ZWVrc0luWWVhciIsIndlZWtPZmZzZXROZXh0IiwibG9jYWxlV2VlayIsIl93ZWVrIiwiZGVmYXVsdExvY2FsZVdlZWsiLCJsb2NhbGVGaXJzdERheU9mV2VlayIsImxvY2FsZUZpcnN0RGF5T2ZZZWFyIiwiZ2V0U2V0V2VlayIsImFkZCIsImdldFNldElTT1dlZWsiLCJ3ZWVrZGF5c01pbiIsIndlZWtkYXlzU2hvcnQiLCJ3ZWVrZGF5cyIsIndlZWtkYXlzTWluUmVnZXgiLCJ3ZWVrZGF5c1Nob3J0UmVnZXgiLCJ3ZWVrZGF5c1JlZ2V4Iiwid2Vla2RheXNQYXJzZSIsInBhcnNlV2Vla2RheSIsInBhcnNlSXNvV2Vla2RheSIsInNoaWZ0V2Vla2RheXMiLCJ3cyIsImNvbmNhdCIsImRlZmF1bHRMb2NhbGVXZWVrZGF5cyIsImRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0IiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluIiwiZGVmYXVsdFdlZWtkYXlzUmVnZXgiLCJkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4IiwiZGVmYXVsdFdlZWtkYXlzTWluUmVnZXgiLCJsb2NhbGVXZWVrZGF5cyIsIl93ZWVrZGF5cyIsImRheSIsImxvY2FsZVdlZWtkYXlzU2hvcnQiLCJfd2Vla2RheXNTaG9ydCIsImxvY2FsZVdlZWtkYXlzTWluIiwiX3dlZWtkYXlzTWluIiwiaGFuZGxlU3RyaWN0UGFyc2UkMSIsIndlZWtkYXlOYW1lIiwiX3dlZWtkYXlzUGFyc2UiLCJfc2hvcnRXZWVrZGF5c1BhcnNlIiwiX21pbldlZWtkYXlzUGFyc2UiLCJsb2NhbGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzUGFyc2VFeGFjdCIsIl9mdWxsV2Vla2RheXNQYXJzZSIsImdldFNldERheU9mV2VlayIsImdldERheSIsImdldFNldExvY2FsZURheU9mV2VlayIsImdldFNldElTT0RheU9mV2VlayIsImNvbXB1dGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNSZWdleCIsIl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXgiLCJfd2Vla2RheXNTaG9ydFJlZ2V4IiwiX3dlZWtkYXlzTWluU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNNaW5SZWdleCIsIm1pblBpZWNlcyIsIm1pbnAiLCJzaG9ydHAiLCJsb25ncCIsImhGb3JtYXQiLCJob3VycyIsImtGb3JtYXQiLCJtaW51dGVzIiwic2Vjb25kcyIsImxvd2VyY2FzZSIsIm1hdGNoTWVyaWRpZW0iLCJfbWVyaWRpZW1QYXJzZSIsImtJbnB1dCIsIl9pc1BtIiwiaXNQTSIsIl9tZXJpZGllbSIsInBvcyIsInBvczEiLCJwb3MyIiwibG9jYWxlSXNQTSIsImNoYXJBdCIsImRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlIiwiZ2V0U2V0SG91ciIsImxvY2FsZU1lcmlkaWVtIiwiaXNMb3dlciIsImJhc2VDb25maWciLCJkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwibWVyaWRpZW1QYXJzZSIsImxvY2FsZXMiLCJsb2NhbGVGYW1pbGllcyIsImdsb2JhbExvY2FsZSIsImNvbW1vblByZWZpeCIsImFycjEiLCJhcnIyIiwibWlubCIsIm5vcm1hbGl6ZUxvY2FsZSIsImNob29zZUxvY2FsZSIsIm5hbWVzIiwiaiIsIm5leHQiLCJsb2FkTG9jYWxlIiwiaXNMb2NhbGVOYW1lU2FuZSIsIm9sZExvY2FsZSIsImFsaWFzZWRSZXF1aXJlIiwiX2FiYnIiLCJyZXF1aXJlIiwiZ2V0U2V0R2xvYmFsTG9jYWxlIiwiZSIsInZhbHVlcyIsImRhdGEiLCJnZXRMb2NhbGUiLCJkZWZpbmVMb2NhbGUiLCJhYmJyIiwicGFyZW50TG9jYWxlIiwiZm9yRWFjaCIsInVwZGF0ZUxvY2FsZSIsInRtcExvY2FsZSIsImxpc3RMb2NhbGVzIiwiY2hlY2tPdmVyZmxvdyIsIl9vdmVyZmxvd0RheU9mWWVhciIsIl9vdmVyZmxvd1dlZWtzIiwiX292ZXJmbG93V2Vla2RheSIsImV4dGVuZGVkSXNvUmVnZXgiLCJiYXNpY0lzb1JlZ2V4IiwidHpSZWdleCIsImlzb0RhdGVzIiwiaXNvVGltZXMiLCJhc3BOZXRKc29uUmVnZXgiLCJvYnNPZmZzZXRzIiwiVVQiLCJHTVQiLCJFRFQiLCJFU1QiLCJDRFQiLCJDU1QiLCJNRFQiLCJNU1QiLCJQRFQiLCJQU1QiLCJjb25maWdGcm9tSVNPIiwibCIsImV4ZWMiLCJhbGxvd1RpbWUiLCJkYXRlRm9ybWF0IiwidGltZUZvcm1hdCIsInR6Rm9ybWF0IiwiaXNvRGF0ZXNMZW4iLCJpc29UaW1lc0xlbiIsImNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQiLCJleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzIiwieWVhclN0ciIsIm1vbnRoU3RyIiwiZGF5U3RyIiwiaG91clN0ciIsIm1pbnV0ZVN0ciIsInNlY29uZFN0ciIsInJlc3VsdCIsInVudHJ1bmNhdGVZZWFyIiwicHJlcHJvY2Vzc1JGQzI4MjIiLCJjaGVja1dlZWtkYXkiLCJ3ZWVrZGF5U3RyIiwicGFyc2VkSW5wdXQiLCJ3ZWVrZGF5UHJvdmlkZWQiLCJ3ZWVrZGF5QWN0dWFsIiwiY2FsY3VsYXRlT2Zmc2V0Iiwib2JzT2Zmc2V0IiwibWlsaXRhcnlPZmZzZXQiLCJudW1PZmZzZXQiLCJobSIsImNvbmZpZ0Zyb21SRkMyODIyIiwicGFyc2VkQXJyYXkiLCJzZXRVVENNaW51dGVzIiwiZ2V0VVRDTWludXRlcyIsImNvbmZpZ0Zyb21TdHJpbmciLCJjcmVhdGVGcm9tSW5wdXRGYWxsYmFjayIsIl91c2VVVEMiLCJkZWZhdWx0cyIsImMiLCJjdXJyZW50RGF0ZUFycmF5Iiwibm93VmFsdWUiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRNb250aCIsImdldERhdGUiLCJjb25maWdGcm9tQXJyYXkiLCJjdXJyZW50RGF0ZSIsImV4cGVjdGVkV2Vla2RheSIsInllYXJUb1VzZSIsImRheU9mWWVhckZyb21XZWVrSW5mbyIsIl9kYXlPZlllYXIiLCJfbmV4dERheSIsIndlZWtZZWFyIiwidGVtcCIsIndlZWtkYXlPdmVyZmxvdyIsImN1cldlZWsiLCJHRyIsIlciLCJFIiwiY3JlYXRlTG9jYWwiLCJnZyIsIklTT184NjAxIiwiUkZDXzI4MjIiLCJza2lwcGVkIiwic3RyaW5nTGVuZ3RoIiwidG90YWxQYXJzZWRJbnB1dExlbmd0aCIsIm1lcmlkaWVtRml4V3JhcCIsImVyYXNDb252ZXJ0WWVhciIsImhvdXIiLCJpc1BtIiwibWVyaWRpZW1Ib3VyIiwiY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5IiwidGVtcENvbmZpZyIsImJlc3RNb21lbnQiLCJzY29yZVRvQmVhdCIsImN1cnJlbnRTY29yZSIsInZhbGlkRm9ybWF0Rm91bmQiLCJiZXN0Rm9ybWF0SXNWYWxpZCIsImNvbmZpZ2ZMZW4iLCJzY29yZSIsImNvbmZpZ0Zyb21PYmplY3QiLCJkYXlPckRhdGUiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsImNyZWF0ZUZyb21Db25maWciLCJwcmVwYXJlQ29uZmlnIiwicHJlcGFyc2UiLCJjb25maWdGcm9tSW5wdXQiLCJpc1VUQyIsInByb3RvdHlwZU1pbiIsIm90aGVyIiwicHJvdG90eXBlTWF4IiwicGlja0J5IiwibW9tZW50cyIsIm9yZGVyaW5nIiwiaXNEdXJhdGlvblZhbGlkIiwidW5pdEhhc0RlY2ltYWwiLCJvcmRlckxlbiIsInBhcnNlRmxvYXQiLCJpc1ZhbGlkJDEiLCJjcmVhdGVJbnZhbGlkJDEiLCJjcmVhdGVEdXJhdGlvbiIsIkR1cmF0aW9uIiwiZHVyYXRpb24iLCJ5ZWFycyIsInF1YXJ0ZXJzIiwicXVhcnRlciIsIndlZWtzIiwiaXNvV2VlayIsImRheXMiLCJtaWxsaXNlY29uZHMiLCJfbWlsbGlzZWNvbmRzIiwiX2RheXMiLCJfZGF0YSIsIl9idWJibGUiLCJpc0R1cmF0aW9uIiwiYWJzUm91bmQiLCJyb3VuZCIsImNvbXBhcmVBcnJheXMiLCJhcnJheTEiLCJhcnJheTIiLCJkb250Q29udmVydCIsImxlbmd0aERpZmYiLCJkaWZmcyIsIm9mZnNldCIsInNlcGFyYXRvciIsInV0Y09mZnNldCIsIm9mZnNldEZyb21TdHJpbmciLCJjaHVua09mZnNldCIsIm1hdGNoZXIiLCJtYXRjaGVzIiwiY2h1bmsiLCJwYXJ0cyIsImNsb25lV2l0aE9mZnNldCIsIm1vZGVsIiwiY2xvbmUiLCJzZXRUaW1lIiwibG9jYWwiLCJnZXREYXRlT2Zmc2V0IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJnZXRTZXRPZmZzZXQiLCJrZWVwTG9jYWxUaW1lIiwia2VlcE1pbnV0ZXMiLCJsb2NhbEFkanVzdCIsIl9jaGFuZ2VJblByb2dyZXNzIiwiYWRkU3VidHJhY3QiLCJnZXRTZXRab25lIiwic2V0T2Zmc2V0VG9VVEMiLCJzZXRPZmZzZXRUb0xvY2FsIiwic3VidHJhY3QiLCJzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCIsInRab25lIiwiaGFzQWxpZ25lZEhvdXJPZmZzZXQiLCJpc0RheWxpZ2h0U2F2aW5nVGltZSIsImlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCIsIl9pc0RTVFNoaWZ0ZWQiLCJ0b0FycmF5IiwiaXNMb2NhbCIsImlzVXRjT2Zmc2V0IiwiaXNVdGMiLCJhc3BOZXRSZWdleCIsImlzb1JlZ2V4IiwicmV0IiwiZGlmZlJlcyIsInBhcnNlSXNvIiwibW9tZW50c0RpZmZlcmVuY2UiLCJpbnZhbGlkIiwiaW5wIiwicG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZSIsImJhc2UiLCJpc0FmdGVyIiwiaXNCZWZvcmUiLCJjcmVhdGVBZGRlciIsImRpcmVjdGlvbiIsInBlcmlvZCIsImR1ciIsInRtcCIsImlzQWRkaW5nIiwiaXNTdHJpbmciLCJTdHJpbmciLCJpc01vbWVudElucHV0IiwiaXNOdW1iZXJPclN0cmluZ0FycmF5IiwiaXNNb21lbnRJbnB1dE9iamVjdCIsIm9iamVjdFRlc3QiLCJwcm9wZXJ0eVRlc3QiLCJwcm9wZXJ0aWVzIiwicHJvcGVydHkiLCJwcm9wZXJ0eUxlbiIsImFycmF5VGVzdCIsImRhdGFUeXBlVGVzdCIsImZpbHRlciIsIml0ZW0iLCJpc0NhbGVuZGFyU3BlYyIsImdldENhbGVuZGFyRm9ybWF0IiwibXlNb21lbnQiLCJjYWxlbmRhciQxIiwidGltZSIsImZvcm1hdHMiLCJzb2QiLCJzdGFydE9mIiwiY2FsZW5kYXJGb3JtYXQiLCJsb2NhbElucHV0IiwiZW5kT2YiLCJpc0JldHdlZW4iLCJpbmNsdXNpdml0eSIsImxvY2FsRnJvbSIsImxvY2FsVG8iLCJpc1NhbWUiLCJpbnB1dE1zIiwiaXNTYW1lT3JBZnRlciIsImlzU2FtZU9yQmVmb3JlIiwiYXNGbG9hdCIsInRoYXQiLCJ6b25lRGVsdGEiLCJtb250aERpZmYiLCJ3aG9sZU1vbnRoRGlmZiIsImFuY2hvciIsImFuY2hvcjIiLCJhZGp1c3QiLCJkZWZhdWx0Rm9ybWF0IiwiZGVmYXVsdEZvcm1hdFV0YyIsInRvSVNPU3RyaW5nIiwia2VlcE9mZnNldCIsInRvRGF0ZSIsImluc3BlY3QiLCJ6b25lIiwicHJlZml4IiwiZGF0ZXRpbWUiLCJzdWZmaXgiLCJpbnB1dFN0cmluZyIsInBvc3Rmb3JtYXQiLCJodW1hbml6ZSIsImZyb21Ob3ciLCJ0b05vdyIsIm5ld0xvY2FsZURhdGEiLCJsYW5nIiwiTVNfUEVSX1NFQ09ORCIsIk1TX1BFUl9NSU5VVEUiLCJNU19QRVJfSE9VUiIsIk1TX1BFUl80MDBfWUVBUlMiLCJtb2QkMSIsImRpdmlkZW5kIiwiZGl2aXNvciIsImxvY2FsU3RhcnRPZkRhdGUiLCJ1dGNTdGFydE9mRGF0ZSIsInN0YXJ0T2ZEYXRlIiwiaXNvV2Vla2RheSIsInVuaXgiLCJ0b09iamVjdCIsInRvSlNPTiIsImlzVmFsaWQkMiIsInBhcnNpbmdGbGFncyIsImludmFsaWRBdCIsImNyZWF0aW9uRGF0YSIsIm1hdGNoRXJhQWJiciIsIm1hdGNoRXJhTmFtZSIsIm1hdGNoRXJhTmFycm93IiwiZXJhc1BhcnNlIiwibWF0Y2hFcmFZZWFyT3JkaW5hbCIsIl9lcmFZZWFyT3JkaW5hbFJlZ2V4IiwiZXJhWWVhck9yZGluYWxQYXJzZSIsImxvY2FsZUVyYXMiLCJlcmFzIiwiX2VyYXMiLCJzaW5jZSIsInVudGlsIiwiSW5maW5pdHkiLCJsb2NhbGVFcmFzUGFyc2UiLCJlcmFOYW1lIiwibmFycm93IiwibG9jYWxlRXJhc0NvbnZlcnRZZWFyIiwiZGlyIiwiZ2V0RXJhTmFtZSIsImdldEVyYU5hcnJvdyIsImdldEVyYUFiYnIiLCJnZXRFcmFZZWFyIiwiZXJhc05hbWVSZWdleCIsImNvbXB1dGVFcmFzUGFyc2UiLCJfZXJhc05hbWVSZWdleCIsIl9lcmFzUmVnZXgiLCJlcmFzQWJiclJlZ2V4IiwiX2VyYXNBYmJyUmVnZXgiLCJlcmFzTmFycm93UmVnZXgiLCJfZXJhc05hcnJvd1JlZ2V4IiwiYWJiclBpZWNlcyIsIm5hbWVQaWVjZXMiLCJuYXJyb3dQaWVjZXMiLCJpc29XZWVrWWVhciIsImFkZFdlZWtZZWFyRm9ybWF0VG9rZW4iLCJnZXR0ZXIiLCJnZXRTZXRXZWVrWWVhciIsImdldFNldFdlZWtZZWFySGVscGVyIiwiZ2V0U2V0SVNPV2Vla1llYXIiLCJnZXRJU09XZWVrc0luWWVhciIsImdldElTT1dlZWtzSW5JU09XZWVrWWVhciIsImdldFdlZWtzSW5ZZWFyIiwid2Vla0luZm8iLCJnZXRXZWVrc0luV2Vla1llYXIiLCJ3ZWVrc1RhcmdldCIsInNldFdlZWtBbGwiLCJkYXlPZlllYXJEYXRhIiwiZ2V0U2V0UXVhcnRlciIsImdldFNldERheU9mTW9udGgiLCJnZXRTZXREYXlPZlllYXIiLCJnZXRTZXRNaW51dGUiLCJnZXRTZXRTZWNvbmQiLCJnZXRTZXRNaWxsaXNlY29uZCIsInBhcnNlTXMiLCJnZXRab25lQWJiciIsImdldFpvbmVOYW1lIiwicHJvdG8iLCJTeW1ib2wiLCJlcmFOYXJyb3ciLCJlcmFBYmJyIiwiZXJhWWVhciIsImlzb1dlZWtzIiwid2Vla3NJbldlZWtZZWFyIiwiaXNvV2Vla3NJblllYXIiLCJpc29XZWVrc0luSVNPV2Vla1llYXIiLCJwYXJzZVpvbmUiLCJpc0RTVCIsInpvbmVBYmJyIiwiem9uZU5hbWUiLCJkYXRlcyIsImlzRFNUU2hpZnRlZCIsImNyZWF0ZVVuaXgiLCJjcmVhdGVJblpvbmUiLCJwcmVQYXJzZVBvc3RGb3JtYXQiLCJwcm90byQxIiwiZmlyc3REYXlPZlllYXIiLCJmaXJzdERheU9mV2VlayIsImdldCQxIiwiaW5kZXgiLCJmaWVsZCIsInNldHRlciIsImxpc3RNb250aHNJbXBsIiwib3V0IiwibGlzdFdlZWtkYXlzSW1wbCIsImxvY2FsZVNvcnRlZCIsInNoaWZ0IiwibGlzdE1vbnRocyIsImxpc3RNb250aHNTaG9ydCIsImxpc3RXZWVrZGF5cyIsImxpc3RXZWVrZGF5c1Nob3J0IiwibGlzdFdlZWtkYXlzTWluIiwibGFuZ0RhdGEiLCJtYXRoQWJzIiwiYWRkU3VidHJhY3QkMSIsImFkZCQxIiwic3VidHJhY3QkMSIsImFic0NlaWwiLCJidWJibGUiLCJtb250aHNGcm9tRGF5cyIsIm1vbnRoc1RvRGF5cyIsImRheXNUb01vbnRocyIsImFzIiwidmFsdWVPZiQxIiwibWFrZUFzIiwiYWxpYXMiLCJhc01pbGxpc2Vjb25kcyIsImFzU2Vjb25kcyIsImFzTWludXRlcyIsImFzSG91cnMiLCJhc0RheXMiLCJhc1dlZWtzIiwiYXNNb250aHMiLCJhc1F1YXJ0ZXJzIiwiYXNZZWFycyIsImNsb25lJDEiLCJnZXQkMiIsIm1ha2VHZXR0ZXIiLCJ0aHJlc2hvbGRzIiwic3Vic3RpdHV0ZVRpbWVBZ28iLCJyZWxhdGl2ZVRpbWUkMSIsInBvc05lZ0R1cmF0aW9uIiwiZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmciLCJyb3VuZGluZ0Z1bmN0aW9uIiwiZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkIiwidGhyZXNob2xkIiwibGltaXQiLCJhcmdXaXRoU3VmZml4IiwiYXJnVGhyZXNob2xkcyIsIndpdGhTdWZmaXgiLCJ0aCIsImFzc2lnbiIsImFicyQxIiwidG9JU09TdHJpbmckMSIsInRvdGFsIiwidG90YWxTaWduIiwieW1TaWduIiwiZGF5c1NpZ24iLCJobXNTaWduIiwidG9GaXhlZCIsInByb3RvJDIiLCJ0b0lzb1N0cmluZyIsInZlcnNpb24iLCJyZWxhdGl2ZVRpbWVSb3VuZGluZyIsInJlbGF0aXZlVGltZVRocmVzaG9sZCIsIkhUTUw1X0ZNVCIsIkRBVEVUSU1FX0xPQ0FMIiwiREFURVRJTUVfTE9DQUxfU0VDT05EUyIsIkRBVEVUSU1FX0xPQ0FMX01TIiwiVElNRSIsIlRJTUVfU0VDT05EUyIsIlRJTUVfTVMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFBRSxXQUFVQSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjtBQUN6QixVQUErREMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCRixPQUFPLEVBQXZGLEdBQ0EsU0FEQTtBQUdILENBSkMsRUFJQSxJQUpBLEVBSU8sWUFBWTtBQUFFOztBQUVuQixNQUFJRyxZQUFKOztBQUVBLFdBQVNDLEtBQVQsR0FBaUI7QUFDYixXQUFPRCxZQUFZLENBQUNFLEtBQWIsQ0FBbUIsSUFBbkIsRUFBeUJDLFNBQXpCLENBQVA7QUFDSCxHQU5nQixDQVFqQjtBQUNBOzs7QUFDQSxXQUFTQyxlQUFULENBQXlCQyxRQUF6QixFQUFtQztBQUMvQkwsZ0JBQVksR0FBR0ssUUFBZjtBQUNIOztBQUVELFdBQVNDLE9BQVQsQ0FBaUJDLEtBQWpCLEVBQXdCO0FBQ3BCLFdBQ0lBLEtBQUssWUFBWUMsS0FBakIsSUFDQUMsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxRQUFqQixDQUEwQkMsSUFBMUIsQ0FBK0JMLEtBQS9CLE1BQTBDLGdCQUY5QztBQUlIOztBQUVELFdBQVNNLFFBQVQsQ0FBa0JOLEtBQWxCLEVBQXlCO0FBQ3JCO0FBQ0E7QUFDQSxXQUNJQSxLQUFLLElBQUksSUFBVCxJQUNBRSxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLFFBQWpCLENBQTBCQyxJQUExQixDQUErQkwsS0FBL0IsTUFBMEMsaUJBRjlDO0FBSUg7O0FBRUQsV0FBU08sVUFBVCxDQUFvQkMsQ0FBcEIsRUFBdUJDLENBQXZCLEVBQTBCO0FBQ3RCLFdBQU9QLE1BQU0sQ0FBQ0Ms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TixHQUFxQkEsWUFBckI7QUFDQW5lLE9BQUssQ0FBQ3VlLFlBQU4sR0FBcUJBLFlBQXJCO0FBQ0F2ZSxPQUFLLENBQUM0YyxPQUFOLEdBQWdCNkIsV0FBaEI7QUFDQXplLE9BQUssQ0FBQ3FZLGFBQU4sR0FBc0JrZCxpQkFBdEI7QUFDQXYxQixPQUFLLENBQUMrTixjQUFOLEdBQXVCQSxjQUF2QjtBQUNBL04sT0FBSyxDQUFDNDRCLG9CQUFOLEdBQTZCckIsMEJBQTdCO0FBQ0F2M0IsT0FBSyxDQUFDNjRCLHFCQUFOLEdBQThCcEIsMkJBQTlCO0FBQ0F6M0IsT0FBSyxDQUFDd3NCLGNBQU4sR0FBdUJQLGlCQUF2QjtBQUNBanNCLE9BQUssQ0FBQ1MsU0FBTixHQUFrQjZ5QixLQUFsQixDQXpoTGlCLENBMmhMakI7O0FBQ0F0ekIsT0FBSyxDQUFDODRCLFNBQU4sR0FBa0I7QUFDZEMsa0JBQWMsRUFBRSxrQkFERjtBQUNzQjtBQUNwQ0MsMEJBQXNCLEVBQUUscUJBRlY7QUFFaUM7QUFDL0NDLHFCQUFpQixFQUFFLHlCQUhMO0FBR2dDO0FBQzlDem1CLFFBQUksRUFBRSxZQUpRO0FBSU07QUFDcEIwbUIsUUFBSSxFQUFFLE9BTFE7QUFLQztBQUNmQyxnQkFBWSxFQUFFLFVBTkE7QUFNWTtBQUMxQkMsV0FBTyxFQUFFLGNBUEs7QUFPVztBQUN6QnZtQixRQUFJLEVBQUUsWUFSUTtBQVFNO0FBQ3BCTixTQUFLLEVBQUUsU0FUTyxDQVNJOztBQVRKLEdBQWxCO0FBWUEsU0FBT3ZTLEtBQVA7QUFFSCxDQTlpTEMsQ0FBRCxDIiwiZmlsZSI6IndkL1IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMjkuM1xuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzKCkge1xuICAgICAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBkb25lIHRvIHJlZ2lzdGVyIHRoZSBtZXRob2QgY2FsbGVkIHdpdGggbW9tZW50KClcbiAgICAvLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbiAgICBmdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgICAgICAvLyBpbnB1dCAhPSBudWxsXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCAhPSBudWxsICYmXG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0RW1wdHkob2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fFxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGFyckxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRQYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VuczogW10sXG4gICAgICAgICAgICB1bnVzZWRJbnB1dDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdzogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0OiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRFcmE6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGg6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0OiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZDogZmFsc2UsXG4gICAgICAgICAgICBpc286IGZhbHNlLFxuICAgICAgICAgICAgcGFyc2VkRGF0ZVBhcnRzOiBbXSxcbiAgICAgICAgICAgIGVyYTogbnVsbCxcbiAgICAgICAgICAgIG1lcmlkaWVtOiBudWxsLFxuICAgICAgICAgICAgcmZjMjgyMjogZmFsc2UsXG4gICAgICAgICAgICB3ZWVrZGF5TWlzbWF0Y2g6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNpbmdGbGFncyhtKSB7XG4gICAgICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5fcGY7XG4gICAgfVxuXG4gICAgdmFyIHNvbWU7XG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyksXG4gICAgICAgICAgICAgICAgbGVuID0gdC5sZW5ndGggPj4+IDAsXG4gICAgICAgICAgICAgICAgaTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pLFxuICAgICAgICAgICAgICAgIHBhcnNlZFBhcnRzID0gc29tZS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRXJhICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkTW9udGggJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgICAgICghZmxhZ3MubWVyaWRpZW0gfHwgKGZsYWdzLm1lcmlkaWVtICYmIHBhcnNlZFBhcnRzKSk7XG5cbiAgICAgICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBpc05vd1ZhbGlkID1cbiAgICAgICAgICAgICAgICAgICAgaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5jaGFyc0xlZnRPdmVyID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIFBsdWdpbnMgdGhhdCBhZGQgcHJvcGVydGllcyBzaG91bGQgYWxzbyBhZGQgdGhlIGtleSBoZXJlIChudWxsIHZhbHVlKSxcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxuICAgIHZhciBtb21lbnRQcm9wZXJ0aWVzID0gKGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXSksXG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBwcm9wLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgbW9tZW50UHJvcGVydGllc0xlbiA9IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllc0xlbiA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbiAgICBmdW5jdGlvbiBNb21lbnQoY29uZmlnKSB7XG4gICAgICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcCBpbiBjYXNlIHVwZGF0ZU9mZnNldCBjcmVhdGVzIG5ldyBtb21lbnRcbiAgICAgICAgLy8gb2JqZWN0cy5cbiAgICAgICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50KG9iaikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXJnLFxuICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIGFyZ0xlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGFyZ3VtZW50c1swXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgIG1zZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuQXJndW1lbnRzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0eXBlb2YgRnVuY3Rpb24gIT09ICd1bmRlZmluZWQnICYmIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY29uZmlnLCBpKSkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAnfCcgK1xuICAgICAgICAgICAgICAgIC9cXGR7MSwyfS8uc291cmNlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSxcbiAgICAgICAgICAgIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5OiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXk6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5OiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlazogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhcihrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgK1xuICAgICAgICAgICAgYWJzTnVtYmVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPVxuICAgICAgICAgICAgLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KFtIaF1tbShzcyk/fE1vfE1NP00/TT98RG98REREb3xERD9EP0Q/fGRkZD9kP3xkbz98d1tvfHddP3xXW298V10/fFFvP3xOezEsNX18WVlZWVlZfFlZWVlZfFlZWVl8WVl8eXsyLDR9fHlvP3xnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xraz98bW0/fHNzP3xTezEsOX18eHxYfHp6P3xaWj98LikvZyxcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZyxcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zID0ge30sXG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge307XG5cbiAgICAvLyB0b2tlbjogICAgJ00nXG4gICAgLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuICAgIC8vIG9yZGluYWw6ICAnTW8nXG4gICAgLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG4gICAgZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4odG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKFxuICAgICAgICAgICAgICAgICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgICAgICAgICAgIHRva2VuXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gZm9ybWF0Lm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJyxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGlzRnVuY3Rpb24oYXJyYXlbaV0pXG4gICAgICAgICAgICAgICAgICAgID8gYXJyYXlbaV0uY2FsbChtb20sIGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgOiBhcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gZm9ybWF0TW9tZW50KG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPVxuICAgICAgICAgICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyxcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTOiAnaDptbTpzcyBBJyxcbiAgICAgICAgTFQ6ICdoOm1tIEEnLFxuICAgICAgICBMOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMOiAnTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgICAgIExMTEw6ICdkZGRkLCBNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQoa2V5KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldLFxuICAgICAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICAgICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXJcbiAgICAgICAgICAgIC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodG9rKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdNTU1NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdNTScgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnREQnIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ2RkZGQnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2suc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuICAgIGZ1bmN0aW9uIGludmFsaWREYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJyxcbiAgICAgICAgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgICAgICBmdXR1cmU6ICdpbiAlcycsXG4gICAgICAgIHBhc3Q6ICclcyBhZ28nLFxuICAgICAgICBzOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgICAgIHNzOiAnJWQgc2Vjb25kcycsXG4gICAgICAgIG06ICdhIG1pbnV0ZScsXG4gICAgICAgIG1tOiAnJWQgbWludXRlcycsXG4gICAgICAgIGg6ICdhbiBob3VyJyxcbiAgICAgICAgaGg6ICclZCBob3VycycsXG4gICAgICAgIGQ6ICdhIGRheScsXG4gICAgICAgIGRkOiAnJWQgZGF5cycsXG4gICAgICAgIHc6ICdhIHdlZWsnLFxuICAgICAgICB3dzogJyVkIHdlZWtzJyxcbiAgICAgICAgTTogJ2EgbW9udGgnLFxuICAgICAgICBNTTogJyVkIG1vbnRocycsXG4gICAgICAgIHk6ICdhIHllYXInLFxuICAgICAgICB5eTogJyVkIHllYXJzJyxcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dClcbiAgICAgICAgICAgID8gb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSlcbiAgICAgICAgICAgIDogb3V0cHV0LnJlcGxhY2UoLyVkL2ksIG51bWJlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFzdEZ1dHVyZShkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IHVuaXQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVVbml0cyh1bml0cykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0ge30sXG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgICAgIHByb3A7XG5cbiAgICAgICAgZm9yIChwcm9wIGluIGlucHV0T2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVkUHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbiAgICB9XG5cbiAgICB2YXIgcHJpb3JpdGllcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgICAgIHByaW9yaXRpZXNbdW5pdF0gPSBwcmlvcml0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgICAgIHZhciB1bml0cyA9IFtdLFxuICAgICAgICAgICAgdTtcbiAgICAgICAgZm9yICh1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcCh1bml0c09iaiwgdSkpIHtcbiAgICAgICAgICAgICAgICB1bml0cy5wdXNoKHsgdW5pdDogdSwgcHJpb3JpdHk6IHByaW9yaXRpZXNbdV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gKHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDApIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzRmxvb3IobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICAvLyAtMCAtPiAwXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XG4gICAgICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgIT09IDAgJiYgaXNGaW5pdGUoY29lcmNlZE51bWJlcikpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldFNldCh1bml0LCBrZWVwVGltZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNldCQxKHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKClcbiAgICAgICAgICAgID8gbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKClcbiAgICAgICAgICAgIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCQxKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHVuaXQgPT09ICdGdWxsWWVhcicgJiZcbiAgICAgICAgICAgICAgICBpc0xlYXBZZWFyKG1vbS55ZWFyKCkpICYmXG4gICAgICAgICAgICAgICAgbW9tLm1vbnRoKCkgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBtb20uZGF0ZSgpID09PSAyOVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbW9tLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc3RyaW5nR2V0KHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0cmluZ1NldCh1bml0cywgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICAgICAgdmFyIHByaW9yaXRpemVkID0gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0cyksXG4gICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICBwcmlvcml0aXplZExlbiA9IHByaW9yaXRpemVkLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcmlvcml0aXplZExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSA9IC9cXGQvLCAvLyAgICAgICAwIC0gOVxuICAgICAgICBtYXRjaDIgPSAvXFxkXFxkLywgLy8gICAgICAwMCAtIDk5XG4gICAgICAgIG1hdGNoMyA9IC9cXGR7M30vLCAvLyAgICAgMDAwIC0gOTk5XG4gICAgICAgIG1hdGNoNCA9IC9cXGR7NH0vLCAvLyAgICAwMDAwIC0gOTk5OVxuICAgICAgICBtYXRjaDYgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMiA9IC9cXGRcXGQ/LywgLy8gICAgICAgMCAtIDk5XG4gICAgICAgIG1hdGNoM3RvNCA9IC9cXGRcXGRcXGRcXGQ/LywgLy8gICAgIDk5OSAtIDk5OTlcbiAgICAgICAgbWF0Y2g1dG82ID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vLCAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMyA9IC9cXGR7MSwzfS8sIC8vICAgICAgIDAgLSA5OTlcbiAgICAgICAgbWF0Y2gxdG80ID0gL1xcZHsxLDR9LywgLy8gICAgICAgMCAtIDk5OTlcbiAgICAgICAgbWF0Y2gxdG82ID0gL1srLV0/XFxkezEsNn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoVW5zaWduZWQgPSAvXFxkKy8sIC8vICAgICAgIDAgLSBpbmZcbiAgICAgICAgbWF0Y2hTaWduZWQgPSAvWystXT9cXGQrLywgLy8gICAgLWluZiAtIGluZlxuICAgICAgICBtYXRjaE9mZnNldCA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naSwgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuICAgICAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgICAgICBtYXRjaFdvcmQgPVxuICAgICAgICAgICAgL1swLTldezAsMjU2fVsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRjA3XFx1RkYxMC1cXHVGRkVGXXsxLDI1Nn18W1xcdTA2MDAtXFx1MDZGRlxcL117MSwyNTZ9KFxccyo/W1xcdTA2MDAtXFx1MDZGRl17MSwyNTZ9KXsxLDJ9L2ksXG4gICAgICAgIHJlZ2V4ZXM7XG5cbiAgICByZWdleGVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRSZWdleFRva2VuKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KVxuICAgICAgICAgICAgPyByZWdleFxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBpc1N0cmljdCAmJiBzdHJpY3RSZWdleCA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHJlZ2V4ZXMsIHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdleGVzW3Rva2VuXShjb25maWcuX3N0cmljdCwgY29uZmlnLl9sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbiAgICBmdW5jdGlvbiB1bmVzY2FwZUZvcm1hdChzKSB7XG4gICAgICAgIHJldHVybiByZWdleEVzY2FwZShcbiAgICAgICAgICAgIHNcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnXFxcXCcsICcnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZnVuYyA9IGNhbGxiYWNrLFxuICAgICAgICAgICAgdG9rZW5MZW47XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRva2VuTGVuID0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5MZW47IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDAsXG4gICAgICAgIE1PTlRIID0gMSxcbiAgICAgICAgREFURSA9IDIsXG4gICAgICAgIEhPVVIgPSAzLFxuICAgICAgICBNSU5VVEUgPSA0LFxuICAgICAgICBTRUNPTkQgPSA1LFxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXG4gICAgICAgIFdFRUsgPSA3LFxuICAgICAgICBXRUVLREFZID0gODtcblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxXG4gICAgICAgICAgICA/IGlzTGVhcFllYXIoeWVhcilcbiAgICAgICAgICAgICAgICA/IDI5XG4gICAgICAgICAgICAgICAgOiAyOFxuICAgICAgICAgICAgOiAzMSAtICgobW9kTW9udGggJSA3KSAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9XG4gICAgICAgICAgICAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoXG4gICAgICAgICAgICAgICAgJ18nXG4gICAgICAgICAgICApLFxuICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPVxuICAgICAgICAgICAgJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpLFxuICAgICAgICBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vLFxuICAgICAgICBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1xuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbXG4gICAgICAgICAgICAgICAgICAodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFtcbiAgICAgICAgICAgICAgICAgIE1PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/IHplcm9GaWxsKHksIDQpIDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCA0XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgNV0sIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID1cbiAgICAgICAgICAgIGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSh5KSB7XG4gICAgICAgIHZhciBkYXRlLCBhcmdzO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLFxuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlayxcbiAgICAgICAgICAgIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oXG4gICAgICAgIFsndycsICd3dycsICdXJywgJ1dXJ10sXG4gICAgICAgIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93OiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA2dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyh3cywgbikge1xuICAgICAgICByZXR1cm4gd3Muc2xpY2UobiwgNykuY29uY2F0KHdzLnNsaWNlKDAsIG4pKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID1cbiAgICAgICAgICAgICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1xuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1tcbiAgICAgICAgICAgICAgICAgIG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gd2Vla2RheXNbbS5kYXkoKV1cbiAgICAgICAgICAgIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydChtKSB7XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNTaG9ydCwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV1cbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4oXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXMobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sXG4gICAgICAgICAgICBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBtaW5wLFxuICAgICAgICAgICAgc2hvcnRwLFxuICAgICAgICAgICAgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5cyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgdGhpcy5ob3VycygpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQsXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgICAgICAvLyB0aGlzIHJ1bGUuXG4gICAgICAgIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSxcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge30sXG4gICAgICAgIGxvY2FsZUZhbWlsaWVzID0ge30sXG4gICAgICAgIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIGNvbW1vblByZWZpeChhcnIxLCBhcnIyKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbWlubCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5sOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0Lmxlbmd0aCA+PSBqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vblByZWZpeChzcGxpdCwgbmV4dCkgPj0gaiAtIDFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbGVOYW1lU2FuZShuYW1lKSB7XG4gICAgICAgIC8vIFByZXZlbnQgbmFtZXMgdGhhdCBsb29rIGxpa2UgZmlsZXN5c3RlbSBwYXRocywgaS5lIGNvbnRhaW4gJy8nIG9yICdcXCdcbiAgICAgICAgcmV0dXJuIG5hbWUubWF0Y2goJ15bXi9cXFxcXFxcXF0qJCcpICE9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsLFxuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmU7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIG1vZHVsZSAmJlxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgJiZcbiAgICAgICAgICAgIGlzTG9jYWxlTmFtZVNhbmUobmFtZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIG5vdCBmb3VuZCB0byBhdm9pZCByZXBlYXRpbmcgZXhwZW5zaXZlIGZpbGUgcmVxdWlyZSBjYWxsIGNhdXNpbmcgaGlnaCBDUFVcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBmaW5kIGVuLVVTLCBlbl9VUywgZW4tdXMgZm9yIGV2ZXJ5IGZvcm1hdCBjYWxsXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG51bGw7IC8vIG51bGwgbWVhbnMgbm90IGZvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZShrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xvY2FsZSAnICsga2V5ICsgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICAnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcblxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCAmJiBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNoaWxkIGxvY2FsZSBpbi1wbGFjZSB0byBhdm9pZCBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldChtZXJnZUNvbmZpZ3MobG9jYWxlc1tuYW1lXS5fY29uZmlnLCBjb25maWcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlTG9jYWxlIGlzIGNhbGxlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhYmJyIHNvIGl0IHdpbGwgaGF2ZSBhIG5hbWUgKGdldHRlcnMgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvdGhlcndpc2UpLlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZ2V0U2V0R2xvYmFsTG9jYWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyhtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdyxcbiAgICAgICAgICAgIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSA8IDAgfHwgYVtNT05USF0gPiAxMVxuICAgICAgICAgICAgICAgICAgICA/IE1PTlRIXG4gICAgICAgICAgICAgICAgICAgIDogYVtEQVRFXSA8IDEgfHwgYVtEQVRFXSA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKVxuICAgICAgICAgICAgICAgICAgICA/IERBVEVcbiAgICAgICAgICAgICAgICAgICAgOiBhW0hPVVJdIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAgIGFbSE9VUl0gPiAyNCB8fFxuICAgICAgICAgICAgICAgICAgICAgIChhW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYVtNSU5VVEVdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW1NFQ09ORF0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdICE9PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgPyBIT1VSXG4gICAgICAgICAgICAgICAgICAgIDogYVtNSU5VVEVdIDwgMCB8fCBhW01JTlVURV0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTlVURVxuICAgICAgICAgICAgICAgICAgICA6IGFbU0VDT05EXSA8IDAgfHwgYVtTRUNPTkRdID4gNTlcbiAgICAgICAgICAgICAgICAgICAgPyBTRUNPTkRcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTlcbiAgICAgICAgICAgICAgICAgICAgPyBNSUxMSVNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IC0xO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJlxuICAgICAgICAgICAgICAgIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG4gICAgICAgIGJhc2ljSXNvUmVnZXggPVxuICAgICAgICAgICAgL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZHwpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LyxcbiAgICAgICAgaXNvRGF0ZXMgPSBbXG4gICAgICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTScsIC9cXGR7Nn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVknLCAvXFxkezR9LywgZmFsc2VdLFxuICAgICAgICBdLFxuICAgICAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgICAgIGlzb1RpbWVzID0gW1xuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEgnLCAvXFxkXFxkL10sXG4gICAgICAgIF0sXG4gICAgICAgIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoLT9cXGQrKS9pLFxuICAgICAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgICAgIHJmYzI4MjIgPVxuICAgICAgICAgICAgL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLyxcbiAgICAgICAgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIFVUOiAwLFxuICAgICAgICAgICAgR01UOiAwLFxuICAgICAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUFNUOiAtOCAqIDYwLFxuICAgICAgICB9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQsXG4gICAgICAgICAgICB0ekZvcm1hdCxcbiAgICAgICAgICAgIGlzb0RhdGVzTGVuID0gaXNvRGF0ZXMubGVuZ3RoLFxuICAgICAgICAgICAgaXNvVGltZXNMZW4gPSBpc29UaW1lcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pc28gPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBpc29EYXRlc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzNdKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzTGVuOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgeWVhclN0cixcbiAgICAgICAgbW9udGhTdHIsXG4gICAgICAgIGRheVN0cixcbiAgICAgICAgaG91clN0cixcbiAgICAgICAgbWludXRlU3RyLFxuICAgICAgICBzZWNvbmRTdHJcbiAgICApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcc1xccyovLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW5kZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzJdXG4gICAgICAgICAgICAgICAgKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKSxcbiAgICAgICAgICAgICAgICBtID0gaG0gJSAxMDAsXG4gICAgICAgICAgICAgICAgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKSxcbiAgICAgICAgICAgIHBhcnNlZEFycmF5O1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgICAgICAgICBtYXRjaFs0XSxcbiAgICAgICAgICAgICAgICBtYXRjaFszXSxcbiAgICAgICAgICAgICAgICBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICBtYXRjaFs1XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs2XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs3XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gMSkgQVNQLk5FVCwgMikgSVNPLCAzKSBSRkMgMjgyMiBmb3JtYXRzLCBvciA0KSBvcHRpb25hbCBmYWxsYmFjayBpZiBwYXJzaW5nIGlzbid0IHN0cmljdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX3N0cmljdCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAgICAgJ2Rpc2NvdXJhZ2VkLiBQbGVhc2UgcmVmZXIgdG8gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBleHBlY3RlZFdlZWtkYXksXG4gICAgICAgICAgICB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHxcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9PT0gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPVxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9PSBudWxsID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDXG4gICAgICAgICAgICA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKVxuICAgICAgICAgICAgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fdyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdywgY3VyV2VlaztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIHcuR0csXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdLFxuICAgICAgICAgICAgICAgIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwLFxuICAgICAgICAgICAgZXJhLFxuICAgICAgICAgICAgdG9rZW5MZW47XG5cbiAgICAgICAgdG9rZW5zID1cbiAgICAgICAgICAgIGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcbiAgICAgICAgdG9rZW5MZW4gPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5MZW47IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fFxuICAgICAgICAgICAgICAgIFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9XG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChcbiAgICAgICAgICAgIGNvbmZpZy5fbG9jYWxlLFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdLFxuICAgICAgICAgICAgY29uZmlnLl9tZXJpZGllbVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGhhbmRsZSBlcmFcbiAgICAgICAgZXJhID0gZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZXJhO1xuICAgICAgICBpZiAoZXJhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSBjb25maWcuX2xvY2FsZS5lcmFzQ29udmVydFllYXIoZXJhLCBjb25maWcuX2FbWUVBUl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSxcbiAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQsXG4gICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlnZkxlbiA9IGNvbmZpZy5fZi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGNvbmZpZ2ZMZW4gPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWdmTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKGlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmICghYmVzdEZvcm1hdElzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZEZvcm1hdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSksXG4gICAgICAgICAgICBkYXlPckRhdGUgPSBpLmRheSA9PT0gdW5kZWZpbmVkID8gaS5kYXRlIDogaS5kYXk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChcbiAgICAgICAgICAgIFtpLnllYXIsIGkubW9udGgsIGRheU9yRGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoeyBudWxsSW5wdXQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gdHJ1ZSB8fCBmb3JtYXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4KCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICtuZXcgRGF0ZSgpO1xuICAgIH07XG5cbiAgICB2YXIgb3JkZXJpbmcgPSBbXG4gICAgICAgICd5ZWFyJyxcbiAgICAgICAgJ3F1YXJ0ZXInLFxuICAgICAgICAnbW9udGgnLFxuICAgICAgICAnd2VlaycsXG4gICAgICAgICdkYXknLFxuICAgICAgICAnaG91cicsXG4gICAgICAgICdtaW51dGUnLFxuICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gZmFsc2UsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgb3JkZXJMZW4gPSBvcmRlcmluZy5sZW5ndGg7XG4gICAgICAgIGZvciAoa2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKG0sIGtleSkgJiZcbiAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgICAgICBpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJMZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID1cbiAgICAgICAgICAgICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgKyB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgKyBxdWFydGVycyAqIDMgKyB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpLFxuICAgICAgICAgICAgICAgIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2lnbiArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yICtcbiAgICAgICAgICAgICAgICB6ZXJvRmlsbCh+fm9mZnNldCAlIDYwLCAyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpLFxuICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIG1pbnV0ZXM7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmsgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHBhcnRzID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgPyAwIDogcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPVxuICAgICAgICAgICAgICAgIChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LnZhbHVlT2YoKVxuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0KG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0KGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge30sXG4gICAgICAgICAgICBvdGhlcjtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID1cbiAgICAgICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXigtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspOihcXGQrKSg/OjooXFxkKykoXFwuXFxkKik/KT8kLyxcbiAgICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgICAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgICAgIGlzb1JlZ2V4ID1cbiAgICAgICAgICAgIC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbihpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXM6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTTogaW5wdXQuX21vbnRocyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpIHx8ICFpc05hTigraW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSAraW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9ICtpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICBkOiB0b0ludChtYXRjaFtEQVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIGg6IHRvSW50KG1hdGNoW0hPVVJdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbTogdG9JbnQobWF0Y2hbTUlOVVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIHM6IHRvSW50KG1hdGNoW1NFQ09ORF0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtczogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiwgLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTTogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHc6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG06IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19pc1ZhbGlkJykpIHtcbiAgICAgICAgICAgIHJldC5faXNWYWxpZCA9IGlucHV0Ll9pc1ZhbGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28oaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7fTtcblxuICAgICAgICByZXMubW9udGhzID1cbiAgICAgICAgICAgIG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgKyAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICdtb21lbnQoKS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7XG4gICAgICAgICAgICAgICAgdmFsID0gcGVyaW9kO1xuICAgICAgICAgICAgICAgIHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZCA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKSxcbiAgICAgICAgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZztcbiAgICB9XG5cbiAgICAvLyB0eXBlIE1vbWVudElucHV0ID0gTW9tZW50IHwgRGF0ZSB8IHN0cmluZyB8IG51bWJlciB8IChudW1iZXIgfCBzdHJpbmcpW10gfCBNb21lbnRJbnB1dE9iamVjdCB8IHZvaWQ7IC8vIG51bGwgfCB1bmRlZmluZWRcbiAgICBmdW5jdGlvbiBpc01vbWVudElucHV0KGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc01vbWVudChpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzRGF0ZShpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzU3RyaW5nKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNOdW1iZXIoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc01vbWVudElucHV0T2JqZWN0KGlucHV0KSB8fFxuICAgICAgICAgICAgaW5wdXQgPT09IG51bGwgfHxcbiAgICAgICAgICAgIGlucHV0ID09PSB1bmRlZmluZWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudElucHV0T2JqZWN0KGlucHV0KSB7XG4gICAgICAgIHZhciBvYmplY3RUZXN0ID0gaXNPYmplY3QoaW5wdXQpICYmICFpc09iamVjdEVtcHR5KGlucHV0KSxcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IGZhbHNlLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICAgICAneWVhcnMnLFxuICAgICAgICAgICAgICAgICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAneScsXG4gICAgICAgICAgICAgICAgJ21vbnRocycsXG4gICAgICAgICAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgICAgICAgICAnTScsXG4gICAgICAgICAgICAgICAgJ2RheXMnLFxuICAgICAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgICAgICdkJyxcbiAgICAgICAgICAgICAgICAnZGF0ZXMnLFxuICAgICAgICAgICAgICAgICdkYXRlJyxcbiAgICAgICAgICAgICAgICAnRCcsXG4gICAgICAgICAgICAgICAgJ2hvdXJzJyxcbiAgICAgICAgICAgICAgICAnaG91cicsXG4gICAgICAgICAgICAgICAgJ2gnLFxuICAgICAgICAgICAgICAgICdtaW51dGVzJyxcbiAgICAgICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICAgICAnbScsXG4gICAgICAgICAgICAgICAgJ3NlY29uZHMnLFxuICAgICAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICAgICAnbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgICAgICdtcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgcHJvcGVydHlMZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydHlMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgdmFyIGFycmF5VGVzdCA9IGlzQXJyYXkoaW5wdXQpLFxuICAgICAgICAgICAgZGF0YVR5cGVUZXN0ID0gZmFsc2U7XG4gICAgICAgIGlmIChhcnJheVRlc3QpIHtcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9XG4gICAgICAgICAgICAgICAgaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNOdW1iZXIoaXRlbSkgJiYgaXNTdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUZXN0ICYmIGRhdGFUeXBlVGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NhbGVuZGFyU3BlYyhpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3NhbWVEYXknLFxuICAgICAgICAgICAgICAgICduZXh0RGF5JyxcbiAgICAgICAgICAgICAgICAnbGFzdERheScsXG4gICAgICAgICAgICAgICAgJ25leHRXZWVrJyxcbiAgICAgICAgICAgICAgICAnbGFzdFdlZWsnLFxuICAgICAgICAgICAgICAgICdzYW1lRWxzZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHByb3BlcnR5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBwcm9wZXJ0eVRlc3QgfHwgaGFzT3duUHJvcChpbnB1dCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdFRlc3QgJiYgcHJvcGVydHlUZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGRpZmYgPCAtNlxuICAgICAgICAgICAgPyAnc2FtZUVsc2UnXG4gICAgICAgICAgICA6IGRpZmYgPCAtMVxuICAgICAgICAgICAgPyAnbGFzdFdlZWsnXG4gICAgICAgICAgICA6IGRpZmYgPCAwXG4gICAgICAgICAgICA/ICdsYXN0RGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgMVxuICAgICAgICAgICAgPyAnc2FtZURheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDJcbiAgICAgICAgICAgID8gJ25leHREYXknXG4gICAgICAgICAgICA6IGRpZmYgPCA3XG4gICAgICAgICAgICA/ICduZXh0V2VlaydcbiAgICAgICAgICAgIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3Igc2luZ2xlIHBhcmFtZXRlciwgZm9ybWF0cyBvbmx5IG92ZXJsb2FkIHRvIHRoZSBjYWxlbmRhciBmdW5jdGlvblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9tZW50SW5wdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgZm9ybWF0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDYWxlbmRhclNwZWMoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICBmb3JtYXRzICYmXG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKVxuICAgICAgICAgICAgICAgICAgICA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdylcbiAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChcbiAgICAgICAgICAgIG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2Vlbihmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0FmdGVyKGxvY2FsRnJvbSwgdW5pdHMpXG4gICAgICAgICAgICAgICAgOiAhdGhpcy5pc0JlZm9yZShsb2NhbEZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknXG4gICAgICAgICAgICAgICAgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNBZnRlcihsb2NhbFRvLCB1bml0cykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiZcbiAgICAgICAgICAgICAgICBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlcihpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCwgem9uZURlbHRhLCBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYoYSwgYikge1xuICAgICAgICBpZiAoYS5kYXRlKCkgPCBiLmRhdGUoKSkge1xuICAgICAgICAgICAgLy8gZW5kLW9mLW1vbnRoIGNhbGN1bGF0aW9ucyB3b3JrIGNvcnJlY3Qgd2hlbiB0aGUgc3RhcnQgbW9udGggaGFzIG1vcmVcbiAgICAgICAgICAgIC8vIGRheXMgdGhhbiB0aGUgZW5kIG1vbnRoLlxuICAgICAgICAgICAgcmV0dXJuIC1tb250aERpZmYoYiwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgICAgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlLFxuICAgICAgICAgICAgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgdXRjXG4gICAgICAgICAgICAgICAgICAgID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXSdcbiAgICAgICAgICAgICAgICAgICAgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApXG4gICAgICAgICAgICAgICAgICAgIC50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQoXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gICAgICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCcsXG4gICAgICAgICAgICB6b25lID0gJycsXG4gICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICB5ZWFyLFxuICAgICAgICAgICAgZGF0ZXRpbWUsXG4gICAgICAgICAgICBzdWZmaXg7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgICAgICB5ZWFyID0gMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5ID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgICAgIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgICAgIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKVxuICAgICAgICAgICAgICAgID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0Y1xuICAgICAgICAgICAgICAgIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8IGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyB0bzogdGhpcywgZnJvbTogdGltZSB9KVxuICAgICAgICAgICAgICAgIC5sb2NhbGUodGhpcy5sb2NhbGUoKSlcbiAgICAgICAgICAgICAgICAuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZnJvbTogdGhpcywgdG86IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICBmdW5jdGlvbiBsb2NhbGUoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIHZhciBNU19QRVJfU0VDT05EID0gMTAwMCxcbiAgICAgICAgTVNfUEVSX01JTlVURSA9IDYwICogTVNfUEVSX1NFQ09ORCxcbiAgICAgICAgTVNfUEVSX0hPVVIgPSA2MCAqIE1TX1BFUl9NSU5VVEUsXG4gICAgICAgIE1TX1BFUl80MDBfWUVBUlMgPSAoMzY1ICogNDAwICsgOTcpICogMjQgKiBNU19QRVJfSE9VUjtcblxuICAgIC8vIGFjdHVhbCBtb2R1bG8gLSBoYW5kbGVzIG5lZ2F0aXZlIG51bWJlcnMgKGZvciBkYXRlcyBiZWZvcmUgMTk3MCk6XG4gICAgZnVuY3Rpb24gbW9kJDEoZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuICgoZGl2aWRlbmQgJSBkaXZpc29yKSArIGRpdmlzb3IpICUgZGl2aXNvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXRjU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyBEYXRlLlVUQyByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5LCBtLCBkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSAtICh0aGlzLm1vbnRoKCkgJSAzKSxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpICsgMSwgMCwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMykgKyAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSArIDdcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9XG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSIC1cbiAgICAgICAgICAgICAgICAgICAgbW9kJDEoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgICAgICkgLVxuICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfTUlOVVRFIC0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfU0VDT05EIC0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtLnllYXIoKSxcbiAgICAgICAgICAgIG0ubW9udGgoKSxcbiAgICAgICAgICAgIG0uZGF0ZSgpLFxuICAgICAgICAgICAgbS5ob3VyKCksXG4gICAgICAgICAgICBtLm1pbnV0ZSgpLFxuICAgICAgICAgICAgbS5zZWNvbmQoKSxcbiAgICAgICAgICAgIG0ubWlsbGlzZWNvbmQoKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMigpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3QsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ04nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTk4nLCAwLCAwLCAnZXJhTmFtZScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OTicsIDAsIDAsICdlcmFOYXJyb3cnKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5JywgMV0sICd5bycsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5JywgMl0sIDAsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eScsIDNdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXl5JywgNF0sIDAsICdlcmFZZWFyJyk7XG5cbiAgICBhZGRSZWdleFRva2VuKCdOJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OJywgbWF0Y2hFcmFOYW1lKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OTicsIG1hdGNoRXJhTmFycm93KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oXG4gICAgICAgIFsnTicsICdOTicsICdOTk4nLCAnTk5OTicsICdOTk5OTiddLFxuICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB2YXIgZXJhID0gY29uZmlnLl9sb2NhbGUuZXJhc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAgICAgaWYgKGVyYSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYSA9IGVyYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEVyYSA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3knLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5bycsIG1hdGNoRXJhWWVhck9yZGluYWwpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ3knLCAneXknLCAneXl5JywgJ3l5eXknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3lvJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpIHtcbiAgICAgICAgICAgIG1hdGNoID0gaW5wdXQubWF0Y2goY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UpIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZShpbnB1dCwgbWF0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuX2VyYXMgfHwgZ2V0TG9jYWxlKCdlbicpLl9lcmFzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnNpbmNlKS5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5zaW5jZSA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSArSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0udW50aWwpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS51bnRpbCA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJhcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzUGFyc2UoZXJhTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFiYnIsXG4gICAgICAgICAgICBuYXJyb3c7XG4gICAgICAgIGVyYU5hbWUgPSBlcmFOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lID0gZXJhc1tpXS5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBhYmJyID0gZXJhc1tpXS5hYmJyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBuYXJyb3cgPSBlcmFzW2ldLm5hcnJvdy50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYmJyID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFycm93ID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFtuYW1lLCBhYmJyLCBuYXJyb3ddLmluZGV4T2YoZXJhTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc0NvbnZlcnRZZWFyKGVyYSwgeWVhcikge1xuICAgICAgICB2YXIgZGlyID0gZXJhLnNpbmNlIDw9IGVyYS51bnRpbCA/ICsxIDogLTE7XG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKSArICh5ZWFyIC0gZXJhLm9mZnNldCkgKiBkaXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYW1lKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYU5hcnJvdygpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhQWJicigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5hYmJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFZZWFyKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGRpciA9IGVyYXNbaV0uc2luY2UgPD0gZXJhc1tpXS51bnRpbCA/ICsxIDogLTE7XG5cbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHx8XG4gICAgICAgICAgICAgICAgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMueWVhcigpIC0gaG9va3MoZXJhc1tpXS5zaW5jZSkueWVhcigpKSAqIGRpciArXG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0ub2Zmc2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYW1lUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYW1lUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc0FiYnJSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzQWJiclJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzQWJiclJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNOYXJyb3dSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFycm93UmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYXJyb3dSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYUFiYnIoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFtZShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc05hbWVSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFOYXJyb3coaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYXJyb3dSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFZZWFyT3JkaW5hbChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXggfHwgbWF0Y2hVbnNpZ25lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRXJhc1BhcnNlKCkge1xuICAgICAgICB2YXIgYWJiclBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFtZVBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFycm93UGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYW1lKSk7XG4gICAgICAgICAgICBhYmJyUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKSk7XG4gICAgICAgICAgICBuYXJyb3dQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xuXG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSkpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VyYXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc05hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG5hbWVQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzQWJiclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgYWJiclBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYXJyb3dSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbmFycm93UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFxuICAgICAgICBbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLFxuICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrKCksXG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoKSxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICA0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy5pc29XZWVrWWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhcigpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLndlZWtZZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbFxuICAgICAgICAgICAgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMylcbiAgICAgICAgICAgIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyAodGhpcy5tb250aCgpICUgMykpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0XG4gICAgICAgICAgICA/IGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZSB8fCBsb2NhbGUuX29yZGluYWxQYXJzZVxuICAgICAgICAgICAgOiBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhcihpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID1cbiAgICAgICAgICAgIE1hdGgucm91bmQoXG4gICAgICAgICAgICAgICAgKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTVcbiAgICAgICAgICAgICkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKGlucHV0IC0gZGF5T2ZZZWFyLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW4sIGdldFNldE1pbGxpc2Vjb25kO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cblxuICAgIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ID0gZnJvbU5vdztcbiAgICBwcm90by50byA9IHRvO1xuICAgIHByb3RvLnRvTm93ID0gdG9Ob3c7XG4gICAgcHJvdG8uZ2V0ID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgPSBpc1NhbWU7XG4gICAgcHJvdG8uaXNTYW1lT3JBZnRlciA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgPSBsYW5nO1xuICAgIHByb3RvLmxvY2FsZSA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcbiAgICBwcm90by5tYXggPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBwcm90by5zZXQgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiA9IHN0YXJ0T2Y7XG4gICAgcHJvdG8uc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBwcm90by50b0FycmF5ID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSA9IHRvRGF0ZTtcbiAgICBwcm90by50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nO1xuICAgIHByb3RvLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICE9IG51bGwpIHtcbiAgICAgICAgcHJvdG9bU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01vbWVudDwnICsgdGhpcy5mb3JtYXQoKSArICc+JztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvdG8udG9KU09OID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiA9IHZhbHVlT2Y7XG4gICAgcHJvdG8uY3JlYXRpb25EYXRhID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLmVyYU5hbWUgPSBnZXRFcmFOYW1lO1xuICAgIHByb3RvLmVyYU5hcnJvdyA9IGdldEVyYU5hcnJvdztcbiAgICBwcm90by5lcmFBYmJyID0gZ2V0RXJhQWJicjtcbiAgICBwcm90by5lcmFZZWFyID0gZ2V0RXJhWWVhcjtcbiAgICBwcm90by55ZWFyID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayA9IHByb3RvLndlZWtzID0gZ2V0U2V0V2VlaztcbiAgICBwcm90by5pc29XZWVrID0gcHJvdG8uaXNvV2Vla3MgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8ud2Vla3NJbldlZWtZZWFyID0gZ2V0V2Vla3NJbldlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJbklTT1dlZWtZZWFyID0gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyO1xuICAgIHByb3RvLmRhdGUgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIHByb3RvLmRheSA9IHByb3RvLmRheXMgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBwcm90by5sb2NhbCA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgcHJvdG8ucGFyc2Vab25lID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgPSBpc0xvY2FsO1xuICAgIHByb3RvLmlzVXRjT2Zmc2V0ID0gaXNVdGNPZmZzZXQ7XG4gICAgcHJvdG8uaXNVdGMgPSBpc1V0YztcbiAgICBwcm90by5pc1VUQyA9IGlzVXRjO1xuICAgIHByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcbiAgICBwcm90by5kYXRlcyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0U2V0RGF5T2ZNb250aFxuICAgICk7XG4gICAgcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJyxcbiAgICAgICAgZ2V0U2V0TW9udGhcbiAgICApO1xuICAgIHByb3RvLnllYXJzID0gZGVwcmVjYXRlKFxuICAgICAgICAneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsXG4gICAgICAgIGdldFNldFllYXJcbiAgICApO1xuICAgIHByb3RvLnpvbmUgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsXG4gICAgICAgIGdldFNldFpvbmVcbiAgICApO1xuICAgIHByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLFxuICAgICAgICBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWRcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peChpbnB1dCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJblpvbmUoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgcHJvdG8kMS5sb25nRGF0ZUZvcm1hdCA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG8kMS5zZXQgPSBzZXQ7XG4gICAgcHJvdG8kMS5lcmFzID0gbG9jYWxlRXJhcztcbiAgICBwcm90byQxLmVyYXNQYXJzZSA9IGxvY2FsZUVyYXNQYXJzZTtcbiAgICBwcm90byQxLmVyYXNDb252ZXJ0WWVhciA9IGxvY2FsZUVyYXNDb252ZXJ0WWVhcjtcbiAgICBwcm90byQxLmVyYXNBYmJyUmVnZXggPSBlcmFzQWJiclJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hbWVSZWdleCA9IGVyYXNOYW1lUmVnZXg7XG4gICAgcHJvdG8kMS5lcmFzTmFycm93UmVnZXggPSBlcmFzTmFycm93UmVnZXg7XG5cbiAgICBwcm90byQxLm1vbnRocyA9IGxvY2FsZU1vbnRocztcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0ID0gbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSA9IGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggPSBtb250aHNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIHByb3RvJDEud2Vla2RheXMgPSBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluID0gbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ID0gbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgPSBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5c1JlZ2V4ID0gd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCA9IHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzTWluUmVnZXggPSB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICgpXG4gICAgLy8gKDUpXG4gICAgLy8gKGZtdCwgNSlcbiAgICAvLyAoZm10KVxuICAgIC8vICh0cnVlKVxuICAgIC8vICh0cnVlLCA1KVxuICAgIC8vICh0cnVlLCBmbXQsIDUpXG4gICAgLy8gKHRydWUsIGZtdClcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0KGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgIH1cblxuICAgIGdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIGVyYXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDEtMDEtMDEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiArSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBbm5vIERvbWluaScsXG4gICAgICAgICAgICAgICAgbmFycm93OiAnQUQnLFxuICAgICAgICAgICAgICAgIGFiYnI6ICdBRCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNpbmNlOiAnMDAwMC0xMi0zMScsXG4gICAgICAgICAgICAgICAgdW50aWw6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0JlZm9yZSBDaHJpc3QnLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0JDJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQkMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICAgICAgdG9JbnQoKG51bWJlciAlIDEwMCkgLyAxMCkgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3RoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdzdCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnbmQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZVxuICAgICk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0TG9jYWxlXG4gICAgKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBhYnMoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMsXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgICAgIHNlY29uZHMsXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyhkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiAoZGF5cyAqIDQ4MDApIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyhtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiAobW9udGhzICogMTQ2MDk3KSAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXModW5pdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzIC8gNyArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDI0ICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDE0NDAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiB2YWx1ZU9mJDEoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpLFxuICAgICAgICBhc1NlY29uZHMgPSBtYWtlQXMoJ3MnKSxcbiAgICAgICAgYXNNaW51dGVzID0gbWFrZUFzKCdtJyksXG4gICAgICAgIGFzSG91cnMgPSBtYWtlQXMoJ2gnKSxcbiAgICAgICAgYXNEYXlzID0gbWFrZUFzKCdkJyksXG4gICAgICAgIGFzV2Vla3MgPSBtYWtlQXMoJ3cnKSxcbiAgICAgICAgYXNNb250aHMgPSBtYWtlQXMoJ00nKSxcbiAgICAgICAgYXNRdWFydGVycyA9IG1ha2VBcygnUScpLFxuICAgICAgICBhc1llYXJzID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKSxcbiAgICAgICAgc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKSxcbiAgICAgICAgbWludXRlcyA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKSxcbiAgICAgICAgaG91cnMgPSBtYWtlR2V0dGVyKCdob3VycycpLFxuICAgICAgICBkYXlzID0gbWFrZUdldHRlcignZGF5cycpLFxuICAgICAgICBtb250aHMgPSBtYWtlR2V0dGVyKCdtb250aHMnKSxcbiAgICAgICAgeWVhcnMgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICAgIHRocmVzaG9sZHMgPSB7XG4gICAgICAgICAgICBzczogNDQsIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICAgICAgczogNDUsIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgICAgICBtOiA0NSwgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgICAgICBoOiAyMiwgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgICAgICBkOiAyNiwgLy8gZGF5cyB0byBtb250aC93ZWVrXG4gICAgICAgICAgICB3OiBudWxsLCAvLyB3ZWVrcyB0byBtb250aFxuICAgICAgICAgICAgTTogMTEsIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCB0aHJlc2hvbGRzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpLFxuICAgICAgICAgICAgc2Vjb25kcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpLFxuICAgICAgICAgICAgbWludXRlcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpLFxuICAgICAgICAgICAgaG91cnMgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKSxcbiAgICAgICAgICAgIGRheXMgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKSxcbiAgICAgICAgICAgIG1vbnRocyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpLFxuICAgICAgICAgICAgd2Vla3MgPSByb3VuZChkdXJhdGlvbi5hcygndycpKSxcbiAgICAgICAgICAgIHllYXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSksXG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgICAgIChzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsnc3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8PSAxICYmIFsnbSddKSB8fFxuICAgICAgICAgICAgICAgIChtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPD0gMSAmJiBbJ2gnXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8PSAxICYmIFsnZCddKSB8fFxuICAgICAgICAgICAgICAgIChkYXlzIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSk7XG5cbiAgICAgICAgaWYgKHRocmVzaG9sZHMudyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICBhIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDw9IDEgJiYgWyd3J10pIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDwgdGhyZXNob2xkcy53ICYmIFsnd3cnLCB3ZWVrc10pO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhIHx8XG4gICAgICAgICAgICAobW9udGhzIDw9IDEgJiYgWydNJ10pIHx8XG4gICAgICAgICAgICAobW9udGhzIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdKSB8fFxuICAgICAgICAgICAgKHllYXJzIDw9IDEgJiYgWyd5J10pIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm91bmRpbmdGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUoYXJnV2l0aFN1ZmZpeCwgYXJnVGhyZXNob2xkcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aXRoU3VmZml4ID0gZmFsc2UsXG4gICAgICAgICAgICB0aCA9IHRocmVzaG9sZHMsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJnVGhyZXNob2xkcyA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgICAgICAgICBhcmdXaXRoU3VmZml4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdpdGhTdWZmaXggPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnVGhyZXNob2xkcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoID0gT2JqZWN0LmFzc2lnbih7fSwgdGhyZXNob2xkcywgYXJnVGhyZXNob2xkcyk7XG4gICAgICAgICAgICBpZiAoYXJnVGhyZXNob2xkcy5zICE9IG51bGwgJiYgYXJnVGhyZXNob2xkcy5zcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGguc3MgPSBhcmdUaHJlc2hvbGRzLnMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCB0aCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMCxcbiAgICAgICAgICAgIGRheXMgPSBhYnMkMSh0aGlzLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFicyQxKHRoaXMuX21vbnRocyksXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCksXG4gICAgICAgICAgICB0b3RhbFNpZ24sXG4gICAgICAgICAgICB5bVNpZ24sXG4gICAgICAgICAgICBkYXlzU2lnbixcbiAgICAgICAgICAgIGhtc1NpZ247XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcblxuICAgICAgICB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRvdGFsU2lnbiArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKHllYXJzID8geW1TaWduICsgeWVhcnMgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKG1vbnRocyA/IHltU2lnbiArIG1vbnRocyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoZGF5cyA/IGRheXNTaWduICsgZGF5cyArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgfHwgbWludXRlcyB8fCBzZWNvbmRzID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChob3VycyA/IGhtc1NpZ24gKyBob3VycyArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobWludXRlcyA/IGhtc1NpZ24gKyBtaW51dGVzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzZWNvbmRzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyA9IGFicztcbiAgICBwcm90byQyLmFkZCA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzUXVhcnRlcnMgPSBhc1F1YXJ0ZXJzO1xuICAgIHByb3RvJDIuYXNZZWFycyA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsXG4gICAgICAgIHRvSVNPU3RyaW5nJDFcbiAgICApO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyEgbW9tZW50LmpzXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjkuMyc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gPSBwcm90bztcbiAgICBob29rcy5taW4gPSBtaW47XG4gICAgaG9va3MubWF4ID0gbWF4O1xuICAgIGhvb2tzLm5vdyA9IG5vdztcbiAgICBob29rcy51dGMgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdHR0dHLVtXXVdXJywgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJywgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///wd/R\n")}}]);