(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[15],{"16Al":function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar ReactPropTypesSecret = __webpack_require__(\"WbBG\");\n\nfunction emptyFunction() {}\n\nfunction emptyFunctionWithReset() {}\n\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function () {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n\n    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');\n    err.name = 'Invariant Violation';\n    throw err;\n  }\n\n  ;\n  shim.isRequired = shim;\n\n  function getShim() {\n    return shim;\n  }\n\n  ; // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n\n  var ReactPropTypes = {\n    array: shim,\n    bigint: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n  ReactPropTypes.PropTypes = ReactPropTypes;\n  return ReactPropTypes;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanM/ZDdhMCJdLCJuYW1lcyI6WyJSZWFjdFByb3BUeXBlc1NlY3JldCIsInJlcXVpcmUiLCJlbXB0eUZ1bmN0aW9uIiwiZW1wdHlGdW5jdGlvbldpdGhSZXNldCIsInJlc2V0V2FybmluZ0NhY2hlIiwibW9kdWxlIiwiZXhwb3J0cyIsInNoaW0iLCJwcm9wcyIsInByb3BOYW1lIiwiY29tcG9uZW50TmFtZSIsImxvY2F0aW9uIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiZXJyIiwiRXJyb3IiLCJuYW1lIiwiaXNSZXF1aXJlZCIsImdldFNoaW0iLCJSZWFjdFByb3BUeXBlcyIsImFycmF5IiwiYmlnaW50IiwiYm9vbCIsImZ1bmMiLCJudW1iZXIiLCJvYmplY3QiLCJzdHJpbmciLCJzeW1ib2wiLCJhbnkiLCJhcnJheU9mIiwiZWxlbWVudCIsImVsZW1lbnRUeXBlIiwiaW5zdGFuY2VPZiIsIm5vZGUiLCJvYmplY3RPZiIsIm9uZU9mIiwib25lT2ZUeXBlIiwic2hhcGUiLCJleGFjdCIsImNoZWNrUHJvcFR5cGVzIiwiUHJvcFR5cGVzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFYTs7QUFFYixJQUFJQSxvQkFBb0IsR0FBR0MsbUJBQU8sQ0FBQyxNQUFELENBQWxDOztBQUVBLFNBQVNDLGFBQVQsR0FBeUIsQ0FBRTs7QUFDM0IsU0FBU0Msc0JBQVQsR0FBa0MsQ0FBRTs7QUFDcENBLHNCQUFzQixDQUFDQyxpQkFBdkIsR0FBMkNGLGFBQTNDOztBQUVBRyxNQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBVztFQUMxQixTQUFTQyxJQUFULENBQWNDLEtBQWQsRUFBcUJDLFFBQXJCLEVBQStCQyxhQUEvQixFQUE4Q0MsUUFBOUMsRUFBd0RDLFlBQXhELEVBQXNFQyxNQUF0RSxFQUE4RTtJQUM1RSxJQUFJQSxNQUFNLEtBQUtiLG9CQUFmLEVBQXFDO01BQ25DO01BQ0E7SUFDRDs7SUFDRCxJQUFJYyxHQUFHLEdBQUcsSUFBSUMsS0FBSixDQUNSLHlGQUNBLCtDQURBLEdBRUEsZ0RBSFEsQ0FBVjtJQUtBRCxHQUFHLENBQUNFLElBQUosR0FBVyxxQkFBWDtJQUNBLE1BQU1GLEdBQU47RUFDRDs7RUFBQTtFQUNEUCxJQUFJLENBQUNVLFVBQUwsR0FBa0JWLElBQWxCOztFQUNBLFNBQVNXLE9BQVQsR0FBbUI7SUFDakIsT0FBT1gsSUFBUDtFQUNEOztFQUFBLENBakJ5QixDQWtCMUI7RUFDQTs7RUFDQSxJQUFJWSxjQUFjLEdBQUc7SUFDbkJDLEtBQUssRUFBRWIsSUFEWTtJQUVuQmMsTUFBTSxFQUFFZCxJQUZXO0lBR25CZSxJQUFJLEVBQUVmLElBSGE7SUFJbkJnQixJQUFJLEVBQUVoQixJQUphO0lBS25CaUIsTUFBTSxFQUFFakIsSUFMVztJQU1uQmtCLE1BQU0sRUFBRWxCLElBTlc7SUFPbkJtQixNQUFNLEVBQUVuQixJQVBXO0lBUW5Cb0IsTUFBTSxFQUFFcEIsSUFSVztJQVVuQnFCLEdBQUcsRUFBRXJCLElBVmM7SUFXbkJzQixPQUFPLEVBQUVYLE9BWFU7SUFZbkJZLE9BQU8sRUFBRXZCLElBWlU7SUFhbkJ3QixXQUFXLEVBQUV4QixJQWJNO0lBY25CeUIsVUFBVSxFQUFFZCxPQWRPO0lBZW5CZSxJQUFJLEVBQUUxQixJQWZhO0lBZ0JuQjJCLFFBQVEsRUFBRWhCLE9BaEJTO0lBaUJuQmlCLEtBQUssRUFBRWpCLE9BakJZO0lBa0JuQmtCLFNBQVMsRUFBRWxCLE9BbEJRO0lBbUJuQm1CLEtBQUssRUFBRW5CLE9BbkJZO0lBb0JuQm9CLEtBQUssRUFBRXBCLE9BcEJZO0lBc0JuQnFCLGNBQWMsRUFBRXBDLHNCQXRCRztJQXVCbkJDLGlCQUFpQixFQUFFRjtFQXZCQSxDQUFyQjtFQTBCQWlCLGNBQWMsQ0FBQ3FCLFNBQWYsR0FBMkJyQixjQUEzQjtFQUVBLE9BQU9BLGNBQVA7QUFDRCxDQWpERCIsImZpbGUiOiIxNkFsLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fVxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbldpdGhSZXNldCgpIHt9XG5lbXB0eUZ1bmN0aW9uV2l0aFJlc2V0LnJlc2V0V2FybmluZ0NhY2hlID0gZW1wdHlGdW5jdGlvbjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIHRocm93IGVycjtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJpZ2ludDogc2hpbSxcbiAgICBib29sOiBzaGltLFxuICAgIGZ1bmM6IHNoaW0sXG4gICAgbnVtYmVyOiBzaGltLFxuICAgIG9iamVjdDogc2hpbSxcbiAgICBzdHJpbmc6IHNoaW0sXG4gICAgc3ltYm9sOiBzaGltLFxuXG4gICAgYW55OiBzaGltLFxuICAgIGFycmF5T2Y6IGdldFNoaW0sXG4gICAgZWxlbWVudDogc2hpbSxcbiAgICBlbGVtZW50VHlwZTogc2hpbSxcbiAgICBpbnN0YW5jZU9mOiBnZXRTaGltLFxuICAgIG5vZGU6IHNoaW0sXG4gICAgb2JqZWN0T2Y6IGdldFNoaW0sXG4gICAgb25lT2Y6IGdldFNoaW0sXG4gICAgb25lT2ZUeXBlOiBnZXRTaGltLFxuICAgIHNoYXBlOiBnZXRTaGltLFxuICAgIGV4YWN0OiBnZXRTaGltLFxuXG4gICAgY2hlY2tQcm9wVHlwZXM6IGVtcHR5RnVuY3Rpb25XaXRoUmVzZXQsXG4gICAgcmVzZXRXYXJuaW5nQ2FjaGU6IGVtcHR5RnVuY3Rpb25cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16Al\n")},"17x9":function(module,exports,__webpack_require__){eval('/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nif (false) { var throwOnDirectAccess, ReactIs; } else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = __webpack_require__("16Al")();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcz9kN2JjIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBSUEsS0FBSixFQUEyQyxxQ0FBM0MsTUFPTztFQUNMO0VBQ0E7RUFDQUMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCQyxtQkFBTyxDQUFDLE1BQUQsQ0FBUCxFQUFqQjtBQUNEIiwiZmlsZSI6IjE3eDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17x9\n')},"33yf":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,\n// backported and transplited with Babel, with backwards-compat fixes\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  } // if the path is allowed to go above the root, restore leading ..s\n\n\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n} // path.resolve([from ...], to)\n// posix version\n\n\nexports.resolve = function () {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = i >= 0 ? arguments[i] : process.cwd(); // Skip empty and invalid entries\n\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  } // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n  // Normalize the path\n\n\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n  return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n}; // path.normalize(path)\n// posix version\n\n\nexports.normalize = function (path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/'; // Normalize the path\n\n  path = normalizeArray(filter(path.split('/'), function (p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n}; // posix version\n\n\nexports.isAbsolute = function (path) {\n  return path.charAt(0) === '/';\n}; // posix version\n\n\nexports.join = function () {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function (p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n\n    return p;\n  }).join('/'));\n}; // path.relative(from, to)\n// posix version\n\n\nexports.relative = function (from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  if (path.length === 0) return '.';\n  var code = path.charCodeAt(0);\n  var hasRoot = code === 47\n  /*/*/\n  ;\n  var end = -1;\n  var matchedSlash = true;\n\n  for (var i = path.length - 1; i >= 1; --i) {\n    code = path.charCodeAt(i);\n\n    if (code === 47\n    /*/*/\n    ) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      // We saw the first non-path separator\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n\n  if (hasRoot && end === 1) {\n    // return '//';\n    // Backwards-compat fix:\n    return '/';\n  }\n\n  return path.slice(0, end);\n};\n\nfunction basename(path) {\n  if (typeof path !== 'string') path = path + '';\n  var start = 0;\n  var end = -1;\n  var matchedSlash = true;\n  var i;\n\n  for (i = path.length - 1; i >= 0; --i) {\n    if (path.charCodeAt(i) === 47\n    /*/*/\n    ) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        start = i + 1;\n        break;\n      }\n    } else if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // path component\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n  return path.slice(start, end);\n} // Uses a mixed approach for backwards-compatibility, as ext behavior changed\n// in new Node.js versions, so only basename() above is backported here\n\n\nexports.basename = function (path, ext) {\n  var f = basename(path);\n\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n\n  return f;\n};\n\nexports.extname = function (path) {\n  if (typeof path !== 'string') path = path + '';\n  var startDot = -1;\n  var startPart = 0;\n  var end = -1;\n  var matchedSlash = true; // Track the state of characters (if any) we see before our first dot and\n  // after any path separator we find\n\n  var preDotState = 0;\n\n  for (var i = path.length - 1; i >= 0; --i) {\n    var code = path.charCodeAt(i);\n\n    if (code === 47\n    /*/*/\n    ) {\n      // If we reached a path separator that was not part of a set of path\n      // separators at the end of the string, stop now\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n\n      continue;\n    }\n\n    if (end === -1) {\n      // We saw the first non-path separator, mark this as the end of our\n      // extension\n      matchedSlash = false;\n      end = i + 1;\n    }\n\n    if (code === 46\n    /*.*/\n    ) {\n      // If this is our first dot, mark it as the start of our extension\n      if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n    } else if (startDot !== -1) {\n      // We saw a non-dot and non-path separator before our dot, so we should\n      // have a good chance at having a non-empty extension\n      preDotState = -1;\n    }\n  }\n\n  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot\n  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'\n  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n    return '';\n  }\n\n  return path.slice(startDot, end);\n};\n\nfunction filter(xs, f) {\n  if (xs.filter) return xs.filter(f);\n  var res = [];\n\n  for (var i = 0; i < xs.length; i++) {\n    if (f(xs[i], i, xs)) res.push(xs[i]);\n  }\n\n  return res;\n} // String.prototype.substr - negative index don't work in IE8\n\n\nvar substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {\n  return str.substr(start, len);\n} : function (str, start, len) {\n  if (start < 0) start = str.length + start;\n  return str.substr(start, len);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"Q2Ig\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzP2RmN2MiXSwibmFtZXMiOlsibm9ybWFsaXplQXJyYXkiLCJwYXJ0cyIsImFsbG93QWJvdmVSb290IiwidXAiLCJpIiwibGVuZ3RoIiwibGFzdCIsInNwbGljZSIsInVuc2hpZnQiLCJleHBvcnRzIiwicmVzb2x2ZSIsInJlc29sdmVkUGF0aCIsInJlc29sdmVkQWJzb2x1dGUiLCJhcmd1bWVudHMiLCJwYXRoIiwicHJvY2VzcyIsImN3ZCIsIlR5cGVFcnJvciIsImNoYXJBdCIsImZpbHRlciIsInNwbGl0IiwicCIsImpvaW4iLCJub3JtYWxpemUiLCJpc0Fic29sdXRlIiwidHJhaWxpbmdTbGFzaCIsInN1YnN0ciIsInBhdGhzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJpbmRleCIsInJlbGF0aXZlIiwiZnJvbSIsInRvIiwidHJpbSIsImFyciIsInN0YXJ0IiwiZW5kIiwiZnJvbVBhcnRzIiwidG9QYXJ0cyIsIk1hdGgiLCJtaW4iLCJzYW1lUGFydHNMZW5ndGgiLCJvdXRwdXRQYXJ0cyIsInB1c2giLCJjb25jYXQiLCJzZXAiLCJkZWxpbWl0ZXIiLCJkaXJuYW1lIiwiY29kZSIsImNoYXJDb2RlQXQiLCJoYXNSb290IiwibWF0Y2hlZFNsYXNoIiwiYmFzZW5hbWUiLCJleHQiLCJmIiwiZXh0bmFtZSIsInN0YXJ0RG90Iiwic3RhcnRQYXJ0IiwicHJlRG90U3RhdGUiLCJ4cyIsInJlcyIsInN0ciIsImxlbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVNBLGNBQVQsQ0FBd0JDLEtBQXhCLEVBQStCQyxjQUEvQixF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aURBLFNBQVNwQixNQUFULENBQWlCMkMsRUFBakIsRUFBcUJMLENBQXJCLEVBQXdCO0VBQ3BCLElBQUlLLEVBQUUsQ0FBQzNDLE1BQVAsRUFBZSxPQUFPMkMsRUFBRSxDQUFDM0MsTUFBSCxDQUFVc0MsQ0FBVixDQUFQO0VBQ2YsSUFBSU0sR0FBRyxHQUFHLEVBQVY7O0VBQ0EsS0FBSyxJQUFJM0QsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzBELEVBQUUsQ0FBQ3pELE1BQXZCLEVBQStCRCxDQUFDLEVBQWhDLEVBQW9DO0lBQ2hDLElBQUlxRCxDQUFDLENBQUNLLEVBQUUsQ0FBQzFELENBQUQsQ0FBSCxFQUFRQSxDQUFSLEVBQVcwRCxFQUFYLENBQUwsRUFBcUJDLEdBQUcsQ0FBQ2pCLElBQUosQ0FBU2dCLEVBQUUsQ0FBQzFELENBQUQsQ0FBWDtFQUN4Qjs7RUFDRCxPQUFPMkQsR0FBUDtBQUNILEMsQ0FFRDs7O0FBQ0EsSUFBSXJDLE1BQU0sR0FBRyxLQUFLQSxNQUFMLENBQVksQ0FBQyxDQUFiLE1BQW9CLEdBQXBCLEdBQ1AsVUFBVXNDLEdBQVYsRUFBZTFCLEtBQWYsRUFBc0IyQixHQUF0QixFQUEyQjtFQUFFLE9BQU9ELEdBQUcsQ0FBQ3RDLE1BQUosQ0FBV1ksS0FBWCxFQUFrQjJCLEdBQWxCLENBQVA7QUFBK0IsQ0FEckQsR0FFUCxVQUFVRCxHQUFWLEVBQWUxQixLQUFmLEVBQXNCMkIsR0FBdEIsRUFBMkI7RUFDekIsSUFBSTNCLEtBQUssR0FBRyxDQUFaLEVBQWVBLEtBQUssR0FBRzBCLEdBQUcsQ0FBQzNELE1BQUosR0FBYWlDLEtBQXJCO0VBQ2YsT0FBTzBCLEdBQUcsQ0FBQ3RDLE1BQUosQ0FBV1ksS0FBWCxFQUFrQjJCLEdBQWxCLENBQVA7QUFDSCxDQUxMLEMiLCJmaWxlIjoiMzN5Zi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33yf\n")},"3Mpw":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"b\", function() { return /* binding */ defaultProps; });\n\n// UNUSED EXPORTS: Prism\n\n// CONCATENATED MODULE: ./node_modules/prism-react-renderer/prism/index.js\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\n\n/**\n * prism-react-renderer:\n * This file has been modified to remove:\n * - globals and window dependency\n * - worker support\n * - highlightAll and other element dependent methods\n * - _.hooks helpers\n * - UMD/node-specific hacks\n * It has also been run through prettier\n */\nvar Prism = function () {\n  // Private helper vars\n  var lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n  var uniqueId = 0; // The grammar object for plaintext\n\n  var plainTextGrammar = {};\n  var _ = {\n    /**\n     * A namespace for utility methods.\n     *\n     * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n     * change or disappear at any time.\n     *\n     * @namespace\n     * @memberof Prism\n     */\n    util: {\n      encode: function encode(tokens) {\n        if (tokens instanceof Token) {\n          return new Token(tokens.type, encode(tokens.content), tokens.alias);\n        } else if (Array.isArray(tokens)) {\n          return tokens.map(encode);\n        } else {\n          return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n        }\n      },\n\n      /**\n       * Returns the name of the type of the given value.\n       *\n       * @param {any} o\n       * @returns {string}\n       * @example\n       * type(null)      === 'Null'\n       * type(undefined) === 'Undefined'\n       * type(123)       === 'Number'\n       * type('foo')     === 'String'\n       * type(true)      === 'Boolean'\n       * type([1, 2])    === 'Array'\n       * type({})        === 'Object'\n       * type(String)    === 'Function'\n       * type(/abc+/)    === 'RegExp'\n       */\n      type: function type(o) {\n        return Object.prototype.toString.call(o).slice(8, -1);\n      },\n\n      /**\n       * Returns a unique number for the given object. Later calls will still return the same number.\n       *\n       * @param {Object} obj\n       * @returns {number}\n       */\n      objId: function objId(obj) {\n        if (!obj['__id']) {\n          Object.defineProperty(obj, '__id', {\n            value: ++uniqueId\n          });\n        }\n\n        return obj['__id'];\n      },\n\n      /**\n       * Creates a deep clone of the given object.\n       *\n       * The main intended use of this function is to clone language definitions.\n       *\n       * @param {T} o\n       * @param {Record<number, any>} [visited]\n       * @returns {T}\n       * @template T\n       */\n      clone: function deepClone(o, visited) {\n        visited = visited || {};\n        var clone;\n        var id;\n\n        switch (_.util.type(o)) {\n          case 'Object':\n            id = _.util.objId(o);\n\n            if (visited[id]) {\n              return visited[id];\n            }\n\n            clone =\n            /** @type {Record<string, any>} */\n            {};\n            visited[id] = clone;\n\n            for (var key in o) {\n              if (o.hasOwnProperty(key)) {\n                clone[key] = deepClone(o[key], visited);\n              }\n            }\n\n            return (\n              /** @type {any} */\n              clone\n            );\n\n          case 'Array':\n            id = _.util.objId(o);\n\n            if (visited[id]) {\n              return visited[id];\n            }\n\n            clone = [];\n            visited[id] = clone;\n\n            /** @type {Array} */\n\n            /** @type {any} */\n            o.forEach(function (v, i) {\n              clone[i] = deepClone(v, visited);\n            });\n            return (\n              /** @type {any} */\n              clone\n            );\n\n          default:\n            return o;\n        }\n      },\n\n      /**\n       * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n       *\n       * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n       *\n       * @param {Element} element\n       * @returns {string}\n       */\n      getLanguage: function getLanguage(element) {\n        while (element) {\n          var m = lang.exec(element.className);\n\n          if (m) {\n            return m[1].toLowerCase();\n          }\n\n          element = element.parentElement;\n        }\n\n        return 'none';\n      },\n\n      /**\n       * Sets the Prism `language-xxxx` class of the given element.\n       *\n       * @param {Element} element\n       * @param {string} language\n       * @returns {void}\n       */\n      setLanguage: function setLanguage(element, language) {\n        // remove all `language-xxxx` classes\n        // (this might leave behind a leading space)\n        element.className = element.className.replace(RegExp(lang, 'gi'), ''); // add the new `language-xxxx` class\n        // (using `classList` will automatically clean up spaces for us)\n\n        element.classList.add('language-' + language);\n      },\n\n      /**\n       * Returns whether a given class is active for `element`.\n       *\n       * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n       * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n       * given class is just the given class with a `no-` prefix.\n       *\n       * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n       * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n       * ancestors have the given class or the negated version of it, then the default activation will be returned.\n       *\n       * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n       * version of it, the class is considered active.\n       *\n       * @param {Element} element\n       * @param {string} className\n       * @param {boolean} [defaultActivation=false]\n       * @returns {boolean}\n       */\n      isActive: function isActive(element, className, defaultActivation) {\n        var no = 'no-' + className;\n\n        while (element) {\n          var classList = element.classList;\n\n          if (classList.contains(className)) {\n            return true;\n          }\n\n          if (classList.contains(no)) {\n            return false;\n          }\n\n          element = element.parentElement;\n        }\n\n        return !!defaultActivation;\n      }\n    },\n\n    /**\n     * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n     *\n     * @namespace\n     * @memberof Prism\n     * @public\n     */\n    languages: {\n      /**\n       * The grammar for plain, unformatted text.\n       */\n      plain: plainTextGrammar,\n      plaintext: plainTextGrammar,\n      text: plainTextGrammar,\n      txt: plainTextGrammar,\n\n      /**\n       * Creates a deep copy of the language with the given id and appends the given tokens.\n       *\n       * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n       * will be overwritten at its original position.\n       *\n       * ## Best practices\n       *\n       * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n       * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n       * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n       *\n       * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n       * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n       *\n       * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n       * @param {Grammar} redef The new tokens to append.\n       * @returns {Grammar} The new language created.\n       * @public\n       * @example\n       * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n       *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n       *     // at its original position\n       *     'comment': { ... },\n       *     // CSS doesn't have a 'color' token, so this token will be appended\n       *     'color': /\\b(?:red|green|blue)\\b/\n       * });\n       */\n      extend: function extend(id, redef) {\n        var lang = _.util.clone(_.languages[id]);\n\n        for (var key in redef) {\n          lang[key] = redef[key];\n        }\n\n        return lang;\n      },\n\n      /**\n       * Inserts tokens _before_ another token in a language definition or any other grammar.\n       *\n       * ## Usage\n       *\n       * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n       * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n       * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n       * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n       * this:\n       *\n       * ```js\n       * Prism.languages.markup.style = {\n       *     // token\n       * };\n       * ```\n       *\n       * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n       * before existing tokens. For the CSS example above, you would use it like this:\n       *\n       * ```js\n       * Prism.languages.insertBefore('markup', 'cdata', {\n       *     'style': {\n       *         // token\n       *     }\n       * });\n       * ```\n       *\n       * ## Special cases\n       *\n       * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n       * will be ignored.\n       *\n       * This behavior can be used to insert tokens after `before`:\n       *\n       * ```js\n       * Prism.languages.insertBefore('markup', 'comment', {\n       *     'comment': Prism.languages.markup.comment,\n       *     // tokens after 'comment'\n       * });\n       * ```\n       *\n       * ## Limitations\n       *\n       * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n       * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n       * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n       * deleting properties which is necessary to insert at arbitrary positions.\n       *\n       * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n       * Instead, it will create a new object and replace all references to the target object with the new one. This\n       * can be done without temporarily deleting properties, so the iteration order is well-defined.\n       *\n       * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n       * you hold the target object in a variable, then the value of the variable will not change.\n       *\n       * ```js\n       * var oldMarkup = Prism.languages.markup;\n       * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n       *\n       * assert(oldMarkup !== Prism.languages.markup);\n       * assert(newMarkup === Prism.languages.markup);\n       * ```\n       *\n       * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n       * object to be modified.\n       * @param {string} before The key to insert before.\n       * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n       * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n       * object to be modified.\n       *\n       * Defaults to `Prism.languages`.\n       * @returns {Grammar} The new grammar object.\n       * @public\n       */\n      insertBefore: function insertBefore(inside, before, insert, root) {\n        root = root ||\n        /** @type {any} */\n        _.languages;\n        var grammar = root[inside];\n        /** @type {Grammar} */\n\n        var ret = {};\n\n        for (var token in grammar) {\n          if (grammar.hasOwnProperty(token)) {\n            if (token == before) {\n              for (var newToken in insert) {\n                if (insert.hasOwnProperty(newToken)) {\n                  ret[newToken] = insert[newToken];\n                }\n              }\n            } // Do not insert token which also occur in insert. See #1525\n\n\n            if (!insert.hasOwnProperty(token)) {\n              ret[token] = grammar[token];\n            }\n          }\n        }\n\n        var old = root[inside];\n        root[inside] = ret; // Update references in other language definitions\n\n        _.languages.DFS(_.languages, function (key, value) {\n          if (value === old && key != inside) {\n            this[key] = ret;\n          }\n        });\n\n        return ret;\n      },\n      // Traverse a language definition with Depth First Search\n      DFS: function DFS(o, callback, type, visited) {\n        visited = visited || {};\n        var objId = _.util.objId;\n\n        for (var i in o) {\n          if (o.hasOwnProperty(i)) {\n            callback.call(o, i, o[i], type || i);\n            var property = o[i];\n\n            var propertyType = _.util.type(property);\n\n            if (propertyType === 'Object' && !visited[objId(property)]) {\n              visited[objId(property)] = true;\n              DFS(property, callback, null, visited);\n            } else if (propertyType === 'Array' && !visited[objId(property)]) {\n              visited[objId(property)] = true;\n              DFS(property, callback, i, visited);\n            }\n          }\n        }\n      }\n    },\n    plugins: {},\n\n    /**\n     * Low-level function, only use if you know what you\u2019re doing. It accepts a string of text as input\n     * and the language definitions to use, and returns a string with the HTML produced.\n     *\n     * The following hooks will be run:\n     * 1. `before-tokenize`\n     * 2. `after-tokenize`\n     * 3. `wrap`: On each {@link Token}.\n     *\n     * @param {string} text A string with the code to be highlighted.\n     * @param {Grammar} grammar An object containing the tokens to use.\n     *\n     * Usually a language definition like `Prism.languages.markup`.\n     * @param {string} language The name of the language definition passed to `grammar`.\n     * @returns {string} The highlighted HTML.\n     * @memberof Prism\n     * @public\n     * @example\n     * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n     */\n    highlight: function highlight(text, grammar, language) {\n      var env = {\n        code: text,\n        grammar: grammar,\n        language: language\n      };\n\n      _.hooks.run('before-tokenize', env);\n\n      env.tokens = _.tokenize(env.code, env.grammar);\n\n      _.hooks.run('after-tokenize', env);\n\n      return Token.stringify(_.util.encode(env.tokens), env.language);\n    },\n\n    /**\n     * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n     * and the language definitions to use, and returns an array with the tokenized code.\n     *\n     * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n     *\n     * This method could be useful in other contexts as well, as a very crude parser.\n     *\n     * @param {string} text A string with the code to be highlighted.\n     * @param {Grammar} grammar An object containing the tokens to use.\n     *\n     * Usually a language definition like `Prism.languages.markup`.\n     * @returns {TokenStream} An array of strings and tokens, a token stream.\n     * @memberof Prism\n     * @public\n     * @example\n     * let code = `var foo = 0;`;\n     * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n     * tokens.forEach(token => {\n     *     if (token instanceof Prism.Token && token.type === 'number') {\n     *         console.log(`Found numeric literal: ${token.content}`);\n     *     }\n     * });\n     */\n    tokenize: function tokenize(text, grammar) {\n      var rest = grammar.rest;\n\n      if (rest) {\n        for (var token in rest) {\n          grammar[token] = rest[token];\n        }\n\n        delete grammar.rest;\n      }\n\n      var tokenList = new LinkedList();\n      addAfter(tokenList, tokenList.head, text);\n      matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n      return toArray(tokenList);\n    },\n\n    /**\n     * @namespace\n     * @memberof Prism\n     * @public\n     */\n    hooks: {\n      all: {},\n\n      /**\n       * Adds the given callback to the list of callbacks for the given hook.\n       *\n       * The callback will be invoked when the hook it is registered for is run.\n       * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n       *\n       * One callback function can be registered to multiple hooks and the same hook multiple times.\n       *\n       * @param {string} name The name of the hook.\n       * @param {HookCallback} callback The callback function which is given environment variables.\n       * @public\n       */\n      add: function add(name, callback) {\n        var hooks = _.hooks.all;\n        hooks[name] = hooks[name] || [];\n        hooks[name].push(callback);\n      },\n\n      /**\n       * Runs a hook invoking all registered callbacks with the given environment variables.\n       *\n       * Callbacks will be invoked synchronously and in the order in which they were registered.\n       *\n       * @param {string} name The name of the hook.\n       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n       * @public\n       */\n      run: function run(name, env) {\n        var callbacks = _.hooks.all[name];\n\n        if (!callbacks || !callbacks.length) {\n          return;\n        }\n\n        for (var i = 0, callback; callback = callbacks[i++];) {\n          callback(env);\n        }\n      }\n    },\n    Token: Token\n  }; // Typescript note:\n  // The following can be used to import the Token type in JSDoc:\n  //\n  //   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n  /**\n   * Creates a new token.\n   *\n   * @param {string} type See {@link Token#type type}\n   * @param {string | TokenStream} content See {@link Token#content content}\n   * @param {string|string[]} [alias] The alias(es) of the token.\n   * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n   * @class\n   * @global\n   * @public\n   */\n\n  function Token(type, content, alias, matchedStr) {\n    /**\n     * The type of the token.\n     *\n     * This is usually the key of a pattern in a {@link Grammar}.\n     *\n     * @type {string}\n     * @see GrammarToken\n     * @public\n     */\n    this.type = type;\n    /**\n     * The strings or tokens contained by this token.\n     *\n     * This will be a token stream if the pattern matched also defined an `inside` grammar.\n     *\n     * @type {string | TokenStream}\n     * @public\n     */\n\n    this.content = content;\n    /**\n     * The alias(es) of the token.\n     *\n     * @type {string|string[]}\n     * @see GrammarToken\n     * @public\n     */\n\n    this.alias = alias; // Copy of the full string this token was created from\n\n    this.length = (matchedStr || '').length | 0;\n  }\n  /**\n   * A token stream is an array of strings and {@link Token Token} objects.\n   *\n   * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n   * them.\n   *\n   * 1. No adjacent strings.\n   * 2. No empty strings.\n   *\n   *    The only exception here is the token stream that only contains the empty string and nothing else.\n   *\n   * @typedef {Array<string | Token>} TokenStream\n   * @global\n   * @public\n   */\n\n  /**\n   * Converts the given token or token stream to an HTML representation.\n   *\n   * The following hooks will be run:\n   * 1. `wrap`: On each {@link Token}.\n   *\n   * @param {string | Token | TokenStream} o The token or token stream to be converted.\n   * @param {string} language The name of current language.\n   * @returns {string} The HTML representation of the token or token stream.\n   * @memberof Token\n   * @static\n   */\n\n\n  Token.stringify = function stringify(o, language) {\n    if (typeof o == 'string') {\n      return o;\n    }\n\n    if (Array.isArray(o)) {\n      var s = '';\n      o.forEach(function (e) {\n        s += stringify(e, language);\n      });\n      return s;\n    }\n\n    var env = {\n      type: o.type,\n      content: stringify(o.content, language),\n      tag: 'span',\n      classes: ['token', o.type],\n      attributes: {},\n      language: language\n    };\n    var aliases = o.alias;\n\n    if (aliases) {\n      if (Array.isArray(aliases)) {\n        Array.prototype.push.apply(env.classes, aliases);\n      } else {\n        env.classes.push(aliases);\n      }\n    }\n\n    _.hooks.run('wrap', env);\n\n    var attributes = '';\n\n    for (var name in env.attributes) {\n      attributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n    }\n\n    return '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n  };\n  /**\n   * @param {RegExp} pattern\n   * @param {number} pos\n   * @param {string} text\n   * @param {boolean} lookbehind\n   * @returns {RegExpExecArray | null}\n   */\n\n\n  function matchPattern(pattern, pos, text, lookbehind) {\n    pattern.lastIndex = pos;\n    var match = pattern.exec(text);\n\n    if (match && lookbehind && match[1]) {\n      // change the match to remove the text matched by the Prism lookbehind group\n      var lookbehindLength = match[1].length;\n      match.index += lookbehindLength;\n      match[0] = match[0].slice(lookbehindLength);\n    }\n\n    return match;\n  }\n  /**\n   * @param {string} text\n   * @param {LinkedList<string | Token>} tokenList\n   * @param {any} grammar\n   * @param {LinkedListNode<string | Token>} startNode\n   * @param {number} startPos\n   * @param {RematchOptions} [rematch]\n   * @returns {void}\n   * @private\n   *\n   * @typedef RematchOptions\n   * @property {string} cause\n   * @property {number} reach\n   */\n\n\n  function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n    for (var token in grammar) {\n      if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n        continue;\n      }\n\n      var patterns = grammar[token];\n      patterns = Array.isArray(patterns) ? patterns : [patterns];\n\n      for (var j = 0; j < patterns.length; ++j) {\n        if (rematch && rematch.cause == token + ',' + j) {\n          return;\n        }\n\n        var patternObj = patterns[j];\n        var inside = patternObj.inside;\n        var lookbehind = !!patternObj.lookbehind;\n        var greedy = !!patternObj.greedy;\n        var alias = patternObj.alias;\n\n        if (greedy && !patternObj.pattern.global) {\n          // Without the global flag, lastIndex won't work\n          var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n          patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n        }\n        /** @type {RegExp} */\n\n\n        var pattern = patternObj.pattern || patternObj;\n\n        for ( // iterate the token list and keep track of the current token/string position\n        var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {\n          if (rematch && pos >= rematch.reach) {\n            break;\n          }\n\n          var str = currentNode.value;\n\n          if (tokenList.length > text.length) {\n            // Something went terribly wrong, ABORT, ABORT!\n            return;\n          }\n\n          if (str instanceof Token) {\n            continue;\n          }\n\n          var removeCount = 1; // this is the to parameter of removeBetween\n\n          var match;\n\n          if (greedy) {\n            match = matchPattern(pattern, pos, text, lookbehind);\n\n            if (!match || match.index >= text.length) {\n              break;\n            }\n\n            var from = match.index;\n            var to = match.index + match[0].length;\n            var p = pos; // find the node that contains the match\n\n            p += currentNode.value.length;\n\n            while (from >= p) {\n              currentNode = currentNode.next;\n              p += currentNode.value.length;\n            } // adjust pos (and p)\n\n\n            p -= currentNode.value.length;\n            pos = p; // the current node is a Token, then the match starts inside another Token, which is invalid\n\n            if (currentNode.value instanceof Token) {\n              continue;\n            } // find the last node which is affected by this match\n\n\n            for (var k = currentNode; k !== tokenList.tail && (p < to || typeof k.value === 'string'); k = k.next) {\n              removeCount++;\n              p += k.value.length;\n            }\n\n            removeCount--; // replace with the new match\n\n            str = text.slice(pos, p);\n            match.index -= pos;\n          } else {\n            match = matchPattern(pattern, 0, str, lookbehind);\n\n            if (!match) {\n              continue;\n            }\n          } // eslint-disable-next-line no-redeclare\n\n\n          var from = match.index;\n          var matchStr = match[0];\n          var before = str.slice(0, from);\n          var after = str.slice(from + matchStr.length);\n          var reach = pos + str.length;\n\n          if (rematch && reach > rematch.reach) {\n            rematch.reach = reach;\n          }\n\n          var removeFrom = currentNode.prev;\n\n          if (before) {\n            removeFrom = addAfter(tokenList, removeFrom, before);\n            pos += before.length;\n          }\n\n          removeRange(tokenList, removeFrom, removeCount);\n          var wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n          currentNode = addAfter(tokenList, removeFrom, wrapped);\n\n          if (after) {\n            addAfter(tokenList, currentNode, after);\n          }\n\n          if (removeCount > 1) {\n            // at least one Token object was removed, so we have to do some rematching\n            // this can only happen if the current pattern is greedy\n\n            /** @type {RematchOptions} */\n            var nestedRematch = {\n              cause: token + ',' + j,\n              reach: reach\n            };\n            matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch); // the reach might have been extended because of the rematching\n\n            if (rematch && nestedRematch.reach > rematch.reach) {\n              rematch.reach = nestedRematch.reach;\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @typedef LinkedListNode\n   * @property {T} value\n   * @property {LinkedListNode<T> | null} prev The previous node.\n   * @property {LinkedListNode<T> | null} next The next node.\n   * @template T\n   * @private\n   */\n\n  /**\n   * @template T\n   * @private\n   */\n\n\n  function LinkedList() {\n    /** @type {LinkedListNode<T>} */\n    var head = {\n      value: null,\n      prev: null,\n      next: null\n    };\n    /** @type {LinkedListNode<T>} */\n\n    var tail = {\n      value: null,\n      prev: head,\n      next: null\n    };\n    head.next = tail;\n    /** @type {LinkedListNode<T>} */\n\n    this.head = head;\n    /** @type {LinkedListNode<T>} */\n\n    this.tail = tail;\n    this.length = 0;\n  }\n  /**\n   * Adds a new node with the given value to the list.\n   *\n   * @param {LinkedList<T>} list\n   * @param {LinkedListNode<T>} node\n   * @param {T} value\n   * @returns {LinkedListNode<T>} The added node.\n   * @template T\n   */\n\n\n  function addAfter(list, node, value) {\n    // assumes that node != list.tail && values.length >= 0\n    var next = node.next;\n    var newNode = {\n      value: value,\n      prev: node,\n      next: next\n    };\n    node.next = newNode;\n    next.prev = newNode;\n    list.length++;\n    return newNode;\n  }\n  /**\n   * Removes `count` nodes after the given node. The given node will not be removed.\n   *\n   * @param {LinkedList<T>} list\n   * @param {LinkedListNode<T>} node\n   * @param {number} count\n   * @template T\n   */\n\n\n  function removeRange(list, node, count) {\n    var next = node.next;\n\n    for (var i = 0; i < count && next !== list.tail; i++) {\n      next = next.next;\n    }\n\n    node.next = next;\n    next.prev = node;\n    list.length -= i;\n  }\n  /**\n   * @param {LinkedList<T>} list\n   * @returns {T[]}\n   * @template T\n   */\n\n\n  function toArray(list) {\n    var array = [];\n    var node = list.head.next;\n\n    while (node !== list.tail) {\n      array.push(node.value);\n      node = node.next;\n    }\n\n    return array;\n  }\n\n  return _;\n}();\n\nvar prism = Prism;\nPrism[\"default\"] = Prism;\n/* This content is auto-generated to include some prismjs language components: */\n\n/* \"prismjs/components/prism-markup\" */\n\nprism.languages.markup = {\n  'comment': {\n    pattern: /\x3c!--(?:(?!\x3c!--)[\\s\\S])*?--\x3e/,\n    greedy: true\n  },\n  'prolog': {\n    pattern: /<\\?[\\s\\S]+?\\?>/,\n    greedy: true\n  },\n  'doctype': {\n    // https://www.w3.org/TR/xml/#NT-doctypedecl\n    pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|\x3c!--(?:[^-]|-(?!->))*--\x3e)*\\]\\s*)?>/i,\n    greedy: true,\n    inside: {\n      'internal-subset': {\n        pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n        lookbehind: true,\n        greedy: true,\n        inside: null // see below\n\n      },\n      'string': {\n        pattern: /\"[^\"]*\"|'[^']*'/,\n        greedy: true\n      },\n      'punctuation': /^<!|>$|[[\\]]/,\n      'doctype-tag': /^DOCTYPE/i,\n      'name': /[^\\s<>'\"]+/\n    }\n  },\n  'cdata': {\n    pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n    greedy: true\n  },\n  'tag': {\n    pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n    greedy: true,\n    inside: {\n      'tag': {\n        pattern: /^<\\/?[^\\s>\\/]+/,\n        inside: {\n          'punctuation': /^<\\/?/,\n          'namespace': /^[^\\s>\\/:]+:/\n        }\n      },\n      'special-attr': [],\n      'attr-value': {\n        pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n        inside: {\n          'punctuation': [{\n            pattern: /^=/,\n            alias: 'attr-equals'\n          }, /\"|'/]\n        }\n      },\n      'punctuation': /\\/?>/,\n      'attr-name': {\n        pattern: /[^\\s>\\/]+/,\n        inside: {\n          'namespace': /^[^\\s>\\/:]+:/\n        }\n      }\n    }\n  },\n  'entity': [{\n    pattern: /&[\\da-z]{1,8};/i,\n    alias: 'named-entity'\n  }, /&#x?[\\da-f]{1,8};/i]\n};\nprism.languages.markup['tag'].inside['attr-value'].inside['entity'] = prism.languages.markup['entity'];\nprism.languages.markup['doctype'].inside['internal-subset'].inside = prism.languages.markup; // Plugin to make entity title show the real entity, idea by Roman Komarov\n\nprism.hooks.add('wrap', function (env) {\n  if (env.type === 'entity') {\n    env.attributes['title'] = env.content.replace(/&amp;/, '&');\n  }\n});\nObject.defineProperty(prism.languages.markup.tag, 'addInlined', {\n  /**\n   * Adds an inlined language to markup.\n   *\n   * An example of an inlined language is CSS with `<style>` tags.\n   *\n   * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addInlined('style', 'css');\n   */\n  value: function addInlined(tagName, lang) {\n    var includedCdataInside = {};\n    includedCdataInside['language-' + lang] = {\n      pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n      lookbehind: true,\n      inside: prism.languages[lang]\n    };\n    includedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n    var inside = {\n      'included-cdata': {\n        pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n        inside: includedCdataInside\n      }\n    };\n    inside['language-' + lang] = {\n      pattern: /[\\s\\S]+/,\n      inside: prism.languages[lang]\n    };\n    var def = {};\n    def[tagName] = {\n      pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () {\n        return tagName;\n      }), 'i'),\n      lookbehind: true,\n      greedy: true,\n      inside: inside\n    };\n    prism.languages.insertBefore('markup', 'cdata', def);\n  }\n});\nObject.defineProperty(prism.languages.markup.tag, 'addAttribute', {\n  /**\n   * Adds an pattern to highlight languages embedded in HTML attributes.\n   *\n   * An example of an inlined language is CSS with `style` attributes.\n   *\n   * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n   * case insensitive.\n   * @param {string} lang The language key.\n   * @example\n   * addAttribute('style', 'css');\n   */\n  value: function value(attrName, lang) {\n    prism.languages.markup.tag.inside['special-attr'].push({\n      pattern: RegExp(/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source, 'i'),\n      lookbehind: true,\n      inside: {\n        'attr-name': /^[^\\s=]+/,\n        'attr-value': {\n          pattern: /=[\\s\\S]+/,\n          inside: {\n            'value': {\n              pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n              lookbehind: true,\n              alias: [lang, 'language-' + lang],\n              inside: prism.languages[lang]\n            },\n            'punctuation': [{\n              pattern: /^=/,\n              alias: 'attr-equals'\n            }, /\"|'/]\n          }\n        }\n      }\n    });\n  }\n});\nprism.languages.html = prism.languages.markup;\nprism.languages.mathml = prism.languages.markup;\nprism.languages.svg = prism.languages.markup;\nprism.languages.xml = prism.languages.extend('markup', {});\nprism.languages.ssml = prism.languages.xml;\nprism.languages.atom = prism.languages.xml;\nprism.languages.rss = prism.languages.xml;\n/* \"prismjs/components/prism-bash\" */\n\n(function (Prism) {\n  // $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\\n' '|'\n  // + LC_ALL, RANDOM, REPLY, SECONDS.\n  // + make sure PS1..4 are here as they are not always set,\n  // - some useless things.\n  var envVars = '\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b';\n  var commandAfterHeredoc = {\n    pattern: /(^([\"']?)\\w+\\2)[ \\t]+\\S.*/,\n    lookbehind: true,\n    alias: 'punctuation',\n    // this looks reasonably well in all themes\n    inside: null // see below\n\n  };\n  var insideString = {\n    'bash': commandAfterHeredoc,\n    'environment': {\n      pattern: RegExp('\\\\$' + envVars),\n      alias: 'constant'\n    },\n    'variable': [// [0]: Arithmetic Environment\n    {\n      pattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,\n      greedy: true,\n      inside: {\n        // If there is a $ sign at the beginning highlight $(( and )) as variable\n        'variable': [{\n          pattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/,\n          lookbehind: true\n        }, /^\\$\\(\\(/],\n        'number': /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,\n        // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic\n        'operator': /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,\n        // If there is no $ sign at the beginning highlight (( and )) as punctuation\n        'punctuation': /\\(\\(?|\\)\\)?|,|;/\n      }\n    }, // [1]: Command Substitution\n    {\n      pattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|`[^`]+`/,\n      greedy: true,\n      inside: {\n        'variable': /^\\$\\(|^`|\\)$|`$/\n      }\n    }, // [2]: Brace expansion\n    {\n      pattern: /\\$\\{[^}]+\\}/,\n      greedy: true,\n      inside: {\n        'operator': /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,\n        'punctuation': /[\\[\\]]/,\n        'environment': {\n          pattern: RegExp('(\\\\{)' + envVars),\n          lookbehind: true,\n          alias: 'constant'\n        }\n      }\n    }, /\\$(?:\\w+|[#?*!@$])/],\n    // Escape sequences from echo and printf's manuals, and escaped quotes.\n    'entity': /\\\\(?:[abceEfnrtv\\\\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/\n  };\n  Prism.languages.bash = {\n    'shebang': {\n      pattern: /^#!\\s*\\/.*/,\n      alias: 'important'\n    },\n    'comment': {\n      pattern: /(^|[^\"{\\\\$])#.*/,\n      lookbehind: true\n    },\n    'function-name': [// a) function foo {\n    // b) foo() {\n    // c) function foo() {\n    // but not \u201cfoo {\u201d\n    {\n      // a) and c)\n      pattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,\n      lookbehind: true,\n      alias: 'function'\n    }, {\n      // b)\n      pattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/,\n      alias: 'function'\n    }],\n    // Highlight variable names as variables in for and select beginnings.\n    'for-or-select': {\n      pattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,\n      alias: 'variable',\n      lookbehind: true\n    },\n    // Highlight variable names as variables in the left-hand part\n    // of assignments (\u201c=\u201d and \u201c+=\u201d).\n    'assign-left': {\n      pattern: /(^|[\\s;|&]|[<>]\\()\\w+(?=\\+?=)/,\n      inside: {\n        'environment': {\n          pattern: RegExp('(^|[\\\\s;|&]|[<>]\\\\()' + envVars),\n          lookbehind: true,\n          alias: 'constant'\n        }\n      },\n      alias: 'variable',\n      lookbehind: true\n    },\n    'string': [// Support for Here-documents https://en.wikipedia.org/wiki/Here_document\n    {\n      pattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,\n      lookbehind: true,\n      greedy: true,\n      inside: insideString\n    }, // Here-document with quotes around the tag\n    // \u2192 No expansion (so no \u201cinside\u201d).\n    {\n      pattern: /((?:^|[^<])<<-?\\s*)([\"'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'bash': commandAfterHeredoc\n      }\n    }, // \u201cNormal\u201d string\n    {\n      // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n      pattern: /(^|[^\\\\](?:\\\\\\\\)*)\"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|`[^`]+`|[^\"\\\\`$])*\"/,\n      lookbehind: true,\n      greedy: true,\n      inside: insideString\n    }, {\n      // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html\n      pattern: /(^|[^$\\\\])'[^']*'/,\n      lookbehind: true,\n      greedy: true\n    }, {\n      // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html\n      pattern: /\\$'(?:[^'\\\\]|\\\\[\\s\\S])*'/,\n      greedy: true,\n      inside: {\n        'entity': insideString.entity\n      }\n    }],\n    'environment': {\n      pattern: RegExp('\\\\$?' + envVars),\n      alias: 'constant'\n    },\n    'variable': insideString.variable,\n    'function': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,\n      lookbehind: true\n    },\n    'keyword': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\\s;|&])/,\n      lookbehind: true\n    },\n    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n    'builtin': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:\\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\\s;|&])/,\n      lookbehind: true,\n      // Alias added to make those easier to distinguish from strings.\n      alias: 'class-name'\n    },\n    'boolean': {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:false|true)(?=$|[)\\s;|&])/,\n      lookbehind: true\n    },\n    'file-descriptor': {\n      pattern: /\\B&\\d\\b/,\n      alias: 'important'\n    },\n    'operator': {\n      // Lots of redirections here, but not just that.\n      pattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,\n      inside: {\n        'file-descriptor': {\n          pattern: /^\\d/,\n          alias: 'important'\n        }\n      }\n    },\n    'punctuation': /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,\n    'number': {\n      pattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/,\n      lookbehind: true\n    }\n  };\n  commandAfterHeredoc.inside = Prism.languages.bash;\n  /* Patterns in command substitution. */\n\n  var toBeCopied = ['comment', 'function-name', 'for-or-select', 'assign-left', 'string', 'environment', 'function', 'keyword', 'builtin', 'boolean', 'file-descriptor', 'operator', 'punctuation', 'number'];\n  var inside = insideString.variable[1].inside;\n\n  for (var i = 0; i < toBeCopied.length; i++) {\n    inside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];\n  }\n\n  Prism.languages.shell = Prism.languages.bash;\n})(prism);\n/* \"prismjs/components/prism-clike\" */\n\n\nprism.languages.clike = {\n  'comment': [{\n    pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    lookbehind: true,\n    greedy: true\n  }, {\n    pattern: /(^|[^\\\\:])\\/\\/.*/,\n    lookbehind: true,\n    greedy: true\n  }],\n  'string': {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true\n  },\n  'class-name': {\n    pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n    lookbehind: true,\n    inside: {\n      'punctuation': /[.\\\\]/\n    }\n  },\n  'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n  'boolean': /\\b(?:false|true)\\b/,\n  'function': /\\b\\w+(?=\\()/,\n  'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n  'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n  'punctuation': /[{}[\\];(),.:]/\n};\n/* \"prismjs/components/prism-c\" */\n\nprism.languages.c = prism.languages.extend('clike', {\n  'comment': {\n    pattern: /\\/\\/(?:[^\\r\\n\\\\]|\\\\(?:\\r\\n?|\\n|(?![\\r\\n])))*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    greedy: true\n  },\n  'string': {\n    // https://en.cppreference.com/w/c/language/string_literal\n    pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n    greedy: true\n  },\n  'class-name': {\n    pattern: /(\\b(?:enum|struct)\\s+(?:__attribute__\\s*\\(\\([\\s\\S]*?\\)\\)\\s*)?)\\w+|\\b[a-z]\\w*_t\\b/,\n    lookbehind: true\n  },\n  'keyword': /\\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b/,\n  'function': /\\b[a-z_]\\w*(?=\\s*\\()/i,\n  'number': /(?:\\b0x(?:[\\da-f]+(?:\\.[\\da-f]*)?|\\.[\\da-f]+)(?:p[+-]?\\d+)?|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?)[ful]{0,4}/i,\n  'operator': />>=?|<<=?|->|([-+&|:])\\1|[?:~]|[-+*/%&|^!=<>]=?/\n});\nprism.languages.insertBefore('c', 'string', {\n  'char': {\n    // https://en.cppreference.com/w/c/language/character_constant\n    pattern: /'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n]){0,32}'/,\n    greedy: true\n  }\n});\nprism.languages.insertBefore('c', 'string', {\n  'macro': {\n    // allow for multiline macro definitions\n    // spaces after the # character compile fine with gcc\n    pattern: /(^[\\t ]*)#\\s*[a-z](?:[^\\r\\n\\\\/]|\\/(?!\\*)|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/|\\\\(?:\\r\\n|[\\s\\S]))*/im,\n    lookbehind: true,\n    greedy: true,\n    alias: 'property',\n    inside: {\n      'string': [{\n        // highlight the path of the include statement as a string\n        pattern: /^(#\\s*include\\s*)<[^>]+>/,\n        lookbehind: true\n      }, prism.languages.c['string']],\n      'char': prism.languages.c['char'],\n      'comment': prism.languages.c['comment'],\n      'macro-name': [{\n        pattern: /(^#\\s*define\\s+)\\w+\\b(?!\\()/i,\n        lookbehind: true\n      }, {\n        pattern: /(^#\\s*define\\s+)\\w+\\b(?=\\()/i,\n        lookbehind: true,\n        alias: 'function'\n      }],\n      // highlight macro directives as keywords\n      'directive': {\n        pattern: /^(#\\s*)[a-z]+/,\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      'directive-hash': /^#/,\n      'punctuation': /##|\\\\(?=[\\r\\n])/,\n      'expression': {\n        pattern: /\\S[\\s\\S]*/,\n        inside: prism.languages.c\n      }\n    }\n  }\n});\nprism.languages.insertBefore('c', 'function', {\n  // highlight predefined macros as constants\n  'constant': /\\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\\b/\n});\ndelete prism.languages.c['boolean'];\n/* \"prismjs/components/prism-cpp\" */\n\n(function (Prism) {\n  var keyword = /\\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\\b/;\n  var modName = /\\b(?!<keyword>)\\w+(?:\\s*\\.\\s*\\w+)*\\b/.source.replace(/<keyword>/g, function () {\n    return keyword.source;\n  });\n  Prism.languages.cpp = Prism.languages.extend('c', {\n    'class-name': [{\n      pattern: RegExp(/(\\b(?:class|concept|enum|struct|typename)\\s+)(?!<keyword>)\\w+/.source.replace(/<keyword>/g, function () {\n        return keyword.source;\n      })),\n      lookbehind: true\n    }, // This is intended to capture the class name of method implementations like:\n    //   void foo::bar() const {}\n    // However! The `foo` in the above example could also be a namespace, so we only capture the class name if\n    // it starts with an uppercase letter. This approximation should give decent results.\n    /\\b[A-Z]\\w*(?=\\s*::\\s*\\w+\\s*\\()/, // This will capture the class name before destructors like:\n    //   Foo::~Foo() {}\n    /\\b[A-Z_]\\w*(?=\\s*::\\s*~\\w+\\s*\\()/i, // This also intends to capture the class name of method implementations but here the class has template\n    // parameters, so it can't be a namespace (until C++ adds generic namespaces).\n    /\\b\\w+(?=\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\\s*::\\s*\\w+\\s*\\()/],\n    'keyword': keyword,\n    'number': {\n      pattern: /(?:\\b0b[01']+|\\b0x(?:[\\da-f']+(?:\\.[\\da-f']*)?|\\.[\\da-f']+)(?:p[+-]?[\\d']+)?|(?:\\b[\\d']+(?:\\.[\\d']*)?|\\B\\.[\\d']+)(?:e[+-]?[\\d']+)?)[ful]{0,4}/i,\n      greedy: true\n    },\n    'operator': />>=?|<<=?|->|--|\\+\\+|&&|\\|\\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\\b/,\n    'boolean': /\\b(?:false|true)\\b/\n  });\n  Prism.languages.insertBefore('cpp', 'string', {\n    'module': {\n      // https://en.cppreference.com/w/cpp/language/modules\n      pattern: RegExp(/(\\b(?:import|module)\\s+)/.source + '(?:' + // header-name\n      /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|<[^<>\\r\\n]*>/.source + '|' + // module name or partition or both\n      /<mod-name>(?:\\s*:\\s*<mod-name>)?|:\\s*<mod-name>/.source.replace(/<mod-name>/g, function () {\n        return modName;\n      }) + ')'),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'string': /^[<\"][\\s\\S]+/,\n        'operator': /:/,\n        'punctuation': /\\./\n      }\n    },\n    'raw-string': {\n      pattern: /R\"([^()\\\\ ]{0,16})\\([\\s\\S]*?\\)\\1\"/,\n      alias: 'string',\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'keyword', {\n    'generic-function': {\n      pattern: /\\b(?!operator\\b)[a-z_]\\w*\\s*<(?:[^<>]|<[^<>]*>)*>(?=\\s*\\()/i,\n      inside: {\n        'function': /^\\w+/,\n        'generic': {\n          pattern: /<[\\s\\S]+/,\n          alias: 'class-name',\n          inside: Prism.languages.cpp\n        }\n      }\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'operator', {\n    'double-colon': {\n      pattern: /::/,\n      alias: 'punctuation'\n    }\n  });\n  Prism.languages.insertBefore('cpp', 'class-name', {\n    // the base clause is an optional list of parent classes\n    // https://en.cppreference.com/w/cpp/language/class\n    'base-clause': {\n      pattern: /(\\b(?:class|struct)\\s+\\w+\\s*:\\s*)[^;{}\"'\\s]+(?:\\s+[^;{}\"'\\s]+)*(?=\\s*[;{])/,\n      lookbehind: true,\n      greedy: true,\n      inside: Prism.languages.extend('cpp', {})\n    }\n  });\n  Prism.languages.insertBefore('inside', 'double-colon', {\n    // All untokenized words that are not namespaces should be class names\n    'class-name': /\\b[a-z_]\\w*\\b(?!\\s*::)/i\n  }, Prism.languages.cpp['base-clause']);\n})(prism);\n/* \"prismjs/components/prism-css\" */\n\n\n(function (Prism) {\n  var string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n  Prism.languages.css = {\n    'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n    'atrule': {\n      pattern: /@[\\w-](?:[^;{\\s]|\\s+(?![\\s{]))*(?:;|(?=\\s*\\{))/,\n      inside: {\n        'rule': /^@[\\w-]+/,\n        'selector-function-argument': {\n          pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n          lookbehind: true,\n          alias: 'selector'\n        },\n        'keyword': {\n          pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n          lookbehind: true\n        } // See rest below\n\n      }\n    },\n    'url': {\n      // https://drafts.csswg.org/css-values-3/#urls\n      pattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n      greedy: true,\n      inside: {\n        'function': /^url/i,\n        'punctuation': /^\\(|\\)$/,\n        'string': {\n          pattern: RegExp('^' + string.source + '$'),\n          alias: 'url'\n        }\n      }\n    },\n    'selector': {\n      pattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n      lookbehind: true\n    },\n    'string': {\n      pattern: string,\n      greedy: true\n    },\n    'property': {\n      pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n      lookbehind: true\n    },\n    'important': /!important\\b/i,\n    'function': {\n      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n      lookbehind: true\n    },\n    'punctuation': /[(){};:,]/\n  };\n  Prism.languages.css['atrule'].inside.rest = Prism.languages.css;\n  var markup = Prism.languages.markup;\n\n  if (markup) {\n    markup.tag.addInlined('style', 'css');\n    markup.tag.addAttribute('style', 'css');\n  }\n})(prism);\n/* \"prismjs/components/prism-css-extras\" */\n\n\n(function (Prism) {\n  var string = /(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/;\n  var selectorInside;\n  Prism.languages.css.selector = {\n    pattern: Prism.languages.css.selector.pattern,\n    lookbehind: true,\n    inside: selectorInside = {\n      'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\\w]+/,\n      'pseudo-class': /:[-\\w]+/,\n      'class': /\\.[-\\w]+/,\n      'id': /#[-\\w]+/,\n      'attribute': {\n        pattern: RegExp('\\\\[(?:[^[\\\\]\"\\']|' + string.source + ')*\\\\]'),\n        greedy: true,\n        inside: {\n          'punctuation': /^\\[|\\]$/,\n          'case-sensitivity': {\n            pattern: /(\\s)[si]$/i,\n            lookbehind: true,\n            alias: 'keyword'\n          },\n          'namespace': {\n            pattern: /^(\\s*)(?:(?!\\s)[-*\\w\\xA0-\\uFFFF])*\\|(?!=)/,\n            lookbehind: true,\n            inside: {\n              'punctuation': /\\|$/\n            }\n          },\n          'attr-name': {\n            pattern: /^(\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+/,\n            lookbehind: true\n          },\n          'attr-value': [string, {\n            pattern: /(=\\s*)(?:(?!\\s)[-\\w\\xA0-\\uFFFF])+(?=\\s*$)/,\n            lookbehind: true\n          }],\n          'operator': /[|~*^$]?=/\n        }\n      },\n      'n-th': [{\n        pattern: /(\\(\\s*)[+-]?\\d*[\\dn](?:\\s*[+-]\\s*\\d+)?(?=\\s*\\))/,\n        lookbehind: true,\n        inside: {\n          'number': /[\\dn]+/,\n          'operator': /[+-]/\n        }\n      }, {\n        pattern: /(\\(\\s*)(?:even|odd)(?=\\s*\\))/i,\n        lookbehind: true\n      }],\n      'combinator': />|\\+|~|\\|\\|/,\n      // the `tag` token has been existed and removed.\n      // because we can't find a perfect tokenize to match it.\n      // if you want to add it, please read https://github.com/PrismJS/prism/pull/2373 first.\n      'punctuation': /[(),]/\n    }\n  };\n  Prism.languages.css['atrule'].inside['selector-function-argument'].inside = selectorInside;\n  Prism.languages.insertBefore('css', 'property', {\n    'variable': {\n      pattern: /(^|[^-\\w\\xA0-\\uFFFF])--(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*/i,\n      lookbehind: true\n    }\n  });\n  var unit = {\n    pattern: /(\\b\\d+)(?:%|[a-z]+(?![\\w-]))/,\n    lookbehind: true\n  }; // 123 -123 .123 -.123 12.3 -12.3\n\n  var number = {\n    pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n    lookbehind: true\n  };\n  Prism.languages.insertBefore('css', 'function', {\n    'operator': {\n      pattern: /(\\s)[+\\-*\\/](?=\\s)/,\n      lookbehind: true\n    },\n    // CAREFUL!\n    // Previewers and Inline color use hexcode and color.\n    'hexcode': {\n      pattern: /\\B#[\\da-f]{3,8}\\b/i,\n      alias: 'color'\n    },\n    'color': [{\n      pattern: /(^|[^\\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\\w-])/i,\n      lookbehind: true\n    }, {\n      pattern: /\\b(?:hsl|rgb)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:hsl|rgb)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n      inside: {\n        'unit': unit,\n        'number': number,\n        'function': /[\\w-]+(?=\\()/,\n        'punctuation': /[(),]/\n      }\n    }],\n    // it's important that there is no boundary assertion after the hex digits\n    'entity': /\\\\[\\da-f]{1,8}/i,\n    'unit': unit,\n    'number': number\n  });\n})(prism);\n/* \"prismjs/components/prism-javascript\" */\n\n\nprism.languages.javascript = prism.languages.extend('clike', {\n  'class-name': [prism.languages.clike['class-name'], {\n    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n    lookbehind: true\n  }],\n  'keyword': [{\n    pattern: /((?:^|\\})\\s*)catch\\b/,\n    lookbehind: true\n  }, {\n    pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n    lookbehind: true\n  }],\n  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n  'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n  'number': {\n    pattern: RegExp(/(^|[^\\w$])/.source + '(?:' + ( // constant\n    /NaN|Infinity/.source + '|' + // binary integer\n    /0[bB][01]+(?:_[01]+)*n?/.source + '|' + // octal integer\n    /0[oO][0-7]+(?:_[0-7]+)*n?/.source + '|' + // hexadecimal integer\n    /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + '|' + // decimal bigint\n    /\\d+(?:_\\d+)*n/.source + '|' + // decimal number (integer or float) but no bigint\n    /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + ')' + /(?![\\w$])/.source),\n    lookbehind: true\n  },\n  'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\nprism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\nprism.languages.insertBefore('javascript', 'keyword', {\n  'regex': {\n    // eslint-disable-next-line regexp/no-dupe-characters-character-class\n    pattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)\\/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/,\n    lookbehind: true,\n    greedy: true,\n    inside: {\n      'regex-source': {\n        pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n        lookbehind: true,\n        alias: 'language-regex',\n        inside: prism.languages.regex\n      },\n      'regex-delimiter': /^\\/|\\/$/,\n      'regex-flags': /^[a-z]+$/\n    }\n  },\n  // This must be declared before keyword because we use \"function\" inside the look-forward\n  'function-variable': {\n    pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n    alias: 'function'\n  },\n  'parameter': [{\n    pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }, {\n    pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }, {\n    pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }, {\n    pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n    lookbehind: true,\n    inside: prism.languages.javascript\n  }],\n  'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\nprism.languages.insertBefore('javascript', 'string', {\n  'hashbang': {\n    pattern: /^#!.*/,\n    greedy: true,\n    alias: 'comment'\n  },\n  'template-string': {\n    pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n    greedy: true,\n    inside: {\n      'template-punctuation': {\n        pattern: /^`|`$/,\n        alias: 'string'\n      },\n      'interpolation': {\n        pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n        lookbehind: true,\n        inside: {\n          'interpolation-punctuation': {\n            pattern: /^\\$\\{|\\}$/,\n            alias: 'punctuation'\n          },\n          rest: prism.languages.javascript\n        }\n      },\n      'string': /[\\s\\S]+/\n    }\n  },\n  'string-property': {\n    pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n    lookbehind: true,\n    greedy: true,\n    alias: 'property'\n  }\n});\nprism.languages.insertBefore('javascript', 'operator', {\n  'literal-property': {\n    pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n    lookbehind: true,\n    alias: 'property'\n  }\n});\n\nif (prism.languages.markup) {\n  prism.languages.markup.tag.addInlined('script', 'javascript'); // add attribute support for all DOM events.\n  // https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\n  prism.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, 'javascript');\n}\n\nprism.languages.js = prism.languages.javascript;\n/* \"prismjs/components/prism-coffeescript\" */\n\n(function (Prism) {\n  // Ignore comments starting with { to privilege string interpolation highlighting\n  var comment = /#(?!\\{).+/;\n  var interpolation = {\n    pattern: /#\\{[^}]+\\}/,\n    alias: 'variable'\n  };\n  Prism.languages.coffeescript = Prism.languages.extend('javascript', {\n    'comment': comment,\n    'string': [// Strings are multiline\n    {\n      pattern: /'(?:\\\\[\\s\\S]|[^\\\\'])*'/,\n      greedy: true\n    }, {\n      // Strings are multiline\n      pattern: /\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"/,\n      greedy: true,\n      inside: {\n        'interpolation': interpolation\n      }\n    }],\n    'keyword': /\\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\\b/,\n    'class-member': {\n      pattern: /@(?!\\d)\\w+/,\n      alias: 'variable'\n    }\n  });\n  Prism.languages.insertBefore('coffeescript', 'comment', {\n    'multiline-comment': {\n      pattern: /###[\\s\\S]+?###/,\n      alias: 'comment'\n    },\n    // Block regexp can contain comments and interpolation\n    'block-regex': {\n      pattern: /\\/{3}[\\s\\S]*?\\/{3}/,\n      alias: 'regex',\n      inside: {\n        'comment': comment,\n        'interpolation': interpolation\n      }\n    }\n  });\n  Prism.languages.insertBefore('coffeescript', 'string', {\n    'inline-javascript': {\n      pattern: /`(?:\\\\[\\s\\S]|[^\\\\`])*`/,\n      inside: {\n        'delimiter': {\n          pattern: /^`|`$/,\n          alias: 'punctuation'\n        },\n        'script': {\n          pattern: /[\\s\\S]+/,\n          alias: 'language-javascript',\n          inside: Prism.languages.javascript\n        }\n      }\n    },\n    // Block strings\n    'multiline-string': [{\n      pattern: /'''[\\s\\S]*?'''/,\n      greedy: true,\n      alias: 'string'\n    }, {\n      pattern: /\"\"\"[\\s\\S]*?\"\"\"/,\n      greedy: true,\n      alias: 'string',\n      inside: {\n        interpolation: interpolation\n      }\n    }]\n  });\n  Prism.languages.insertBefore('coffeescript', 'keyword', {\n    // Object property\n    'property': /(?!\\d)\\w+(?=\\s*:(?!:))/\n  });\n  delete Prism.languages.coffeescript['template-string'];\n  Prism.languages.coffee = Prism.languages.coffeescript;\n})(prism);\n/* \"prismjs/components/prism-yaml\" */\n\n\n(function (Prism) {\n  // https://yaml.org/spec/1.2/spec.html#c-ns-anchor-property\n  // https://yaml.org/spec/1.2/spec.html#c-ns-alias-node\n  var anchorOrAlias = /[*&][^\\s[\\]{},]+/; // https://yaml.org/spec/1.2/spec.html#c-ns-tag-property\n\n  var tag = /!(?:<[\\w\\-%#;/?:@&=+$,.!~*'()[\\]]+>|(?:[a-zA-Z\\d-]*!)?[\\w\\-%#;/?:@&=+$.~*'()]+)?/; // https://yaml.org/spec/1.2/spec.html#c-ns-properties(n,c)\n\n  var properties = '(?:' + tag.source + '(?:[ \\t]+' + anchorOrAlias.source + ')?|' + anchorOrAlias.source + '(?:[ \\t]+' + tag.source + ')?)'; // https://yaml.org/spec/1.2/spec.html#ns-plain(n,c)\n  // This is a simplified version that doesn't support \"#\" and multiline keys\n  // All these long scarry character classes are simplified versions of YAML's characters\n\n  var plainKey = /(?:[^\\s\\x00-\\x08\\x0e-\\x1f!\"#%&'*,\\-:>?@[\\]`{|}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]|[?:-]<PLAIN>)(?:[ \\t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function () {\n    return /[^\\s\\x00-\\x08\\x0e-\\x1f,[\\]{}\\x7f-\\x84\\x86-\\x9f\\ud800-\\udfff\\ufffe\\uffff]/.source;\n  });\n  var string = /\"(?:[^\"\\\\\\r\\n]|\\\\.)*\"|'(?:[^'\\\\\\r\\n]|\\\\.)*'/.source;\n  /**\n   *\n   * @param {string} value\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */\n\n  function createValuePattern(value, flags) {\n    flags = (flags || '').replace(/m/g, '') + 'm'; // add m flag\n\n    var pattern = /([:\\-,[{]\\s*(?:\\s<<prop>>[ \\t]+)?)(?:<<value>>)(?=[ \\t]*(?:$|,|\\]|\\}|(?:[\\r\\n]\\s*)?#))/.source.replace(/<<prop>>/g, function () {\n      return properties;\n    }).replace(/<<value>>/g, function () {\n      return value;\n    });\n    return RegExp(pattern, flags);\n  }\n\n  Prism.languages.yaml = {\n    'scalar': {\n      pattern: RegExp(/([\\-:]\\s*(?:\\s<<prop>>[ \\t]+)?[|>])[ \\t]*(?:((?:\\r?\\n|\\r)[ \\t]+)\\S[^\\r\\n]*(?:\\2[^\\r\\n]+)*)/.source.replace(/<<prop>>/g, function () {\n        return properties;\n      })),\n      lookbehind: true,\n      alias: 'string'\n    },\n    'comment': /#.*/,\n    'key': {\n      pattern: RegExp(/((?:^|[:\\-,[{\\r\\n?])[ \\t]*(?:<<prop>>[ \\t]+)?)<<key>>(?=\\s*:\\s)/.source.replace(/<<prop>>/g, function () {\n        return properties;\n      }).replace(/<<key>>/g, function () {\n        return '(?:' + plainKey + '|' + string + ')';\n      })),\n      lookbehind: true,\n      greedy: true,\n      alias: 'atrule'\n    },\n    'directive': {\n      pattern: /(^[ \\t]*)%.+/m,\n      lookbehind: true,\n      alias: 'important'\n    },\n    'datetime': {\n      pattern: createValuePattern(/\\d{4}-\\d\\d?-\\d\\d?(?:[tT]|[ \\t]+)\\d\\d?:\\d{2}:\\d{2}(?:\\.\\d*)?(?:[ \\t]*(?:Z|[-+]\\d\\d?(?::\\d{2})?))?|\\d{4}-\\d{2}-\\d{2}|\\d\\d?:\\d{2}(?::\\d{2}(?:\\.\\d*)?)?/.source),\n      lookbehind: true,\n      alias: 'number'\n    },\n    'boolean': {\n      pattern: createValuePattern(/false|true/.source, 'i'),\n      lookbehind: true,\n      alias: 'important'\n    },\n    'null': {\n      pattern: createValuePattern(/null|~/.source, 'i'),\n      lookbehind: true,\n      alias: 'important'\n    },\n    'string': {\n      pattern: createValuePattern(string),\n      lookbehind: true,\n      greedy: true\n    },\n    'number': {\n      pattern: createValuePattern(/[+-]?(?:0x[\\da-f]+|0o[0-7]+|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?|\\.inf|\\.nan)/.source, 'i'),\n      lookbehind: true\n    },\n    'tag': tag,\n    'important': anchorOrAlias,\n    'punctuation': /---|[:[\\]{}\\-,|>?]|\\.\\.\\./\n  };\n  Prism.languages.yml = Prism.languages.yaml;\n})(prism);\n/* \"prismjs/components/prism-markdown\" */\n\n\n(function (Prism) {\n  // Allow only one line break\n  var inner = /(?:\\\\.|[^\\\\\\n\\r]|(?:\\n|\\r\\n?)(?![\\r\\n]))/.source;\n  /**\n   * This function is intended for the creation of the bold or italic pattern.\n   *\n   * This also adds a lookbehind group to the given pattern to ensure that the pattern is not backslash-escaped.\n   *\n   * _Note:_ Keep in mind that this adds a capturing group.\n   *\n   * @param {string} pattern\n   * @returns {RegExp}\n   */\n\n  function createInline(pattern) {\n    pattern = pattern.replace(/<inner>/g, function () {\n      return inner;\n    });\n    return RegExp(/((?:^|[^\\\\])(?:\\\\{2})*)/.source + '(?:' + pattern + ')');\n  }\n\n  var tableCell = /(?:\\\\.|``(?:[^`\\r\\n]|`(?!`))+``|`[^`\\r\\n]+`|[^\\\\|\\r\\n`])+/.source;\n  var tableRow = /\\|?__(?:\\|__)+\\|?(?:(?:\\n|\\r\\n?)|(?![\\s\\S]))/.source.replace(/__/g, function () {\n    return tableCell;\n  });\n  var tableLine = /\\|?[ \\t]*:?-{3,}:?[ \\t]*(?:\\|[ \\t]*:?-{3,}:?[ \\t]*)+\\|?(?:\\n|\\r\\n?)/.source;\n  Prism.languages.markdown = Prism.languages.extend('markup', {});\n  Prism.languages.insertBefore('markdown', 'prolog', {\n    'front-matter-block': {\n      pattern: /(^(?:\\s*[\\r\\n])?)---(?!.)[\\s\\S]*?[\\r\\n]---(?!.)/,\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'punctuation': /^---|---$/,\n        'front-matter': {\n          pattern: /\\S+(?:\\s+\\S+)*/,\n          alias: ['yaml', 'language-yaml'],\n          inside: Prism.languages.yaml\n        }\n      }\n    },\n    'blockquote': {\n      // > ...\n      pattern: /^>(?:[\\t ]*>)*/m,\n      alias: 'punctuation'\n    },\n    'table': {\n      pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),\n      inside: {\n        'table-data-rows': {\n          pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),\n          lookbehind: true,\n          inside: {\n            'table-data': {\n              pattern: RegExp(tableCell),\n              inside: Prism.languages.markdown\n            },\n            'punctuation': /\\|/\n          }\n        },\n        'table-line': {\n          pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),\n          lookbehind: true,\n          inside: {\n            'punctuation': /\\||:?-{3,}:?/\n          }\n        },\n        'table-header-row': {\n          pattern: RegExp('^' + tableRow + '$'),\n          inside: {\n            'table-header': {\n              pattern: RegExp(tableCell),\n              alias: 'important',\n              inside: Prism.languages.markdown\n            },\n            'punctuation': /\\|/\n          }\n        }\n      }\n    },\n    'code': [{\n      // Prefixed by 4 spaces or 1 tab and preceded by an empty line\n      pattern: /((?:^|\\n)[ \\t]*\\n|(?:^|\\r\\n?)[ \\t]*\\r\\n?)(?: {4}|\\t).+(?:(?:\\n|\\r\\n?)(?: {4}|\\t).+)*/,\n      lookbehind: true,\n      alias: 'keyword'\n    }, {\n      // ```optional language\n      // code block\n      // ```\n      pattern: /^```[\\s\\S]*?^```$/m,\n      greedy: true,\n      inside: {\n        'code-block': {\n          pattern: /^(```.*(?:\\n|\\r\\n?))[\\s\\S]+?(?=(?:\\n|\\r\\n?)^```$)/m,\n          lookbehind: true\n        },\n        'code-language': {\n          pattern: /^(```).+/,\n          lookbehind: true\n        },\n        'punctuation': /```/\n      }\n    }],\n    'title': [{\n      // title 1\n      // =======\n      // title 2\n      // -------\n      pattern: /\\S.*(?:\\n|\\r\\n?)(?:==+|--+)(?=[ \\t]*$)/m,\n      alias: 'important',\n      inside: {\n        punctuation: /==+$|--+$/\n      }\n    }, {\n      // # title 1\n      // ###### title 6\n      pattern: /(^\\s*)#.+/m,\n      lookbehind: true,\n      alias: 'important',\n      inside: {\n        punctuation: /^#+|#+$/\n      }\n    }],\n    'hr': {\n      // ***\n      // ---\n      // * * *\n      // -----------\n      pattern: /(^\\s*)([*-])(?:[\\t ]*\\2){2,}(?=\\s*$)/m,\n      lookbehind: true,\n      alias: 'punctuation'\n    },\n    'list': {\n      // * item\n      // + item\n      // - item\n      // 1. item\n      pattern: /(^\\s*)(?:[*+-]|\\d+\\.)(?=[\\t ].)/m,\n      lookbehind: true,\n      alias: 'punctuation'\n    },\n    'url-reference': {\n      // [id]: http://example.com \"Optional title\"\n      // [id]: http://example.com 'Optional title'\n      // [id]: http://example.com (Optional title)\n      // [id]: <http://example.com> \"Optional title\"\n      pattern: /!?\\[[^\\]]+\\]:[\\t ]+(?:\\S+|<(?:\\\\.|[^>\\\\])+>)(?:[\\t ]+(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\)))?/,\n      inside: {\n        'variable': {\n          pattern: /^(!?\\[)[^\\]]+/,\n          lookbehind: true\n        },\n        'string': /(?:\"(?:\\\\.|[^\"\\\\])*\"|'(?:\\\\.|[^'\\\\])*'|\\((?:\\\\.|[^)\\\\])*\\))$/,\n        'punctuation': /^[\\[\\]!:]|[<>]/\n      },\n      alias: 'url'\n    },\n    'bold': {\n      // **strong**\n      // __strong__\n      // allow one nested instance of italic text using the same delimiter\n      pattern: createInline(/\\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\\b|\\*\\*(?:(?!\\*)<inner>|\\*(?:(?!\\*)<inner>)+\\*)+\\*\\*/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'content': {\n          pattern: /(^..)[\\s\\S]+(?=..$)/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'punctuation': /\\*\\*|__/\n      }\n    },\n    'italic': {\n      // *em*\n      // _em_\n      // allow one nested instance of bold text using the same delimiter\n      pattern: createInline(/\\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\\b|\\*(?:(?!\\*)<inner>|\\*\\*(?:(?!\\*)<inner>)+\\*\\*)+\\*/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'content': {\n          pattern: /(^.)[\\s\\S]+(?=.$)/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'punctuation': /[*_]/\n      }\n    },\n    'strike': {\n      // ~~strike through~~\n      // ~strike~\n      // eslint-disable-next-line regexp/strict\n      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\\2/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'content': {\n          pattern: /(^~~?)[\\s\\S]+(?=\\1$)/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'punctuation': /~~?/\n      }\n    },\n    'code-snippet': {\n      // `code`\n      // ``code``\n      pattern: /(^|[^\\\\`])(?:``[^`\\r\\n]+(?:`[^`\\r\\n]+)*``(?!`)|`[^`\\r\\n]+`(?!`))/,\n      lookbehind: true,\n      greedy: true,\n      alias: ['code', 'keyword']\n    },\n    'url': {\n      // [example](http://example.com \"Optional title\")\n      // [example][id]\n      // [example] [id]\n      pattern: createInline(/!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\\t ]+\"(?:\\\\.|[^\"\\\\])*\")?\\)|[ \\t]?\\[(?:(?!\\])<inner>)+\\])/.source),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'operator': /^!/,\n        'content': {\n          pattern: /(^\\[)[^\\]]+(?=\\])/,\n          lookbehind: true,\n          inside: {} // see below\n\n        },\n        'variable': {\n          pattern: /(^\\][ \\t]?\\[)[^\\]]+(?=\\]$)/,\n          lookbehind: true\n        },\n        'url': {\n          pattern: /(^\\]\\()[^\\s)]+/,\n          lookbehind: true\n        },\n        'string': {\n          pattern: /(^[ \\t]+)\"(?:\\\\.|[^\"\\\\])*\"(?=\\)$)/,\n          lookbehind: true\n        }\n      }\n    }\n  });\n  ['url', 'bold', 'italic', 'strike'].forEach(function (token) {\n    ['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {\n      if (token !== inside) {\n        Prism.languages.markdown[token].inside.content.inside[inside] = Prism.languages.markdown[inside];\n      }\n    });\n  });\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'markdown' && env.language !== 'md') {\n      return;\n    }\n\n    function walkTokens(tokens) {\n      if (!tokens || typeof tokens === 'string') {\n        return;\n      }\n\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (token.type !== 'code') {\n          walkTokens(token.content);\n          continue;\n        }\n        /*\n         * Add the correct `language-xxxx` class to this code block. Keep in mind that the `code-language` token\n         * is optional. But the grammar is defined so that there is only one case we have to handle:\n         *\n         * token.content = [\n         *     <span class=\"punctuation\">```</span>,\n         *     <span class=\"code-language\">xxxx</span>,\n         *     '\\n', // exactly one new lines (\\r or \\n or \\r\\n)\n         *     <span class=\"code-block\">...</span>,\n         *     '\\n', // exactly one new lines again\n         *     <span class=\"punctuation\">```</span>\n         * ];\n         */\n\n\n        var codeLang = token.content[1];\n        var codeBlock = token.content[3];\n\n        if (codeLang && codeBlock && codeLang.type === 'code-language' && codeBlock.type === 'code-block' && typeof codeLang.content === 'string') {\n          // this might be a language that Prism does not support\n          // do some replacements to support C++, C#, and F#\n          var lang = codeLang.content.replace(/\\b#/g, 'sharp').replace(/\\b\\+\\+/g, 'pp'); // only use the first word\n\n          lang = (/[a-z][\\w-]*/i.exec(lang) || [''])[0].toLowerCase();\n          var alias = 'language-' + lang; // add alias\n\n          if (!codeBlock.alias) {\n            codeBlock.alias = [alias];\n          } else if (typeof codeBlock.alias === 'string') {\n            codeBlock.alias = [codeBlock.alias, alias];\n          } else {\n            codeBlock.alias.push(alias);\n          }\n        }\n      }\n    }\n\n    walkTokens(env.tokens);\n  });\n  Prism.hooks.add('wrap', function (env) {\n    if (env.type !== 'code-block') {\n      return;\n    }\n\n    var codeLang = '';\n\n    for (var i = 0, l = env.classes.length; i < l; i++) {\n      var cls = env.classes[i];\n      var match = /language-(.+)/.exec(cls);\n\n      if (match) {\n        codeLang = match[1];\n        break;\n      }\n    }\n\n    var grammar = Prism.languages[codeLang];\n\n    if (!grammar) {\n      if (codeLang && codeLang !== 'none' && Prism.plugins.autoloader) {\n        var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);\n        env.attributes['id'] = id;\n        Prism.plugins.autoloader.loadLanguages(codeLang, function () {\n          var ele = document.getElementById(id);\n\n          if (ele) {\n            ele.innerHTML = Prism.highlight(ele.textContent, Prism.languages[codeLang], codeLang);\n          }\n        });\n      }\n    } else {\n      env.content = Prism.highlight(textContent(env.content), grammar, codeLang);\n    }\n  });\n  var tagPattern = RegExp(Prism.languages.markup.tag.pattern.source, 'gi');\n  /**\n   * A list of known entity names.\n   *\n   * This will always be incomplete to save space. The current list is the one used by lowdash's unescape function.\n   *\n   * @see {@link https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/unescape.js#L2}\n   */\n\n  var KNOWN_ENTITY_NAMES = {\n    'amp': '&',\n    'lt': '<',\n    'gt': '>',\n    'quot': '\"'\n  }; // IE 11 doesn't support `String.fromCodePoint`\n\n  var fromCodePoint = String.fromCodePoint || String.fromCharCode;\n  /**\n   * Returns the text content of a given HTML source code string.\n   *\n   * @param {string} html\n   * @returns {string}\n   */\n\n  function textContent(html) {\n    // remove all tags\n    var text = html.replace(tagPattern, ''); // decode known entities\n\n    text = text.replace(/&(\\w{1,8}|#x?[\\da-f]{1,8});/gi, function (m, code) {\n      code = code.toLowerCase();\n\n      if (code[0] === '#') {\n        var value;\n\n        if (code[1] === 'x') {\n          value = parseInt(code.slice(2), 16);\n        } else {\n          value = Number(code.slice(1));\n        }\n\n        return fromCodePoint(value);\n      } else {\n        var known = KNOWN_ENTITY_NAMES[code];\n\n        if (known) {\n          return known;\n        } // unable to decode\n\n\n        return m;\n      }\n    });\n    return text;\n  }\n\n  Prism.languages.md = Prism.languages.markdown;\n})(prism);\n/* \"prismjs/components/prism-graphql\" */\n\n\nprism.languages.graphql = {\n  'comment': /#.*/,\n  'description': {\n    pattern: /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\n    greedy: true,\n    alias: 'string',\n    inside: {\n      'language-markdown': {\n        pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\n        lookbehind: true,\n        inside: prism.languages.markdown\n      }\n    }\n  },\n  'string': {\n    pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\n    greedy: true\n  },\n  'number': /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'boolean': /\\b(?:false|true)\\b/,\n  'variable': /\\$[a-z_]\\w*/i,\n  'directive': {\n    pattern: /@[a-z_]\\w*/i,\n    alias: 'function'\n  },\n  'attr-name': {\n    pattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\n    greedy: true\n  },\n  'atom-input': {\n    pattern: /\\b[A-Z]\\w*Input\\b/,\n    alias: 'class-name'\n  },\n  'scalar': /\\b(?:Boolean|Float|ID|Int|String)\\b/,\n  'constant': /\\b[A-Z][A-Z_\\d]*\\b/,\n  'class-name': {\n    pattern: /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\n    lookbehind: true\n  },\n  'fragment': {\n    pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-mutation': {\n    pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'definition-query': {\n    pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\n    lookbehind: true,\n    alias: 'function'\n  },\n  'keyword': /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\n  'operator': /[!=|&]|\\.{3}/,\n  'property-query': /\\w+(?=\\s*\\()/,\n  'object': /\\w+(?=\\s*\\{)/,\n  'punctuation': /[!(){}\\[\\]:=,]/,\n  'property': /\\w+/\n};\nprism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\n  if (env.language !== 'graphql') {\n    return;\n  }\n  /**\n   * get the graphql token stream that we want to customize\n   *\n   * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n   * @type {Token[]}\n   */\n\n\n  var validTokens = env.tokens.filter(function (token) {\n    return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';\n  });\n  var currentIndex = 0;\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {number} offset\n   * @returns {Token | undefined}\n   */\n\n  function getToken(offset) {\n    return validTokens[currentIndex + offset];\n  }\n  /**\n   * Returns whether the token relative to the current index has the given type.\n   *\n   * @param {readonly string[]} types\n   * @param {number} [offset=0]\n   * @returns {boolean}\n   */\n\n\n  function isTokenType(types, offset) {\n    offset = offset || 0;\n\n    for (var i = 0; i < types.length; i++) {\n      var token = getToken(i + offset);\n\n      if (!token || token.type !== types[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Returns the index of the closing bracket to an opening bracket.\n   *\n   * It is assumed that `token[currentIndex - 1]` is an opening bracket.\n   *\n   * If no closing bracket could be found, `-1` will be returned.\n   *\n   * @param {RegExp} open\n   * @param {RegExp} close\n   * @returns {number}\n   */\n\n\n  function findClosingBracket(open, close) {\n    var stackHeight = 1;\n\n    for (var i = currentIndex; i < validTokens.length; i++) {\n      var token = validTokens[i];\n      var content = token.content;\n\n      if (token.type === 'punctuation' && typeof content === 'string') {\n        if (open.test(content)) {\n          stackHeight++;\n        } else if (close.test(content)) {\n          stackHeight--;\n\n          if (stackHeight === 0) {\n            return i;\n          }\n        }\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Adds an alias to the given token.\n   *\n   * @param {Token} token\n   * @param {string} alias\n   * @returns {void}\n   */\n\n\n  function addAlias(token, alias) {\n    var aliases = token.alias;\n\n    if (!aliases) {\n      token.alias = aliases = [];\n    } else if (!Array.isArray(aliases)) {\n      token.alias = aliases = [aliases];\n    }\n\n    aliases.push(alias);\n  }\n\n  for (; currentIndex < validTokens.length;) {\n    var startToken = validTokens[currentIndex++]; // add special aliases for mutation tokens\n\n    if (startToken.type === 'keyword' && startToken.content === 'mutation') {\n      // any array of the names of all input variables (if any)\n      var inputVariables = [];\n\n      if (isTokenType(['definition-mutation', 'punctuation']) && getToken(1).content === '(') {\n        // definition\n        currentIndex += 2; // skip 'definition-mutation' and 'punctuation'\n\n        var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/);\n\n        if (definitionEnd === -1) {\n          continue;\n        } // find all input variables\n\n\n        for (; currentIndex < definitionEnd; currentIndex++) {\n          var t = getToken(0);\n\n          if (t.type === 'variable') {\n            addAlias(t, 'variable-input');\n            inputVariables.push(t.content);\n          }\n        }\n\n        currentIndex = definitionEnd + 1;\n      }\n\n      if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {\n        currentIndex++; // skip opening bracket\n\n        addAlias(getToken(0), 'property-mutation');\n\n        if (inputVariables.length > 0) {\n          var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/);\n\n          if (mutationEnd === -1) {\n            continue;\n          } // give references to input variables a special alias\n\n\n          for (var i = currentIndex; i < mutationEnd; i++) {\n            var varToken = validTokens[i];\n\n            if (varToken.type === 'variable' && inputVariables.indexOf(varToken.content) >= 0) {\n              addAlias(varToken, 'variable-input');\n            }\n          }\n        }\n      }\n    }\n  }\n});\n/* \"prismjs/components/prism-sql\" */\n\nprism.languages.sql = {\n  'comment': {\n    pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|(?:--|\\/\\/|#).*)/,\n    lookbehind: true\n  },\n  'variable': [{\n    pattern: /@([\"'`])(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1/,\n    greedy: true\n  }, /@[\\w.$]+/],\n  'string': {\n    pattern: /(^|[^@\\\\])(\"|')(?:\\\\[\\s\\S]|(?!\\2)[^\\\\]|\\2\\2)*\\2/,\n    greedy: true,\n    lookbehind: true\n  },\n  'identifier': {\n    pattern: /(^|[^@\\\\])`(?:\\\\[\\s\\S]|[^`\\\\]|``)*`/,\n    greedy: true,\n    lookbehind: true,\n    inside: {\n      'punctuation': /^`|`$/\n    }\n  },\n  'function': /\\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\\s*\\()/i,\n  // Should we highlight user defined functions too?\n  'keyword': /\\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\\b/i,\n  'boolean': /\\b(?:FALSE|NULL|TRUE)\\b/i,\n  'number': /\\b0x[\\da-f]+\\b|\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+\\b/i,\n  'operator': /[-+*\\/=%^~]|&&?|\\|\\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\\b/i,\n  'punctuation': /[;[\\]()`,.]/\n};\n/* \"prismjs/components/prism-js-templates\" */\n\n(function (Prism) {\n  var templateString = Prism.languages.javascript['template-string']; // see the pattern in prism-javascript.js\n\n  var templateLiteralPattern = templateString.pattern.source;\n  var interpolationObject = templateString.inside['interpolation'];\n  var interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];\n  var interpolationPattern = interpolationObject.pattern.source;\n  /**\n   * Creates a new pattern to match a template string with a special tag.\n   *\n   * This will return `undefined` if there is no grammar with the given language id.\n   *\n   * @param {string} language The language id of the embedded language. E.g. `markdown`.\n   * @param {string} tag The regex pattern to match the tag.\n   * @returns {object | undefined}\n   * @example\n   * createTemplate('css', /\\bcss/.source);\n   */\n\n  function createTemplate(language, tag) {\n    if (!Prism.languages[language]) {\n      return undefined;\n    }\n\n    return {\n      pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        'template-punctuation': {\n          pattern: /^`|`$/,\n          alias: 'string'\n        },\n        'embedded-code': {\n          pattern: /[\\s\\S]+/,\n          alias: language\n        }\n      }\n    };\n  }\n\n  Prism.languages.javascript['template-string'] = [// styled-jsx:\n  //   css`a { color: #25F; }`\n  // styled-components:\n  //   styled.h1`color: red;`\n  createTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), // html`<p></p>`\n  // div.innerHTML = `<p></p>`\n  createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source), // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n  createTemplate('svg', /\\bsvg/.source), // md`# h1`, markdown`## h2`\n  createTemplate('markdown', /\\b(?:markdown|md)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\n  createTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source), // sql`...`\n  createTemplate('sql', /\\bsql/.source), // vanilla template string\n  templateString].filter(Boolean);\n  /**\n   * Returns a specific placeholder literal for the given language.\n   *\n   * @param {number} counter\n   * @param {string} language\n   * @returns {string}\n   */\n\n  function getPlaceholder(counter, language) {\n    return '___' + language.toUpperCase() + '_' + counter + '___';\n  }\n  /**\n   * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n   *\n   * @param {string} code\n   * @param {any} grammar\n   * @param {string} language\n   * @returns {(string|Token)[]}\n   */\n\n\n  function tokenizeWithHooks(code, grammar, language) {\n    var env = {\n      code: code,\n      grammar: grammar,\n      language: language\n    };\n    Prism.hooks.run('before-tokenize', env);\n    env.tokens = Prism.tokenize(env.code, env.grammar);\n    Prism.hooks.run('after-tokenize', env);\n    return env.tokens;\n  }\n  /**\n   * Returns the token of the given JavaScript interpolation expression.\n   *\n   * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n   * @returns {Token}\n   */\n\n\n  function tokenizeInterpolationExpression(expression) {\n    var tempGrammar = {};\n    tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;\n    /** @type {Array} */\n\n    var tokens = Prism.tokenize(expression, tempGrammar);\n\n    if (tokens.length === 3) {\n      /**\n       * The token array will look like this\n       * [\n       *     [\"interpolation-punctuation\", \"${\"]\n       *     \"...\" // JavaScript expression of the interpolation\n       *     [\"interpolation-punctuation\", \"}\"]\n       * ]\n       */\n      var args = [1, 1];\n      args.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));\n      tokens.splice.apply(tokens, args);\n    }\n\n    return new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);\n  }\n  /**\n   * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n   *\n   * This function has 3 phases:\n   *\n   * 1. Replace all JavaScript interpolation expression with a placeholder.\n   *    The placeholder will have the syntax of a identify of the target language.\n   * 2. Tokenize the code with placeholders.\n   * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n   *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n   *    tokenized as two tokens by the grammar of the embedded language.\n   *\n   * @param {string} code\n   * @param {object} grammar\n   * @param {string} language\n   * @returns {Token}\n   */\n\n\n  function tokenizeEmbedded(code, grammar, language) {\n    // 1. First filter out all interpolations\n    // because they might be escaped, we need a lookbehind, so we use Prism\n\n    /** @type {(Token|string)[]} */\n    var _tokens = Prism.tokenize(code, {\n      'interpolation': {\n        pattern: RegExp(interpolationPattern),\n        lookbehind: true\n      }\n    }); // replace all interpolations with a placeholder which is not in the code already\n\n\n    var placeholderCounter = 0;\n    /** @type {Object<string, string>} */\n\n    var placeholderMap = {};\n\n    var embeddedCode = _tokens.map(function (token) {\n      if (typeof token === 'string') {\n        return token;\n      } else {\n        var interpolationExpression = token.content;\n        var placeholder;\n\n        while (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) {\n          /* noop */\n        }\n\n        placeholderMap[placeholder] = interpolationExpression;\n        return placeholder;\n      }\n    }).join(''); // 2. Tokenize the embedded code\n\n\n    var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language); // 3. Re-insert the interpolation\n\n    var placeholders = Object.keys(placeholderMap);\n    placeholderCounter = 0;\n    /**\n     *\n     * @param {(Token|string)[]} tokens\n     * @returns {void}\n     */\n\n    function walkTokens(tokens) {\n      for (var i = 0; i < tokens.length; i++) {\n        if (placeholderCounter >= placeholders.length) {\n          return;\n        }\n\n        var token = tokens[i];\n\n        if (typeof token === 'string' || typeof token.content === 'string') {\n          var placeholder = placeholders[placeholderCounter];\n          var s = typeof token === 'string' ? token :\n          /** @type {string} */\n          token.content;\n          var index = s.indexOf(placeholder);\n\n          if (index !== -1) {\n            ++placeholderCounter;\n            var before = s.substring(0, index);\n            var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);\n            var after = s.substring(index + placeholder.length);\n            var replacement = [];\n\n            if (before) {\n              replacement.push(before);\n            }\n\n            replacement.push(middle);\n\n            if (after) {\n              var afterTokens = [after];\n              walkTokens(afterTokens);\n              replacement.push.apply(replacement, afterTokens);\n            }\n\n            if (typeof token === 'string') {\n              tokens.splice.apply(tokens, [i, 1].concat(replacement));\n              i += replacement.length - 1;\n            } else {\n              token.content = replacement;\n            }\n          }\n        } else {\n          var content = token.content;\n\n          if (Array.isArray(content)) {\n            walkTokens(content);\n          } else {\n            walkTokens([content]);\n          }\n        }\n      }\n    }\n\n    walkTokens(embeddedTokens);\n    return new Prism.Token(language, embeddedTokens, 'language-' + language, code);\n  }\n  /**\n   * The languages for which JS templating will handle tagged template literals.\n   *\n   * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n   */\n\n\n  var supportedLanguages = {\n    'javascript': true,\n    'js': true,\n    'typescript': true,\n    'ts': true,\n    'jsx': true,\n    'tsx': true\n  };\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (!(env.language in supportedLanguages)) {\n      return;\n    }\n    /**\n     * Finds and tokenizes all template strings with an embedded languages.\n     *\n     * @param {(Token | string)[]} tokens\n     * @returns {void}\n     */\n\n\n    function findTemplateStrings(tokens) {\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        var token = tokens[i];\n\n        if (typeof token === 'string') {\n          continue;\n        }\n\n        var content = token.content;\n\n        if (!Array.isArray(content)) {\n          if (typeof content !== 'string') {\n            findTemplateStrings([content]);\n          }\n\n          continue;\n        }\n\n        if (token.type === 'template-string') {\n          /**\n           * A JavaScript template-string token will look like this:\n           *\n           * [\"template-string\", [\n           *     [\"template-punctuation\", \"`\"],\n           *     (\n           *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n           *         or\n           *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n           *                                  It also has an alias which is the language of the embedded code.\n           *     ),\n           *     [\"template-punctuation\", \"`\"]\n           * ]]\n           */\n          var embedded = content[1];\n\n          if (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {\n            // get string content\n            var code = stringContent(embedded);\n            var alias = embedded.alias;\n            var language = Array.isArray(alias) ? alias[0] : alias;\n            var grammar = Prism.languages[language];\n\n            if (!grammar) {\n              // the embedded language isn't registered.\n              continue;\n            }\n\n            content[1] = tokenizeEmbedded(code, grammar, language);\n          }\n        } else {\n          findTemplateStrings(content);\n        }\n      }\n    }\n\n    findTemplateStrings(env.tokens);\n  });\n  /**\n   * Returns the string content of a token or token stream.\n   *\n   * @param {string | Token | (string | Token)[]} value\n   * @returns {string}\n   */\n\n  function stringContent(value) {\n    if (typeof value === 'string') {\n      return value;\n    } else if (Array.isArray(value)) {\n      return value.map(stringContent).join('');\n    } else {\n      return stringContent(value.content);\n    }\n  }\n})(prism);\n/* \"prismjs/components/prism-typescript\" */\n\n\n(function (Prism) {\n  Prism.languages.typescript = Prism.languages.extend('javascript', {\n    'class-name': {\n      pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n      lookbehind: true,\n      greedy: true,\n      inside: null // see below\n\n    },\n    'builtin': /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/\n  }); // The keywords TypeScript adds to JavaScript\n\n  Prism.languages.typescript.keyword.push(/\\b(?:abstract|declare|is|keyof|readonly|require)\\b/, // keywords that have to be followed by an identifier\n  /\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/, // This is for `import type *, {}`\n  /\\btype\\b(?=\\s*(?:[\\{*]|$))/); // doesn't work with TS because TS is too complex\n\n  delete Prism.languages.typescript['parameter'];\n  delete Prism.languages.typescript['literal-property']; // a version of typescript specifically for highlighting types\n\n  var typeInside = Prism.languages.extend('typescript', {});\n  delete typeInside['class-name'];\n  Prism.languages.typescript['class-name'].inside = typeInside;\n  Prism.languages.insertBefore('typescript', 'function', {\n    'decorator': {\n      pattern: /@[$\\w\\xA0-\\uFFFF]+/,\n      inside: {\n        'at': {\n          pattern: /^@/,\n          alias: 'operator'\n        },\n        'function': /^[\\s\\S]+/\n      }\n    },\n    'generic-function': {\n      // e.g. foo<T extends \"bar\" | \"baz\">( ...\n      pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n      greedy: true,\n      inside: {\n        'function': /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n        'generic': {\n          pattern: /<[\\s\\S]+/,\n          // everything after the first <\n          alias: 'class-name',\n          inside: typeInside\n        }\n      }\n    }\n  });\n  Prism.languages.ts = Prism.languages.typescript;\n})(prism);\n/* \"prismjs/components/prism-js-extras\" */\n\n\n(function (Prism) {\n  Prism.languages.insertBefore('javascript', 'function-variable', {\n    'method-variable': {\n      pattern: RegExp('(\\\\.\\\\s*)' + Prism.languages.javascript['function-variable'].pattern.source),\n      lookbehind: true,\n      alias: ['function-variable', 'method', 'function', 'property-access']\n    }\n  });\n  Prism.languages.insertBefore('javascript', 'function', {\n    'method': {\n      pattern: RegExp('(\\\\.\\\\s*)' + Prism.languages.javascript['function'].source),\n      lookbehind: true,\n      alias: ['function', 'property-access']\n    }\n  });\n  Prism.languages.insertBefore('javascript', 'constant', {\n    'known-class-name': [{\n      // standard built-ins\n      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\n      pattern: /\\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\\b/,\n      alias: 'class-name'\n    }, {\n      // errors\n      pattern: /\\b(?:[A-Z]\\w*)Error\\b/,\n      alias: 'class-name'\n    }]\n  });\n  /**\n   * Replaces the `<ID>` placeholder in the given pattern with a pattern for general JS identifiers.\n   *\n   * @param {string} source\n   * @param {string} [flags]\n   * @returns {RegExp}\n   */\n\n  function withId(source, flags) {\n    return RegExp(source.replace(/<ID>/g, function () {\n      return /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/.source;\n    }), flags);\n  }\n\n  Prism.languages.insertBefore('javascript', 'keyword', {\n    'imports': {\n      // https://tc39.es/ecma262/#sec-imports\n      pattern: withId(/(\\bimport\\b\\s*)(?:<ID>(?:\\s*,\\s*(?:\\*\\s*as\\s+<ID>|\\{[^{}]*\\}))?|\\*\\s*as\\s+<ID>|\\{[^{}]*\\})(?=\\s*\\bfrom\\b)/.source),\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    },\n    'exports': {\n      // https://tc39.es/ecma262/#sec-exports\n      pattern: withId(/(\\bexport\\b\\s*)(?:\\*(?:\\s*as\\s+<ID>)?(?=\\s*\\bfrom\\b)|\\{[^{}]*\\})/.source),\n      lookbehind: true,\n      inside: Prism.languages.javascript\n    }\n  });\n  Prism.languages.javascript['keyword'].unshift({\n    pattern: /\\b(?:as|default|export|from|import)\\b/,\n    alias: 'module'\n  }, {\n    pattern: /\\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\\b/,\n    alias: 'control-flow'\n  }, {\n    pattern: /\\bnull\\b/,\n    alias: ['null', 'nil']\n  }, {\n    pattern: /\\bundefined\\b/,\n    alias: 'nil'\n  });\n  Prism.languages.insertBefore('javascript', 'operator', {\n    'spread': {\n      pattern: /\\.{3}/,\n      alias: 'operator'\n    },\n    'arrow': {\n      pattern: /=>/,\n      alias: 'operator'\n    }\n  });\n  Prism.languages.insertBefore('javascript', 'punctuation', {\n    'property-access': {\n      pattern: withId(/(\\.\\s*)#?<ID>/.source),\n      lookbehind: true\n    },\n    'maybe-class-name': {\n      pattern: /(^|[^$\\w\\xA0-\\uFFFF])[A-Z][$\\w\\xA0-\\uFFFF]+/,\n      lookbehind: true\n    },\n    'dom': {\n      // this contains only a few commonly used DOM variables\n      pattern: /\\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\\b/,\n      alias: 'variable'\n    },\n    'console': {\n      pattern: /\\bconsole(?=\\s*\\.)/,\n      alias: 'class-name'\n    }\n  }); // add 'maybe-class-name' to tokens which might be a class name\n\n  var maybeClassNameTokens = ['function', 'function-variable', 'method', 'method-variable', 'property-access'];\n\n  for (var i = 0; i < maybeClassNameTokens.length; i++) {\n    var token = maybeClassNameTokens[i];\n    var value = Prism.languages.javascript[token]; // convert regex to object\n\n    if (Prism.util.type(value) === 'RegExp') {\n      value = Prism.languages.javascript[token] = {\n        pattern: value\n      };\n    } // keep in mind that we don't support arrays\n\n\n    var inside = value.inside || {};\n    value.inside = inside;\n    inside['maybe-class-name'] = /^[A-Z][\\s\\S]*/;\n  }\n})(prism);\n/* \"prismjs/components/prism-jsx\" */\n\n\n(function (Prism) {\n  var javascript = Prism.util.clone(Prism.languages.javascript);\n  var space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n  var braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n  var spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n  /**\n   * @param {string} source\n   * @param {string} [flags]\n   */\n\n  function re(source, flags) {\n    source = source.replace(/<S>/g, function () {\n      return space;\n    }).replace(/<BRACES>/g, function () {\n      return braces;\n    }).replace(/<SPREAD>/g, function () {\n      return spread;\n    });\n    return RegExp(source, flags);\n  }\n\n  spread = re(spread).source;\n  Prism.languages.jsx = Prism.languages.extend('markup', javascript);\n  Prism.languages.jsx.tag.pattern = re(/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/.source);\n  Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/;\n  Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/;\n  Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n  Prism.languages.jsx.tag.inside['comment'] = javascript['comment'];\n  Prism.languages.insertBefore('inside', 'attr-name', {\n    'spread': {\n      pattern: re(/<SPREAD>/.source),\n      inside: Prism.languages.jsx\n    }\n  }, Prism.languages.jsx.tag);\n  Prism.languages.insertBefore('inside', 'special-attr', {\n    'script': {\n      // Allow for two levels of nesting\n      pattern: re(/=<BRACES>/.source),\n      alias: 'language-javascript',\n      inside: {\n        'script-punctuation': {\n          pattern: /^=(?=\\{)/,\n          alias: 'punctuation'\n        },\n        rest: Prism.languages.jsx\n      }\n    }\n  }, Prism.languages.jsx.tag); // The following will handle plain text inside tags\n\n  var stringifyToken = function stringifyToken(token) {\n    if (!token) {\n      return '';\n    }\n\n    if (typeof token === 'string') {\n      return token;\n    }\n\n    if (typeof token.content === 'string') {\n      return token.content;\n    }\n\n    return token.content.map(stringifyToken).join('');\n  };\n\n  var walkTokens = function walkTokens(tokens) {\n    var openedTags = [];\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      var notTagNorBrace = false;\n\n      if (typeof token !== 'string') {\n        if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n          // We found a tag, now find its kind\n          if (token.content[0].content[0].content === '</') {\n            // Closing tag\n            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n              // Pop matching opening tag\n              openedTags.pop();\n            }\n          } else {\n            if (token.content[token.content.length - 1].content === '/>') ;else {\n              // Opening tag\n              openedTags.push({\n                tagName: stringifyToken(token.content[0].content[1]),\n                openedBraces: 0\n              });\n            }\n          }\n        } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {\n          // Here we might have entered a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces++;\n        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n          // Here we might have left a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces--;\n        } else {\n          notTagNorBrace = true;\n        }\n      }\n\n      if (notTagNorBrace || typeof token === 'string') {\n        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n          // Here we are inside a tag, and not inside a JSX context.\n          // That's plain text: drop any tokens matched.\n          var plainText = stringifyToken(token); // And merge text with adjacent text\n\n          if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n            plainText += stringifyToken(tokens[i + 1]);\n            tokens.splice(i + 1, 1);\n          }\n\n          if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n            plainText = stringifyToken(tokens[i - 1]) + plainText;\n            tokens.splice(i - 1, 1);\n            i--;\n          }\n\n          tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n        }\n      }\n\n      if (token.content && typeof token.content !== 'string') {\n        walkTokens(token.content);\n      }\n    }\n  };\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'jsx' && env.language !== 'tsx') {\n      return;\n    }\n\n    walkTokens(env.tokens);\n  });\n})(prism);\n/* \"prismjs/components/prism-diff\" */\n\n\n(function (Prism) {\n  Prism.languages.diff = {\n    'coord': [// Match all kinds of coord lines (prefixed by \"+++\", \"---\" or \"***\").\n    /^(?:\\*{3}|-{3}|\\+{3}).*$/m, // Match \"@@ ... @@\" coord lines in unified diff.\n    /^@@.*@@$/m, // Match coord lines in normal diff (starts with a number).\n    /^\\d.*$/m] // deleted, inserted, unchanged, diff\n\n  };\n  /**\n   * A map from the name of a block to its line prefix.\n   *\n   * @type {Object<string, string>}\n   */\n\n  var PREFIXES = {\n    'deleted-sign': '-',\n    'deleted-arrow': '<',\n    'inserted-sign': '+',\n    'inserted-arrow': '>',\n    'unchanged': ' ',\n    'diff': '!'\n  }; // add a token for each prefix\n\n  Object.keys(PREFIXES).forEach(function (name) {\n    var prefix = PREFIXES[name];\n    var alias = [];\n\n    if (!/^\\w+$/.test(name)) {\n      // \"deleted-sign\" -> \"deleted\"\n      alias.push(/\\w+/.exec(name)[0]);\n    }\n\n    if (name === 'diff') {\n      alias.push('bold');\n    }\n\n    Prism.languages.diff[name] = {\n      pattern: RegExp('^(?:[' + prefix + '].*(?:\\r\\n?|\\n|(?![\\\\s\\\\S])))+', 'm'),\n      alias: alias,\n      inside: {\n        'line': {\n          pattern: /(.)(?=[\\s\\S]).*(?:\\r\\n?|\\n)?/,\n          lookbehind: true\n        },\n        'prefix': {\n          pattern: /[\\s\\S]/,\n          alias: /\\w+/.exec(name)[0]\n        }\n      }\n    };\n  }); // make prefixes available to Diff plugin\n\n  Object.defineProperty(Prism.languages.diff, 'PREFIXES', {\n    value: PREFIXES\n  });\n})(prism);\n/* \"prismjs/components/prism-git\" */\n\n\nprism.languages.git = {\n  /*\n   * A simple one line comment like in a git status command\n   * For instance:\n   * $ git status\n   * # On branch infinite-scroll\n   * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,\n   * # and have 1 and 2 different commits each, respectively.\n   * nothing to commit (working directory clean)\n   */\n  'comment': /^#.*/m,\n\n  /*\n   * Regexp to match the changed lines in a git diff output. Check the example below.\n   */\n  'deleted': /^[-\u2013].*/m,\n  'inserted': /^\\+.*/m,\n\n  /*\n   * a string (double and simple quote)\n   */\n  'string': /(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\n  /*\n   * a git command. It starts with a random prompt finishing by a $, then \"git\" then some other parameters\n   * For instance:\n   * $ git add file.txt\n   */\n  'command': {\n    pattern: /^.*\\$ git .*$/m,\n    inside: {\n      /*\n       * A git command can contain a parameter starting by a single or a double dash followed by a string\n       * For instance:\n       * $ git diff --cached\n       * $ git log -p\n       */\n      'parameter': /\\s--?\\w+/\n    }\n  },\n\n  /*\n   * Coordinates displayed in a git diff command\n   * For instance:\n   * $ git diff\n   * diff --git file.txt file.txt\n   * index 6214953..1d54a52 100644\n   * --- file.txt\n   * +++ file.txt\n   * @@ -1 +1,2 @@\n   * -Here's my tetx file\n   * +Here's my text file\n   * +And this is the second line\n   */\n  'coord': /^@@.*@@$/m,\n\n  /*\n   * Match a \"commit [SHA1]\" line in a git log output.\n   * For instance:\n   * $ git log\n   * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09\n   * Author: lgiraudel\n   * Date:   Mon Feb 17 11:18:34 2014 +0100\n   *\n   *     Add of a new line\n   */\n  'commit-sha1': /^commit \\w{40}$/m\n};\n/* \"prismjs/components/prism-go\" */\n\nprism.languages.go = prism.languages.extend('clike', {\n  'string': {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\"\\\\\\r\\n])*\"|`[^`]*`/,\n    lookbehind: true,\n    greedy: true\n  },\n  'keyword': /\\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\\b/,\n  'boolean': /\\b(?:_|false|iota|nil|true)\\b/,\n  'number': [// binary and octal integers\n  /\\b0(?:b[01_]+|o[0-7_]+)i?\\b/i, // hexadecimal integers and floats\n  /\\b0x(?:[a-f\\d_]+(?:\\.[a-f\\d_]*)?|\\.[a-f\\d_]+)(?:p[+-]?\\d+(?:_\\d+)*)?i?(?!\\w)/i, // decimal integers and floats\n  /(?:\\b\\d[\\d_]*(?:\\.[\\d_]*)?|\\B\\.\\d[\\d_]*)(?:e[+-]?[\\d_]+)?i?(?!\\w)/i],\n  'operator': /[*\\/%^!=]=?|\\+[=+]?|-[=-]?|\\|[=|]?|&(?:=|&|\\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\\.\\.\\./,\n  'builtin': /\\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\\b/\n});\nprism.languages.insertBefore('go', 'string', {\n  'char': {\n    pattern: /'(?:\\\\.|[^'\\\\\\r\\n]){0,10}'/,\n    greedy: true\n  }\n});\ndelete prism.languages.go['class-name'];\n/* \"prismjs/components/prism-markup-templating\" */\n\n(function (Prism) {\n  /**\n   * Returns the placeholder for the given language id and index.\n   *\n   * @param {string} language\n   * @param {string|number} index\n   * @returns {string}\n   */\n  function getPlaceholder(language, index) {\n    return '___' + language.toUpperCase() + index + '___';\n  }\n\n  Object.defineProperties(Prism.languages['markup-templating'] = {}, {\n    buildPlaceholders: {\n      /**\n       * Tokenize all inline templating expressions matching `placeholderPattern`.\n       *\n       * If `replaceFilter` is provided, only matches of `placeholderPattern` for which `replaceFilter` returns\n       * `true` will be replaced.\n       *\n       * @param {object} env The environment of the `before-tokenize` hook.\n       * @param {string} language The language id.\n       * @param {RegExp} placeholderPattern The matches of this pattern will be replaced by placeholders.\n       * @param {(match: string) => boolean} [replaceFilter]\n       */\n      value: function value(env, language, placeholderPattern, replaceFilter) {\n        if (env.language !== language) {\n          return;\n        }\n\n        var tokenStack = env.tokenStack = [];\n        env.code = env.code.replace(placeholderPattern, function (match) {\n          if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n            return match;\n          }\n\n          var i = tokenStack.length;\n          var placeholder; // Check for existing strings\n\n          while (env.code.indexOf(placeholder = getPlaceholder(language, i)) !== -1) {\n            ++i;\n          } // Create a sparse array\n\n\n          tokenStack[i] = match;\n          return placeholder;\n        }); // Switch the grammar to markup\n\n        env.grammar = Prism.languages.markup;\n      }\n    },\n    tokenizePlaceholders: {\n      /**\n       * Replace placeholders with proper tokens after tokenizing.\n       *\n       * @param {object} env The environment of the `after-tokenize` hook.\n       * @param {string} language The language id.\n       */\n      value: function value(env, language) {\n        if (env.language !== language || !env.tokenStack) {\n          return;\n        } // Switch the grammar back\n\n\n        env.grammar = Prism.languages[language];\n        var j = 0;\n        var keys = Object.keys(env.tokenStack);\n\n        function walkTokens(tokens) {\n          for (var i = 0; i < tokens.length; i++) {\n            // all placeholders are replaced already\n            if (j >= keys.length) {\n              break;\n            }\n\n            var token = tokens[i];\n\n            if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n              var k = keys[j];\n              var t = env.tokenStack[k];\n              var s = typeof token === 'string' ? token : token.content;\n              var placeholder = getPlaceholder(language, k);\n              var index = s.indexOf(placeholder);\n\n              if (index > -1) {\n                ++j;\n                var before = s.substring(0, index);\n                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar), 'language-' + language, t);\n                var after = s.substring(index + placeholder.length);\n                var replacement = [];\n\n                if (before) {\n                  replacement.push.apply(replacement, walkTokens([before]));\n                }\n\n                replacement.push(middle);\n\n                if (after) {\n                  replacement.push.apply(replacement, walkTokens([after]));\n                }\n\n                if (typeof token === 'string') {\n                  tokens.splice.apply(tokens, [i, 1].concat(replacement));\n                } else {\n                  token.content = replacement;\n                }\n              }\n            } else if (token.content\n            /* && typeof token.content !== 'string' */\n            ) {\n              walkTokens(token.content);\n            }\n          }\n\n          return tokens;\n        }\n\n        walkTokens(env.tokens);\n      }\n    }\n  });\n})(prism);\n/* \"prismjs/components/prism-handlebars\" */\n\n\n(function (Prism) {\n  Prism.languages.handlebars = {\n    'comment': /\\{\\{![\\s\\S]*?\\}\\}/,\n    'delimiter': {\n      pattern: /^\\{\\{\\{?|\\}\\}\\}?$/,\n      alias: 'punctuation'\n    },\n    'string': /([\"'])(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    'number': /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee][+-]?\\d+)?/,\n    'boolean': /\\b(?:false|true)\\b/,\n    'block': {\n      pattern: /^(\\s*(?:~\\s*)?)[#\\/]\\S+?(?=\\s*(?:~\\s*)?$|\\s)/,\n      lookbehind: true,\n      alias: 'keyword'\n    },\n    'brackets': {\n      pattern: /\\[[^\\]]+\\]/,\n      inside: {\n        punctuation: /\\[|\\]/,\n        variable: /[\\s\\S]+/\n      }\n    },\n    'punctuation': /[!\"#%&':()*+,.\\/;<=>@\\[\\\\\\]^`{|}~]/,\n    'variable': /[^!\"#%&'()*+,\\/;<=>@\\[\\\\\\]^`{|}~\\s]+/\n  };\n  Prism.hooks.add('before-tokenize', function (env) {\n    var handlebarsPattern = /\\{\\{\\{[\\s\\S]+?\\}\\}\\}|\\{\\{[\\s\\S]+?\\}\\}/g;\n    Prism.languages['markup-templating'].buildPlaceholders(env, 'handlebars', handlebarsPattern);\n  });\n  Prism.hooks.add('after-tokenize', function (env) {\n    Prism.languages['markup-templating'].tokenizePlaceholders(env, 'handlebars');\n  });\n  Prism.languages.hbs = Prism.languages.handlebars;\n})(prism);\n/* \"prismjs/components/prism-json\" */\n// https://www.json.org/json-en.html\n\n\nprism.languages.json = {\n  'property': {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n    lookbehind: true,\n    greedy: true\n  },\n  'string': {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?!\\s*:)/,\n    lookbehind: true,\n    greedy: true\n  },\n  'comment': {\n    pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    greedy: true\n  },\n  'number': /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  'punctuation': /[{}[\\],]/,\n  'operator': /:/,\n  'boolean': /\\b(?:false|true)\\b/,\n  'null': {\n    pattern: /\\bnull\\b/,\n    alias: 'keyword'\n  }\n};\nprism.languages.webmanifest = prism.languages.json;\n/* \"prismjs/components/prism-less\" */\n\n/* FIXME :\n :extend() is not handled specifically : its highlighting is buggy.\n Mixin usage must be inside a ruleset to be highlighted.\n At-rules (e.g. import) containing interpolations are buggy.\n Detached rulesets are highlighted as at-rules.\n A comment before a mixin usage prevents the latter to be properly highlighted.\n */\n\nprism.languages.less = prism.languages.extend('css', {\n  'comment': [/\\/\\*[\\s\\S]*?\\*\\//, {\n    pattern: /(^|[^\\\\])\\/\\/.*/,\n    lookbehind: true\n  }],\n  'atrule': {\n    pattern: /@[\\w-](?:\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n    inside: {\n      'punctuation': /[:()]/\n    }\n  },\n  // selectors and mixins are considered the same\n  'selector': {\n    pattern: /(?:@\\{[\\w-]+\\}|[^{};\\s@])(?:@\\{[\\w-]+\\}|\\((?:[^(){}]|\\([^(){}]*\\))*\\)|[^(){};@\\s]|\\s+(?!\\s))*?(?=\\s*\\{)/,\n    inside: {\n      // mixin parameters\n      'variable': /@+[\\w-]+/\n    }\n  },\n  'property': /(?:@\\{[\\w-]+\\}|[\\w-])+(?:\\+_?)?(?=\\s*:)/,\n  'operator': /[+\\-*\\/]/\n});\nprism.languages.insertBefore('less', 'property', {\n  'variable': [// Variable declaration (the colon must be consumed!)\n  {\n    pattern: /@[\\w-]+\\s*:/,\n    inside: {\n      'punctuation': /:/\n    }\n  }, // Variable usage\n  /@@?[\\w-]+/],\n  'mixin-usage': {\n    pattern: /([{;]\\s*)[.#](?!\\d)[\\w-].*?(?=[(;])/,\n    lookbehind: true,\n    alias: 'function'\n  }\n});\n/* \"prismjs/components/prism-makefile\" */\n\nprism.languages.makefile = {\n  'comment': {\n    pattern: /(^|[^\\\\])#(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n])*/,\n    lookbehind: true\n  },\n  'string': {\n    pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n    greedy: true\n  },\n  'builtin-target': {\n    pattern: /\\.[A-Z][^:#=\\s]+(?=\\s*:(?!=))/,\n    alias: 'builtin'\n  },\n  'target': {\n    pattern: /^(?:[^:=\\s]|[ \\t]+(?![\\s:]))+(?=\\s*:(?!=))/m,\n    alias: 'symbol',\n    inside: {\n      'variable': /\\$+(?:(?!\\$)[^(){}:#=\\s]+|(?=[({]))/\n    }\n  },\n  'variable': /\\$+(?:(?!\\$)[^(){}:#=\\s]+|\\([@*%<^+?][DF]\\)|(?=[({]))/,\n  // Directives\n  'keyword': /-include\\b|\\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\\b/,\n  'function': {\n    pattern: /(\\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \\t])/,\n    lookbehind: true\n  },\n  'operator': /(?:::|[?:+!])?=|[|@]/,\n  'punctuation': /[:;(){}]/\n};\n/* \"prismjs/components/prism-objectivec\" */\n\nprism.languages.objectivec = prism.languages.extend('c', {\n  'string': {\n    pattern: /@?\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"/,\n    greedy: true\n  },\n  'keyword': /\\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\\b/,\n  'operator': /-[->]?|\\+\\+?|!=?|<<?=?|>>?=?|==?|&&?|\\|\\|?|[~^%?*\\/@]/\n});\ndelete prism.languages.objectivec['class-name'];\nprism.languages.objc = prism.languages.objectivec;\n/* \"prismjs/components/prism-ocaml\" */\n// https://ocaml.org/manual/lex.html\n\nprism.languages.ocaml = {\n  'comment': {\n    pattern: /\\(\\*[\\s\\S]*?\\*\\)/,\n    greedy: true\n  },\n  'char': {\n    pattern: /'(?:[^\\\\\\r\\n']|\\\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,\n    greedy: true\n  },\n  'string': [{\n    pattern: /\"(?:\\\\(?:[\\s\\S]|\\r\\n)|[^\\\\\\r\\n\"])*\"/,\n    greedy: true\n  }, {\n    pattern: /\\{([a-z_]*)\\|[\\s\\S]*?\\|\\1\\}/,\n    greedy: true\n  }],\n  'number': [// binary and octal\n  /\\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\\b/i, // hexadecimal\n  /\\b0x[a-f0-9][a-f0-9_]*(?:\\.[a-f0-9_]*)?(?:p[+-]?\\d[\\d_]*)?(?!\\w)/i, // decimal\n  /\\b\\d[\\d_]*(?:\\.[\\d_]*)?(?:e[+-]?\\d[\\d_]*)?(?!\\w)/i],\n  'directive': {\n    pattern: /\\B#\\w+/,\n    alias: 'property'\n  },\n  'label': {\n    pattern: /\\B~\\w+/,\n    alias: 'property'\n  },\n  'type-variable': {\n    pattern: /\\B'\\w+/,\n    alias: 'function'\n  },\n  'variant': {\n    pattern: /`\\w+/,\n    alias: 'symbol'\n  },\n  // For the list of keywords and operators,\n  // see: http://caml.inria.fr/pub/docs/manual-ocaml/lex.html#sec84\n  'keyword': /\\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\\b/,\n  'boolean': /\\b(?:false|true)\\b/,\n  'operator-like-punctuation': {\n    pattern: /\\[[<>|]|[>|]\\]|\\{<|>\\}/,\n    alias: 'punctuation'\n  },\n  // Custom operators are allowed\n  'operator': /\\.[.~]|:[=>]|[=<>@^|&+\\-*\\/$%!?~][!$%&*+\\-.\\/:<=>?@^|~]*|\\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\\b/,\n  'punctuation': /;;|::|[(){}\\[\\].,:;#]|\\b_\\b/\n};\n/* \"prismjs/components/prism-python\" */\n\nprism.languages.python = {\n  'comment': {\n    pattern: /(^|[^\\\\])#.*/,\n    lookbehind: true,\n    greedy: true\n  },\n  'string-interpolation': {\n    pattern: /(?:f|fr|rf)(?:(\"\"\"|''')[\\s\\S]*?\\1|(\"|')(?:\\\\.|(?!\\2)[^\\\\\\r\\n])*\\2)/i,\n    greedy: true,\n    inside: {\n      'interpolation': {\n        // \"{\" <expression> <optional \"!s\", \"!r\", or \"!a\"> <optional \":\" format specifier> \"}\"\n        pattern: /((?:^|[^{])(?:\\{\\{)*)\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}]|\\{(?!\\{)(?:[^{}])+\\})+\\})+\\}/,\n        lookbehind: true,\n        inside: {\n          'format-spec': {\n            pattern: /(:)[^:(){}]+(?=\\}$)/,\n            lookbehind: true\n          },\n          'conversion-option': {\n            pattern: /![sra](?=[:}]$)/,\n            alias: 'punctuation'\n          },\n          rest: null\n        }\n      },\n      'string': /[\\s\\S]+/\n    }\n  },\n  'triple-quoted-string': {\n    pattern: /(?:[rub]|br|rb)?(\"\"\"|''')[\\s\\S]*?\\1/i,\n    greedy: true,\n    alias: 'string'\n  },\n  'string': {\n    pattern: /(?:[rub]|br|rb)?(\"|')(?:\\\\.|(?!\\1)[^\\\\\\r\\n])*\\1/i,\n    greedy: true\n  },\n  'function': {\n    pattern: /((?:^|\\s)def[ \\t]+)[a-zA-Z_]\\w*(?=\\s*\\()/g,\n    lookbehind: true\n  },\n  'class-name': {\n    pattern: /(\\bclass\\s+)\\w+/i,\n    lookbehind: true\n  },\n  'decorator': {\n    pattern: /(^[\\t ]*)@\\w+(?:\\.\\w+)*/m,\n    lookbehind: true,\n    alias: ['annotation', 'punctuation'],\n    inside: {\n      'punctuation': /\\./\n    }\n  },\n  'keyword': /\\b(?:_(?=\\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\\b/,\n  'builtin': /\\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\\b/,\n  'boolean': /\\b(?:False|None|True)\\b/,\n  'number': /\\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\\b|(?:\\b\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\B\\.\\d+(?:_\\d+)*)(?:e[+-]?\\d+(?:_\\d+)*)?j?(?!\\w)/i,\n  'operator': /[-+%=]=?|!=|:=|\\*\\*?=?|\\/\\/?=?|<[<=>]?|>[=>]?|[&|^~]/,\n  'punctuation': /[{}[\\];(),.:]/\n};\nprism.languages.python['string-interpolation'].inside['interpolation'].inside.rest = prism.languages.python;\nprism.languages.py = prism.languages.python;\n/* \"prismjs/components/prism-reason\" */\n\nprism.languages.reason = prism.languages.extend('clike', {\n  'string': {\n    pattern: /\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\\\\\\r\\n\"])*\"/,\n    greedy: true\n  },\n  // 'class-name' must be matched *after* 'constructor' defined below\n  'class-name': /\\b[A-Z]\\w*/,\n  'keyword': /\\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\\b/,\n  'operator': /\\.{3}|:[:=]|\\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\\-*\\/]\\.?|\\b(?:asr|land|lor|lsl|lsr|lxor|mod)\\b/\n});\nprism.languages.insertBefore('reason', 'class-name', {\n  'char': {\n    pattern: /'(?:\\\\x[\\da-f]{2}|\\\\o[0-3][0-7][0-7]|\\\\\\d{3}|\\\\.|[^'\\\\\\r\\n])'/,\n    greedy: true\n  },\n  // Negative look-ahead prevents from matching things like String.capitalize\n  'constructor': /\\b[A-Z]\\w*\\b(?!\\s*\\.)/,\n  'label': {\n    pattern: /\\b[a-z]\\w*(?=::)/,\n    alias: 'symbol'\n  }\n}); // We can't match functions property, so let's not even try.\n\ndelete prism.languages.reason[\"function\"];\n/* \"prismjs/components/prism-sass\" */\n\n(function (Prism) {\n  Prism.languages.sass = Prism.languages.extend('css', {\n    // Sass comments don't need to be closed, only indented\n    'comment': {\n      pattern: /^([ \\t]*)\\/[\\/*].*(?:(?:\\r?\\n|\\r)\\1[ \\t].+)*/m,\n      lookbehind: true,\n      greedy: true\n    }\n  });\n  Prism.languages.insertBefore('sass', 'atrule', {\n    // We want to consume the whole line\n    'atrule-line': {\n      // Includes support for = and + shortcuts\n      pattern: /^(?:[ \\t]*)[@+=].+/m,\n      greedy: true,\n      inside: {\n        'atrule': /(?:@[\\w-]+|[+=])/\n      }\n    }\n  });\n  delete Prism.languages.sass.atrule;\n  var variable = /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/;\n  var operator = [/[+*\\/%]|[=!]=|<=?|>=?|\\b(?:and|not|or)\\b/, {\n    pattern: /(\\s)-(?=\\s)/,\n    lookbehind: true\n  }];\n  Prism.languages.insertBefore('sass', 'property', {\n    // We want to consume the whole line\n    'variable-line': {\n      pattern: /^[ \\t]*\\$.+/m,\n      greedy: true,\n      inside: {\n        'punctuation': /:/,\n        'variable': variable,\n        'operator': operator\n      }\n    },\n    // We want to consume the whole line\n    'property-line': {\n      pattern: /^[ \\t]*(?:[^:\\s]+ *:.*|:[^:\\s].*)/m,\n      greedy: true,\n      inside: {\n        'property': [/[^:\\s]+(?=\\s*:)/, {\n          pattern: /(:)[^:\\s]+/,\n          lookbehind: true\n        }],\n        'punctuation': /:/,\n        'variable': variable,\n        'operator': operator,\n        'important': Prism.languages.sass.important\n      }\n    }\n  });\n  delete Prism.languages.sass.property;\n  delete Prism.languages.sass.important; // Now that whole lines for other patterns are consumed,\n  // what's left should be selectors\n\n  Prism.languages.insertBefore('sass', 'punctuation', {\n    'selector': {\n      pattern: /^([ \\t]*)\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*(?:,(?:\\r?\\n|\\r)\\1[ \\t]+\\S(?:,[^,\\r\\n]+|[^,\\r\\n]*)(?:,[^,\\r\\n]+)*)*/m,\n      lookbehind: true,\n      greedy: true\n    }\n  });\n})(prism);\n/* \"prismjs/components/prism-scss\" */\n\n\nprism.languages.scss = prism.languages.extend('css', {\n  'comment': {\n    pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n    lookbehind: true\n  },\n  'atrule': {\n    pattern: /@[\\w-](?:\\([^()]+\\)|[^()\\s]|\\s+(?!\\s))*?(?=\\s+[{;])/,\n    inside: {\n      'rule': /@[\\w-]+/ // See rest below\n\n    }\n  },\n  // url, compassified\n  'url': /(?:[-a-z]+-)?url(?=\\()/i,\n  // CSS selector regex is not appropriate for Sass\n  // since there can be lot more things (var, @ directive, nesting..)\n  // a selector must start at the end of a property or after a brace (end of other rules or nesting)\n  // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable\n  // the end of a selector is found when there is no rules in it ( {} or {\\s}) or if there is a property (because an interpolated var\n  // can \"pass\" as a selector- e.g: proper#{$erty})\n  // this one was hard to do, so please be careful if you edit this one :)\n  'selector': {\n    // Initial look-ahead is used to prevent matching of blank selectors\n    pattern: /(?=\\S)[^@;{}()]?(?:[^@;{}()\\s]|\\s+(?!\\s)|#\\{\\$[-\\w]+\\})+(?=\\s*\\{(?:\\}|\\s|[^}][^:{}]*[:{][^}]))/,\n    inside: {\n      'parent': {\n        pattern: /&/,\n        alias: 'important'\n      },\n      'placeholder': /%[-\\w]+/,\n      'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n    }\n  },\n  'property': {\n    pattern: /(?:[-\\w]|\\$[-\\w]|#\\{\\$[-\\w]+\\})+(?=\\s*:)/,\n    inside: {\n      'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n    }\n  }\n});\nprism.languages.insertBefore('scss', 'atrule', {\n  'keyword': [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\\b/i, {\n    pattern: /( )(?:from|through)(?= )/,\n    lookbehind: true\n  }]\n});\nprism.languages.insertBefore('scss', 'important', {\n  // var and interpolated vars\n  'variable': /\\$[-\\w]+|#\\{\\$[-\\w]+\\}/\n});\nprism.languages.insertBefore('scss', 'function', {\n  'module-modifier': {\n    pattern: /\\b(?:as|hide|show|with)\\b/i,\n    alias: 'keyword'\n  },\n  'placeholder': {\n    pattern: /%[-\\w]+/,\n    alias: 'selector'\n  },\n  'statement': {\n    pattern: /\\B!(?:default|optional)\\b/i,\n    alias: 'keyword'\n  },\n  'boolean': /\\b(?:false|true)\\b/,\n  'null': {\n    pattern: /\\bnull\\b/,\n    alias: 'keyword'\n  },\n  'operator': {\n    pattern: /(\\s)(?:[-+*\\/%]|[=!]=|<=?|>=?|and|not|or)(?=\\s)/,\n    lookbehind: true\n  }\n});\nprism.languages.scss['atrule'].inside.rest = prism.languages.scss;\n/* \"prismjs/components/prism-stylus\" */\n\n(function (Prism) {\n  var unit = {\n    pattern: /(\\b\\d+)(?:%|[a-z]+)/,\n    lookbehind: true\n  }; // 123 -123 .123 -.123 12.3 -12.3\n\n  var number = {\n    pattern: /(^|[^\\w.-])-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/,\n    lookbehind: true\n  };\n  var inside = {\n    'comment': {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n      lookbehind: true\n    },\n    'url': {\n      pattern: /\\burl\\(([\"']?).*?\\1\\)/i,\n      greedy: true\n    },\n    'string': {\n      pattern: /(\"|')(?:(?!\\1)[^\\\\\\r\\n]|\\\\(?:\\r\\n|[\\s\\S]))*\\1/,\n      greedy: true\n    },\n    'interpolation': null,\n    // See below\n    'func': null,\n    // See below\n    'important': /\\B!(?:important|optional)\\b/i,\n    'keyword': {\n      pattern: /(^|\\s+)(?:(?:else|for|if|return|unless)(?=\\s|$)|@[\\w-]+)/,\n      lookbehind: true\n    },\n    'hexcode': /#[\\da-f]{3,6}/i,\n    'color': [/\\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\\b/i, {\n      pattern: /\\b(?:hsl|rgb)\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*\\)\\B|\\b(?:hsl|rgb)a\\(\\s*\\d{1,3}\\s*,\\s*\\d{1,3}%?\\s*,\\s*\\d{1,3}%?\\s*,\\s*(?:0|0?\\.\\d+|1)\\s*\\)\\B/i,\n      inside: {\n        'unit': unit,\n        'number': number,\n        'function': /[\\w-]+(?=\\()/,\n        'punctuation': /[(),]/\n      }\n    }],\n    'entity': /\\\\[\\da-f]{1,8}/i,\n    'unit': unit,\n    'boolean': /\\b(?:false|true)\\b/,\n    'operator': [// We want non-word chars around \"-\" because it is\n    // accepted in property names.\n    /~|[+!\\/%<>?=]=?|[-:]=|\\*[*=]?|\\.{2,3}|&&|\\|\\||\\B-\\B|\\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\\b/],\n    'number': number,\n    'punctuation': /[{}()\\[\\];:,]/\n  };\n  inside['interpolation'] = {\n    pattern: /\\{[^\\r\\n}:]+\\}/,\n    alias: 'variable',\n    inside: {\n      'delimiter': {\n        pattern: /^\\{|\\}$/,\n        alias: 'punctuation'\n      },\n      rest: inside\n    }\n  };\n  inside['func'] = {\n    pattern: /[\\w-]+\\([^)]*\\).*/,\n    inside: {\n      'function': /^[^(]+/,\n      rest: inside\n    }\n  };\n  Prism.languages.stylus = {\n    'atrule-declaration': {\n      pattern: /(^[ \\t]*)@.+/m,\n      lookbehind: true,\n      inside: {\n        'atrule': /^@[\\w-]+/,\n        rest: inside\n      }\n    },\n    'variable-declaration': {\n      pattern: /(^[ \\t]*)[\\w$-]+\\s*.?=[ \\t]*(?:\\{[^{}]*\\}|\\S.*|$)/m,\n      lookbehind: true,\n      inside: {\n        'variable': /^\\S+/,\n        rest: inside\n      }\n    },\n    'statement': {\n      pattern: /(^[ \\t]*)(?:else|for|if|return|unless)[ \\t].+/m,\n      lookbehind: true,\n      inside: {\n        'keyword': /^\\S+/,\n        rest: inside\n      }\n    },\n    // A property/value pair cannot end with a comma or a brace\n    // It cannot have indented content unless it ended with a semicolon\n    'property-declaration': {\n      pattern: /((?:^|\\{)([ \\t]*))(?:[\\w-]|\\{[^}\\r\\n]+\\})+(?:\\s*:\\s*|[ \\t]+)(?!\\s)[^{\\r\\n]*(?:;|[^{\\r\\n,]$(?!(?:\\r?\\n|\\r)(?:\\{|\\2[ \\t])))/m,\n      lookbehind: true,\n      inside: {\n        'property': {\n          pattern: /^[^\\s:]+/,\n          inside: {\n            'interpolation': inside.interpolation\n          }\n        },\n        rest: inside\n      }\n    },\n    // A selector can contain parentheses only as part of a pseudo-element\n    // It can span multiple lines.\n    // It must end with a comma or an accolade or have indented content.\n    'selector': {\n      pattern: /(^[ \\t]*)(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\)|(?![\\w-]))|\\{[^}\\r\\n]+\\})+)(?:(?:\\r?\\n|\\r)(?:\\1(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\)|(?![\\w-]))|\\{[^}\\r\\n]+\\})+)))*(?:,$|\\{|(?=(?:\\r?\\n|\\r)(?:\\{|\\1[ \\t])))/m,\n      lookbehind: true,\n      inside: {\n        'interpolation': inside.interpolation,\n        'comment': inside.comment,\n        'punctuation': /[{},]/\n      }\n    },\n    'func': inside.func,\n    'string': inside.string,\n    'comment': {\n      pattern: /(^|[^\\\\])(?:\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n      lookbehind: true,\n      greedy: true\n    },\n    'interpolation': inside.interpolation,\n    'punctuation': /[{}()\\[\\];:.]/\n  };\n})(prism);\n/* \"prismjs/components/prism-tsx\" */\n\n\n(function (Prism) {\n  var typescript = Prism.util.clone(Prism.languages.typescript);\n  Prism.languages.tsx = Prism.languages.extend('jsx', typescript); // doesn't work with TS because TS is too complex\n\n  delete Prism.languages.tsx['parameter'];\n  delete Prism.languages.tsx['literal-property']; // This will prevent collisions between TSX tags and TS generic types.\n  // Idea by https://github.com/karlhorky\n  // Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n\n  var tag = Prism.languages.tsx.tag;\n  tag.pattern = RegExp(/(^|[^\\w$]|(?=<\\/))/.source + '(?:' + tag.pattern.source + ')', tag.pattern.flags);\n  tag.lookbehind = true;\n})(prism);\n/* \"prismjs/components/prism-wasm\" */\n\n\nprism.languages.wasm = {\n  'comment': [/\\(;[\\s\\S]*?;\\)/, {\n    pattern: /;;.*/,\n    greedy: true\n  }],\n  'string': {\n    pattern: /\"(?:\\\\[\\s\\S]|[^\"\\\\])*\"/,\n    greedy: true\n  },\n  'keyword': [{\n    pattern: /\\b(?:align|offset)=/,\n    inside: {\n      'operator': /=/\n    }\n  }, {\n    pattern: /\\b(?:(?:f32|f64|i32|i64)(?:\\.(?:abs|add|and|ceil|clz|const|convert_[su]\\/i(?:32|64)|copysign|ctz|demote\\/f64|div(?:_[su])?|eqz?|extend_[su]\\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\\/f32|reinterpret\\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\\/f(?:32|64))?|wrap\\/i64|xor))?|memory\\.(?:grow|size))\\b/,\n    inside: {\n      'punctuation': /\\./\n    }\n  }, /\\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\\b/],\n  'variable': /\\$[\\w!#$%&'*+\\-./:<=>?@\\\\^`|~]+/,\n  'number': /[+-]?\\b(?:\\d(?:_?\\d)*(?:\\.\\d(?:_?\\d)*)?(?:[eE][+-]?\\d(?:_?\\d)*)?|0x[\\da-fA-F](?:_?[\\da-fA-F])*(?:\\.[\\da-fA-F](?:_?[\\da-fA-D])*)?(?:[pP][+-]?\\d(?:_?\\d)*)?)\\b|\\binf\\b|\\bnan(?::0x[\\da-fA-F](?:_?[\\da-fA-D])*)?\\b/,\n  'punctuation': /[()]/\n};\n/* harmony default export */ var prism_react_renderer_prism = (prism);\n// CONCATENATED MODULE: ./node_modules/prism-react-renderer/themes/duotoneDark/index.js\n// Duotone Dark\n// Author: Simurai, adapted from DuoTone themes for Atom (http://simurai.com/projects/2016/01/01/duotone-themes)\n// Conversion: Bram de Haan (http://atelierbram.github.io/Base2Tone-prism/output/prism/prism-base2tone-evening-dark.css)\n// Generated with Base16 Builder (https://github.com/base16-builder/base16-builder)\nvar theme = {\n  plain: {\n    backgroundColor: \"#2a2734\",\n    color: \"#9a86fd\"\n  },\n  styles: [{\n    types: [\"comment\", \"prolog\", \"doctype\", \"cdata\", \"punctuation\"],\n    style: {\n      color: \"#6c6783\"\n    }\n  }, {\n    types: [\"namespace\"],\n    style: {\n      opacity: 0.7\n    }\n  }, {\n    types: [\"tag\", \"operator\", \"number\"],\n    style: {\n      color: \"#e09142\"\n    }\n  }, {\n    types: [\"property\", \"function\"],\n    style: {\n      color: \"#9a86fd\"\n    }\n  }, {\n    types: [\"tag-id\", \"selector\", \"atrule-id\"],\n    style: {\n      color: \"#eeebff\"\n    }\n  }, {\n    types: [\"attr-name\"],\n    style: {\n      color: \"#c4b9fe\"\n    }\n  }, {\n    types: [\"boolean\", \"string\", \"entity\", \"url\", \"attr-value\", \"keyword\", \"control\", \"directive\", \"unit\", \"statement\", \"regex\", \"atrule\", \"placeholder\", \"variable\"],\n    style: {\n      color: \"#ffcc99\"\n    }\n  }, {\n    types: [\"deleted\"],\n    style: {\n      textDecorationLine: \"line-through\"\n    }\n  }, {\n    types: [\"inserted\"],\n    style: {\n      textDecorationLine: \"underline\"\n    }\n  }, {\n    types: [\"italic\"],\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, {\n    types: [\"important\", \"bold\"],\n    style: {\n      fontWeight: \"bold\"\n    }\n  }, {\n    types: [\"important\"],\n    style: {\n      color: \"#c4b9fe\"\n    }\n  }]\n};\n/* harmony default export */ var duotoneDark = (theme);\n// EXTERNAL MODULE: ./node_modules/umi/node_modules/react/index.js\nvar react = __webpack_require__(\"kM82\");\n\n// CONCATENATED MODULE: ./node_modules/prism-react-renderer/dist/index.js\n\n\n\n\nvar defaultProps = {\n  // $FlowFixMe\n  Prism: prism_react_renderer_prism,\n  theme: duotoneDark\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function normalizeEmptyLines(line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\\n\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].content = \"\\n\";\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function appendTypes(types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\n\nvar normalizeTokens = function normalizeTokens(tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var i$1 = 1; i$1 < newlineCount; i$1++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[i$1]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nvar themeToDict = function themeToDict(theme, language) {\n  var plain = theme.plain; // $FlowFixMe\n\n  var base = Object.create(null);\n  var themeDict = theme.styles.reduce(function (acc, themeEntry) {\n    var languages = themeEntry.languages;\n    var style = themeEntry.style;\n\n    if (languages && !languages.includes(language)) {\n      return acc;\n    }\n\n    themeEntry.types.forEach(function (type) {\n      // $FlowFixMe\n      var accStyle = _extends({}, acc[type], style);\n\n      acc[type] = accStyle;\n    });\n    return acc;\n  }, base); // $FlowFixMe\n\n  themeDict.root = plain; // $FlowFixMe\n\n  themeDict.plain = _extends({}, plain, {\n    backgroundColor: null\n  });\n  return themeDict;\n};\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  }\n\n  return target;\n}\n\nvar Highlight = /*@__PURE__*/function (Component) {\n  function Highlight() {\n    var this$1 = this;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) {\n      args[len] = arguments[len];\n    }\n\n    Component.apply(this, args);\n\n    _defineProperty(this, \"getThemeDict\", function (props) {\n      if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n        return this$1.themeDict;\n      }\n\n      this$1.prevTheme = props.theme;\n      this$1.prevLanguage = props.language;\n      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n      return this$1.themeDict = themeDict;\n    });\n\n    _defineProperty(this, \"getLineProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"line\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token-line\",\n        style: undefined,\n        key: undefined\n      });\n\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict !== undefined) {\n        output.style = themeDict.plain;\n      }\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"getStyleForToken\", function (ref) {\n      var types = ref.types;\n      var empty = ref.empty;\n      var typesSize = types.length;\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict === undefined) {\n        return undefined;\n      } else if (typesSize === 1 && types[0] === \"plain\") {\n        return empty ? {\n          display: \"inline-block\"\n        } : undefined;\n      } else if (typesSize === 1 && !empty) {\n        return themeDict[types[0]];\n      }\n\n      var baseStyle = empty ? {\n        display: \"inline-block\"\n      } : {}; // $FlowFixMe\n\n      var typeStyles = types.map(function (type) {\n        return themeDict[type];\n      });\n      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));\n    });\n\n    _defineProperty(this, \"getTokenProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var token = ref.token;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"token\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token \" + token.types.join(\" \"),\n        children: token.content,\n        style: this$1.getStyleForToken(token),\n        key: undefined\n      });\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"tokenize\", function (Prism, code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language,\n        tokens: []\n      };\n      Prism.hooks.run(\"before-tokenize\", env);\n      var tokens = env.tokens = Prism.tokenize(env.code, env.grammar, env.language);\n      Prism.hooks.run(\"after-tokenize\", env);\n      return tokens;\n    });\n  }\n\n  if (Component) Highlight.__proto__ = Component;\n  Highlight.prototype = Object.create(Component && Component.prototype);\n  Highlight.prototype.constructor = Highlight;\n\n  Highlight.prototype.render = function render() {\n    var ref = this.props;\n    var Prism = ref.Prism;\n    var language = ref.language;\n    var code = ref.code;\n    var children = ref.children;\n    var themeDict = this.getThemeDict(this.props);\n    var grammar = Prism.languages[language];\n    var mixedTokens = grammar !== undefined ? this.tokenize(Prism, code, grammar, language) : [code];\n    var tokens = normalizeTokens(mixedTokens);\n    return children({\n      tokens: tokens,\n      className: \"prism-code language-\" + language,\n      style: themeDict !== undefined ? themeDict.root : {},\n      getLineProps: this.getLineProps,\n      getTokenProps: this.getTokenProps\n    });\n  };\n\n  return Highlight;\n}(react[\"Component\"]);\n\n/* harmony default export */ var dist = __webpack_exports__[\"a\"] = (Highlight);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvcHJpc20vaW5kZXguanM/NDk1MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvdGhlbWVzL2R1b3RvbmVEYXJrL2luZGV4LmpzP2Q2MGYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3ByaXNtLXJlYWN0LXJlbmRlcmVyL2Rpc3QvaW5kZXguanM/ZGNjYSJdLCJuYW1lcyI6WyJQcmlzbSIsImxhbmciLCJ1bmlxdWVJZCIsInBsYWluVGV4dEdyYW1tYXIiLCJfIiwidXRpbCIsImVuY29kZSIsInRva2VucyIsIlRva2VuIiwidHlwZSIsImNvbnRlbnQiLCJhbGlhcyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInJlcGxhY2UiLCJvIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJvYmpJZCIsIm9iaiIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJjbG9uZSIsImRlZXBDbG9uZSIsInZpc2l0ZWQiLCJpZCIsImtleSIsImhhc093blByb3BlcnR5IiwiZm9yRWFjaCIsInYiLCJpIiwiZ2V0TGFuZ3VhZ2UiLCJlbGVtZW50IiwibSIsImV4ZWMiLCJjbGFzc05hbWUiLCJ0b0xvd2VyQ2FzZSIsInBhcmVudEVsZW1lbnQiLCJzZXRMYW5ndWFnZSIsImxhbmd1YWdlIiwiUmVnRXhwIiwiY2xhc3NMaXN0IiwiYWRkIiwiaXNBY3RpdmUiLCJkZWZhdWx0QWN0aXZhdGlvbiIsIm5vIiwiY29udGFpbnMiLCJsYW5ndWFnZXMiLCJwbGFpbiIsInBsYWludGV4dCIsInRleHQiLCJ0eHQiLCJleHRlbmQiLCJyZWRlZiIsImluc2VydEJlZm9yZSIsImluc2lkZSIsImJlZm9yZSIsImluc2VydCIsInJvb3QiLCJncmFtbWFyIiwicmV0IiwidG9rZW4iLCJuZXdUb2tlbiIsIm9sZCIsIkRGUyIsImNhbGxiYWNrIiwicHJvcGVydHkiLCJwcm9wZXJ0eVR5cGUiLCJwbHVnaW5zIiwiaGlnaGxpZ2h0IiwiZW52IiwiY29kZSIsImhvb2tzIiwicnVuIiwidG9rZW5pemUiLCJzdHJpbmdpZnkiLCJyZXN0IiwidG9rZW5MaXN0IiwiTGlua2VkTGlzdCIsImFkZEFmdGVyIiwiaGVhZCIsIm1hdGNoR3JhbW1hciIsInRvQXJyYXkiLCJhbGwiLCJuYW1lIiwicHVzaCIsImNhbGxiYWNrcyIsImxlbmd0aCIsIm1hdGNoZWRTdHIiLCJzIiwiZSIsInRhZyIsImNsYXNzZXMiLCJhdHRyaWJ1dGVzIiwiYWxpYXNlcyIsImFwcGx5Iiwiam9pbiIsIm1hdGNoUGF0dGVybiIsInBhdHRlcm4iLCJwb3MiLCJsb29rYmVoaW5kIiwibGFzdEluZGV4IiwibWF0Y2giLCJsb29rYmVoaW5kTGVuZ3RoIiwiaW5kZXgiLCJzdGFydE5vZGUiLCJzdGFydFBvcyIsInJlbWF0Y2giLCJwYXR0ZXJucyIsImoiLCJjYXVzZSIsInBhdHRlcm5PYmoiLCJncmVlZHkiLCJnbG9iYWwiLCJmbGFncyIsInNvdXJjZSIsImN1cnJlbnROb2RlIiwibmV4dCIsInRhaWwiLCJyZWFjaCIsInN0ciIsInJlbW92ZUNvdW50IiwiZnJvbSIsInRvIiwicCIsImsiLCJtYXRjaFN0ciIsImFmdGVyIiwicmVtb3ZlRnJvbSIsInByZXYiLCJyZW1vdmVSYW5nZSIsIndyYXBwZWQiLCJuZXN0ZWRSZW1hdGNoIiwibGlzdCIsIm5vZGUiLCJuZXdOb2RlIiwiY291bnQiLCJhcnJheSIsInByaXNtIiwibWFya3VwIiwiYWRkSW5saW5lZCIsInRhZ05hbWUiLCJpbmNsdWRlZENkYXRhSW5zaWRlIiwiZGVmIiwiYXR0ck5hbWUiLCJodG1sIiwibWF0aG1sIiwic3ZnIiwieG1sIiwic3NtbCIsImF0b20iLCJyc3MiLCJlbnZWYXJzIiwiY29tbWFuZEFmdGVySGVyZWRvYyIsImluc2lkZVN0cmluZyIsImJhc2giLCJlbnRpdHkiLCJ2YXJpYWJsZSIsInRvQmVDb3BpZWQiLCJzaGVsbCIsImNsaWtlIiwiYyIsImtleXdvcmQiLCJtb2ROYW1lIiwiY3BwIiwic3RyaW5nIiwiY3NzIiwiYWRkQXR0cmlidXRlIiwic2VsZWN0b3JJbnNpZGUiLCJzZWxlY3RvciIsInVuaXQiLCJudW1iZXIiLCJqYXZhc2NyaXB0IiwicmVnZXgiLCJqcyIsImNvbW1lbnQiLCJpbnRlcnBvbGF0aW9uIiwiY29mZmVlc2NyaXB0IiwiY29mZmVlIiwiYW5jaG9yT3JBbGlhcyIsInByb3BlcnRpZXMiLCJwbGFpbktleSIsImNyZWF0ZVZhbHVlUGF0dGVybiIsInlhbWwiLCJ5bWwiLCJpbm5lciIsImNyZWF0ZUlubGluZSIsInRhYmxlQ2VsbCIsInRhYmxlUm93IiwidGFibGVMaW5lIiwibWFya2Rvd24iLCJwdW5jdHVhdGlvbiIsIndhbGtUb2tlbnMiLCJsIiwiY29kZUxhbmciLCJjb2RlQmxvY2siLCJjbHMiLCJhdXRvbG9hZGVyIiwiRGF0ZSIsInZhbHVlT2YiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJsb2FkTGFuZ3VhZ2VzIiwiZWxlIiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwidGFnUGF0dGVybiIsIktOT1dOX0VOVElUWV9OQU1FUyIsImZyb21Db2RlUG9pbnQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJwYXJzZUludCIsIk51bWJlciIsImtub3duIiwibWQiLCJncmFwaHFsIiwiYWZ0ZXJUb2tlbml6ZUdyYXBocWwiLCJ2YWxpZFRva2VucyIsImZpbHRlciIsImN1cnJlbnRJbmRleCIsImdldFRva2VuIiwib2Zmc2V0IiwiaXNUb2tlblR5cGUiLCJ0eXBlcyIsImZpbmRDbG9zaW5nQnJhY2tldCIsIm9wZW4iLCJjbG9zZSIsInN0YWNrSGVpZ2h0IiwidGVzdCIsImFkZEFsaWFzIiwic3RhcnRUb2tlbiIsImlucHV0VmFyaWFibGVzIiwiZGVmaW5pdGlvbkVuZCIsInQiLCJtdXRhdGlvbkVuZCIsInZhclRva2VuIiwiaW5kZXhPZiIsInNxbCIsInRlbXBsYXRlU3RyaW5nIiwidGVtcGxhdGVMaXRlcmFsUGF0dGVybiIsImludGVycG9sYXRpb25PYmplY3QiLCJpbnRlcnBvbGF0aW9uUHVuY3R1YXRpb25PYmplY3QiLCJpbnRlcnBvbGF0aW9uUGF0dGVybiIsImNyZWF0ZVRlbXBsYXRlIiwidW5kZWZpbmVkIiwiQm9vbGVhbiIsImdldFBsYWNlaG9sZGVyIiwiY291bnRlciIsInRvVXBwZXJDYXNlIiwidG9rZW5pemVXaXRoSG9va3MiLCJ0b2tlbml6ZUludGVycG9sYXRpb25FeHByZXNzaW9uIiwiZXhwcmVzc2lvbiIsInRlbXBHcmFtbWFyIiwiYXJncyIsInNwbGljZSIsInRva2VuaXplRW1iZWRkZWQiLCJfdG9rZW5zIiwicGxhY2Vob2xkZXJDb3VudGVyIiwicGxhY2Vob2xkZXJNYXAiLCJlbWJlZGRlZENvZGUiLCJpbnRlcnBvbGF0aW9uRXhwcmVzc2lvbiIsInBsYWNlaG9sZGVyIiwiZW1iZWRkZWRUb2tlbnMiLCJwbGFjZWhvbGRlcnMiLCJrZXlzIiwic3Vic3RyaW5nIiwibWlkZGxlIiwicmVwbGFjZW1lbnQiLCJhZnRlclRva2VucyIsImNvbmNhdCIsInN1cHBvcnRlZExhbmd1YWdlcyIsImZpbmRUZW1wbGF0ZVN0cmluZ3MiLCJlbWJlZGRlZCIsInN0cmluZ0NvbnRlbnQiLCJ0eXBlc2NyaXB0IiwidHlwZUluc2lkZSIsInRzIiwid2l0aElkIiwidW5zaGlmdCIsIm1heWJlQ2xhc3NOYW1lVG9rZW5zIiwic3BhY2UiLCJicmFjZXMiLCJzcHJlYWQiLCJyZSIsImpzeCIsInN0cmluZ2lmeVRva2VuIiwib3BlbmVkVGFncyIsIm5vdFRhZ05vckJyYWNlIiwicG9wIiwib3BlbmVkQnJhY2VzIiwicGxhaW5UZXh0IiwiZGlmZiIsIlBSRUZJWEVTIiwicHJlZml4IiwiZ2l0IiwiZ28iLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYnVpbGRQbGFjZWhvbGRlcnMiLCJwbGFjZWhvbGRlclBhdHRlcm4iLCJyZXBsYWNlRmlsdGVyIiwidG9rZW5TdGFjayIsInRva2VuaXplUGxhY2Vob2xkZXJzIiwiaGFuZGxlYmFycyIsImhhbmRsZWJhcnNQYXR0ZXJuIiwiaGJzIiwianNvbiIsIndlYm1hbmlmZXN0IiwibGVzcyIsIm1ha2VmaWxlIiwib2JqZWN0aXZlYyIsIm9iamMiLCJvY2FtbCIsInB5dGhvbiIsInB5IiwicmVhc29uIiwic2FzcyIsImF0cnVsZSIsIm9wZXJhdG9yIiwiaW1wb3J0YW50Iiwic2NzcyIsInN0eWx1cyIsImZ1bmMiLCJ0c3giLCJ3YXNtIiwidGhlbWUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsInN0eWxlcyIsInN0eWxlIiwib3BhY2l0eSIsInRleHREZWNvcmF0aW9uTGluZSIsImZvbnRTdHlsZSIsImZvbnRXZWlnaHQiLCJkZWZhdWx0UHJvcHMiLCJfZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfZXh0ZW5kcyIsImFzc2lnbiIsInRhcmdldCIsImFyZ3VtZW50cyIsIm5ld2xpbmVSZSIsIm5vcm1hbGl6ZUVtcHR5TGluZXMiLCJsaW5lIiwiZW1wdHkiLCJhcHBlbmRUeXBlcyIsInR5cGVzU2l6ZSIsIm5vcm1hbGl6ZVRva2VucyIsInR5cGVBcnJTdGFjayIsInRva2VuQXJyU3RhY2siLCJ0b2tlbkFyckluZGV4U3RhY2siLCJ0b2tlbkFyclNpemVTdGFjayIsInN0YWNrSW5kZXgiLCJjdXJyZW50TGluZSIsImFjYyIsInRva2VuQXJyIiwic3BsaXRCeU5ld2xpbmVzIiwic3BsaXQiLCJuZXdsaW5lQ291bnQiLCJpJDEiLCJ0aGVtZVRvRGljdCIsImJhc2UiLCJjcmVhdGUiLCJ0aGVtZURpY3QiLCJyZWR1Y2UiLCJ0aGVtZUVudHJ5IiwiaW5jbHVkZXMiLCJhY2NTdHlsZSIsIm9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZSIsIkhpZ2hsaWdodCIsIkNvbXBvbmVudCIsInRoaXMkMSIsImxlbiIsInByb3BzIiwicHJldlRoZW1lIiwicHJldkxhbmd1YWdlIiwicmVmIiwicmVzdCQxIiwib3V0cHV0IiwiZ2V0VGhlbWVEaWN0IiwiZGlzcGxheSIsImJhc2VTdHlsZSIsInR5cGVTdHlsZXMiLCJjaGlsZHJlbiIsImdldFN0eWxlRm9yVG9rZW4iLCJfX3Byb3RvX18iLCJjb25zdHJ1Y3RvciIsInJlbmRlciIsIm1peGVkVG9rZW5zIiwiZ2V0TGluZVByb3BzIiwiZ2V0VG9rZW5Qcm9wcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQyxJQUFJQSxLQUFLLEdBQUksWUFBWTtFQUV6QjtFQUNBLElBQUlDLElBQUksR0FBRyx5Q0FBWDtFQUNBLElBQUlDLFFBQVEsR0FBRyxDQUFmLENBSnlCLENBTXpCOztFQUNBLElBQUlDLGdCQUFnQixHQUFHLEVBQXZCO0VBR0EsSUFBSUMsQ0FBQyxHQUFHO0lBQ1A7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0lBQ0VDLElBQUksRUFBRTtNQUNMQyxNQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFnQkMsTUFBaEIsRUFBd0I7UUFDL0IsSUFBSUEsTUFBTSxZQUFZQyxLQUF0QixFQUE2QjtVQUM1QixPQUFPLElBQUlBLEtBQUosQ0FBVUQsTUFBTSxDQUFDRSxJQUFqQixFQUF1QkgsTUFBTSxDQUFDQyxNQUFNLENBQUNHLE9BQVIsQ0FBN0IsRUFBK0NILE1BQU0sQ0FBQ0ksS0FBdEQsQ0FBUDtRQUNBLENBRkQsTUFFTyxJQUFJQyxLQUFLLENBQUNDLE9BQU4sQ0FBY04sTUFBZCxDQUFKLEVBQTJCO1VBQ2pDLE9BQU9BLE1BQU0sQ0FBQ08sR0FBUCxDQUFXUixNQUFYLENBQVA7UUFDQSxDQUZNLE1BRUE7VUFDTixPQUFPQyxNQUFNLENBQUNRLE9BQVAsQ0FBZSxJQUFmLEVBQXFCLE9BQXJCLEVBQThCQSxPQUE5QixDQUFzQyxJQUF0QyxF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QW5CO0lBQ0EsSUFBSWdDLElBQUksR0FBR3NULEdBQUcsQ0FBQ3RULElBQWY7SUFDQSxJQUFJNlQsUUFBUSxHQUFHUCxHQUFHLENBQUNPLFFBQW5CO0lBQ0EsSUFBSXJCLFNBQVMsR0FBRyxLQUFLaUIsWUFBTCxDQUFrQixLQUFLTixLQUF2QixDQUFoQjtJQUNBLElBQUkvVCxPQUFPLEdBQUcvRCxLQUFLLENBQUNtRCxTQUFOLENBQWdCUixRQUFoQixDQUFkO0lBQ0EsSUFBSWtXLFdBQVcsR0FBRzlVLE9BQU8sS0FBSzRMLFNBQVosR0FBd0IsS0FBSzdLLFFBQUwsQ0FBYzlFLEtBQWQsRUFBcUIyRSxJQUFyQixFQUEyQlosT0FBM0IsRUFBb0NwQixRQUFwQyxDQUF4QixHQUF3RSxDQUFDZ0MsSUFBRCxDQUExRjtJQUNBLElBQUlwRSxNQUFNLEdBQUc0VixlQUFlLENBQUMwQyxXQUFELENBQTVCO0lBQ0EsT0FBT0wsUUFBUSxDQUFDO01BQ2RqWSxNQUFNLEVBQUVBLE1BRE07TUFFZGdDLFNBQVMsRUFBRSx5QkFBeUJJLFFBRnRCO01BR2RvUyxLQUFLLEVBQUVvQyxTQUFTLEtBQUt4SCxTQUFkLEdBQTBCd0gsU0FBUyxDQUFDclQsSUFBcEMsR0FBMkMsRUFIcEM7TUFJZGdWLFlBQVksRUFBRSxLQUFLQSxZQUpMO01BS2RDLGFBQWEsRUFBRSxLQUFLQTtJQUxOLENBQUQsQ0FBZjtFQU9ELENBakJEOztFQW1CQSxPQUFPckIsU0FBUDtBQUNELENBcko0QixDQXFKM0JDLGtCQXJKMkIsQ0FBN0I7O0FBdUplRCw2RUFBZiIsImZpbGUiOiIzTXB3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBQcmlzbTogTGlnaHR3ZWlnaHQsIHJvYnVzdCwgZWxlZ2FudCBzeW50YXggaGlnaGxpZ2h0aW5nXG4gKlxuICogQGxpY2Vuc2UgTUlUIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD5cbiAqIEBhdXRob3IgTGVhIFZlcm91IDxodHRwczovL2xlYS52ZXJvdS5tZT5cbiAqIEBuYW1lc3BhY2VcbiAqIEBwdWJsaWNcbiAqL1xuLyoqXG4gKiBwcmlzbS1yZWFjdC1yZW5kZXJlcjpcbiAqIFRoaXMgZmlsZSBoYXMgYmVlbiBtb2RpZmllZCB0byByZW1vdmU6XG4gKiAtIGdsb2JhbHMgYW5kIHdpbmRvdyBkZXBlbmRlbmN5XG4gKiAtIHdvcmtlciBzdXBwb3J0XG4gKiAtIGhpZ2hsaWdodEFsbCBhbmQgb3RoZXIgZWxlbWVudCBkZXBlbmRlbnQgbWV0aG9kc1xuICogLSBfLmhvb2tzIGhlbHBlcnNcbiAqIC0gVU1EL25vZGUtc3BlY2lmaWMgaGFja3NcbiAqIEl0IGhhcyBhbHNvIGJlZW4gcnVuIHRocm91Z2ggcHJldHRpZXJcbiAqL1xuXG4gdmFyIFByaXNtID0gKGZ1bmN0aW9uICgpIHtcblxuXHQvLyBQcml2YXRlIGhlbHBlciB2YXJzXG5cdHZhciBsYW5nID0gLyg/Ol58XFxzKWxhbmcoPzp1YWdlKT8tKFtcXHctXSspKD89XFxzfCQpL2k7XG5cdHZhciB1bmlxdWVJZCA9IDA7XG5cblx0Ly8gVGhlIGdyYW1tYXIgb2JqZWN0IGZvciBwbGFpbnRleHRcblx0dmFyIHBsYWluVGV4dEdyYW1tYXIgPSB7fTtcblxuXG5cdHZhciBfID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgbmFtZXNwYWNlIGZvciB1dGlsaXR5IG1ldGhvZHMuXG5cdFx0ICpcblx0XHQgKiBBbGwgZnVuY3Rpb24gaW4gdGhpcyBuYW1lc3BhY2UgdGhhdCBhcmUgbm90IGV4cGxpY2l0bHkgbWFya2VkIGFzIF9wdWJsaWNfIGFyZSBmb3IgX19pbnRlcm5hbCB1c2Ugb25seV9fIGFuZCBtYXlcblx0XHQgKiBjaGFuZ2Ugb3IgZGlzYXBwZWFyIGF0IGFueSB0aW1lLlxuXHRcdCAqXG5cdFx0ICogQG5hbWVzcGFjZVxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqL1xuXHRcdHV0aWw6IHtcblx0XHRcdGVuY29kZTogZnVuY3Rpb24gZW5jb2RlKHRva2Vucykge1xuXHRcdFx0XHRpZiAodG9rZW5zIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFRva2VuKHRva2Vucy50eXBlLCBlbmNvZGUodG9rZW5zLmNvbnRlbnQpLCB0b2tlbnMuYWxpYXMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodG9rZW5zKSkge1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMubWFwKGVuY29kZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRva2Vucy5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cXHUwMGEwL2csICcgJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgdHlwZSBvZiB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHthbnl9IG9cblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0XHQgKiBAZXhhbXBsZVxuXHRcdFx0ICogdHlwZShudWxsKSAgICAgID09PSAnTnVsbCdcblx0XHRcdCAqIHR5cGUodW5kZWZpbmVkKSA9PT0gJ1VuZGVmaW5lZCdcblx0XHRcdCAqIHR5cGUoMTIzKSAgICAgICA9PT0gJ051bWJlcidcblx0XHRcdCAqIHR5cGUoJ2ZvbycpICAgICA9PT0gJ1N0cmluZydcblx0XHRcdCAqIHR5cGUodHJ1ZSkgICAgICA9PT0gJ0Jvb2xlYW4nXG5cdFx0XHQgKiB0eXBlKFsxLCAyXSkgICAgPT09ICdBcnJheSdcblx0XHRcdCAqIHR5cGUoe30pICAgICAgICA9PT0gJ09iamVjdCdcblx0XHRcdCAqIHR5cGUoU3RyaW5nKSAgICA9PT0gJ0Z1bmN0aW9uJ1xuXHRcdFx0ICogdHlwZSgvYWJjKy8pICAgID09PSAnUmVnRXhwJ1xuXHRcdFx0ICovXG5cdFx0XHR0eXBlOiBmdW5jdGlvbiAobykge1xuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyBhIHVuaXF1ZSBudW1iZXIgZm9yIHRoZSBnaXZlbiBvYmplY3QuIExhdGVyIGNhbGxzIHdpbGwgc3RpbGwgcmV0dXJuIHRoZSBzYW1lIG51bWJlci5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdFx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfVxuXHRcdFx0ICovXG5cdFx0XHRvYmpJZDogZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRpZiAoIW9ialsnX19pZCddKSB7XG5cdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ19faWQnLCB7IHZhbHVlOiArK3VuaXF1ZUlkIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmpbJ19faWQnXTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ3JlYXRlcyBhIGRlZXAgY2xvbmUgb2YgdGhlIGdpdmVuIG9iamVjdC5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgbWFpbiBpbnRlbmRlZCB1c2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBjbG9uZSBsYW5ndWFnZSBkZWZpbml0aW9ucy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge1R9IG9cblx0XHRcdCAqIEBwYXJhbSB7UmVjb3JkPG51bWJlciwgYW55Pn0gW3Zpc2l0ZWRdXG5cdFx0XHQgKiBAcmV0dXJucyB7VH1cblx0XHRcdCAqIEB0ZW1wbGF0ZSBUXG5cdFx0XHQgKi9cblx0XHRcdGNsb25lOiBmdW5jdGlvbiBkZWVwQ2xvbmUobywgdmlzaXRlZCkge1xuXHRcdFx0XHR2aXNpdGVkID0gdmlzaXRlZCB8fCB7fTtcblxuXHRcdFx0XHR2YXIgY2xvbmU7IHZhciBpZDtcblx0XHRcdFx0c3dpdGNoIChfLnV0aWwudHlwZShvKSkge1xuXHRcdFx0XHRcdGNhc2UgJ09iamVjdCc6XG5cdFx0XHRcdFx0XHRpZCA9IF8udXRpbC5vYmpJZChvKTtcblx0XHRcdFx0XHRcdGlmICh2aXNpdGVkW2lkXSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmlzaXRlZFtpZF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjbG9uZSA9IC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgYW55Pn0gKi8gKHt9KTtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbaWRdID0gY2xvbmU7XG5cblx0XHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBvKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdFx0XHRjbG9uZVtrZXldID0gZGVlcENsb25lKG9ba2V5XSwgdmlzaXRlZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2xvbmUpO1xuXG5cdFx0XHRcdFx0Y2FzZSAnQXJyYXknOlxuXHRcdFx0XHRcdFx0aWQgPSBfLnV0aWwub2JqSWQobyk7XG5cdFx0XHRcdFx0XHRpZiAodmlzaXRlZFtpZF0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZpc2l0ZWRbaWRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2xvbmUgPSBbXTtcblx0XHRcdFx0XHRcdHZpc2l0ZWRbaWRdID0gY2xvbmU7XG5cblx0XHRcdFx0XHRcdCgvKiogQHR5cGUge0FycmF5fSAqLygvKiogQHR5cGUge2FueX0gKi8obykpKS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7XG5cdFx0XHRcdFx0XHRcdGNsb25lW2ldID0gZGVlcENsb25lKHYsIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKGNsb25lKTtcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRyZXR1cm4gbztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHRoZSBQcmlzbSBsYW5ndWFnZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBzZXQgYnkgYSBgbGFuZ3VhZ2UteHh4eGAgb3IgYGxhbmcteHh4eGAgY2xhc3MuXG5cdFx0XHQgKlxuXHRcdFx0ICogSWYgbm8gbGFuZ3VhZ2UgaXMgc2V0IGZvciB0aGUgZWxlbWVudCBvciB0aGUgZWxlbWVudCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGBub25lYCB3aWxsIGJlIHJldHVybmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuXHRcdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0Z2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0XHRcdHdoaWxlIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0dmFyIG0gPSBsYW5nLmV4ZWMoZWxlbWVudC5jbGFzc05hbWUpO1xuXHRcdFx0XHRcdGlmIChtKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbVsxXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAnbm9uZSc7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFNldHMgdGhlIFByaXNtIGBsYW5ndWFnZS14eHh4YCBjbGFzcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuXHRcdFx0ICogQHJldHVybnMge3ZvaWR9XG5cdFx0XHQgKi9cblx0XHRcdHNldExhbmd1YWdlOiBmdW5jdGlvbiAoZWxlbWVudCwgbGFuZ3VhZ2UpIHtcblx0XHRcdFx0Ly8gcmVtb3ZlIGFsbCBgbGFuZ3VhZ2UteHh4eGAgY2xhc3Nlc1xuXHRcdFx0XHQvLyAodGhpcyBtaWdodCBsZWF2ZSBiZWhpbmQgYSBsZWFkaW5nIHNwYWNlKVxuXHRcdFx0XHRlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoUmVnRXhwKGxhbmcsICdnaScpLCAnJyk7XG5cblx0XHRcdFx0Ly8gYWRkIHRoZSBuZXcgYGxhbmd1YWdlLXh4eHhgIGNsYXNzXG5cdFx0XHRcdC8vICh1c2luZyBgY2xhc3NMaXN0YCB3aWxsIGF1dG9tYXRpY2FsbHkgY2xlYW4gdXAgc3BhY2VzIGZvciB1cylcblx0XHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdsYW5ndWFnZS0nICsgbGFuZ3VhZ2UpO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHdoZXRoZXIgYSBnaXZlbiBjbGFzcyBpcyBhY3RpdmUgZm9yIGBlbGVtZW50YC5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgY2xhc3MgY2FuIGJlIGFjdGl2YXRlZCBpZiBgZWxlbWVudGAgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIHRoZSBnaXZlbiBjbGFzcyBhbmQgaXQgY2FuIGJlIGRlYWN0aXZhdGVkXG5cdFx0XHQgKiBpZiBgZWxlbWVudGAgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIHRoZSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIGNsYXNzLiBUaGUgX25lZ2F0ZWQgdmVyc2lvbl8gb2YgdGhlXG5cdFx0XHQgKiBnaXZlbiBjbGFzcyBpcyBqdXN0IHRoZSBnaXZlbiBjbGFzcyB3aXRoIGEgYG5vLWAgcHJlZml4LlxuXHRcdFx0ICpcblx0XHRcdCAqIFdoZXRoZXIgdGhlIGNsYXNzIGlzIGFjdGl2ZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIGBlbGVtZW50YCAod2hlcmUgYGVsZW1lbnRgIGl0c2VsZiBpc1xuXHRcdFx0ICogY2xvc2VzdCBhbmNlc3RvcikgdGhhdCBoYXMgdGhlIGdpdmVuIGNsYXNzIG9yIHRoZSBuZWdhdGVkIHZlcnNpb24gb2YgaXQuIElmIG5laXRoZXIgYGVsZW1lbnRgIG5vciBhbnkgb2YgaXRzXG5cdFx0XHQgKiBhbmNlc3RvcnMgaGF2ZSB0aGUgZ2l2ZW4gY2xhc3Mgb3IgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiBpdCwgdGhlbiB0aGUgZGVmYXVsdCBhY3RpdmF0aW9uIHdpbGwgYmUgcmV0dXJuZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogSW4gdGhlIHBhcmFkb3hpY2FsIHNpdHVhdGlvbiB3aGVyZSB0aGUgY2xvc2VzdCBhbmNlc3RvciBjb250YWlucyBfX2JvdGhfXyB0aGUgZ2l2ZW4gY2xhc3MgYW5kIHRoZSBuZWdhdGVkXG5cdFx0XHQgKiB2ZXJzaW9uIG9mIGl0LCB0aGUgY2xhc3MgaXMgY29uc2lkZXJlZCBhY3RpdmUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWZhdWx0QWN0aXZhdGlvbj1mYWxzZV1cblx0XHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRpc0FjdGl2ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSwgZGVmYXVsdEFjdGl2YXRpb24pIHtcblx0XHRcdFx0dmFyIG5vID0gJ25vLScgKyBjbGFzc05hbWU7XG5cblx0XHRcdFx0d2hpbGUgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHR2YXIgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG5cdFx0XHRcdFx0aWYgKGNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNsYXNzTGlzdC5jb250YWlucyhubykpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gISFkZWZhdWx0QWN0aXZhdGlvbjtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBuYW1lc3BhY2UgY29udGFpbnMgYWxsIGN1cnJlbnRseSBsb2FkZWQgbGFuZ3VhZ2VzIGFuZCB0aGUgc29tZSBoZWxwZXIgZnVuY3Rpb25zIHRvIGNyZWF0ZSBhbmQgbW9kaWZ5IGxhbmd1YWdlcy5cblx0XHQgKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0bGFuZ3VhZ2VzOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBncmFtbWFyIGZvciBwbGFpbiwgdW5mb3JtYXR0ZWQgdGV4dC5cblx0XHRcdCAqL1xuXHRcdFx0cGxhaW46IHBsYWluVGV4dEdyYW1tYXIsXG5cdFx0XHRwbGFpbnRleHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cdFx0XHR0ZXh0OiBwbGFpblRleHRHcmFtbWFyLFxuXHRcdFx0dHh0OiBwbGFpblRleHRHcmFtbWFyLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIGxhbmd1YWdlIHdpdGggdGhlIGdpdmVuIGlkIGFuZCBhcHBlbmRzIHRoZSBnaXZlbiB0b2tlbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogSWYgYSB0b2tlbiBpbiBgcmVkZWZgIGFsc28gYXBwZWFycyBpbiB0aGUgY29waWVkIGxhbmd1YWdlLCB0aGVuIHRoZSBleGlzdGluZyB0b2tlbiBpbiB0aGUgY29waWVkIGxhbmd1YWdlXG5cdFx0XHQgKiB3aWxsIGJlIG92ZXJ3cml0dGVuIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvbi5cblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBCZXN0IHByYWN0aWNlc1xuXHRcdFx0ICpcblx0XHRcdCAqIFNpbmNlIHRoZSBwb3NpdGlvbiBvZiBvdmVyd3JpdGluZyB0b2tlbnMgKHRva2VuIGluIGByZWRlZmAgdGhhdCBvdmVyd3JpdGUgdG9rZW5zIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2UpXG5cdFx0XHQgKiBkb2Vzbid0IG1hdHRlciwgdGhleSBjYW4gdGVjaG5pY2FsbHkgYmUgaW4gYW55IG9yZGVyLiBIb3dldmVyLCB0aGlzIGNhbiBiZSBjb25mdXNpbmcgdG8gb3RoZXJzIHRoYXQgdHJ5aW5nIHRvXG5cdFx0XHQgKiB1bmRlcnN0YW5kIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGJlY2F1c2UsIG5vcm1hbGx5LCB0aGUgb3JkZXIgb2YgdG9rZW5zIG1hdHRlcnMgaW4gUHJpc20gZ3JhbW1hcnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlcmVmb3JlLCBpdCBpcyBlbmNvdXJhZ2VkIHRvIG9yZGVyIG92ZXJ3cml0aW5nIHRva2VucyBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9ucyBvZiB0aGUgb3ZlcndyaXR0ZW4gdG9rZW5zLlxuXHRcdFx0ICogRnVydGhlcm1vcmUsIGFsbCBub24tb3ZlcndyaXRpbmcgdG9rZW5zIHNob3VsZCBiZSBwbGFjZWQgYWZ0ZXIgdGhlIG92ZXJ3cml0aW5nIG9uZXMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgbGFuZ3VhZ2UgdG8gZXh0ZW5kLiBUaGlzIGhhcyB0byBiZSBhIGtleSBpbiBgUHJpc20ubGFuZ3VhZ2VzYC5cblx0XHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gcmVkZWYgVGhlIG5ldyB0b2tlbnMgdG8gYXBwZW5kLlxuXHRcdFx0ICogQHJldHVybnMge0dyYW1tYXJ9IFRoZSBuZXcgbGFuZ3VhZ2UgY3JlYXRlZC5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXNbJ2Nzcy13aXRoLWNvbG9ycyddID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3NzJywge1xuXHRcdFx0ICogICAgIC8vIFByaXNtLmxhbmd1YWdlcy5jc3MgYWxyZWFkeSBoYXMgYSAnY29tbWVudCcgdG9rZW4sIHNvIHRoaXMgdG9rZW4gd2lsbCBvdmVyd3JpdGUgQ1NTJyAnY29tbWVudCcgdG9rZW5cblx0XHRcdCAqICAgICAvLyBhdCBpdHMgb3JpZ2luYWwgcG9zaXRpb25cblx0XHRcdCAqICAgICAnY29tbWVudCc6IHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgLy8gQ1NTIGRvZXNuJ3QgaGF2ZSBhICdjb2xvcicgdG9rZW4sIHNvIHRoaXMgdG9rZW4gd2lsbCBiZSBhcHBlbmRlZFxuXHRcdFx0ICogICAgICdjb2xvcic6IC9cXGIoPzpyZWR8Z3JlZW58Ymx1ZSlcXGIvXG5cdFx0XHQgKiB9KTtcblx0XHRcdCAqL1xuXHRcdFx0ZXh0ZW5kOiBmdW5jdGlvbiAoaWQsIHJlZGVmKSB7XG5cdFx0XHRcdHZhciBsYW5nID0gXy51dGlsLmNsb25lKF8ubGFuZ3VhZ2VzW2lkXSk7XG5cblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlZGVmKSB7XG5cdFx0XHRcdFx0bGFuZ1trZXldID0gcmVkZWZba2V5XTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBsYW5nO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBJbnNlcnRzIHRva2VucyBfYmVmb3JlXyBhbm90aGVyIHRva2VuIGluIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBvciBhbnkgb3RoZXIgZ3JhbW1hci5cblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBVc2FnZVxuXHRcdFx0ICpcblx0XHRcdCAqIFRoaXMgaGVscGVyIG1ldGhvZCBtYWtlcyBpdCBlYXN5IHRvIG1vZGlmeSBleGlzdGluZyBsYW5ndWFnZXMuIEZvciBleGFtcGxlLCB0aGUgQ1NTIGxhbmd1YWdlIGRlZmluaXRpb25cblx0XHRcdCAqIG5vdCBvbmx5IGRlZmluZXMgQ1NTIGhpZ2hsaWdodGluZyBmb3IgQ1NTIGRvY3VtZW50cywgYnV0IGFsc28gbmVlZHMgdG8gZGVmaW5lIGhpZ2hsaWdodGluZyBmb3IgQ1NTIGVtYmVkZGVkXG5cdFx0XHQgKiBpbiBIVE1MIHRocm91Z2ggYDxzdHlsZT5gIGVsZW1lbnRzLiBUbyBkbyB0aGlzLCBpdCBuZWVkcyB0byBtb2RpZnkgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGFuZCBhZGQgdGhlXG5cdFx0XHQgKiBhcHByb3ByaWF0ZSB0b2tlbnMuIEhvd2V2ZXIsIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYCBpcyBhIHJlZ3VsYXIgSmF2YVNjcmlwdCBvYmplY3QgbGl0ZXJhbCwgc28gaWYgeW91IGRvXG5cdFx0XHQgKiB0aGlzOlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnN0eWxlID0ge1xuXHRcdFx0ICogICAgIC8vIHRva2VuXG5cdFx0XHQgKiB9O1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogdGhlbiB0aGUgYHN0eWxlYCB0b2tlbiB3aWxsIGJlIGFkZGVkIChhbmQgcHJvY2Vzc2VkKSBhdCB0aGUgZW5kLiBgaW5zZXJ0QmVmb3JlYCBhbGxvd3MgeW91IHRvIGluc2VydCB0b2tlbnNcblx0XHRcdCAqIGJlZm9yZSBleGlzdGluZyB0b2tlbnMuIEZvciB0aGUgQ1NTIGV4YW1wbGUgYWJvdmUsIHlvdSB3b3VsZCB1c2UgaXQgbGlrZSB0aGlzOlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY2RhdGEnLCB7XG5cdFx0XHQgKiAgICAgJ3N0eWxlJzoge1xuXHRcdFx0ICogICAgICAgICAvLyB0b2tlblxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqIH0pO1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogIyMgU3BlY2lhbCBjYXNlc1xuXHRcdFx0ICpcblx0XHRcdCAqIElmIHRoZSBncmFtbWFycyBvZiBgaW5zaWRlYCBhbmQgYGluc2VydGAgaGF2ZSB0b2tlbnMgd2l0aCB0aGUgc2FtZSBuYW1lLCB0aGUgdG9rZW5zIGluIGBpbnNpZGVgJ3MgZ3JhbW1hclxuXHRcdFx0ICogd2lsbCBiZSBpZ25vcmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoaXMgYmVoYXZpb3IgY2FuIGJlIHVzZWQgdG8gaW5zZXJ0IHRva2VucyBhZnRlciBgYmVmb3JlYDpcblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NvbW1lbnQnLCB7XG5cdFx0XHQgKiAgICAgJ2NvbW1lbnQnOiBQcmlzbS5sYW5ndWFnZXMubWFya3VwLmNvbW1lbnQsXG5cdFx0XHQgKiAgICAgLy8gdG9rZW5zIGFmdGVyICdjb21tZW50J1xuXHRcdFx0ICogfSk7XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBMaW1pdGF0aW9uc1xuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBtYWluIHByb2JsZW0gYGluc2VydEJlZm9yZWAgaGFzIHRvIHNvbHZlIGlzIGl0ZXJhdGlvbiBvcmRlci4gU2luY2UgRVMyMDE1LCB0aGUgaXRlcmF0aW9uIG9yZGVyIGZvciBvYmplY3Rcblx0XHRcdCAqIHByb3BlcnRpZXMgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgaW5zZXJ0aW9uIG9yZGVyIChleGNlcHQgZm9yIGludGVnZXIga2V5cykgYnV0IHNvbWUgYnJvd3NlcnMgYmVoYXZlXG5cdFx0XHQgKiBkaWZmZXJlbnRseSB3aGVuIGtleXMgYXJlIGRlbGV0ZWQgYW5kIHJlLWluc2VydGVkLiBTbyBgaW5zZXJ0QmVmb3JlYCBjYW4ndCBiZSBpbXBsZW1lbnRlZCBieSB0ZW1wb3JhcmlseVxuXHRcdFx0ICogZGVsZXRpbmcgcHJvcGVydGllcyB3aGljaCBpcyBuZWNlc3NhcnkgdG8gaW5zZXJ0IGF0IGFyYml0cmFyeSBwb3NpdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogVG8gc29sdmUgdGhpcyBwcm9ibGVtLCBgaW5zZXJ0QmVmb3JlYCBkb2Vzbid0IGFjdHVhbGx5IGluc2VydCB0aGUgZ2l2ZW4gdG9rZW5zIGludG8gdGhlIHRhcmdldCBvYmplY3QuXG5cdFx0XHQgKiBJbnN0ZWFkLCBpdCB3aWxsIGNyZWF0ZSBhIG5ldyBvYmplY3QgYW5kIHJlcGxhY2UgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIHRhcmdldCBvYmplY3Qgd2l0aCB0aGUgbmV3IG9uZS4gVGhpc1xuXHRcdFx0ICogY2FuIGJlIGRvbmUgd2l0aG91dCB0ZW1wb3JhcmlseSBkZWxldGluZyBwcm9wZXJ0aWVzLCBzbyB0aGUgaXRlcmF0aW9uIG9yZGVyIGlzIHdlbGwtZGVmaW5lZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBIb3dldmVyLCBvbmx5IHJlZmVyZW5jZXMgdGhhdCBjYW4gYmUgcmVhY2hlZCBmcm9tIGBQcmlzbS5sYW5ndWFnZXNgIG9yIGBpbnNlcnRgIHdpbGwgYmUgcmVwbGFjZWQuIEkuZS4gaWZcblx0XHRcdCAqIHlvdSBob2xkIHRoZSB0YXJnZXQgb2JqZWN0IGluIGEgdmFyaWFibGUsIHRoZW4gdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSB3aWxsIG5vdCBjaGFuZ2UuXG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIHZhciBvbGRNYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXHRcdFx0ICogdmFyIG5ld01hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjb21tZW50JywgeyAuLi4gfSk7XG5cdFx0XHQgKlxuXHRcdFx0ICogYXNzZXJ0KG9sZE1hcmt1cCAhPT0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCk7XG5cdFx0XHQgKiBhc3NlcnQobmV3TWFya3VwID09PSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBpbnNpZGUgVGhlIHByb3BlcnR5IG9mIGByb290YCAoZS5nLiBhIGxhbmd1YWdlIGlkIGluIGBQcmlzbS5sYW5ndWFnZXNgKSB0aGF0IGNvbnRhaW5zIHRoZVxuXHRcdFx0ICogb2JqZWN0IHRvIGJlIG1vZGlmaWVkLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGJlZm9yZSBUaGUga2V5IHRvIGluc2VydCBiZWZvcmUuXG5cdFx0XHQgKiBAcGFyYW0ge0dyYW1tYXJ9IGluc2VydCBBbiBvYmplY3QgY29udGFpbmluZyB0aGUga2V5LXZhbHVlIHBhaXJzIHRvIGJlIGluc2VydGVkLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbcm9vdF0gVGhlIG9iamVjdCBjb250YWluaW5nIGBpbnNpZGVgLCBpLmUuIHRoZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcblx0XHRcdCAqIG9iamVjdCB0byBiZSBtb2RpZmllZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBEZWZhdWx0cyB0byBgUHJpc20ubGFuZ3VhZ2VzYC5cblx0XHRcdCAqIEByZXR1cm5zIHtHcmFtbWFyfSBUaGUgbmV3IGdyYW1tYXIgb2JqZWN0LlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChpbnNpZGUsIGJlZm9yZSwgaW5zZXJ0LCByb290KSB7XG5cdFx0XHRcdHJvb3QgPSByb290IHx8IC8qKiBAdHlwZSB7YW55fSAqLyAoXy5sYW5ndWFnZXMpO1xuXHRcdFx0XHR2YXIgZ3JhbW1hciA9IHJvb3RbaW5zaWRlXTtcblx0XHRcdFx0LyoqIEB0eXBlIHtHcmFtbWFyfSAqL1xuXHRcdFx0XHR2YXIgcmV0ID0ge307XG5cblx0XHRcdFx0Zm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuXHRcdFx0XHRcdGlmIChncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuXG5cdFx0XHRcdFx0XHRpZiAodG9rZW4gPT0gYmVmb3JlKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG5ld1Rva2VuIGluIGluc2VydCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpbnNlcnQuaGFzT3duUHJvcGVydHkobmV3VG9rZW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXRbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gRG8gbm90IGluc2VydCB0b2tlbiB3aGljaCBhbHNvIG9jY3VyIGluIGluc2VydC4gU2VlICMxNTI1XG5cdFx0XHRcdFx0XHRpZiAoIWluc2VydC5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcblx0XHRcdFx0XHRcdFx0cmV0W3Rva2VuXSA9IGdyYW1tYXJbdG9rZW5dO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvbGQgPSByb290W2luc2lkZV07XG5cdFx0XHRcdHJvb3RbaW5zaWRlXSA9IHJldDtcblxuXHRcdFx0XHQvLyBVcGRhdGUgcmVmZXJlbmNlcyBpbiBvdGhlciBsYW5ndWFnZSBkZWZpbml0aW9uc1xuXHRcdFx0XHRfLmxhbmd1YWdlcy5ERlMoXy5sYW5ndWFnZXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBvbGQgJiYga2V5ICE9IGluc2lkZSkge1xuXHRcdFx0XHRcdFx0dGhpc1trZXldID0gcmV0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRyYXZlcnNlIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiB3aXRoIERlcHRoIEZpcnN0IFNlYXJjaFxuXHRcdFx0REZTOiBmdW5jdGlvbiBERlMobywgY2FsbGJhY2ssIHR5cGUsIHZpc2l0ZWQpIHtcblx0XHRcdFx0dmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG5cblx0XHRcdFx0dmFyIG9iaklkID0gXy51dGlsLm9iaklkO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgaW4gbykge1xuXHRcdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG5cblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eSA9IG9baV07XG5cdFx0XHRcdFx0XHR2YXIgcHJvcGVydHlUeXBlID0gXy51dGlsLnR5cGUocHJvcGVydHkpO1xuXG5cdFx0XHRcdFx0XHRpZiAocHJvcGVydHlUeXBlID09PSAnT2JqZWN0JyAmJiAhdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldKSB7XG5cdFx0XHRcdFx0XHRcdHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIG51bGwsIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwcm9wZXJ0eVR5cGUgPT09ICdBcnJheScgJiYgIXZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSkge1xuXHRcdFx0XHRcdFx0XHR2aXNpdGVkW29iaklkKHByb3BlcnR5KV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRERlMocHJvcGVydHksIGNhbGxiYWNrLCBpLCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cGx1Z2luczoge30sXG5cblxuXHRcdC8qKlxuXHRcdCAqIExvdy1sZXZlbCBmdW5jdGlvbiwgb25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3XigJlyZSBkb2luZy4gSXQgYWNjZXB0cyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0XG5cdFx0ICogYW5kIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyB0byB1c2UsIGFuZCByZXR1cm5zIGEgc3RyaW5nIHdpdGggdGhlIEhUTUwgcHJvZHVjZWQuXG5cdFx0ICpcblx0XHQgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuXHRcdCAqIDEuIGBiZWZvcmUtdG9rZW5pemVgXG5cdFx0ICogMi4gYGFmdGVyLXRva2VuaXplYFxuXHRcdCAqIDMuIGB3cmFwYDogT24gZWFjaCB7QGxpbmsgVG9rZW59LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHQgQSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0byBiZSBoaWdobGlnaHRlZC5cblx0XHQgKiBAcGFyYW0ge0dyYW1tYXJ9IGdyYW1tYXIgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRva2VucyB0byB1c2UuXG5cdFx0ICpcblx0XHQgKiBVc3VhbGx5IGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBsaWtlIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gcGFzc2VkIHRvIGBncmFtbWFyYC5cblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaGlnaGxpZ2h0ZWQgSFRNTC5cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBQcmlzbS5oaWdobGlnaHQoJ3ZhciBmb28gPSB0cnVlOycsIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0LCAnamF2YXNjcmlwdCcpO1xuXHRcdCAqL1xuXHRcdGhpZ2hsaWdodDogZnVuY3Rpb24gKHRleHQsIGdyYW1tYXIsIGxhbmd1YWdlKSB7XG5cdFx0XHR2YXIgZW52ID0ge1xuXHRcdFx0XHRjb2RlOiB0ZXh0LFxuXHRcdFx0XHRncmFtbWFyOiBncmFtbWFyLFxuXHRcdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2Vcblx0XHRcdH07XG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLXRva2VuaXplJywgZW52KTtcblx0XHRcdGVudi50b2tlbnMgPSBfLnRva2VuaXplKGVudi5jb2RlLCBlbnYuZ3JhbW1hcik7XG5cdFx0XHRfLmhvb2tzLnJ1bignYWZ0ZXItdG9rZW5pemUnLCBlbnYpO1xuXHRcdFx0cmV0dXJuIFRva2VuLnN0cmluZ2lmeShfLnV0aWwuZW5jb2RlKGVudi50b2tlbnMpLCBlbnYubGFuZ3VhZ2UpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGlzIHRoZSBoZWFydCBvZiBQcmlzbSwgYW5kIHRoZSBtb3N0IGxvdy1sZXZlbCBmdW5jdGlvbiB5b3UgY2FuIHVzZS4gSXQgYWNjZXB0cyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0XG5cdFx0ICogYW5kIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyB0byB1c2UsIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIHRva2VuaXplZCBjb2RlLlxuXHRcdCAqXG5cdFx0ICogV2hlbiB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBpbmNsdWRlcyBuZXN0ZWQgdG9rZW5zLCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5IG9uIGVhY2ggb2YgdGhlc2UgdG9rZW5zLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBtZXRob2QgY291bGQgYmUgdXNlZnVsIGluIG90aGVyIGNvbnRleHRzIGFzIHdlbGwsIGFzIGEgdmVyeSBjcnVkZSBwYXJzZXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBBIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGJlIGhpZ2hsaWdodGVkLlxuXHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gZ3JhbW1hciBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW5zIHRvIHVzZS5cblx0XHQgKlxuXHRcdCAqIFVzdWFsbHkgYSBsYW5ndWFnZSBkZWZpbml0aW9uIGxpa2UgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgLlxuXHRcdCAqIEByZXR1cm5zIHtUb2tlblN0cmVhbX0gQW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgdG9rZW5zLCBhIHRva2VuIHN0cmVhbS5cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBsZXQgY29kZSA9IGB2YXIgZm9vID0gMDtgO1xuXHRcdCAqIGxldCB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShjb2RlLCBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCk7XG5cdFx0ICogdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xuXHRcdCAqICAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBQcmlzbS5Ub2tlbiAmJiB0b2tlbi50eXBlID09PSAnbnVtYmVyJykge1xuXHRcdCAqICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIG51bWVyaWMgbGl0ZXJhbDogJHt0b2tlbi5jb250ZW50fWApO1xuXHRcdCAqICAgICB9XG5cdFx0ICogfSk7XG5cdFx0ICovXG5cdFx0dG9rZW5pemU6IGZ1bmN0aW9uICh0ZXh0LCBncmFtbWFyKSB7XG5cdFx0XHR2YXIgcmVzdCA9IGdyYW1tYXIucmVzdDtcblx0XHRcdGlmIChyZXN0KSB7XG5cdFx0XHRcdGZvciAodmFyIHRva2VuIGluIHJlc3QpIHtcblx0XHRcdFx0XHRncmFtbWFyW3Rva2VuXSA9IHJlc3RbdG9rZW5dO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGdyYW1tYXIucmVzdDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRva2VuTGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5cdFx0XHRhZGRBZnRlcih0b2tlbkxpc3QsIHRva2VuTGlzdC5oZWFkLCB0ZXh0KTtcblxuXHRcdFx0bWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgdG9rZW5MaXN0LmhlYWQsIDApO1xuXG5cdFx0XHRyZXR1cm4gdG9BcnJheSh0b2tlbkxpc3QpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAbmFtZXNwYWNlXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGhvb2tzOiB7XG5cdFx0XHRhbGw6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFkZHMgdGhlIGdpdmVuIGNhbGxiYWNrIHRvIHRoZSBsaXN0IG9mIGNhbGxiYWNrcyBmb3IgdGhlIGdpdmVuIGhvb2suXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBob29rIGl0IGlzIHJlZ2lzdGVyZWQgZm9yIGlzIHJ1bi5cblx0XHRcdCAqIEhvb2tzIGFyZSB1c3VhbGx5IGRpcmVjdGx5IHJ1biBieSBhIGhpZ2hsaWdodCBmdW5jdGlvbiBidXQgeW91IGNhbiBhbHNvIHJ1biBob29rcyB5b3Vyc2VsZi5cblx0XHRcdCAqXG5cdFx0XHQgKiBPbmUgY2FsbGJhY2sgZnVuY3Rpb24gY2FuIGJlIHJlZ2lzdGVyZWQgdG8gbXVsdGlwbGUgaG9va3MgYW5kIHRoZSBzYW1lIGhvb2sgbXVsdGlwbGUgdGltZXMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2suXG5cdFx0XHQgKiBAcGFyYW0ge0hvb2tDYWxsYmFja30gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGdpdmVuIGVudmlyb25tZW50IHZhcmlhYmxlcy5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqL1xuXHRcdFx0YWRkOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIGhvb2tzID0gXy5ob29rcy5hbGw7XG5cblx0XHRcdFx0aG9va3NbbmFtZV0gPSBob29rc1tuYW1lXSB8fCBbXTtcblxuXHRcdFx0XHRob29rc1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUnVucyBhIGhvb2sgaW52b2tpbmcgYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGVudmlyb25tZW50IHZhcmlhYmxlcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBDYWxsYmFja3Mgd2lsbCBiZSBpbnZva2VkIHN5bmNocm9ub3VzbHkgYW5kIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgcmVnaXN0ZXJlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gZW52IFRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb2YgdGhlIGhvb2sgcGFzc2VkIHRvIGFsbCBjYWxsYmFja3MgcmVnaXN0ZXJlZC5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqL1xuXHRcdFx0cnVuOiBmdW5jdGlvbiAobmFtZSwgZW52KSB7XG5cdFx0XHRcdHZhciBjYWxsYmFja3MgPSBfLmhvb2tzLmFsbFtuYW1lXTtcblxuXHRcdFx0XHRpZiAoIWNhbGxiYWNrcyB8fCAhY2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBjYWxsYmFjazsgKGNhbGxiYWNrID0gY2FsbGJhY2tzW2krK10pOykge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVudik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0VG9rZW46IFRva2VuXG5cdH07XG5cblxuXHQvLyBUeXBlc2NyaXB0IG5vdGU6XG5cdC8vIFRoZSBmb2xsb3dpbmcgY2FuIGJlIHVzZWQgdG8gaW1wb3J0IHRoZSBUb2tlbiB0eXBlIGluIEpTRG9jOlxuXHQvL1xuXHQvLyAgIEB0eXBlZGVmIHtJbnN0YW5jZVR5cGU8aW1wb3J0KFwiLi9wcmlzbS1jb3JlXCIpW1wiVG9rZW5cIl0+fSBUb2tlblxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHRva2VuLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBTZWUge0BsaW5rIFRva2VuI3R5cGUgdHlwZX1cblx0ICogQHBhcmFtIHtzdHJpbmcgfCBUb2tlblN0cmVhbX0gY29udGVudCBTZWUge0BsaW5rIFRva2VuI2NvbnRlbnQgY29udGVudH1cblx0ICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IFthbGlhc10gVGhlIGFsaWFzKGVzKSBvZiB0aGUgdG9rZW4uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbWF0Y2hlZFN0cj1cIlwiXSBBIGNvcHkgb2YgdGhlIGZ1bGwgc3RyaW5nIHRoaXMgdG9rZW4gd2FzIGNyZWF0ZWQgZnJvbS5cblx0ICogQGNsYXNzXG5cdCAqIEBnbG9iYWxcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gVG9rZW4odHlwZSwgY29udGVudCwgYWxpYXMsIG1hdGNoZWRTdHIpIHtcblx0XHQvKipcblx0XHQgKiBUaGUgdHlwZSBvZiB0aGUgdG9rZW4uXG5cdFx0ICpcblx0XHQgKiBUaGlzIGlzIHVzdWFsbHkgdGhlIGtleSBvZiBhIHBhdHRlcm4gaW4gYSB7QGxpbmsgR3JhbW1hcn0uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBzZWUgR3JhbW1hclRva2VuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0LyoqXG5cdFx0ICogVGhlIHN0cmluZ3Mgb3IgdG9rZW5zIGNvbnRhaW5lZCBieSB0aGlzIHRva2VuLlxuXHRcdCAqXG5cdFx0ICogVGhpcyB3aWxsIGJlIGEgdG9rZW4gc3RyZWFtIGlmIHRoZSBwYXR0ZXJuIG1hdGNoZWQgYWxzbyBkZWZpbmVkIGFuIGBpbnNpZGVgIGdyYW1tYXIuXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nIHwgVG9rZW5TdHJlYW19XG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGFsaWFzKGVzKSBvZiB0aGUgdG9rZW4uXG5cdFx0ICpcblx0XHQgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfVxuXHRcdCAqIEBzZWUgR3JhbW1hclRva2VuXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdHRoaXMuYWxpYXMgPSBhbGlhcztcblx0XHQvLyBDb3B5IG9mIHRoZSBmdWxsIHN0cmluZyB0aGlzIHRva2VuIHdhcyBjcmVhdGVkIGZyb21cblx0XHR0aGlzLmxlbmd0aCA9IChtYXRjaGVkU3RyIHx8ICcnKS5sZW5ndGggfCAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgdG9rZW4gc3RyZWFtIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHtAbGluayBUb2tlbiBUb2tlbn0gb2JqZWN0cy5cblx0ICpcblx0ICogVG9rZW4gc3RyZWFtcyBoYXZlIHRvIGZ1bGZpbGwgYSBmZXcgcHJvcGVydGllcyB0aGF0IGFyZSBhc3N1bWVkIGJ5IG1vc3QgZnVuY3Rpb25zIChtb3N0bHkgaW50ZXJuYWwgb25lcykgdGhhdCBwcm9jZXNzXG5cdCAqIHRoZW0uXG5cdCAqXG5cdCAqIDEuIE5vIGFkamFjZW50IHN0cmluZ3MuXG5cdCAqIDIuIE5vIGVtcHR5IHN0cmluZ3MuXG5cdCAqXG5cdCAqICAgIFRoZSBvbmx5IGV4Y2VwdGlvbiBoZXJlIGlzIHRoZSB0b2tlbiBzdHJlYW0gdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBlbXB0eSBzdHJpbmcgYW5kIG5vdGhpbmcgZWxzZS5cblx0ICpcblx0ICogQHR5cGVkZWYge0FycmF5PHN0cmluZyB8IFRva2VuPn0gVG9rZW5TdHJlYW1cblx0ICogQGdsb2JhbFxuXHQgKiBAcHVibGljXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdG9rZW4gb3IgdG9rZW4gc3RyZWFtIHRvIGFuIEhUTUwgcmVwcmVzZW50YXRpb24uXG5cdCAqXG5cdCAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG5cdCAqIDEuIGB3cmFwYDogT24gZWFjaCB7QGxpbmsgVG9rZW59LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuIHwgVG9rZW5TdHJlYW19IG8gVGhlIHRva2VuIG9yIHRva2VuIHN0cmVhbSB0byBiZSBjb252ZXJ0ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZSBUaGUgbmFtZSBvZiBjdXJyZW50IGxhbmd1YWdlLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgSFRNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9rZW4gb3IgdG9rZW4gc3RyZWFtLlxuXHQgKiBAbWVtYmVyb2YgVG9rZW5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0VG9rZW4uc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KG8sIGxhbmd1YWdlKSB7XG5cdFx0aWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gbztcblx0XHR9XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkobykpIHtcblx0XHRcdHZhciBzID0gJyc7XG5cdFx0XHRvLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0cyArPSBzdHJpbmdpZnkoZSwgbGFuZ3VhZ2UpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcztcblx0XHR9XG5cblx0XHR2YXIgZW52ID0ge1xuXHRcdFx0dHlwZTogby50eXBlLFxuXHRcdFx0Y29udGVudDogc3RyaW5naWZ5KG8uY29udGVudCwgbGFuZ3VhZ2UpLFxuXHRcdFx0dGFnOiAnc3BhbicsXG5cdFx0XHRjbGFzc2VzOiBbJ3Rva2VuJywgby50eXBlXSxcblx0XHRcdGF0dHJpYnV0ZXM6IHt9LFxuXHRcdFx0bGFuZ3VhZ2U6IGxhbmd1YWdlXG5cdFx0fTtcblxuXHRcdHZhciBhbGlhc2VzID0gby5hbGlhcztcblx0XHRpZiAoYWxpYXNlcykge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYWxpYXNlcykpIHtcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW52LmNsYXNzZXMsIGFsaWFzZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZW52LmNsYXNzZXMucHVzaChhbGlhc2VzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRfLmhvb2tzLnJ1bignd3JhcCcsIGVudik7XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9ICcnO1xuXHRcdGZvciAodmFyIG5hbWUgaW4gZW52LmF0dHJpYnV0ZXMpIHtcblx0XHRcdGF0dHJpYnV0ZXMgKz0gJyAnICsgbmFtZSArICc9XCInICsgKGVudi5hdHRyaWJ1dGVzW25hbWVdIHx8ICcnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykgKyAnXCInO1xuXHRcdH1cblxuXHRcdHJldHVybiAnPCcgKyBlbnYudGFnICsgJyBjbGFzcz1cIicgKyBlbnYuY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICsgYXR0cmlidXRlcyArICc+JyArIGVudi5jb250ZW50ICsgJzwvJyArIGVudi50YWcgKyAnPic7XG5cdH07XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7UmVnRXhwfSBwYXR0ZXJuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwb3Ncblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHRcblx0ICogQHBhcmFtIHtib29sZWFufSBsb29rYmVoaW5kXG5cdCAqIEByZXR1cm5zIHtSZWdFeHBFeGVjQXJyYXkgfCBudWxsfVxuXHQgKi9cblx0ZnVuY3Rpb24gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHBvcywgdGV4dCwgbG9va2JlaGluZCkge1xuXHRcdHBhdHRlcm4ubGFzdEluZGV4ID0gcG9zO1xuXHRcdHZhciBtYXRjaCA9IHBhdHRlcm4uZXhlYyh0ZXh0KTtcblx0XHRpZiAobWF0Y2ggJiYgbG9va2JlaGluZCAmJiBtYXRjaFsxXSkge1xuXHRcdFx0Ly8gY2hhbmdlIHRoZSBtYXRjaCB0byByZW1vdmUgdGhlIHRleHQgbWF0Y2hlZCBieSB0aGUgUHJpc20gbG9va2JlaGluZCBncm91cFxuXHRcdFx0dmFyIGxvb2tiZWhpbmRMZW5ndGggPSBtYXRjaFsxXS5sZW5ndGg7XG5cdFx0XHRtYXRjaC5pbmRleCArPSBsb29rYmVoaW5kTGVuZ3RoO1xuXHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZShsb29rYmVoaW5kTGVuZ3RoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hdGNoO1xuXHR9XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxzdHJpbmcgfCBUb2tlbj59IHRva2VuTGlzdFxuXHQgKiBAcGFyYW0ge2FueX0gZ3JhbW1hclxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPHN0cmluZyB8IFRva2VuPn0gc3RhcnROb2RlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFBvc1xuXHQgKiBAcGFyYW0ge1JlbWF0Y2hPcHRpb25zfSBbcmVtYXRjaF1cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqIEBwcml2YXRlXG5cdCAqXG5cdCAqIEB0eXBlZGVmIFJlbWF0Y2hPcHRpb25zXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjYXVzZVxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gcmVhY2hcblx0ICovXG5cdGZ1bmN0aW9uIG1hdGNoR3JhbW1hcih0ZXh0LCB0b2tlbkxpc3QsIGdyYW1tYXIsIHN0YXJ0Tm9kZSwgc3RhcnRQb3MsIHJlbWF0Y2gpIHtcblx0XHRmb3IgKHZhciB0b2tlbiBpbiBncmFtbWFyKSB7XG5cdFx0XHRpZiAoIWdyYW1tYXIuaGFzT3duUHJvcGVydHkodG9rZW4pIHx8ICFncmFtbWFyW3Rva2VuXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHBhdHRlcm5zID0gZ3JhbW1hclt0b2tlbl07XG5cdFx0XHRwYXR0ZXJucyA9IEFycmF5LmlzQXJyYXkocGF0dGVybnMpID8gcGF0dGVybnMgOiBbcGF0dGVybnNdO1xuXG5cdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IHBhdHRlcm5zLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGlmIChyZW1hdGNoICYmIHJlbWF0Y2guY2F1c2UgPT0gdG9rZW4gKyAnLCcgKyBqKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHBhdHRlcm5PYmogPSBwYXR0ZXJuc1tqXTtcblx0XHRcdFx0dmFyIGluc2lkZSA9IHBhdHRlcm5PYmouaW5zaWRlO1xuXHRcdFx0XHR2YXIgbG9va2JlaGluZCA9ICEhcGF0dGVybk9iai5sb29rYmVoaW5kO1xuXHRcdFx0XHR2YXIgZ3JlZWR5ID0gISFwYXR0ZXJuT2JqLmdyZWVkeTtcblx0XHRcdFx0dmFyIGFsaWFzID0gcGF0dGVybk9iai5hbGlhcztcblxuXHRcdFx0XHRpZiAoZ3JlZWR5ICYmICFwYXR0ZXJuT2JqLnBhdHRlcm4uZ2xvYmFsKSB7XG5cdFx0XHRcdFx0Ly8gV2l0aG91dCB0aGUgZ2xvYmFsIGZsYWcsIGxhc3RJbmRleCB3b24ndCB3b3JrXG5cdFx0XHRcdFx0dmFyIGZsYWdzID0gcGF0dGVybk9iai5wYXR0ZXJuLnRvU3RyaW5nKCkubWF0Y2goL1tpbXN1eV0qJC8pWzBdO1xuXHRcdFx0XHRcdHBhdHRlcm5PYmoucGF0dGVybiA9IFJlZ0V4cChwYXR0ZXJuT2JqLnBhdHRlcm4uc291cmNlLCBmbGFncyArICdnJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiogQHR5cGUge1JlZ0V4cH0gKi9cblx0XHRcdFx0dmFyIHBhdHRlcm4gPSBwYXR0ZXJuT2JqLnBhdHRlcm4gfHwgcGF0dGVybk9iajtcblxuXHRcdFx0XHRmb3IgKCAvLyBpdGVyYXRlIHRoZSB0b2tlbiBsaXN0IGFuZCBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHRva2VuL3N0cmluZyBwb3NpdGlvblxuXHRcdFx0XHRcdHZhciBjdXJyZW50Tm9kZSA9IHN0YXJ0Tm9kZS5uZXh0LCBwb3MgPSBzdGFydFBvcztcblx0XHRcdFx0XHRjdXJyZW50Tm9kZSAhPT0gdG9rZW5MaXN0LnRhaWw7XG5cdFx0XHRcdFx0cG9zICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aCwgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0XG5cdFx0XHRcdCkge1xuXG5cdFx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgcG9zID49IHJlbWF0Y2gucmVhY2gpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBzdHIgPSBjdXJyZW50Tm9kZS52YWx1ZTtcblxuXHRcdFx0XHRcdGlmICh0b2tlbkxpc3QubGVuZ3RoID4gdGV4dC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdC8vIFNvbWV0aGluZyB3ZW50IHRlcnJpYmx5IHdyb25nLCBBQk9SVCwgQUJPUlQhXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHN0ciBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgcmVtb3ZlQ291bnQgPSAxOyAvLyB0aGlzIGlzIHRoZSB0byBwYXJhbWV0ZXIgb2YgcmVtb3ZlQmV0d2VlblxuXHRcdFx0XHRcdHZhciBtYXRjaDtcblxuXHRcdFx0XHRcdGlmIChncmVlZHkpIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIHBvcywgdGV4dCwgbG9va2JlaGluZCk7XG5cdFx0XHRcdFx0XHRpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ID49IHRleHQubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR2YXIgZnJvbSA9IG1hdGNoLmluZGV4O1xuXHRcdFx0XHRcdFx0dmFyIHRvID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR2YXIgcCA9IHBvcztcblxuXHRcdFx0XHRcdFx0Ly8gZmluZCB0aGUgbm9kZSB0aGF0IGNvbnRhaW5zIHRoZSBtYXRjaFxuXHRcdFx0XHRcdFx0cCArPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA+PSBwKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubmV4dDtcblx0XHRcdFx0XHRcdFx0cCArPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBhZGp1c3QgcG9zIChhbmQgcClcblx0XHRcdFx0XHRcdHAgLT0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0cG9zID0gcDtcblxuXHRcdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgbm9kZSBpcyBhIFRva2VuLCB0aGVuIHRoZSBtYXRjaCBzdGFydHMgaW5zaWRlIGFub3RoZXIgVG9rZW4sIHdoaWNoIGlzIGludmFsaWRcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50Tm9kZS52YWx1ZSBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBmaW5kIHRoZSBsYXN0IG5vZGUgd2hpY2ggaXMgYWZmZWN0ZWQgYnkgdGhpcyBtYXRjaFxuXHRcdFx0XHRcdFx0Zm9yIChcblx0XHRcdFx0XHRcdFx0dmFyIGsgPSBjdXJyZW50Tm9kZTtcblx0XHRcdFx0XHRcdFx0ayAhPT0gdG9rZW5MaXN0LnRhaWwgJiYgKHAgPCB0byB8fCB0eXBlb2Ygay52YWx1ZSA9PT0gJ3N0cmluZycpO1xuXHRcdFx0XHRcdFx0XHRrID0gay5uZXh0XG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlQ291bnQrKztcblx0XHRcdFx0XHRcdFx0cCArPSBrLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlbW92ZUNvdW50LS07XG5cblx0XHRcdFx0XHRcdC8vIHJlcGxhY2Ugd2l0aCB0aGUgbmV3IG1hdGNoXG5cdFx0XHRcdFx0XHRzdHIgPSB0ZXh0LnNsaWNlKHBvcywgcCk7XG5cdFx0XHRcdFx0XHRtYXRjaC5pbmRleCAtPSBwb3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gbWF0Y2hQYXR0ZXJuKHBhdHRlcm4sIDAsIHN0ciwgbG9va2JlaGluZCk7XG5cdFx0XHRcdFx0XHRpZiAoIW1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblx0XHRcdFx0XHR2YXIgZnJvbSA9IG1hdGNoLmluZGV4O1xuXHRcdFx0XHRcdHZhciBtYXRjaFN0ciA9IG1hdGNoWzBdO1xuXHRcdFx0XHRcdHZhciBiZWZvcmUgPSBzdHIuc2xpY2UoMCwgZnJvbSk7XG5cdFx0XHRcdFx0dmFyIGFmdGVyID0gc3RyLnNsaWNlKGZyb20gKyBtYXRjaFN0ci5sZW5ndGgpO1xuXG5cdFx0XHRcdFx0dmFyIHJlYWNoID0gcG9zICsgc3RyLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAocmVtYXRjaCAmJiByZWFjaCA+IHJlbWF0Y2gucmVhY2gpIHtcblx0XHRcdFx0XHRcdHJlbWF0Y2gucmVhY2ggPSByZWFjaDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgcmVtb3ZlRnJvbSA9IGN1cnJlbnROb2RlLnByZXY7XG5cblx0XHRcdFx0XHRpZiAoYmVmb3JlKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVGcm9tID0gYWRkQWZ0ZXIodG9rZW5MaXN0LCByZW1vdmVGcm9tLCBiZWZvcmUpO1xuXHRcdFx0XHRcdFx0cG9zICs9IGJlZm9yZS5sZW5ndGg7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVtb3ZlUmFuZ2UodG9rZW5MaXN0LCByZW1vdmVGcm9tLCByZW1vdmVDb3VudCk7XG5cblx0XHRcdFx0XHR2YXIgd3JhcHBlZCA9IG5ldyBUb2tlbih0b2tlbiwgaW5zaWRlID8gXy50b2tlbml6ZShtYXRjaFN0ciwgaW5zaWRlKSA6IG1hdGNoU3RyLCBhbGlhcywgbWF0Y2hTdHIpO1xuXHRcdFx0XHRcdGN1cnJlbnROb2RlID0gYWRkQWZ0ZXIodG9rZW5MaXN0LCByZW1vdmVGcm9tLCB3cmFwcGVkKTtcblxuXHRcdFx0XHRcdGlmIChhZnRlcikge1xuXHRcdFx0XHRcdFx0YWRkQWZ0ZXIodG9rZW5MaXN0LCBjdXJyZW50Tm9kZSwgYWZ0ZXIpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChyZW1vdmVDb3VudCA+IDEpIHtcblx0XHRcdFx0XHRcdC8vIGF0IGxlYXN0IG9uZSBUb2tlbiBvYmplY3Qgd2FzIHJlbW92ZWQsIHNvIHdlIGhhdmUgdG8gZG8gc29tZSByZW1hdGNoaW5nXG5cdFx0XHRcdFx0XHQvLyB0aGlzIGNhbiBvbmx5IGhhcHBlbiBpZiB0aGUgY3VycmVudCBwYXR0ZXJuIGlzIGdyZWVkeVxuXG5cdFx0XHRcdFx0XHQvKiogQHR5cGUge1JlbWF0Y2hPcHRpb25zfSAqL1xuXHRcdFx0XHRcdFx0dmFyIG5lc3RlZFJlbWF0Y2ggPSB7XG5cdFx0XHRcdFx0XHRcdGNhdXNlOiB0b2tlbiArICcsJyArIGosXG5cdFx0XHRcdFx0XHRcdHJlYWNoOiByZWFjaFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdG1hdGNoR3JhbW1hcih0ZXh0LCB0b2tlbkxpc3QsIGdyYW1tYXIsIGN1cnJlbnROb2RlLnByZXYsIHBvcywgbmVzdGVkUmVtYXRjaCk7XG5cblx0XHRcdFx0XHRcdC8vIHRoZSByZWFjaCBtaWdodCBoYXZlIGJlZW4gZXh0ZW5kZWQgYmVjYXVzZSBvZiB0aGUgcmVtYXRjaGluZ1xuXHRcdFx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgbmVzdGVkUmVtYXRjaC5yZWFjaCA+IHJlbWF0Y2gucmVhY2gpIHtcblx0XHRcdFx0XHRcdFx0cmVtYXRjaC5yZWFjaCA9IG5lc3RlZFJlbWF0Y2gucmVhY2g7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEB0eXBlZGVmIExpbmtlZExpc3ROb2RlXG5cdCAqIEBwcm9wZXJ0eSB7VH0gdmFsdWVcblx0ICogQHByb3BlcnR5IHtMaW5rZWRMaXN0Tm9kZTxUPiB8IG51bGx9IHByZXYgVGhlIHByZXZpb3VzIG5vZGUuXG5cdCAqIEBwcm9wZXJ0eSB7TGlua2VkTGlzdE5vZGU8VD4gfCBudWxsfSBuZXh0IFRoZSBuZXh0IG5vZGUuXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gTGlua2VkTGlzdCgpIHtcblx0XHQvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuXHRcdHZhciBoZWFkID0geyB2YWx1ZTogbnVsbCwgcHJldjogbnVsbCwgbmV4dDogbnVsbCB9O1xuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dmFyIHRhaWwgPSB7IHZhbHVlOiBudWxsLCBwcmV2OiBoZWFkLCBuZXh0OiBudWxsIH07XG5cdFx0aGVhZC5uZXh0ID0gdGFpbDtcblxuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dGhpcy5oZWFkID0gaGVhZDtcblx0XHQvKiogQHR5cGUge0xpbmtlZExpc3ROb2RlPFQ+fSAqL1xuXHRcdHRoaXMudGFpbCA9IHRhaWw7XG5cdFx0dGhpcy5sZW5ndGggPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBuZXcgbm9kZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgbGlzdC5cblx0ICpcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8VD59IG5vZGVcblx0ICogQHBhcmFtIHtUfSB2YWx1ZVxuXHQgKiBAcmV0dXJucyB7TGlua2VkTGlzdE5vZGU8VD59IFRoZSBhZGRlZCBub2RlLlxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkQWZ0ZXIobGlzdCwgbm9kZSwgdmFsdWUpIHtcblx0XHQvLyBhc3N1bWVzIHRoYXQgbm9kZSAhPSBsaXN0LnRhaWwgJiYgdmFsdWVzLmxlbmd0aCA+PSAwXG5cdFx0dmFyIG5leHQgPSBub2RlLm5leHQ7XG5cblx0XHR2YXIgbmV3Tm9kZSA9IHsgdmFsdWU6IHZhbHVlLCBwcmV2OiBub2RlLCBuZXh0OiBuZXh0IH07XG5cdFx0bm9kZS5uZXh0ID0gbmV3Tm9kZTtcblx0XHRuZXh0LnByZXYgPSBuZXdOb2RlO1xuXHRcdGxpc3QubGVuZ3RoKys7XG5cblx0XHRyZXR1cm4gbmV3Tm9kZTtcblx0fVxuXHQvKipcblx0ICogUmVtb3ZlcyBgY291bnRgIG5vZGVzIGFmdGVyIHRoZSBnaXZlbiBub2RlLiBUaGUgZ2l2ZW4gbm9kZSB3aWxsIG5vdCBiZSByZW1vdmVkLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3Rcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0Tm9kZTxUPn0gbm9kZVxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnRcblx0ICogQHRlbXBsYXRlIFRcblx0ICovXG5cdGZ1bmN0aW9uIHJlbW92ZVJhbmdlKGxpc3QsIG5vZGUsIGNvdW50KSB7XG5cdFx0dmFyIG5leHQgPSBub2RlLm5leHQ7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCAmJiBuZXh0ICE9PSBsaXN0LnRhaWw7IGkrKykge1xuXHRcdFx0bmV4dCA9IG5leHQubmV4dDtcblx0XHR9XG5cdFx0bm9kZS5uZXh0ID0gbmV4dDtcblx0XHRuZXh0LnByZXYgPSBub2RlO1xuXHRcdGxpc3QubGVuZ3RoIC09IGk7XG5cdH1cblx0LyoqXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxUPn0gbGlzdFxuXHQgKiBAcmV0dXJucyB7VFtdfVxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BcnJheShsaXN0KSB7XG5cdFx0dmFyIGFycmF5ID0gW107XG5cdFx0dmFyIG5vZGUgPSBsaXN0LmhlYWQubmV4dDtcblx0XHR3aGlsZSAobm9kZSAhPT0gbGlzdC50YWlsKSB7XG5cdFx0XHRhcnJheS5wdXNoKG5vZGUudmFsdWUpO1xuXHRcdFx0bm9kZSA9IG5vZGUubmV4dDtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9XG5cblx0cmV0dXJuIF87XG5cbn0oKSk7XG5cbnZhciBwcmlzbSA9IFByaXNtO1xuUHJpc20uZGVmYXVsdCA9IFByaXNtO1xuXG4vKiBUaGlzIGNvbnRlbnQgaXMgYXV0by1nZW5lcmF0ZWQgdG8gaW5jbHVkZSBzb21lIHByaXNtanMgbGFuZ3VhZ2UgY29tcG9uZW50czogKi9cblxuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFya3VwXCIgKi9cblxucHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCA9IHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogLzwhLS0oPzooPyE8IS0tKVtcXHNcXFNdKSo/LS0+LyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3Byb2xvZyc6IHtcbiAgICBwYXR0ZXJuOiAvPFxcP1tcXHNcXFNdKz9cXD8+LyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2RvY3R5cGUnOiB7XG4gICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3htbC8jTlQtZG9jdHlwZWRlY2xcbiAgICBwYXR0ZXJuOiAvPCFET0NUWVBFKD86W14+XCInW1xcXV18XCJbXlwiXSpcInwnW14nXSonKSsoPzpcXFsoPzpbXjxcIidcXF1dfFwiW15cIl0qXCJ8J1teJ10qJ3w8KD8hIS0tKXw8IS0tKD86W14tXXwtKD8hLT4pKSotLT4pKlxcXVxccyopPz4vaSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnaW50ZXJuYWwtc3Vic2V0Jzoge1xuICAgICAgICBwYXR0ZXJuOiAvKF5bXlxcW10qXFxbKVtcXHNcXFNdKyg/PVxcXT4kKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiBudWxsIC8vIHNlZSBiZWxvd1xuXG4gICAgICB9LFxuICAgICAgJ3N0cmluZyc6IHtcbiAgICAgICAgcGF0dGVybjogL1wiW15cIl0qXCJ8J1teJ10qJy8sXG4gICAgICAgIGdyZWVkeTogdHJ1ZVxuICAgICAgfSxcbiAgICAgICdwdW5jdHVhdGlvbic6IC9ePCF8PiR8W1tcXF1dLyxcbiAgICAgICdkb2N0eXBlLXRhZyc6IC9eRE9DVFlQRS9pLFxuICAgICAgJ25hbWUnOiAvW15cXHM8PidcIl0rL1xuICAgIH1cbiAgfSxcbiAgJ2NkYXRhJzoge1xuICAgIHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3RhZyc6IHtcbiAgICBwYXR0ZXJuOiAvPFxcLz8oPyFcXGQpW15cXHM+XFwvPSQ8JV0rKD86XFxzKD86XFxzKlteXFxzPlxcLz1dKyg/Olxccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKXwoPz1bXFxzLz5dKSkpKyk/XFxzKlxcLz8+LyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAndGFnJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXjxcXC8/W15cXHM+XFwvXSsvLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXjxcXC8/LyxcbiAgICAgICAgICAnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3NwZWNpYWwtYXR0cic6IFtdLFxuICAgICAgJ2F0dHItdmFsdWUnOiB7XG4gICAgICAgIHBhdHRlcm46IC89XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSspLyxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ3B1bmN0dWF0aW9uJzogW3tcbiAgICAgICAgICAgIHBhdHRlcm46IC9ePS8sXG4gICAgICAgICAgICBhbGlhczogJ2F0dHItZXF1YWxzJ1xuICAgICAgICAgIH0sIC9cInwnL11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdwdW5jdHVhdGlvbic6IC9cXC8/Pi8sXG4gICAgICAnYXR0ci1uYW1lJzoge1xuICAgICAgICBwYXR0ZXJuOiAvW15cXHM+XFwvXSsvLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAnZW50aXR5JzogW3tcbiAgICBwYXR0ZXJuOiAvJltcXGRhLXpdezEsOH07L2ksXG4gICAgYWxpYXM6ICduYW1lZC1lbnRpdHknXG4gIH0sIC8mI3g/W1xcZGEtZl17MSw4fTsvaV1cbn07XG5wcmlzbS5sYW5ndWFnZXMubWFya3VwWyd0YWcnXS5pbnNpZGVbJ2F0dHItdmFsdWUnXS5pbnNpZGVbJ2VudGl0eSddID0gcHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsnZW50aXR5J107XG5wcmlzbS5sYW5ndWFnZXMubWFya3VwWydkb2N0eXBlJ10uaW5zaWRlWydpbnRlcm5hbC1zdWJzZXQnXS5pbnNpZGUgPSBwcmlzbS5sYW5ndWFnZXMubWFya3VwOyAvLyBQbHVnaW4gdG8gbWFrZSBlbnRpdHkgdGl0bGUgc2hvdyB0aGUgcmVhbCBlbnRpdHksIGlkZWEgYnkgUm9tYW4gS29tYXJvdlxuXG5wcmlzbS5ob29rcy5hZGQoJ3dyYXAnLCBmdW5jdGlvbiAoZW52KSB7XG4gIGlmIChlbnYudHlwZSA9PT0gJ2VudGl0eScpIHtcbiAgICBlbnYuYXR0cmlidXRlc1sndGl0bGUnXSA9IGVudi5jb250ZW50LnJlcGxhY2UoLyZhbXA7LywgJyYnKTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRJbmxpbmVkJywge1xuICAvKipcbiAgICogQWRkcyBhbiBpbmxpbmVkIGxhbmd1YWdlIHRvIG1hcmt1cC5cbiAgICpcbiAgICogQW4gZXhhbXBsZSBvZiBhbiBpbmxpbmVkIGxhbmd1YWdlIGlzIENTUyB3aXRoIGA8c3R5bGU+YCB0YWdzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICogY2FzZSBpbnNlbnNpdGl2ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cbiAgICogQGV4YW1wbGVcbiAgICogYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyk7XG4gICAqL1xuICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5saW5lZCh0YWdOYW1lLCBsYW5nKSB7XG4gICAgdmFyIGluY2x1ZGVkQ2RhdGFJbnNpZGUgPSB7fTtcbiAgICBpbmNsdWRlZENkYXRhSW5zaWRlWydsYW5ndWFnZS0nICsgbGFuZ10gPSB7XG4gICAgICBwYXR0ZXJuOiAvKF48IVxcW0NEQVRBXFxbKVtcXHNcXFNdKz8oPz1cXF1cXF0+JCkvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlc1tsYW5nXVxuICAgIH07XG4gICAgaW5jbHVkZWRDZGF0YUluc2lkZVsnY2RhdGEnXSA9IC9ePCFcXFtDREFUQVxcW3xcXF1cXF0+JC9pO1xuICAgIHZhciBpbnNpZGUgPSB7XG4gICAgICAnaW5jbHVkZWQtY2RhdGEnOiB7XG4gICAgICAgIHBhdHRlcm46IC88IVxcW0NEQVRBXFxbW1xcc1xcU10qP1xcXVxcXT4vaSxcbiAgICAgICAgaW5zaWRlOiBpbmNsdWRlZENkYXRhSW5zaWRlXG4gICAgICB9XG4gICAgfTtcbiAgICBpbnNpZGVbJ2xhbmd1YWdlLScgKyBsYW5nXSA9IHtcbiAgICAgIHBhdHRlcm46IC9bXFxzXFxTXSsvLFxuICAgICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXNbbGFuZ11cbiAgICB9O1xuICAgIHZhciBkZWYgPSB7fTtcbiAgICBkZWZbdGFnTmFtZV0gPSB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyg8X19bXj5dKj4pKD86PCFcXFtDREFUQVxcWyg/OlteXFxdXXxcXF0oPyFcXF0+KSkqXFxdXFxdPnwoPyE8IVxcW0NEQVRBXFxbKVtcXHNcXFNdKSo/KD89PFxcL19fPikvLnNvdXJjZS5yZXBsYWNlKC9fXy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0YWdOYW1lO1xuICAgICAgfSksICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBpbnNpZGVcbiAgICB9O1xuICAgIHByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjZGF0YScsIGRlZik7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLCAnYWRkQXR0cmlidXRlJywge1xuICAvKipcbiAgICogQWRkcyBhbiBwYXR0ZXJuIHRvIGhpZ2hsaWdodCBsYW5ndWFnZXMgZW1iZWRkZWQgaW4gSFRNTCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBBbiBleGFtcGxlIG9mIGFuIGlubGluZWQgbGFuZ3VhZ2UgaXMgQ1NTIHdpdGggYHN0eWxlYCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAqIGNhc2UgaW5zZW5zaXRpdmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5nIFRoZSBsYW5ndWFnZSBrZXkuXG4gICAqIEBleGFtcGxlXG4gICAqIGFkZEF0dHJpYnV0ZSgnc3R5bGUnLCAnY3NzJyk7XG4gICAqL1xuICB2YWx1ZTogZnVuY3Rpb24gKGF0dHJOYW1lLCBsYW5nKSB7XG4gICAgcHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlWydzcGVjaWFsLWF0dHInXS5wdXNoKHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKF58W1wiJ1xcc10pLy5zb3VyY2UgKyAnKD86JyArIGF0dHJOYW1lICsgJyknICsgL1xccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKS8uc291cmNlLCAnaScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnYXR0ci1uYW1lJzogL15bXlxccz1dKy8sXG4gICAgICAgICdhdHRyLXZhbHVlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC89W1xcc1xcU10rLyxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICd2YWx1ZSc6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogLyhePVxccyooW1wiJ118KD8hW1wiJ10pKSlcXFNbXFxzXFxTXSooPz1cXDIkKS8sXG4gICAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgICAgIGFsaWFzOiBbbGFuZywgJ2xhbmd1YWdlLScgKyBsYW5nXSxcbiAgICAgICAgICAgICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXNbbGFuZ11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHVuY3R1YXRpb24nOiBbe1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvXj0vLFxuICAgICAgICAgICAgICBhbGlhczogJ2F0dHItZXF1YWxzJ1xuICAgICAgICAgICAgfSwgL1wifCcvXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59KTtcbnByaXNtLmxhbmd1YWdlcy5odG1sID0gcHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcbnByaXNtLmxhbmd1YWdlcy5tYXRobWwgPSBwcmlzbS5sYW5ndWFnZXMubWFya3VwO1xucHJpc20ubGFuZ3VhZ2VzLnN2ZyA9IHByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5wcmlzbS5sYW5ndWFnZXMueG1sID0gcHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnbWFya3VwJywge30pO1xucHJpc20ubGFuZ3VhZ2VzLnNzbWwgPSBwcmlzbS5sYW5ndWFnZXMueG1sO1xucHJpc20ubGFuZ3VhZ2VzLmF0b20gPSBwcmlzbS5sYW5ndWFnZXMueG1sO1xucHJpc20ubGFuZ3VhZ2VzLnJzcyA9IHByaXNtLmxhbmd1YWdlcy54bWw7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1iYXNoXCIgKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICAvLyAkIHNldCB8IGdyZXAgJ15bQS1aXVteWzpzcGFjZTpdXSo9JyB8IGN1dCAtZD0gLWYxIHwgdHIgJ1xcbicgJ3wnXG4gIC8vICsgTENfQUxMLCBSQU5ET00sIFJFUExZLCBTRUNPTkRTLlxuICAvLyArIG1ha2Ugc3VyZSBQUzEuLjQgYXJlIGhlcmUgYXMgdGhleSBhcmUgbm90IGFsd2F5cyBzZXQsXG4gIC8vIC0gc29tZSB1c2VsZXNzIHRoaW5ncy5cbiAgdmFyIGVudlZhcnMgPSAnXFxcXGIoPzpCQVNIfEJBU0hPUFRTfEJBU0hfQUxJQVNFU3xCQVNIX0FSR0N8QkFTSF9BUkdWfEJBU0hfQ01EU3xCQVNIX0NPTVBMRVRJT05fQ09NUEFUX0RJUnxCQVNIX0xJTkVOT3xCQVNIX1JFTUFUQ0h8QkFTSF9TT1VSQ0V8QkFTSF9WRVJTSU5GT3xCQVNIX1ZFUlNJT058Q09MT1JURVJNfENPTFVNTlN8Q09NUF9XT1JEQlJFQUtTfERCVVNfU0VTU0lPTl9CVVNfQUREUkVTU3xERUZBVUxUU19QQVRIfERFU0tUT1BfU0VTU0lPTnxESVJTVEFDS3xESVNQTEFZfEVVSUR8R0RNU0VTU0lPTnxHRE1fTEFOR3xHTk9NRV9LRVlSSU5HX0NPTlRST0x8R05PTUVfS0VZUklOR19QSUR8R1BHX0FHRU5UX0lORk98R1JPVVBTfEhJU1RDT05UUk9MfEhJU1RGSUxFfEhJU1RGSUxFU0laRXxISVNUU0laRXxIT01FfEhPU1ROQU1FfEhPU1RUWVBFfElGU3xJTlNUQU5DRXxKT0J8TEFOR3xMQU5HVUFHRXxMQ19BRERSRVNTfExDX0FMTHxMQ19JREVOVElGSUNBVElPTnxMQ19NRUFTVVJFTUVOVHxMQ19NT05FVEFSWXxMQ19OQU1FfExDX05VTUVSSUN8TENfUEFQRVJ8TENfVEVMRVBIT05FfExDX1RJTUV8TEVTU0NMT1NFfExFU1NPUEVOfExJTkVTfExPR05BTUV8TFNfQ09MT1JTfE1BQ0hUWVBFfE1BSUxDSEVDS3xNQU5EQVRPUllfUEFUSHxOT19BVF9CUklER0V8T0xEUFdEfE9QVEVSUnxPUFRJTkR8T1JCSVRfU09DS0VURElSfE9TVFlQRXxQQVBFUlNJWkV8UEFUSHxQSVBFU1RBVFVTfFBQSUR8UFMxfFBTMnxQUzN8UFM0fFBXRHxSQU5ET018UkVQTFl8U0VDT05EU3xTRUxJTlVYX0lOSVR8U0VTU0lPTnxTRVNTSU9OVFlQRXxTRVNTSU9OX01BTkFHRVJ8U0hFTEx8U0hFTExPUFRTfFNITFZMfFNTSF9BVVRIX1NPQ0t8VEVSTXxVSUR8VVBTVEFSVF9FVkVOVFN8VVBTVEFSVF9JTlNUQU5DRXxVUFNUQVJUX0pPQnxVUFNUQVJUX1NFU1NJT058VVNFUnxXSU5ET1dJRHxYQVVUSE9SSVRZfFhER19DT05GSUdfRElSU3xYREdfQ1VSUkVOVF9ERVNLVE9QfFhER19EQVRBX0RJUlN8WERHX0dSRUVURVJfREFUQV9ESVJ8WERHX01FTlVfUFJFRklYfFhER19SVU5USU1FX0RJUnxYREdfU0VBVHxYREdfU0VBVF9QQVRIfFhER19TRVNTSU9OX0RFU0tUT1B8WERHX1NFU1NJT05fSUR8WERHX1NFU1NJT05fUEFUSHxYREdfU0VTU0lPTl9UWVBFfFhER19WVE5SfFhNT0RJRklFUlMpXFxcXGInO1xuICB2YXIgY29tbWFuZEFmdGVySGVyZWRvYyA9IHtcbiAgICBwYXR0ZXJuOiAvKF4oW1wiJ10/KVxcdytcXDIpWyBcXHRdK1xcUy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAncHVuY3R1YXRpb24nLFxuICAgIC8vIHRoaXMgbG9va3MgcmVhc29uYWJseSB3ZWxsIGluIGFsbCB0aGVtZXNcbiAgICBpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG5cbiAgfTtcbiAgdmFyIGluc2lkZVN0cmluZyA9IHtcbiAgICAnYmFzaCc6IGNvbW1hbmRBZnRlckhlcmVkb2MsXG4gICAgJ2Vudmlyb25tZW50Jzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdcXFxcJCcgKyBlbnZWYXJzKSxcbiAgICAgIGFsaWFzOiAnY29uc3RhbnQnXG4gICAgfSxcbiAgICAndmFyaWFibGUnOiBbLy8gWzBdOiBBcml0aG1ldGljIEVudmlyb25tZW50XG4gICAge1xuICAgICAgcGF0dGVybjogL1xcJD9cXChcXChbXFxzXFxTXSs/XFwpXFwpLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhICQgc2lnbiBhdCB0aGUgYmVnaW5uaW5nIGhpZ2hsaWdodCAkKCggYW5kICkpIGFzIHZhcmlhYmxlXG4gICAgICAgICd2YXJpYWJsZSc6IFt7XG4gICAgICAgICAgcGF0dGVybjogLyheXFwkXFwoXFwoW1xcc1xcU10rKVxcKVxcKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9LCAvXlxcJFxcKFxcKC9dLFxuICAgICAgICAnbnVtYmVyJzogL1xcYjB4W1xcZEEtRmEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzpbRWVdLT9cXGQrKT8vLFxuICAgICAgICAvLyBPcGVyYXRvcnMgYWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvYmFzaHJlZi5odG1sI1NoZWxsLUFyaXRobWV0aWNcbiAgICAgICAgJ29wZXJhdG9yJzogLy0tfFxcK1xcK3xcXCpcXCo9P3w8PD0/fD4+PT98JiZ8XFx8XFx8fFs9IStcXC0qLyU8Pl4mfF09P3xbP346XS8sXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vICQgc2lnbiBhdCB0aGUgYmVnaW5uaW5nIGhpZ2hsaWdodCAoKCBhbmQgKSkgYXMgcHVuY3R1YXRpb25cbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcKFxcKD98XFwpXFwpP3wsfDsvXG4gICAgICB9XG4gICAgfSwgLy8gWzFdOiBDb21tYW5kIFN1YnN0aXR1dGlvblxuICAgIHtcbiAgICAgIHBhdHRlcm46IC9cXCRcXCgoPzpcXChbXildK1xcKXxbXigpXSkrXFwpfGBbXmBdK2AvLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd2YXJpYWJsZSc6IC9eXFwkXFwofF5gfFxcKSR8YCQvXG4gICAgICB9XG4gICAgfSwgLy8gWzJdOiBCcmFjZSBleHBhbnNpb25cbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvXFwkXFx7W159XStcXH0vLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdvcGVyYXRvcic6IC86Wy09PytdP3xbIVxcL118IyM/fCUlP3xcXF5cXF4/fCwsPy8sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9bXFxbXFxdXS8sXG4gICAgICAgICdlbnZpcm9ubWVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJyhcXFxceyknICsgZW52VmFycyksXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBhbGlhczogJ2NvbnN0YW50J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgL1xcJCg/Olxcdyt8WyM/KiFAJF0pL10sXG4gICAgLy8gRXNjYXBlIHNlcXVlbmNlcyBmcm9tIGVjaG8gYW5kIHByaW50ZidzIG1hbnVhbHMsIGFuZCBlc2NhcGVkIHF1b3Rlcy5cbiAgICAnZW50aXR5JzogL1xcXFwoPzpbYWJjZUVmbnJ0dlxcXFxcIl18Tz9bMC03XXsxLDN9fFVbMC05YS1mQS1GXXs4fXx1WzAtOWEtZkEtRl17NH18eFswLTlhLWZBLUZdezEsMn0pL1xuICB9O1xuICBQcmlzbS5sYW5ndWFnZXMuYmFzaCA9IHtcbiAgICAnc2hlYmFuZyc6IHtcbiAgICAgIHBhdHRlcm46IC9eIyFcXHMqXFwvLiovLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgfSxcbiAgICAnY29tbWVudCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXlwie1xcXFwkXSkjLiovLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2Z1bmN0aW9uLW5hbWUnOiBbLy8gYSkgZnVuY3Rpb24gZm9vIHtcbiAgICAvLyBiKSBmb28oKSB7XG4gICAgLy8gYykgZnVuY3Rpb24gZm9vKCkge1xuICAgIC8vIGJ1dCBub3Qg4oCcZm9vIHvigJ1cbiAgICB7XG4gICAgICAvLyBhKSBhbmQgYylcbiAgICAgIHBhdHRlcm46IC8oXFxiZnVuY3Rpb25cXHMrKVtcXHctXSsoPz0oPzpcXHMqXFwoPzpcXHMqXFwpKT9cXHMqXFx7KS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgICB9LCB7XG4gICAgICAvLyBiKVxuICAgICAgcGF0dGVybjogL1xcYltcXHctXSsoPz1cXHMqXFwoXFxzKlxcKVxccypcXHspLyxcbiAgICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gICAgfV0sXG4gICAgLy8gSGlnaGxpZ2h0IHZhcmlhYmxlIG5hbWVzIGFzIHZhcmlhYmxlcyBpbiBmb3IgYW5kIHNlbGVjdCBiZWdpbm5pbmdzLlxuICAgICdmb3Itb3Itc2VsZWN0Jzoge1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpmb3J8c2VsZWN0KVxccyspXFx3Kyg/PVxccytpblxccykvLFxuICAgICAgYWxpYXM6ICd2YXJpYWJsZScsXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAvLyBIaWdobGlnaHQgdmFyaWFibGUgbmFtZXMgYXMgdmFyaWFibGVzIGluIHRoZSBsZWZ0LWhhbmQgcGFydFxuICAgIC8vIG9mIGFzc2lnbm1lbnRzICjigJw94oCdIGFuZCDigJwrPeKAnSkuXG4gICAgJ2Fzc2lnbi1sZWZ0Jzoge1xuICAgICAgcGF0dGVybjogLyhefFtcXHM7fCZdfFs8Pl1cXCgpXFx3Kyg/PVxcKz89KS8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Vudmlyb25tZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnKF58W1xcXFxzO3wmXXxbPD5dXFxcXCgpJyArIGVudlZhcnMpLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgICAgYWxpYXM6ICdjb25zdGFudCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFsaWFzOiAndmFyaWFibGUnLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3N0cmluZyc6IFsvLyBTdXBwb3J0IGZvciBIZXJlLWRvY3VtZW50cyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZXJlX2RvY3VtZW50XG4gICAge1xuICAgICAgcGF0dGVybjogLygoPzpefFtePF0pPDwtP1xccyopKFxcdyspXFxzW1xcc1xcU10qPyg/Olxccj9cXG58XFxyKVxcMi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiBpbnNpZGVTdHJpbmdcbiAgICB9LCAvLyBIZXJlLWRvY3VtZW50IHdpdGggcXVvdGVzIGFyb3VuZCB0aGUgdGFnXG4gICAgLy8g4oaSIE5vIGV4cGFuc2lvbiAoc28gbm8g4oCcaW5zaWRl4oCdKS5cbiAgICB7XG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58W148XSk8PC0/XFxzKikoW1wiJ10pKFxcdyspXFwyXFxzW1xcc1xcU10qPyg/Olxccj9cXG58XFxyKVxcMy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdiYXNoJzogY29tbWFuZEFmdGVySGVyZWRvY1xuICAgICAgfVxuICAgIH0sIC8vIOKAnE5vcm1hbOKAnSBzdHJpbmdcbiAgICB7XG4gICAgICAvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9Eb3VibGUtUXVvdGVzLmh0bWxcbiAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKD86XFxcXFxcXFwpKilcIig/OlxcXFxbXFxzXFxTXXxcXCRcXChbXildK1xcKXxcXCQoPyFcXCgpfGBbXmBdK2B8W15cIlxcXFxgJF0pKlwiLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IGluc2lkZVN0cmluZ1xuICAgIH0sIHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL1NpbmdsZS1RdW90ZXMuaHRtbFxuICAgICAgcGF0dGVybjogLyhefFteJFxcXFxdKSdbXiddKicvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL0FOU0lfMDAyZEMtUXVvdGluZy5odG1sXG4gICAgICBwYXR0ZXJuOiAvXFwkJyg/OlteJ1xcXFxdfFxcXFxbXFxzXFxTXSkqJy8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2VudGl0eSc6IGluc2lkZVN0cmluZy5lbnRpdHlcbiAgICAgIH1cbiAgICB9XSxcbiAgICAnZW52aXJvbm1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ1xcXFwkPycgKyBlbnZWYXJzKSxcbiAgICAgIGFsaWFzOiAnY29uc3RhbnQnXG4gICAgfSxcbiAgICAndmFyaWFibGUnOiBpbnNpZGVTdHJpbmcudmFyaWFibGUsXG4gICAgJ2Z1bmN0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyhefFtcXHM7fCZdfFs8Pl1cXCgpKD86YWRkfGFwcm9wb3N8YXB0fGFwdC1jYWNoZXxhcHQtZ2V0fGFwdGl0dWRlfGFzcGVsbHxhdXRvbXlzcWxiYWNrdXB8YXdrfGJhc2VuYW1lfGJhc2h8YmN8YmNvbnNvbGV8Ymd8YnppcDJ8Y2FsfGNhdHxjZmRpc2t8Y2hncnB8Y2hrY29uZmlnfGNobW9kfGNob3dufGNocm9vdHxja3N1bXxjbGVhcnxjbXB8Y29sdW1ufGNvbW18Y29tcG9zZXJ8Y3B8Y3Jvbnxjcm9udGFifGNzcGxpdHxjdXJsfGN1dHxkYXRlfGRjfGRkfGRkcmVzY3VlfGRlYm9vdHN0cmFwfGRmfGRpZmZ8ZGlmZjN8ZGlnfGRpcnxkaXJjb2xvcnN8ZGlybmFtZXxkaXJzfGRtZXNnfGRvY2tlcnxkb2NrZXItY29tcG9zZXxkdXxlZ3JlcHxlamVjdHxlbnZ8ZXRodG9vbHxleHBhbmR8ZXhwZWN0fGV4cHJ8ZmRmb3JtYXR8ZmRpc2t8Zmd8ZmdyZXB8ZmlsZXxmaW5kfGZtdHxmb2xkfGZvcm1hdHxmcmVlfGZzY2t8ZnRwfGZ1c2VyfGdhd2t8Z2l0fGdwYXJ0ZWR8Z3JlcHxncm91cGFkZHxncm91cGRlbHxncm91cG1vZHxncm91cHN8Z3J1Yi1ta2NvbmZpZ3xnemlwfGhhbHR8aGVhZHxoZ3xoaXN0b3J5fGhvc3R8aG9zdG5hbWV8aHRvcHxpY29udnxpZHxpZmNvbmZpZ3xpZmRvd258aWZ1cHxpbXBvcnR8aW5zdGFsbHxpcHxqb2JzfGpvaW58a2lsbHxraWxsYWxsfGxlc3N8bGlua3xsbnxsb2NhdGV8bG9nbmFtZXxsb2dyb3RhdGV8bG9va3xscGN8bHByfGxwcmludHxscHJpbnRkfGxwcmludHF8bHBybXxsc3xsc29mfGx5bnh8bWFrZXxtYW58bWN8bWRhZG18bWtjb25maWd8bWtkaXJ8bWtlMmZzfG1rZmlmb3xta2ZzfG1raXNvZnN8bWtub2R8bWtzd2FwfG1tdnxtb3JlfG1vc3R8bW91bnR8bXRvb2xzfG10cnxtdXR0fG12fG5hbm98bmN8bmV0c3RhdHxuaWNlfG5sfG5vZGV8bm9odXB8bm90aWZ5LXNlbmR8bnBtfG5zbG9va3VwfG9wfG9wZW58cGFydGVkfHBhc3N3ZHxwYXN0ZXxwYXRoY2hrfHBpbmd8cGtpbGx8cG5wbXxwb2RtYW58cG9kbWFuLWNvbXBvc2V8cG9wZHxwcnxwcmludGNhcHxwcmludGVudnxwc3xwdXNoZHxwdnxxdW90YXxxdW90YWNoZWNrfHF1b3RhY3RsfHJhbXxyYXJ8cmNwfHJlYm9vdHxyZW1zeW5jfHJlbmFtZXxyZW5pY2V8cmV2fHJtfHJtZGlyfHJwbXxyc3luY3xzY3B8c2NyZWVufHNkaWZmfHNlZHxzZW5kbWFpbHxzZXF8c2VydmljZXxzZnRwfHNofHNoZWxsY2hlY2t8c2h1ZnxzaHV0ZG93bnxzbGVlcHxzbG9jYXRlfHNvcnR8c3BsaXR8c3NofHN0YXR8c3RyYWNlfHN1fHN1ZG98c3VtfHN1c3BlbmR8c3dhcG9ufHN5bmN8dGFjfHRhaWx8dGFyfHRlZXx0aW1lfHRpbWVvdXR8dG9wfHRvdWNofHRyfHRyYWNlcm91dGV8dHNvcnR8dHR5fHVtb3VudHx1bmFtZXx1bmV4cGFuZHx1bmlxfHVuaXRzfHVucmFyfHVuc2hhcnx1bnppcHx1cGRhdGUtZ3J1Ynx1cHRpbWV8dXNlcmFkZHx1c2VyZGVsfHVzZXJtb2R8dXNlcnN8dXVkZWNvZGV8dXVlbmNvZGV8dnx2Y3BrZ3x2ZGlyfHZpfHZpbXx2aXJzaHx2bXN0YXR8d2FpdHx3YXRjaHx3Y3x3Z2V0fHdoZXJlaXN8d2hpY2h8d2hvfHdob2FtaXx3cml0ZXx4YXJnc3x4ZGctb3Blbnx5YXJufHllc3x6ZW5pdHl8emlwfHpzaHx6eXBwZXIpKD89JHxbKVxcczt8Jl0pLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdrZXl3b3JkJzoge1xuICAgICAgcGF0dGVybjogLyhefFtcXHM7fCZdfFs8Pl1cXCgpKD86Y2FzZXxkb3xkb25lfGVsaWZ8ZWxzZXxlc2FjfGZpfGZvcnxmdW5jdGlvbnxpZnxpbnxzZWxlY3R8dGhlbnx1bnRpbHx3aGlsZSkoPz0kfFspXFxzO3wmXSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvU2hlbGwtQnVpbHRpbi1Db21tYW5kcy5odG1sXG4gICAgJ2J1aWx0aW4nOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpcXC58OnxhbGlhc3xiaW5kfGJyZWFrfGJ1aWx0aW58Y2FsbGVyfGNkfGNvbW1hbmR8Y29udGludWV8ZGVjbGFyZXxlY2hvfGVuYWJsZXxldmFsfGV4ZWN8ZXhpdHxleHBvcnR8Z2V0b3B0c3xoYXNofGhlbHB8bGV0fGxvY2FsfGxvZ291dHxtYXBmaWxlfHByaW50Znxwd2R8cmVhZHxyZWFkYXJyYXl8cmVhZG9ubHl8cmV0dXJufHNldHxzaGlmdHxzaG9wdHxzb3VyY2V8dGVzdHx0aW1lc3x0cmFwfHR5cGV8dHlwZXNldHx1bGltaXR8dW1hc2t8dW5hbGlhc3x1bnNldCkoPz0kfFspXFxzO3wmXSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIC8vIEFsaWFzIGFkZGVkIHRvIG1ha2UgdGhvc2UgZWFzaWVyIHRvIGRpc3Rpbmd1aXNoIGZyb20gc3RyaW5ncy5cbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9LFxuICAgICdib29sZWFuJzoge1xuICAgICAgcGF0dGVybjogLyhefFtcXHM7fCZdfFs8Pl1cXCgpKD86ZmFsc2V8dHJ1ZSkoPz0kfFspXFxzO3wmXSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2ZpbGUtZGVzY3JpcHRvcic6IHtcbiAgICAgIHBhdHRlcm46IC9cXEImXFxkXFxiLyxcbiAgICAgIGFsaWFzOiAnaW1wb3J0YW50J1xuICAgIH0sXG4gICAgJ29wZXJhdG9yJzoge1xuICAgICAgLy8gTG90cyBvZiByZWRpcmVjdGlvbnMgaGVyZSwgYnV0IG5vdCBqdXN0IHRoYXQuXG4gICAgICBwYXR0ZXJuOiAvXFxkPzw+fD5cXHx8XFwrPXw9Wz1+XT98IT0/fDw8WzwtXT98WyZcXGRdPz4+fFxcZFs8Pl0mP3xbPD5dWyY9XT98Jls+Jl0/fFxcfFsmfF0/LyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZmlsZS1kZXNjcmlwdG9yJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eXFxkLyxcbiAgICAgICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3B1bmN0dWF0aW9uJzogL1xcJD9cXChcXCg/fFxcKVxcKT98XFwuXFwufFt7fVtcXF07XFxcXF0vLFxuICAgICdudW1iZXInOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58XFxzKSg/OlsxLTldXFxkKnwwKSg/OlsuLF1cXGQrKT9cXGIvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH1cbiAgfTtcbiAgY29tbWFuZEFmdGVySGVyZWRvYy5pbnNpZGUgPSBQcmlzbS5sYW5ndWFnZXMuYmFzaDtcbiAgLyogUGF0dGVybnMgaW4gY29tbWFuZCBzdWJzdGl0dXRpb24uICovXG5cbiAgdmFyIHRvQmVDb3BpZWQgPSBbJ2NvbW1lbnQnLCAnZnVuY3Rpb24tbmFtZScsICdmb3Itb3Itc2VsZWN0JywgJ2Fzc2lnbi1sZWZ0JywgJ3N0cmluZycsICdlbnZpcm9ubWVudCcsICdmdW5jdGlvbicsICdrZXl3b3JkJywgJ2J1aWx0aW4nLCAnYm9vbGVhbicsICdmaWxlLWRlc2NyaXB0b3InLCAnb3BlcmF0b3InLCAncHVuY3R1YXRpb24nLCAnbnVtYmVyJ107XG4gIHZhciBpbnNpZGUgPSBpbnNpZGVTdHJpbmcudmFyaWFibGVbMV0uaW5zaWRlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9CZUNvcGllZC5sZW5ndGg7IGkrKykge1xuICAgIGluc2lkZVt0b0JlQ29waWVkW2ldXSA9IFByaXNtLmxhbmd1YWdlcy5iYXNoW3RvQmVDb3BpZWRbaV1dO1xuICB9XG5cbiAgUHJpc20ubGFuZ3VhZ2VzLnNoZWxsID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2g7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jbGlrZVwiICovXG5cblxucHJpc20ubGFuZ3VhZ2VzLmNsaWtlID0ge1xuICAnY29tbWVudCc6IFt7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwqW1xcc1xcU10qPyg/OlxcKlxcL3wkKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWVcbiAgfV0sXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyhbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2NsYXNzLW5hbWUnOiB7XG4gICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHRyYWl0KVxccyt8XFxiY2F0Y2hcXHMrXFwoKVtcXHcuXFxcXF0rL2ksXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdwdW5jdHVhdGlvbic6IC9bLlxcXFxdL1xuICAgIH1cbiAgfSxcbiAgJ2tleXdvcmQnOiAvXFxiKD86YnJlYWt8Y2F0Y2h8Y29udGludWV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xudWxsfHJldHVybnx0aHJvd3x0cnl8d2hpbGUpXFxiLyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAnZnVuY3Rpb24nOiAvXFxiXFx3Kyg/PVxcKCkvLFxuICAnbnVtYmVyJzogL1xcYjB4W1xcZGEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8vaSxcbiAgJ29wZXJhdG9yJzogL1s8Pl09P3xbIT1dPT89P3wtLT98XFwrXFwrP3wmJj98XFx8XFx8P3xbPyovfl4lXS8sXG4gICdwdW5jdHVhdGlvbic6IC9be31bXFxdOygpLC46XS9cbn07XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jXCIgKi9cblxucHJpc20ubGFuZ3VhZ2VzLmMgPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgJ2NvbW1lbnQnOiB7XG4gICAgcGF0dGVybjogL1xcL1xcLyg/OlteXFxyXFxuXFxcXF18XFxcXCg/Olxcclxcbj98XFxufCg/IVtcXHJcXG5dKSkpKnxcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jL2xhbmd1YWdlL3N0cmluZ19saXRlcmFsXG4gICAgcGF0dGVybjogL1wiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcIi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdjbGFzcy1uYW1lJzoge1xuICAgIHBhdHRlcm46IC8oXFxiKD86ZW51bXxzdHJ1Y3QpXFxzKyg/Ol9fYXR0cmlidXRlX19cXHMqXFwoXFwoW1xcc1xcU10qP1xcKVxcKVxccyopPylcXHcrfFxcYlthLXpdXFx3Kl90XFxiLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/Ol9BbGlnbmFzfF9BbGlnbm9mfF9BdG9taWN8X0Jvb2x8X0NvbXBsZXh8X0dlbmVyaWN8X0ltYWdpbmFyeXxfTm9yZXR1cm58X1N0YXRpY19hc3NlcnR8X1RocmVhZF9sb2NhbHxfX2F0dHJpYnV0ZV9ffGFzbXxhdXRvfGJyZWFrfGNhc2V8Y2hhcnxjb25zdHxjb250aW51ZXxkZWZhdWx0fGRvfGRvdWJsZXxlbHNlfGVudW18ZXh0ZXJufGZsb2F0fGZvcnxnb3RvfGlmfGlubGluZXxpbnR8bG9uZ3xyZWdpc3RlcnxyZXR1cm58c2hvcnR8c2lnbmVkfHNpemVvZnxzdGF0aWN8c3RydWN0fHN3aXRjaHx0eXBlZGVmfHR5cGVvZnx1bmlvbnx1bnNpZ25lZHx2b2lkfHZvbGF0aWxlfHdoaWxlKVxcYi8sXG4gICdmdW5jdGlvbic6IC9cXGJbYS16X11cXHcqKD89XFxzKlxcKCkvaSxcbiAgJ251bWJlcic6IC8oPzpcXGIweCg/OltcXGRhLWZdKyg/OlxcLltcXGRhLWZdKik/fFxcLltcXGRhLWZdKykoPzpwWystXT9cXGQrKT98KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OmVbKy1dP1xcZCspPylbZnVsXXswLDR9L2ksXG4gICdvcGVyYXRvcic6IC8+Pj0/fDw8PT98LT58KFstKyZ8Ol0pXFwxfFs/On5dfFstKyovJSZ8XiE9PD5dPT8vXG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2MnLCAnc3RyaW5nJywge1xuICAnY2hhcic6IHtcbiAgICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jL2xhbmd1YWdlL2NoYXJhY3Rlcl9jb25zdGFudFxuICAgIHBhdHRlcm46IC8nKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W14nXFxcXFxcclxcbl0pezAsMzJ9Jy8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnYycsICdzdHJpbmcnLCB7XG4gICdtYWNybyc6IHtcbiAgICAvLyBhbGxvdyBmb3IgbXVsdGlsaW5lIG1hY3JvIGRlZmluaXRpb25zXG4gICAgLy8gc3BhY2VzIGFmdGVyIHRoZSAjIGNoYXJhY3RlciBjb21waWxlIGZpbmUgd2l0aCBnY2NcbiAgICBwYXR0ZXJuOiAvKF5bXFx0IF0qKSNcXHMqW2Etel0oPzpbXlxcclxcblxcXFwvXXxcXC8oPyFcXCopfFxcL1xcKig/OlteKl18XFwqKD8hXFwvKSkqXFwqXFwvfFxcXFwoPzpcXHJcXG58W1xcc1xcU10pKSovaW0sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgYWxpYXM6ICdwcm9wZXJ0eScsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnc3RyaW5nJzogW3tcbiAgICAgICAgLy8gaGlnaGxpZ2h0IHRoZSBwYXRoIG9mIHRoZSBpbmNsdWRlIHN0YXRlbWVudCBhcyBhIHN0cmluZ1xuICAgICAgICBwYXR0ZXJuOiAvXigjXFxzKmluY2x1ZGVcXHMqKTxbXj5dKz4vLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICB9LCBwcmlzbS5sYW5ndWFnZXMuY1snc3RyaW5nJ11dLFxuICAgICAgJ2NoYXInOiBwcmlzbS5sYW5ndWFnZXMuY1snY2hhciddLFxuICAgICAgJ2NvbW1lbnQnOiBwcmlzbS5sYW5ndWFnZXMuY1snY29tbWVudCddLFxuICAgICAgJ21hY3JvLW5hbWUnOiBbe1xuICAgICAgICBwYXR0ZXJuOiAvKF4jXFxzKmRlZmluZVxccyspXFx3K1xcYig/IVxcKCkvaSxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwYXR0ZXJuOiAvKF4jXFxzKmRlZmluZVxccyspXFx3K1xcYig/PVxcKCkvaSxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgICAgIH1dLFxuICAgICAgLy8gaGlnaGxpZ2h0IG1hY3JvIGRpcmVjdGl2ZXMgYXMga2V5d29yZHNcbiAgICAgICdkaXJlY3RpdmUnOiB7XG4gICAgICAgIHBhdHRlcm46IC9eKCNcXHMqKVthLXpdKy8sXG4gICAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICAgIGFsaWFzOiAna2V5d29yZCdcbiAgICAgIH0sXG4gICAgICAnZGlyZWN0aXZlLWhhc2gnOiAvXiMvLFxuICAgICAgJ3B1bmN0dWF0aW9uJzogLyMjfFxcXFwoPz1bXFxyXFxuXSkvLFxuICAgICAgJ2V4cHJlc3Npb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC9cXFNbXFxzXFxTXSovLFxuICAgICAgICBpbnNpZGU6IHByaXNtLmxhbmd1YWdlcy5jXG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2MnLCAnZnVuY3Rpb24nLCB7XG4gIC8vIGhpZ2hsaWdodCBwcmVkZWZpbmVkIG1hY3JvcyBhcyBjb25zdGFudHNcbiAgJ2NvbnN0YW50JzogL1xcYig/OkVPRnxOVUxMfFNFRUtfQ1VSfFNFRUtfRU5EfFNFRUtfU0VUfF9fREFURV9ffF9fRklMRV9ffF9fTElORV9ffF9fVElNRVNUQU1QX198X19USU1FX198X19mdW5jX198c3RkZXJyfHN0ZGlufHN0ZG91dClcXGIvXG59KTtcbmRlbGV0ZSBwcmlzbS5sYW5ndWFnZXMuY1snYm9vbGVhbiddO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tY3BwXCIgKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIga2V5d29yZCA9IC9cXGIoPzphbGlnbmFzfGFsaWdub2Z8YXNtfGF1dG98Ym9vbHxicmVha3xjYXNlfGNhdGNofGNoYXJ8Y2hhcjE2X3R8Y2hhcjMyX3R8Y2hhcjhfdHxjbGFzc3xjb19hd2FpdHxjb19yZXR1cm58Y29feWllbGR8Y29tcGx8Y29uY2VwdHxjb25zdHxjb25zdF9jYXN0fGNvbnN0ZXZhbHxjb25zdGV4cHJ8Y29uc3Rpbml0fGNvbnRpbnVlfGRlY2x0eXBlfGRlZmF1bHR8ZGVsZXRlfGRvfGRvdWJsZXxkeW5hbWljX2Nhc3R8ZWxzZXxlbnVtfGV4cGxpY2l0fGV4cG9ydHxleHRlcm58ZmluYWx8ZmxvYXR8Zm9yfGZyaWVuZHxnb3RvfGlmfGltcG9ydHxpbmxpbmV8aW50fGludDE2X3R8aW50MzJfdHxpbnQ2NF90fGludDhfdHxsb25nfG1vZHVsZXxtdXRhYmxlfG5hbWVzcGFjZXxuZXd8bm9leGNlcHR8bnVsbHB0cnxvcGVyYXRvcnxvdmVycmlkZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmVnaXN0ZXJ8cmVpbnRlcnByZXRfY2FzdHxyZXF1aXJlc3xyZXR1cm58c2hvcnR8c2lnbmVkfHNpemVvZnxzdGF0aWN8c3RhdGljX2Fzc2VydHxzdGF0aWNfY2FzdHxzdHJ1Y3R8c3dpdGNofHRlbXBsYXRlfHRoaXN8dGhyZWFkX2xvY2FsfHRocm93fHRyeXx0eXBlZGVmfHR5cGVpZHx0eXBlbmFtZXx1aW50MTZfdHx1aW50MzJfdHx1aW50NjRfdHx1aW50OF90fHVuaW9ufHVuc2lnbmVkfHVzaW5nfHZpcnR1YWx8dm9pZHx2b2xhdGlsZXx3Y2hhcl90fHdoaWxlKVxcYi87XG4gIHZhciBtb2ROYW1lID0gL1xcYig/ITxrZXl3b3JkPilcXHcrKD86XFxzKlxcLlxccypcXHcrKSpcXGIvLnNvdXJjZS5yZXBsYWNlKC88a2V5d29yZD4vZywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBrZXl3b3JkLnNvdXJjZTtcbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5jcHAgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjJywge1xuICAgICdjbGFzcy1uYW1lJzogW3tcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKFxcYig/OmNsYXNzfGNvbmNlcHR8ZW51bXxzdHJ1Y3R8dHlwZW5hbWUpXFxzKykoPyE8a2V5d29yZD4pXFx3Ky8uc291cmNlLnJlcGxhY2UoLzxrZXl3b3JkPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBrZXl3b3JkLnNvdXJjZTtcbiAgICAgIH0pKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCAvLyBUaGlzIGlzIGludGVuZGVkIHRvIGNhcHR1cmUgdGhlIGNsYXNzIG5hbWUgb2YgbWV0aG9kIGltcGxlbWVudGF0aW9ucyBsaWtlOlxuICAgIC8vICAgdm9pZCBmb286OmJhcigpIGNvbnN0IHt9XG4gICAgLy8gSG93ZXZlciEgVGhlIGBmb29gIGluIHRoZSBhYm92ZSBleGFtcGxlIGNvdWxkIGFsc28gYmUgYSBuYW1lc3BhY2UsIHNvIHdlIG9ubHkgY2FwdHVyZSB0aGUgY2xhc3MgbmFtZSBpZlxuICAgIC8vIGl0IHN0YXJ0cyB3aXRoIGFuIHVwcGVyY2FzZSBsZXR0ZXIuIFRoaXMgYXBwcm94aW1hdGlvbiBzaG91bGQgZ2l2ZSBkZWNlbnQgcmVzdWx0cy5cbiAgICAvXFxiW0EtWl1cXHcqKD89XFxzKjo6XFxzKlxcdytcXHMqXFwoKS8sIC8vIFRoaXMgd2lsbCBjYXB0dXJlIHRoZSBjbGFzcyBuYW1lIGJlZm9yZSBkZXN0cnVjdG9ycyBsaWtlOlxuICAgIC8vICAgRm9vOjp+Rm9vKCkge31cbiAgICAvXFxiW0EtWl9dXFx3Kig/PVxccyo6Olxccyp+XFx3K1xccypcXCgpL2ksIC8vIFRoaXMgYWxzbyBpbnRlbmRzIHRvIGNhcHR1cmUgdGhlIGNsYXNzIG5hbWUgb2YgbWV0aG9kIGltcGxlbWVudGF0aW9ucyBidXQgaGVyZSB0aGUgY2xhc3MgaGFzIHRlbXBsYXRlXG4gICAgLy8gcGFyYW1ldGVycywgc28gaXQgY2FuJ3QgYmUgYSBuYW1lc3BhY2UgKHVudGlsIEMrKyBhZGRzIGdlbmVyaWMgbmFtZXNwYWNlcykuXG4gICAgL1xcYlxcdysoPz1cXHMqPCg/OltePD5dfDwoPzpbXjw+XXw8W148Pl0qPikqPikqPlxccyo6OlxccypcXHcrXFxzKlxcKCkvXSxcbiAgICAna2V5d29yZCc6IGtleXdvcmQsXG4gICAgJ251bWJlcic6IHtcbiAgICAgIHBhdHRlcm46IC8oPzpcXGIwYlswMSddK3xcXGIweCg/OltcXGRhLWYnXSsoPzpcXC5bXFxkYS1mJ10qKT98XFwuW1xcZGEtZiddKykoPzpwWystXT9bXFxkJ10rKT98KD86XFxiW1xcZCddKyg/OlxcLltcXGQnXSopP3xcXEJcXC5bXFxkJ10rKSg/OmVbKy1dP1tcXGQnXSspPylbZnVsXXswLDR9L2ksXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9LFxuICAgICdvcGVyYXRvcic6IC8+Pj0/fDw8PT98LT58LS18XFwrXFwrfCYmfFxcfFxcfHxbPzp+XXw8PT58Wy0rKi8lJnxeIT08Pl09P3xcXGIoPzphbmR8YW5kX2VxfGJpdGFuZHxiaXRvcnxub3R8bm90X2VxfG9yfG9yX2VxfHhvcnx4b3JfZXEpXFxiLyxcbiAgICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi9cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdzdHJpbmcnLCB7XG4gICAgJ21vZHVsZSc6IHtcbiAgICAgIC8vIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2NwcC9sYW5ndWFnZS9tb2R1bGVzXG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoLyhcXGIoPzppbXBvcnR8bW9kdWxlKVxccyspLy5zb3VyY2UgKyAnKD86JyArIC8vIGhlYWRlci1uYW1lXG4gICAgICAvXCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwifDxbXjw+XFxyXFxuXSo+Ly5zb3VyY2UgKyAnfCcgKyAvLyBtb2R1bGUgbmFtZSBvciBwYXJ0aXRpb24gb3IgYm90aFxuICAgICAgLzxtb2QtbmFtZT4oPzpcXHMqOlxccyo8bW9kLW5hbWU+KT98Olxccyo8bW9kLW5hbWU+Ly5zb3VyY2UucmVwbGFjZSgvPG1vZC1uYW1lPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtb2ROYW1lO1xuICAgICAgfSkgKyAnKScpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnc3RyaW5nJzogL15bPFwiXVtcXHNcXFNdKy8sXG4gICAgICAgICdvcGVyYXRvcic6IC86LyxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi9cbiAgICAgIH1cbiAgICB9LFxuICAgICdyYXctc3RyaW5nJzoge1xuICAgICAgcGF0dGVybjogL1JcIihbXigpXFxcXCBdezAsMTZ9KVxcKFtcXHNcXFNdKj9cXClcXDFcIi8sXG4gICAgICBhbGlhczogJ3N0cmluZycsXG4gICAgICBncmVlZHk6IHRydWVcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjcHAnLCAna2V5d29yZCcsIHtcbiAgICAnZ2VuZXJpYy1mdW5jdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC9cXGIoPyFvcGVyYXRvclxcYilbYS16X11cXHcqXFxzKjwoPzpbXjw+XXw8W148Pl0qPikqPig/PVxccypcXCgpL2ksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2Z1bmN0aW9uJzogL15cXHcrLyxcbiAgICAgICAgJ2dlbmVyaWMnOiB7XG4gICAgICAgICAgcGF0dGVybjogLzxbXFxzXFxTXSsvLFxuICAgICAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZScsXG4gICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuY3BwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjcHAnLCAnb3BlcmF0b3InLCB7XG4gICAgJ2RvdWJsZS1jb2xvbic6IHtcbiAgICAgIHBhdHRlcm46IC86Oi8sXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NwcCcsICdjbGFzcy1uYW1lJywge1xuICAgIC8vIHRoZSBiYXNlIGNsYXVzZSBpcyBhbiBvcHRpb25hbCBsaXN0IG9mIHBhcmVudCBjbGFzc2VzXG4gICAgLy8gaHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL2NsYXNzXG4gICAgJ2Jhc2UtY2xhdXNlJzoge1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xzdHJ1Y3QpXFxzK1xcdytcXHMqOlxccyopW147e31cIidcXHNdKyg/OlxccytbXjt7fVwiJ1xcc10rKSooPz1cXHMqWzt7XSkvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3BwJywge30pXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ2RvdWJsZS1jb2xvbicsIHtcbiAgICAvLyBBbGwgdW50b2tlbml6ZWQgd29yZHMgdGhhdCBhcmUgbm90IG5hbWVzcGFjZXMgc2hvdWxkIGJlIGNsYXNzIG5hbWVzXG4gICAgJ2NsYXNzLW5hbWUnOiAvXFxiW2Etel9dXFx3KlxcYig/IVxccyo6OikvaVxuICB9LCBQcmlzbS5sYW5ndWFnZXMuY3BwWydiYXNlLWNsYXVzZSddKTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWNzc1wiICovXG5cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgc3RyaW5nID0gLyg/OlwiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcInwnKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W14nXFxcXFxcclxcbl0pKicpLztcbiAgUHJpc20ubGFuZ3VhZ2VzLmNzcyA9IHtcbiAgICAnY29tbWVudCc6IC9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvLyxcbiAgICAnYXRydWxlJzoge1xuICAgICAgcGF0dGVybjogL0BbXFx3LV0oPzpbXjt7XFxzXXxcXHMrKD8hW1xcc3tdKSkqKD86O3woPz1cXHMqXFx7KSkvLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdydWxlJzogL15AW1xcdy1dKy8sXG4gICAgICAgICdzZWxlY3Rvci1mdW5jdGlvbi1hcmd1bWVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKFxcYnNlbGVjdG9yXFxzKlxcKFxccyooPyFbXFxzKV0pKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpKSsoPz1cXHMqXFwpKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBhbGlhczogJ3NlbGVjdG9yJ1xuICAgICAgICB9LFxuICAgICAgICAna2V5d29yZCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF58W15cXHctXSkoPzphbmR8bm90fG9ubHl8b3IpKD8hW1xcdy1dKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9IC8vIFNlZSByZXN0IGJlbG93XG5cbiAgICAgIH1cbiAgICB9LFxuICAgICd1cmwnOiB7XG4gICAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ1xcXFxidXJsXFxcXCgoPzonICsgc3RyaW5nLnNvdXJjZSArICd8JyArIC8oPzpbXlxcXFxcXHJcXG4oKVwiJ118XFxcXFtcXHNcXFNdKSovLnNvdXJjZSArICcpXFxcXCknLCAnaScpLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdmdW5jdGlvbic6IC9edXJsL2ksXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9eXFwofFxcKSQvLFxuICAgICAgICAnc3RyaW5nJzoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCgnXicgKyBzdHJpbmcuc291cmNlICsgJyQnKSxcbiAgICAgICAgICBhbGlhczogJ3VybCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3NlbGVjdG9yJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCcoXnxbe31cXFxcc10pW157fVxcXFxzXSg/Oltee307XCJcXCdcXFxcc118XFxcXHMrKD8hW1xcXFxze10pfCcgKyBzdHJpbmcuc291cmNlICsgJykqKD89XFxcXHMqXFxcXHspJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnc3RyaW5nJzoge1xuICAgICAgcGF0dGVybjogc3RyaW5nLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAncHJvcGVydHknOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14tXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVstX2EtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9pLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ2ltcG9ydGFudCc6IC8haW1wb3J0YW50XFxiL2ksXG4gICAgJ2Z1bmN0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyhefFteLWEtejAtOV0pWy1hLXowLTldKyg/PVxcKCkvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICdwdW5jdHVhdGlvbic6IC9bKCl7fTs6LF0vXG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5jc3NbJ2F0cnVsZSddLmluc2lkZS5yZXN0ID0gUHJpc20ubGFuZ3VhZ2VzLmNzcztcbiAgdmFyIG1hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5cbiAgaWYgKG1hcmt1cCkge1xuICAgIG1hcmt1cC50YWcuYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyk7XG4gICAgbWFya3VwLnRhZy5hZGRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2NzcycpO1xuICB9XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jc3MtZXh0cmFzXCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciBzdHJpbmcgPSAvKFwifCcpKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS87XG4gIHZhciBzZWxlY3Rvckluc2lkZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNzcy5zZWxlY3RvciA9IHtcbiAgICBwYXR0ZXJuOiBQcmlzbS5sYW5ndWFnZXMuY3NzLnNlbGVjdG9yLnBhdHRlcm4sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBpbnNpZGU6IHNlbGVjdG9ySW5zaWRlID0ge1xuICAgICAgJ3BzZXVkby1lbGVtZW50JzogLzooPzphZnRlcnxiZWZvcmV8Zmlyc3QtbGV0dGVyfGZpcnN0LWxpbmV8c2VsZWN0aW9uKXw6OlstXFx3XSsvLFxuICAgICAgJ3BzZXVkby1jbGFzcyc6IC86Wy1cXHddKy8sXG4gICAgICAnY2xhc3MnOiAvXFwuWy1cXHddKy8sXG4gICAgICAnaWQnOiAvI1stXFx3XSsvLFxuICAgICAgJ2F0dHJpYnV0ZSc6IHtcbiAgICAgICAgcGF0dGVybjogUmVnRXhwKCdcXFxcWyg/OlteW1xcXFxdXCJcXCddfCcgKyBzdHJpbmcuc291cmNlICsgJykqXFxcXF0nKSxcbiAgICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXlxcW3xcXF0kLyxcbiAgICAgICAgICAnY2FzZS1zZW5zaXRpdml0eSc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC8oXFxzKVtzaV0kL2ksXG4gICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgICAgYWxpYXM6ICdrZXl3b3JkJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgJ25hbWVzcGFjZSc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9eKFxccyopKD86KD8hXFxzKVstKlxcd1xceEEwLVxcdUZGRkZdKSpcXHwoPyE9KS8sXG4gICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXHwkL1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2F0dHItbmFtZSc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9eKFxccyopKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKy8sXG4gICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnYXR0ci12YWx1ZSc6IFtzdHJpbmcsIHtcbiAgICAgICAgICAgIHBhdHRlcm46IC8oPVxccyopKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKyg/PVxccyokKS8sXG4gICAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgJ29wZXJhdG9yJzogL1t8fipeJF0/PS9cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICduLXRoJzogW3tcbiAgICAgICAgcGF0dGVybjogLyhcXChcXHMqKVsrLV0/XFxkKltcXGRuXSg/OlxccypbKy1dXFxzKlxcZCspPyg/PVxccypcXCkpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ251bWJlcic6IC9bXFxkbl0rLyxcbiAgICAgICAgICAnb3BlcmF0b3InOiAvWystXS9cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBwYXR0ZXJuOiAvKFxcKFxccyopKD86ZXZlbnxvZGQpKD89XFxzKlxcKSkvaSxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgfV0sXG4gICAgICAnY29tYmluYXRvcic6IC8+fFxcK3x+fFxcfFxcfC8sXG4gICAgICAvLyB0aGUgYHRhZ2AgdG9rZW4gaGFzIGJlZW4gZXhpc3RlZCBhbmQgcmVtb3ZlZC5cbiAgICAgIC8vIGJlY2F1c2Ugd2UgY2FuJ3QgZmluZCBhIHBlcmZlY3QgdG9rZW5pemUgdG8gbWF0Y2ggaXQuXG4gICAgICAvLyBpZiB5b3Ugd2FudCB0byBhZGQgaXQsIHBsZWFzZSByZWFkIGh0dHBzOi8vZ2l0aHViLmNvbS9QcmlzbUpTL3ByaXNtL3B1bGwvMjM3MyBmaXJzdC5cbiAgICAgICdwdW5jdHVhdGlvbic6IC9bKCksXS9cbiAgICB9XG4gIH07XG4gIFByaXNtLmxhbmd1YWdlcy5jc3NbJ2F0cnVsZSddLmluc2lkZVsnc2VsZWN0b3ItZnVuY3Rpb24tYXJndW1lbnQnXS5pbnNpZGUgPSBzZWxlY3Rvckluc2lkZTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3NzJywgJ3Byb3BlcnR5Jywge1xuICAgICd2YXJpYWJsZSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXi1cXHdcXHhBMC1cXHVGRkZGXSktLSg/IVxccylbLV9hLXpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbLVxcd1xceEEwLVxcdUZGRkZdKSovaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9XG4gIH0pO1xuICB2YXIgdW5pdCA9IHtcbiAgICBwYXR0ZXJuOiAvKFxcYlxcZCspKD86JXxbYS16XSsoPyFbXFx3LV0pKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9OyAvLyAxMjMgLTEyMyAuMTIzIC0uMTIzIDEyLjMgLTEyLjNcblxuICB2YXIgbnVtYmVyID0ge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcdy4tXSktPyg/OlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKykvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY3NzJywgJ2Z1bmN0aW9uJywge1xuICAgICdvcGVyYXRvcic6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxzKVsrXFwtKlxcL10oPz1cXHMpLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgIC8vIENBUkVGVUwhXG4gICAgLy8gUHJldmlld2VycyBhbmQgSW5saW5lIGNvbG9yIHVzZSBoZXhjb2RlIGFuZCBjb2xvci5cbiAgICAnaGV4Y29kZSc6IHtcbiAgICAgIHBhdHRlcm46IC9cXEIjW1xcZGEtZl17Myw4fVxcYi9pLFxuICAgICAgYWxpYXM6ICdjb2xvcidcbiAgICB9LFxuICAgICdjb2xvcic6IFt7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXHctXSkoPzpBbGljZUJsdWV8QW50aXF1ZVdoaXRlfEFxdWF8QXF1YW1hcmluZXxBenVyZXxCZWlnZXxCaXNxdWV8QmxhY2t8QmxhbmNoZWRBbG1vbmR8Qmx1ZXxCbHVlVmlvbGV0fEJyb3dufEJ1cmx5V29vZHxDYWRldEJsdWV8Q2hhcnRyZXVzZXxDaG9jb2xhdGV8Q29yYWx8Q29ybmZsb3dlckJsdWV8Q29ybnNpbGt8Q3JpbXNvbnxDeWFufERhcmtCbHVlfERhcmtDeWFufERhcmtHb2xkZW5Sb2R8RGFya0dyW2FlXXl8RGFya0dyZWVufERhcmtLaGFraXxEYXJrTWFnZW50YXxEYXJrT2xpdmVHcmVlbnxEYXJrT3JhbmdlfERhcmtPcmNoaWR8RGFya1JlZHxEYXJrU2FsbW9ufERhcmtTZWFHcmVlbnxEYXJrU2xhdGVCbHVlfERhcmtTbGF0ZUdyW2FlXXl8RGFya1R1cnF1b2lzZXxEYXJrVmlvbGV0fERlZXBQaW5rfERlZXBTa3lCbHVlfERpbUdyW2FlXXl8RG9kZ2VyQmx1ZXxGaXJlQnJpY2t8RmxvcmFsV2hpdGV8Rm9yZXN0R3JlZW58RnVjaHNpYXxHYWluc2Jvcm98R2hvc3RXaGl0ZXxHb2xkfEdvbGRlblJvZHxHclthZV15fEdyZWVufEdyZWVuWWVsbG93fEhvbmV5RGV3fEhvdFBpbmt8SW5kaWFuUmVkfEluZGlnb3xJdm9yeXxLaGFraXxMYXZlbmRlcnxMYXZlbmRlckJsdXNofExhd25HcmVlbnxMZW1vbkNoaWZmb258TGlnaHRCbHVlfExpZ2h0Q29yYWx8TGlnaHRDeWFufExpZ2h0R29sZGVuUm9kWWVsbG93fExpZ2h0R3JbYWVdeXxMaWdodEdyZWVufExpZ2h0UGlua3xMaWdodFNhbG1vbnxMaWdodFNlYUdyZWVufExpZ2h0U2t5Qmx1ZXxMaWdodFNsYXRlR3JbYWVdeXxMaWdodFN0ZWVsQmx1ZXxMaWdodFllbGxvd3xMaW1lfExpbWVHcmVlbnxMaW5lbnxNYWdlbnRhfE1hcm9vbnxNZWRpdW1BcXVhTWFyaW5lfE1lZGl1bUJsdWV8TWVkaXVtT3JjaGlkfE1lZGl1bVB1cnBsZXxNZWRpdW1TZWFHcmVlbnxNZWRpdW1TbGF0ZUJsdWV8TWVkaXVtU3ByaW5nR3JlZW58TWVkaXVtVHVycXVvaXNlfE1lZGl1bVZpb2xldFJlZHxNaWRuaWdodEJsdWV8TWludENyZWFtfE1pc3R5Um9zZXxNb2NjYXNpbnxOYXZham9XaGl0ZXxOYXZ5fE9sZExhY2V8T2xpdmV8T2xpdmVEcmFifE9yYW5nZXxPcmFuZ2VSZWR8T3JjaGlkfFBhbGVHb2xkZW5Sb2R8UGFsZUdyZWVufFBhbGVUdXJxdW9pc2V8UGFsZVZpb2xldFJlZHxQYXBheWFXaGlwfFBlYWNoUHVmZnxQZXJ1fFBpbmt8UGx1bXxQb3dkZXJCbHVlfFB1cnBsZXxSZWR8Um9zeUJyb3dufFJveWFsQmx1ZXxTYWRkbGVCcm93bnxTYWxtb258U2FuZHlCcm93bnxTZWFHcmVlbnxTZWFTaGVsbHxTaWVubmF8U2lsdmVyfFNreUJsdWV8U2xhdGVCbHVlfFNsYXRlR3JbYWVdeXxTbm93fFNwcmluZ0dyZWVufFN0ZWVsQmx1ZXxUYW58VGVhbHxUaGlzdGxlfFRvbWF0b3xUcmFuc3BhcmVudHxUdXJxdW9pc2V8VmlvbGV0fFdoZWF0fFdoaXRlfFdoaXRlU21va2V8WWVsbG93fFllbGxvd0dyZWVuKSg/IVtcXHctXSkvaSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBwYXR0ZXJuOiAvXFxiKD86aHNsfHJnYilcXChcXHMqXFxkezEsM31cXHMqLFxccypcXGR7MSwzfSU/XFxzKixcXHMqXFxkezEsM30lP1xccypcXClcXEJ8XFxiKD86aHNsfHJnYilhXFwoXFxzKlxcZHsxLDN9XFxzKixcXHMqXFxkezEsM30lP1xccyosXFxzKlxcZHsxLDN9JT9cXHMqLFxccyooPzowfDA/XFwuXFxkK3wxKVxccypcXClcXEIvaSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndW5pdCc6IHVuaXQsXG4gICAgICAgICdudW1iZXInOiBudW1iZXIsXG4gICAgICAgICdmdW5jdGlvbic6IC9bXFx3LV0rKD89XFwoKS8sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9bKCksXS9cbiAgICAgIH1cbiAgICB9XSxcbiAgICAvLyBpdCdzIGltcG9ydGFudCB0aGF0IHRoZXJlIGlzIG5vIGJvdW5kYXJ5IGFzc2VydGlvbiBhZnRlciB0aGUgaGV4IGRpZ2l0c1xuICAgICdlbnRpdHknOiAvXFxcXFtcXGRhLWZdezEsOH0vaSxcbiAgICAndW5pdCc6IHVuaXQsXG4gICAgJ251bWJlcic6IG51bWJlclxuICB9KTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWphdmFzY3JpcHRcIiAqL1xuXG5cbnByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0ID0gcHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICdjbGFzcy1uYW1lJzogW3ByaXNtLmxhbmd1YWdlcy5jbGlrZVsnY2xhc3MtbmFtZSddLCB7XG4gICAgcGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXC4oPzpjb25zdHJ1Y3Rvcnxwcm90b3R5cGUpKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XSxcbiAgJ2tleXdvcmQnOiBbe1xuICAgIHBhdHRlcm46IC8oKD86XnxcXH0pXFxzKiljYXRjaFxcYi8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LCB7XG4gICAgcGF0dGVybjogLyhefFteLl18XFwuXFwuXFwuXFxzKilcXGIoPzphc3xhc3NlcnQoPz1cXHMqXFx7KXxhc3luYyg/PVxccyooPzpmdW5jdGlvblxcYnxcXCh8WyRcXHdcXHhBMC1cXHVGRkZGXXwkKSl8YXdhaXR8YnJlYWt8Y2FzZXxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseSg/PVxccyooPzpcXHt8JCkpfGZvcnxmcm9tKD89XFxzKig/OlsnXCJdfCQpKXxmdW5jdGlvbnwoPzpnZXR8c2V0KSg/PVxccyooPzpbI1xcWyRcXHdcXHhBMC1cXHVGRkZGXXwkKSl8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgfV0sXG4gIC8vIEFsbG93IGZvciBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgKFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDA4NDQ0KVxuICAnZnVuY3Rpb24nOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKig/OlxcLlxccyooPzphcHBseXxiaW5kfGNhbGwpXFxzKik/XFwoKS8sXG4gICdudW1iZXInOiB7XG4gICAgcGF0dGVybjogUmVnRXhwKC8oXnxbXlxcdyRdKS8uc291cmNlICsgJyg/OicgKyAoIC8vIGNvbnN0YW50XG4gICAgL05hTnxJbmZpbml0eS8uc291cmNlICsgJ3wnICsgLy8gYmluYXJ5IGludGVnZXJcbiAgICAvMFtiQl1bMDFdKyg/Ol9bMDFdKykqbj8vLnNvdXJjZSArICd8JyArIC8vIG9jdGFsIGludGVnZXJcbiAgICAvMFtvT11bMC03XSsoPzpfWzAtN10rKSpuPy8uc291cmNlICsgJ3wnICsgLy8gaGV4YWRlY2ltYWwgaW50ZWdlclxuICAgIC8wW3hYXVtcXGRBLUZhLWZdKyg/Ol9bXFxkQS1GYS1mXSspKm4/Ly5zb3VyY2UgKyAnfCcgKyAvLyBkZWNpbWFsIGJpZ2ludFxuICAgIC9cXGQrKD86X1xcZCspKm4vLnNvdXJjZSArICd8JyArIC8vIGRlY2ltYWwgbnVtYmVyIChpbnRlZ2VyIG9yIGZsb2F0KSBidXQgbm8gYmlnaW50XG4gICAgLyg/OlxcZCsoPzpfXFxkKykqKD86XFwuKD86XFxkKyg/Ol9cXGQrKSopPyk/fFxcLlxcZCsoPzpfXFxkKykqKSg/OltFZV1bKy1dP1xcZCsoPzpfXFxkKykqKT8vLnNvdXJjZSkgKyAnKScgKyAvKD8hW1xcdyRdKS8uc291cmNlKSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdvcGVyYXRvcic6IC8tLXxcXCtcXCt8XFwqXFwqPT98PT58JiY9P3xcXHxcXHw9P3xbIT1dPT18PDw9P3w+Pj4/PT98Wy0rKi8lJnxeIT08Pl09P3xcXC57M318XFw/XFw/PT98XFw/XFwuP3xbfjpdL1xufSk7XG5wcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsnY2xhc3MtbmFtZSddWzBdLnBhdHRlcm4gPSAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXcpXFxzKylbXFx3LlxcXFxdKy87XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG4gICdyZWdleCc6IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWR1cGUtY2hhcmFjdGVycy1jaGFyYWN0ZXItY2xhc3NcbiAgICBwYXR0ZXJuOiAvKCg/Ol58W14kXFx3XFx4QTAtXFx1RkZGRi5cIidcXF0pXFxzXXxcXGIoPzpyZXR1cm58eWllbGQpKVxccyopXFwvKD86XFxbKD86W15cXF1cXFxcXFxyXFxuXXxcXFxcLikqXFxdfFxcXFwufFteL1xcXFxcXFtcXHJcXG5dKStcXC9bZGdpbXl1c117MCw3fSg/PSg/Olxcc3xcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKlxcKlxcLykqKD86JHxbXFxyXFxuLC47On0pXFxdXXxcXC9cXC8pKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAncmVnZXgtc291cmNlJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXihcXC8pW1xcc1xcU10rKD89XFwvW2Etel0qJCkvLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICBhbGlhczogJ2xhbmd1YWdlLXJlZ2V4JyxcbiAgICAgICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXMucmVnZXhcbiAgICAgIH0sXG4gICAgICAncmVnZXgtZGVsaW1pdGVyJzogL15cXC98XFwvJC8sXG4gICAgICAncmVnZXgtZmxhZ3MnOiAvXlthLXpdKyQvXG4gICAgfVxuICB9LFxuICAvLyBUaGlzIG11c3QgYmUgZGVjbGFyZWQgYmVmb3JlIGtleXdvcmQgYmVjYXVzZSB3ZSB1c2UgXCJmdW5jdGlvblwiIGluc2lkZSB0aGUgbG9vay1mb3J3YXJkXG4gICdmdW5jdGlvbi12YXJpYWJsZSc6IHtcbiAgICBwYXR0ZXJuOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKls9Ol1cXHMqKD86YXN5bmNcXHMqKT8oPzpcXGJmdW5jdGlvblxcYnwoPzpcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXwoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKVxccyo9PikpLyxcbiAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICB9LFxuICAncGFyYW1ldGVyJzogW3tcbiAgICBwYXR0ZXJuOiAvKGZ1bmN0aW9uKD86XFxzKyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSopP1xccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXCkpLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpW18kYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKj0+KS9pLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICB9LCB7XG4gICAgcGF0dGVybjogLyhcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqPT4pLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgfSwge1xuICAgIHBhdHRlcm46IC8oKD86XFxifFxcc3xeKSg/ISg/OmFzfGFzeW5jfGF3YWl0fGJyZWFrfGNhc2V8Y2F0Y2h8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHl8Zm9yfGZyb218ZnVuY3Rpb258Z2V0fGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c2V0fHN0YXRpY3xzdXBlcnxzd2l0Y2h8dGhpc3x0aHJvd3x0cnl8dHlwZW9mfHVuZGVmaW5lZHx2YXJ8dm9pZHx3aGlsZXx3aXRofHlpZWxkKSg/IVskXFx3XFx4QTAtXFx1RkZGRl0pKSg/Oig/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSpcXHMqKVxcKFxccyp8XFxdXFxzKlxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKVxccypcXHspLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGluc2lkZTogcHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgfV0sXG4gICdjb25zdGFudCc6IC9cXGJbQS1aXSg/OltBLVpfXXxcXGR4PykqXFxiL1xufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ3N0cmluZycsIHtcbiAgJ2hhc2hiYW5nJzoge1xuICAgIHBhdHRlcm46IC9eIyEuKi8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGFsaWFzOiAnY29tbWVudCdcbiAgfSxcbiAgJ3RlbXBsYXRlLXN0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvYCg/OlxcXFxbXFxzXFxTXXxcXCRcXHsoPzpbXnt9XXxcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfSkqXFx9KStcXH18KD8hXFwkXFx7KVteXFxcXGBdKSpgLyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAndGVtcGxhdGUtcHVuY3R1YXRpb24nOiB7XG4gICAgICAgIHBhdHRlcm46IC9eYHxgJC8sXG4gICAgICAgIGFsaWFzOiAnc3RyaW5nJ1xuICAgICAgfSxcbiAgICAgICdpbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiAvKCg/Ol58W15cXFxcXSkoPzpcXFxcezJ9KSopXFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9LyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ2ludGVycG9sYXRpb24tcHVuY3R1YXRpb24nOiB7XG4gICAgICAgICAgICBwYXR0ZXJuOiAvXlxcJFxce3xcXH0kLyxcbiAgICAgICAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXN0OiBwcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgJ3N0cmluZyc6IC9bXFxzXFxTXSsvXG4gICAgfVxuICB9LFxuICAnc3RyaW5nLXByb3BlcnR5Jzoge1xuICAgIHBhdHRlcm46IC8oKD86XnxbLHtdKVsgXFx0XSopKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMilbXlxcXFxcXHJcXG5dKSpcXDIoPz1cXHMqOikvbSxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ3Byb3BlcnR5J1xuICB9XG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnb3BlcmF0b3InLCB7XG4gICdsaXRlcmFsLXByb3BlcnR5Jzoge1xuICAgIHBhdHRlcm46IC8oKD86XnxbLHtdKVsgXFx0XSopKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9tLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdwcm9wZXJ0eSdcbiAgfVxufSk7XG5cbmlmIChwcmlzbS5sYW5ndWFnZXMubWFya3VwKSB7XG4gIHByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZElubGluZWQoJ3NjcmlwdCcsICdqYXZhc2NyaXB0Jyk7IC8vIGFkZCBhdHRyaWJ1dGUgc3VwcG9ydCBmb3IgYWxsIERPTSBldmVudHMuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cyNTdGFuZGFyZF9ldmVudHNcblxuICBwcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5hZGRBdHRyaWJ1dGUoL29uKD86YWJvcnR8Ymx1cnxjaGFuZ2V8Y2xpY2t8Y29tcG9zaXRpb24oPzplbmR8c3RhcnR8dXBkYXRlKXxkYmxjbGlja3xlcnJvcnxmb2N1cyg/OmlufG91dCk/fGtleSg/OmRvd258dXApfGxvYWR8bW91c2UoPzpkb3dufGVudGVyfGxlYXZlfG1vdmV8b3V0fG92ZXJ8dXApfHJlc2V0fHJlc2l6ZXxzY3JvbGx8c2VsZWN0fHNsb3RjaGFuZ2V8c3VibWl0fHVubG9hZHx3aGVlbCkvLnNvdXJjZSwgJ2phdmFzY3JpcHQnKTtcbn1cblxucHJpc20ubGFuZ3VhZ2VzLmpzID0gcHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQ7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1jb2ZmZWVzY3JpcHRcIiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIC8vIElnbm9yZSBjb21tZW50cyBzdGFydGluZyB3aXRoIHsgdG8gcHJpdmlsZWdlIHN0cmluZyBpbnRlcnBvbGF0aW9uIGhpZ2hsaWdodGluZ1xuICB2YXIgY29tbWVudCA9IC8jKD8hXFx7KS4rLztcbiAgdmFyIGludGVycG9sYXRpb24gPSB7XG4gICAgcGF0dGVybjogLyNcXHtbXn1dK1xcfS8sXG4gICAgYWxpYXM6ICd2YXJpYWJsZSdcbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmNvZmZlZXNjcmlwdCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2phdmFzY3JpcHQnLCB7XG4gICAgJ2NvbW1lbnQnOiBjb21tZW50LFxuICAgICdzdHJpbmcnOiBbLy8gU3RyaW5ncyBhcmUgbXVsdGlsaW5lXG4gICAge1xuICAgICAgcGF0dGVybjogLycoPzpcXFxcW1xcc1xcU118W15cXFxcJ10pKicvLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSwge1xuICAgICAgLy8gU3RyaW5ncyBhcmUgbXVsdGlsaW5lXG4gICAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcIi8sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2ludGVycG9sYXRpb24nOiBpbnRlcnBvbGF0aW9uXG4gICAgICB9XG4gICAgfV0sXG4gICAgJ2tleXdvcmQnOiAvXFxiKD86YW5kfGJyZWFrfGJ5fGNhdGNofGNsYXNzfGNvbnRpbnVlfGRlYnVnZ2VyfGRlbGV0ZXxkb3xlYWNofGVsc2V8ZXh0ZW5kfGV4dGVuZHN8ZmFsc2V8ZmluYWxseXxmb3J8aWZ8aW58aW5zdGFuY2VvZnxpc3xpc250fGxldHxsb29wfG5hbWVzcGFjZXxuZXd8bm98bm90fG51bGx8b2Z8b2ZmfG9ufG9yfG93bnxyZXR1cm58c3VwZXJ8c3dpdGNofHRoZW58dGhpc3x0aHJvd3x0cnVlfHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHVubGVzc3x1bnRpbHx3aGVufHdoaWxlfHdpbmRvd3x3aXRofHllc3x5aWVsZClcXGIvLFxuICAgICdjbGFzcy1tZW1iZXInOiB7XG4gICAgICBwYXR0ZXJuOiAvQCg/IVxcZClcXHcrLyxcbiAgICAgIGFsaWFzOiAndmFyaWFibGUnXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnY29mZmVlc2NyaXB0JywgJ2NvbW1lbnQnLCB7XG4gICAgJ211bHRpbGluZS1jb21tZW50Jzoge1xuICAgICAgcGF0dGVybjogLyMjI1tcXHNcXFNdKz8jIyMvLFxuICAgICAgYWxpYXM6ICdjb21tZW50J1xuICAgIH0sXG4gICAgLy8gQmxvY2sgcmVnZXhwIGNhbiBjb250YWluIGNvbW1lbnRzIGFuZCBpbnRlcnBvbGF0aW9uXG4gICAgJ2Jsb2NrLXJlZ2V4Jzoge1xuICAgICAgcGF0dGVybjogL1xcL3szfVtcXHNcXFNdKj9cXC97M30vLFxuICAgICAgYWxpYXM6ICdyZWdleCcsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2NvbW1lbnQnOiBjb21tZW50LFxuICAgICAgICAnaW50ZXJwb2xhdGlvbic6IGludGVycG9sYXRpb25cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdjb2ZmZWVzY3JpcHQnLCAnc3RyaW5nJywge1xuICAgICdpbmxpbmUtamF2YXNjcmlwdCc6IHtcbiAgICAgIHBhdHRlcm46IC9gKD86XFxcXFtcXHNcXFNdfFteXFxcXGBdKSpgLyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZGVsaW1pdGVyJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eYHxgJC8sXG4gICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgICAgfSxcbiAgICAgICAgJ3NjcmlwdCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvW1xcc1xcU10rLyxcbiAgICAgICAgICBhbGlhczogJ2xhbmd1YWdlLWphdmFzY3JpcHQnLFxuICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQmxvY2sgc3RyaW5nc1xuICAgICdtdWx0aWxpbmUtc3RyaW5nJzogW3tcbiAgICAgIHBhdHRlcm46IC8nJydbXFxzXFxTXSo/JycnLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnc3RyaW5nJ1xuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC9cIlwiXCJbXFxzXFxTXSo/XCJcIlwiLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGFsaWFzOiAnc3RyaW5nJyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBpbnRlcnBvbGF0aW9uOiBpbnRlcnBvbGF0aW9uXG4gICAgICB9XG4gICAgfV1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2NvZmZlZXNjcmlwdCcsICdrZXl3b3JkJywge1xuICAgIC8vIE9iamVjdCBwcm9wZXJ0eVxuICAgICdwcm9wZXJ0eSc6IC8oPyFcXGQpXFx3Kyg/PVxccyo6KD8hOikpL1xuICB9KTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5jb2ZmZWVzY3JpcHRbJ3RlbXBsYXRlLXN0cmluZyddO1xuICBQcmlzbS5sYW5ndWFnZXMuY29mZmVlID0gUHJpc20ubGFuZ3VhZ2VzLmNvZmZlZXNjcmlwdDtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXlhbWxcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjYy1ucy1hbmNob3ItcHJvcGVydHlcbiAgLy8gaHR0cHM6Ly95YW1sLm9yZy9zcGVjLzEuMi9zcGVjLmh0bWwjYy1ucy1hbGlhcy1ub2RlXG4gIHZhciBhbmNob3JPckFsaWFzID0gL1sqJl1bXlxcc1tcXF17fSxdKy87IC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2MtbnMtdGFnLXByb3BlcnR5XG5cbiAgdmFyIHRhZyA9IC8hKD86PFtcXHdcXC0lIzsvPzpAJj0rJCwuIX4qJygpW1xcXV0rPnwoPzpbYS16QS1aXFxkLV0qISk/W1xcd1xcLSUjOy8/OkAmPSskLn4qJygpXSspPy87IC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI2MtbnMtcHJvcGVydGllcyhuLGMpXG5cbiAgdmFyIHByb3BlcnRpZXMgPSAnKD86JyArIHRhZy5zb3VyY2UgKyAnKD86WyBcXHRdKycgKyBhbmNob3JPckFsaWFzLnNvdXJjZSArICcpP3wnICsgYW5jaG9yT3JBbGlhcy5zb3VyY2UgKyAnKD86WyBcXHRdKycgKyB0YWcuc291cmNlICsgJyk/KSc7IC8vIGh0dHBzOi8veWFtbC5vcmcvc3BlYy8xLjIvc3BlYy5odG1sI25zLXBsYWluKG4sYylcbiAgLy8gVGhpcyBpcyBhIHNpbXBsaWZpZWQgdmVyc2lvbiB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBcIiNcIiBhbmQgbXVsdGlsaW5lIGtleXNcbiAgLy8gQWxsIHRoZXNlIGxvbmcgc2NhcnJ5IGNoYXJhY3RlciBjbGFzc2VzIGFyZSBzaW1wbGlmaWVkIHZlcnNpb25zIG9mIFlBTUwncyBjaGFyYWN0ZXJzXG5cbiAgdmFyIHBsYWluS2V5ID0gLyg/OlteXFxzXFx4MDAtXFx4MDhcXHgwZS1cXHgxZiFcIiMlJicqLFxcLTo+P0BbXFxdYHt8fVxceDdmLVxceDg0XFx4ODYtXFx4OWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZl18Wz86LV08UExBSU4+KSg/OlsgXFx0XSooPzooPyFbIzpdKTxQTEFJTj58OjxQTEFJTj4pKSovLnNvdXJjZS5yZXBsYWNlKC88UExBSU4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gL1teXFxzXFx4MDAtXFx4MDhcXHgwZS1cXHgxZixbXFxde31cXHg3Zi1cXHg4NFxceDg2LVxceDlmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZdLy5zb3VyY2U7XG4gIH0pO1xuICB2YXIgc3RyaW5nID0gL1wiKD86W15cIlxcXFxcXHJcXG5dfFxcXFwuKSpcInwnKD86W14nXFxcXFxcclxcbl18XFxcXC4pKicvLnNvdXJjZTtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICAgKiBAcmV0dXJucyB7UmVnRXhwfVxuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVWYWx1ZVBhdHRlcm4odmFsdWUsIGZsYWdzKSB7XG4gICAgZmxhZ3MgPSAoZmxhZ3MgfHwgJycpLnJlcGxhY2UoL20vZywgJycpICsgJ20nOyAvLyBhZGQgbSBmbGFnXG5cbiAgICB2YXIgcGF0dGVybiA9IC8oWzpcXC0sW3tdXFxzKig/Olxcczw8cHJvcD4+WyBcXHRdKyk/KSg/Ojw8dmFsdWU+PikoPz1bIFxcdF0qKD86JHwsfFxcXXxcXH18KD86W1xcclxcbl1cXHMqKT8jKSkvLnNvdXJjZS5yZXBsYWNlKC88PHByb3A+Pi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9KS5yZXBsYWNlKC88PHZhbHVlPj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICB9XG5cbiAgUHJpc20ubGFuZ3VhZ2VzLnlhbWwgPSB7XG4gICAgJ3NjYWxhcic6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKFtcXC06XVxccyooPzpcXHM8PHByb3A+PlsgXFx0XSspP1t8Pl0pWyBcXHRdKig/OigoPzpcXHI/XFxufFxccilbIFxcdF0rKVxcU1teXFxyXFxuXSooPzpcXDJbXlxcclxcbl0rKSopLy5zb3VyY2UucmVwbGFjZSgvPDxwcm9wPj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICAgIH0pKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ3N0cmluZydcbiAgICB9LFxuICAgICdjb21tZW50JzogLyMuKi8sXG4gICAgJ2tleSc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKCg/Ol58WzpcXC0sW3tcXHJcXG4/XSlbIFxcdF0qKD86PDxwcm9wPj5bIFxcdF0rKT8pPDxrZXk+Pig/PVxccyo6XFxzKS8uc291cmNlLnJlcGxhY2UoLzw8cHJvcD4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgICB9KS5yZXBsYWNlKC88PGtleT4+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcoPzonICsgcGxhaW5LZXkgKyAnfCcgKyBzdHJpbmcgKyAnKSc7XG4gICAgICB9KSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgYWxpYXM6ICdhdHJ1bGUnXG4gICAgfSxcbiAgICAnZGlyZWN0aXZlJzoge1xuICAgICAgcGF0dGVybjogLyheWyBcXHRdKiklLisvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICB9LFxuICAgICdkYXRldGltZSc6IHtcbiAgICAgIHBhdHRlcm46IGNyZWF0ZVZhbHVlUGF0dGVybigvXFxkezR9LVxcZFxcZD8tXFxkXFxkPyg/Olt0VF18WyBcXHRdKylcXGRcXGQ/OlxcZHsyfTpcXGR7Mn0oPzpcXC5cXGQqKT8oPzpbIFxcdF0qKD86WnxbLStdXFxkXFxkPyg/OjpcXGR7Mn0pPykpP3xcXGR7NH0tXFxkezJ9LVxcZHsyfXxcXGRcXGQ/OlxcZHsyfSg/OjpcXGR7Mn0oPzpcXC5cXGQqKT8pPy8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ251bWJlcidcbiAgICB9LFxuICAgICdib29sZWFuJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9mYWxzZXx0cnVlLy5zb3VyY2UsICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgfSxcbiAgICAnbnVsbCc6IHtcbiAgICAgIHBhdHRlcm46IGNyZWF0ZVZhbHVlUGF0dGVybigvbnVsbHx+Ly5zb3VyY2UsICdpJyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdpbXBvcnRhbnQnXG4gICAgfSxcbiAgICAnc3RyaW5nJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKHN0cmluZyksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAnbnVtYmVyJzoge1xuICAgICAgcGF0dGVybjogY3JlYXRlVmFsdWVQYXR0ZXJuKC9bKy1dPyg/OjB4W1xcZGEtZl0rfDBvWzAtN10rfCg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT98XFwuaW5mfFxcLm5hbikvLnNvdXJjZSwgJ2knKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICB9LFxuICAgICd0YWcnOiB0YWcsXG4gICAgJ2ltcG9ydGFudCc6IGFuY2hvck9yQWxpYXMsXG4gICAgJ3B1bmN0dWF0aW9uJzogLy0tLXxbOltcXF17fVxcLSx8Pj9dfFxcLlxcLlxcLi9cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnltbCA9IFByaXNtLmxhbmd1YWdlcy55YW1sO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbWFya2Rvd25cIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgLy8gQWxsb3cgb25seSBvbmUgbGluZSBicmVha1xuICB2YXIgaW5uZXIgPSAvKD86XFxcXC58W15cXFxcXFxuXFxyXXwoPzpcXG58XFxyXFxuPykoPyFbXFxyXFxuXSkpLy5zb3VyY2U7XG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIGZvciB0aGUgY3JlYXRpb24gb2YgdGhlIGJvbGQgb3IgaXRhbGljIHBhdHRlcm4uXG4gICAqXG4gICAqIFRoaXMgYWxzbyBhZGRzIGEgbG9va2JlaGluZCBncm91cCB0byB0aGUgZ2l2ZW4gcGF0dGVybiB0byBlbnN1cmUgdGhhdCB0aGUgcGF0dGVybiBpcyBub3QgYmFja3NsYXNoLWVzY2FwZWQuXG4gICAqXG4gICAqIF9Ob3RlOl8gS2VlcCBpbiBtaW5kIHRoYXQgdGhpcyBhZGRzIGEgY2FwdHVyaW5nIGdyb3VwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVyblxuICAgKiBAcmV0dXJucyB7UmVnRXhwfVxuICAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVJbmxpbmUocGF0dGVybikge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoLzxpbm5lcj4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGlubmVyO1xuICAgIH0pO1xuICAgIHJldHVybiBSZWdFeHAoLygoPzpefFteXFxcXF0pKD86XFxcXHsyfSkqKS8uc291cmNlICsgJyg/OicgKyBwYXR0ZXJuICsgJyknKTtcbiAgfVxuXG4gIHZhciB0YWJsZUNlbGwgPSAvKD86XFxcXC58YGAoPzpbXmBcXHJcXG5dfGAoPyFgKSkrYGB8YFteYFxcclxcbl0rYHxbXlxcXFx8XFxyXFxuYF0pKy8uc291cmNlO1xuICB2YXIgdGFibGVSb3cgPSAvXFx8P19fKD86XFx8X18pK1xcfD8oPzooPzpcXG58XFxyXFxuPyl8KD8hW1xcc1xcU10pKS8uc291cmNlLnJlcGxhY2UoL19fL2csIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGFibGVDZWxsO1xuICB9KTtcbiAgdmFyIHRhYmxlTGluZSA9IC9cXHw/WyBcXHRdKjo/LXszLH06P1sgXFx0XSooPzpcXHxbIFxcdF0qOj8tezMsfTo/WyBcXHRdKikrXFx8Pyg/OlxcbnxcXHJcXG4/KS8uc291cmNlO1xuICBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd24gPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdtYXJrdXAnLCB7fSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmtkb3duJywgJ3Byb2xvZycsIHtcbiAgICAnZnJvbnQtbWF0dGVyLWJsb2NrJzoge1xuICAgICAgcGF0dGVybjogLyheKD86XFxzKltcXHJcXG5dKT8pLS0tKD8hLilbXFxzXFxTXSo/W1xcclxcbl0tLS0oPyEuKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9eLS0tfC0tLSQvLFxuICAgICAgICAnZnJvbnQtbWF0dGVyJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9cXFMrKD86XFxzK1xcUyspKi8sXG4gICAgICAgICAgYWxpYXM6IFsneWFtbCcsICdsYW5ndWFnZS15YW1sJ10sXG4gICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMueWFtbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAnYmxvY2txdW90ZSc6IHtcbiAgICAgIC8vID4gLi4uXG4gICAgICBwYXR0ZXJuOiAvXj4oPzpbXFx0IF0qPikqL20sXG4gICAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICAgIH0sXG4gICAgJ3RhYmxlJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCdeJyArIHRhYmxlUm93ICsgdGFibGVMaW5lICsgJyg/OicgKyB0YWJsZVJvdyArICcpKicsICdtJyksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3RhYmxlLWRhdGEtcm93cyc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14oJyArIHRhYmxlUm93ICsgdGFibGVMaW5lICsgJykoPzonICsgdGFibGVSb3cgKyAnKSokJyksXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICd0YWJsZS1kYXRhJzoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiBSZWdFeHAodGFibGVDZWxsKSxcbiAgICAgICAgICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncHVuY3R1YXRpb24nOiAvXFx8L1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ3RhYmxlLWxpbmUnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCdeKCcgKyB0YWJsZVJvdyArICcpJyArIHRhYmxlTGluZSArICckJyksXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICdwdW5jdHVhdGlvbic6IC9cXHx8Oj8tezMsfTo/L1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ3RhYmxlLWhlYWRlci1yb3cnOiB7XG4gICAgICAgICAgcGF0dGVybjogUmVnRXhwKCdeJyArIHRhYmxlUm93ICsgJyQnKSxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICd0YWJsZS1oZWFkZXInOiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cCh0YWJsZUNlbGwpLFxuICAgICAgICAgICAgICBhbGlhczogJ2ltcG9ydGFudCcsXG4gICAgICAgICAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcfC9cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICdjb2RlJzogW3tcbiAgICAgIC8vIFByZWZpeGVkIGJ5IDQgc3BhY2VzIG9yIDEgdGFiIGFuZCBwcmVjZWRlZCBieSBhbiBlbXB0eSBsaW5lXG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58XFxuKVsgXFx0XSpcXG58KD86XnxcXHJcXG4/KVsgXFx0XSpcXHJcXG4/KSg/OiB7NH18XFx0KS4rKD86KD86XFxufFxcclxcbj8pKD86IHs0fXxcXHQpLispKi8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdrZXl3b3JkJ1xuICAgIH0sIHtcbiAgICAgIC8vIGBgYG9wdGlvbmFsIGxhbmd1YWdlXG4gICAgICAvLyBjb2RlIGJsb2NrXG4gICAgICAvLyBgYGBcbiAgICAgIHBhdHRlcm46IC9eYGBgW1xcc1xcU10qP15gYGAkL20sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2NvZGUtYmxvY2snOiB7XG4gICAgICAgICAgcGF0dGVybjogL14oYGBgLiooPzpcXG58XFxyXFxuPykpW1xcc1xcU10rPyg/PSg/OlxcbnxcXHJcXG4/KV5gYGAkKS9tLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgJ2NvZGUtbGFuZ3VhZ2UnOiB7XG4gICAgICAgICAgcGF0dGVybjogL14oYGBgKS4rLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9gYGAvXG4gICAgICB9XG4gICAgfV0sXG4gICAgJ3RpdGxlJzogW3tcbiAgICAgIC8vIHRpdGxlIDFcbiAgICAgIC8vID09PT09PT1cbiAgICAgIC8vIHRpdGxlIDJcbiAgICAgIC8vIC0tLS0tLS1cbiAgICAgIHBhdHRlcm46IC9cXFMuKig/OlxcbnxcXHJcXG4/KSg/Oj09K3wtLSspKD89WyBcXHRdKiQpL20sXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCcsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgcHVuY3R1YXRpb246IC89PSskfC0tKyQvXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gIyB0aXRsZSAxXG4gICAgICAvLyAjIyMjIyMgdGl0bGUgNlxuICAgICAgcGF0dGVybjogLyheXFxzKikjLisvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2ltcG9ydGFudCcsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgcHVuY3R1YXRpb246IC9eIyt8IyskL1xuICAgICAgfVxuICAgIH1dLFxuICAgICdocic6IHtcbiAgICAgIC8vICoqKlxuICAgICAgLy8gLS0tXG4gICAgICAvLyAqICogKlxuICAgICAgLy8gLS0tLS0tLS0tLS1cbiAgICAgIHBhdHRlcm46IC8oXlxccyopKFsqLV0pKD86W1xcdCBdKlxcMil7Mix9KD89XFxzKiQpL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICB9LFxuICAgICdsaXN0Jzoge1xuICAgICAgLy8gKiBpdGVtXG4gICAgICAvLyArIGl0ZW1cbiAgICAgIC8vIC0gaXRlbVxuICAgICAgLy8gMS4gaXRlbVxuICAgICAgcGF0dGVybjogLyheXFxzKikoPzpbKistXXxcXGQrXFwuKSg/PVtcXHQgXS4pL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICB9LFxuICAgICd1cmwtcmVmZXJlbmNlJzoge1xuICAgICAgLy8gW2lkXTogaHR0cDovL2V4YW1wbGUuY29tIFwiT3B0aW9uYWwgdGl0bGVcIlxuICAgICAgLy8gW2lkXTogaHR0cDovL2V4YW1wbGUuY29tICdPcHRpb25hbCB0aXRsZSdcbiAgICAgIC8vIFtpZF06IGh0dHA6Ly9leGFtcGxlLmNvbSAoT3B0aW9uYWwgdGl0bGUpXG4gICAgICAvLyBbaWRdOiA8aHR0cDovL2V4YW1wbGUuY29tPiBcIk9wdGlvbmFsIHRpdGxlXCJcbiAgICAgIHBhdHRlcm46IC8hP1xcW1teXFxdXStcXF06W1xcdCBdKyg/OlxcUyt8PCg/OlxcXFwufFtePlxcXFxdKSs+KSg/OltcXHQgXSsoPzpcIig/OlxcXFwufFteXCJcXFxcXSkqXCJ8Jyg/OlxcXFwufFteJ1xcXFxdKSonfFxcKCg/OlxcXFwufFteKVxcXFxdKSpcXCkpKT8vLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICd2YXJpYWJsZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXighP1xcWylbXlxcXV0rLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdzdHJpbmcnOiAvKD86XCIoPzpcXFxcLnxbXlwiXFxcXF0pKlwifCcoPzpcXFxcLnxbXidcXFxcXSkqJ3xcXCgoPzpcXFxcLnxbXilcXFxcXSkqXFwpKSQvLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvXltcXFtcXF0hOl18Wzw+XS9cbiAgICAgIH0sXG4gICAgICBhbGlhczogJ3VybCdcbiAgICB9LFxuICAgICdib2xkJzoge1xuICAgICAgLy8gKipzdHJvbmcqKlxuICAgICAgLy8gX19zdHJvbmdfX1xuICAgICAgLy8gYWxsb3cgb25lIG5lc3RlZCBpbnN0YW5jZSBvZiBpdGFsaWMgdGV4dCB1c2luZyB0aGUgc2FtZSBkZWxpbWl0ZXJcbiAgICAgIHBhdHRlcm46IGNyZWF0ZUlubGluZSgvXFxiX18oPzooPyFfKTxpbm5lcj58Xyg/Oig/IV8pPGlubmVyPikrXykrX19cXGJ8XFwqXFwqKD86KD8hXFwqKTxpbm5lcj58XFwqKD86KD8hXFwqKTxpbm5lcj4pK1xcKikrXFwqXFwqLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29udGVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF4uLilbXFxzXFxTXSsoPz0uLiQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge30gLy8gc2VlIGJlbG93XG5cbiAgICAgICAgfSxcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcKlxcKnxfXy9cbiAgICAgIH1cbiAgICB9LFxuICAgICdpdGFsaWMnOiB7XG4gICAgICAvLyAqZW0qXG4gICAgICAvLyBfZW1fXG4gICAgICAvLyBhbGxvdyBvbmUgbmVzdGVkIGluc3RhbmNlIG9mIGJvbGQgdGV4dCB1c2luZyB0aGUgc2FtZSBkZWxpbWl0ZXJcbiAgICAgIHBhdHRlcm46IGNyZWF0ZUlubGluZSgvXFxiXyg/Oig/IV8pPGlubmVyPnxfXyg/Oig/IV8pPGlubmVyPikrX18pK19cXGJ8XFwqKD86KD8hXFwqKTxpbm5lcj58XFwqXFwqKD86KD8hXFwqKTxpbm5lcj4pK1xcKlxcKikrXFwqLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnY29udGVudCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKF4uKVtcXHNcXFNdKyg/PS4kKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHt9IC8vIHNlZSBiZWxvd1xuXG4gICAgICAgIH0sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9bKl9dL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ3N0cmlrZSc6IHtcbiAgICAgIC8vIH5+c3RyaWtlIHRocm91Z2h+flxuICAgICAgLy8gfnN0cmlrZX5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWdleHAvc3RyaWN0XG4gICAgICBwYXR0ZXJuOiBjcmVhdGVJbmxpbmUoLyh+fj8pKD86KD8hfik8aW5uZXI+KStcXDIvLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdjb250ZW50Jzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXn5+PylbXFxzXFxTXSsoPz1cXDEkKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgICBpbnNpZGU6IHt9IC8vIHNlZSBiZWxvd1xuXG4gICAgICAgIH0sXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9+fj8vXG4gICAgICB9XG4gICAgfSxcbiAgICAnY29kZS1zbmlwcGV0Jzoge1xuICAgICAgLy8gYGNvZGVgXG4gICAgICAvLyBgYGNvZGVgYFxuICAgICAgcGF0dGVybjogLyhefFteXFxcXGBdKSg/OmBgW15gXFxyXFxuXSsoPzpgW15gXFxyXFxuXSspKmBgKD8hYCl8YFteYFxcclxcbl0rYCg/IWApKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgYWxpYXM6IFsnY29kZScsICdrZXl3b3JkJ11cbiAgICB9LFxuICAgICd1cmwnOiB7XG4gICAgICAvLyBbZXhhbXBsZV0oaHR0cDovL2V4YW1wbGUuY29tIFwiT3B0aW9uYWwgdGl0bGVcIilcbiAgICAgIC8vIFtleGFtcGxlXVtpZF1cbiAgICAgIC8vIFtleGFtcGxlXSBbaWRdXG4gICAgICBwYXR0ZXJuOiBjcmVhdGVJbmxpbmUoLyE/XFxbKD86KD8hXFxdKTxpbm5lcj4pK1xcXSg/OlxcKFteXFxzKV0rKD86W1xcdCBdK1wiKD86XFxcXC58W15cIlxcXFxdKSpcIik/XFwpfFsgXFx0XT9cXFsoPzooPyFcXF0pPGlubmVyPikrXFxdKS8uc291cmNlKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ29wZXJhdG9yJzogL14hLyxcbiAgICAgICAgJ2NvbnRlbnQnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheXFxbKVteXFxdXSsoPz1cXF0pLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgICAgIGluc2lkZToge30gLy8gc2VlIGJlbG93XG5cbiAgICAgICAgfSxcbiAgICAgICAgJ3ZhcmlhYmxlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXlxcXVsgXFx0XT9cXFspW15cXF1dKyg/PVxcXSQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICd1cmwnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheXFxdXFwoKVteXFxzKV0rLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdzdHJpbmcnOiB7XG4gICAgICAgICAgcGF0dGVybjogLyheWyBcXHRdKylcIig/OlxcXFwufFteXCJcXFxcXSkqXCIoPz1cXCkkKS8sXG4gICAgICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgWyd1cmwnLCAnYm9sZCcsICdpdGFsaWMnLCAnc3RyaWtlJ10uZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBbJ3VybCcsICdib2xkJywgJ2l0YWxpYycsICdzdHJpa2UnLCAnY29kZS1zbmlwcGV0J10uZm9yRWFjaChmdW5jdGlvbiAoaW5zaWRlKSB7XG4gICAgICBpZiAodG9rZW4gIT09IGluc2lkZSkge1xuICAgICAgICBQcmlzbS5sYW5ndWFnZXMubWFya2Rvd25bdG9rZW5dLmluc2lkZS5jb250ZW50Lmluc2lkZVtpbnNpZGVdID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duW2luc2lkZV07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIGlmIChlbnYubGFuZ3VhZ2UgIT09ICdtYXJrZG93bicgJiYgZW52Lmxhbmd1YWdlICE9PSAnbWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fsa1Rva2Vucyh0b2tlbnMpIHtcbiAgICAgIGlmICghdG9rZW5zIHx8IHR5cGVvZiB0b2tlbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ2NvZGUnKSB7XG4gICAgICAgICAgd2Fsa1Rva2Vucyh0b2tlbi5jb250ZW50KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBBZGQgdGhlIGNvcnJlY3QgYGxhbmd1YWdlLXh4eHhgIGNsYXNzIHRvIHRoaXMgY29kZSBibG9jay4gS2VlcCBpbiBtaW5kIHRoYXQgdGhlIGBjb2RlLWxhbmd1YWdlYCB0b2tlblxuICAgICAgICAgKiBpcyBvcHRpb25hbC4gQnV0IHRoZSBncmFtbWFyIGlzIGRlZmluZWQgc28gdGhhdCB0aGVyZSBpcyBvbmx5IG9uZSBjYXNlIHdlIGhhdmUgdG8gaGFuZGxlOlxuICAgICAgICAgKlxuICAgICAgICAgKiB0b2tlbi5jb250ZW50ID0gW1xuICAgICAgICAgKiAgICAgPHNwYW4gY2xhc3M9XCJwdW5jdHVhdGlvblwiPmBgYDwvc3Bhbj4sXG4gICAgICAgICAqICAgICA8c3BhbiBjbGFzcz1cImNvZGUtbGFuZ3VhZ2VcIj54eHh4PC9zcGFuPixcbiAgICAgICAgICogICAgICdcXG4nLCAvLyBleGFjdGx5IG9uZSBuZXcgbGluZXMgKFxcciBvciBcXG4gb3IgXFxyXFxuKVxuICAgICAgICAgKiAgICAgPHNwYW4gY2xhc3M9XCJjb2RlLWJsb2NrXCI+Li4uPC9zcGFuPixcbiAgICAgICAgICogICAgICdcXG4nLCAvLyBleGFjdGx5IG9uZSBuZXcgbGluZXMgYWdhaW5cbiAgICAgICAgICogICAgIDxzcGFuIGNsYXNzPVwicHVuY3R1YXRpb25cIj5gYGA8L3NwYW4+XG4gICAgICAgICAqIF07XG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgdmFyIGNvZGVMYW5nID0gdG9rZW4uY29udGVudFsxXTtcbiAgICAgICAgdmFyIGNvZGVCbG9jayA9IHRva2VuLmNvbnRlbnRbM107XG5cbiAgICAgICAgaWYgKGNvZGVMYW5nICYmIGNvZGVCbG9jayAmJiBjb2RlTGFuZy50eXBlID09PSAnY29kZS1sYW5ndWFnZScgJiYgY29kZUJsb2NrLnR5cGUgPT09ICdjb2RlLWJsb2NrJyAmJiB0eXBlb2YgY29kZUxhbmcuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGJlIGEgbGFuZ3VhZ2UgdGhhdCBQcmlzbSBkb2VzIG5vdCBzdXBwb3J0XG4gICAgICAgICAgLy8gZG8gc29tZSByZXBsYWNlbWVudHMgdG8gc3VwcG9ydCBDKyssIEMjLCBhbmQgRiNcbiAgICAgICAgICB2YXIgbGFuZyA9IGNvZGVMYW5nLmNvbnRlbnQucmVwbGFjZSgvXFxiIy9nLCAnc2hhcnAnKS5yZXBsYWNlKC9cXGJcXCtcXCsvZywgJ3BwJyk7IC8vIG9ubHkgdXNlIHRoZSBmaXJzdCB3b3JkXG5cbiAgICAgICAgICBsYW5nID0gKC9bYS16XVtcXHctXSovaS5leGVjKGxhbmcpIHx8IFsnJ10pWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgdmFyIGFsaWFzID0gJ2xhbmd1YWdlLScgKyBsYW5nOyAvLyBhZGQgYWxpYXNcblxuICAgICAgICAgIGlmICghY29kZUJsb2NrLmFsaWFzKSB7XG4gICAgICAgICAgICBjb2RlQmxvY2suYWxpYXMgPSBbYWxpYXNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGVCbG9jay5hbGlhcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvZGVCbG9jay5hbGlhcyA9IFtjb2RlQmxvY2suYWxpYXMsIGFsaWFzXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZUJsb2NrLmFsaWFzLnB1c2goYWxpYXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHdhbGtUb2tlbnMoZW52LnRva2Vucyk7XG4gIH0pO1xuICBQcmlzbS5ob29rcy5hZGQoJ3dyYXAnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgaWYgKGVudi50eXBlICE9PSAnY29kZS1ibG9jaycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29kZUxhbmcgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZW52LmNsYXNzZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2xzID0gZW52LmNsYXNzZXNbaV07XG4gICAgICB2YXIgbWF0Y2ggPSAvbGFuZ3VhZ2UtKC4rKS8uZXhlYyhjbHMpO1xuXG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29kZUxhbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXNbY29kZUxhbmddO1xuXG4gICAgaWYgKCFncmFtbWFyKSB7XG4gICAgICBpZiAoY29kZUxhbmcgJiYgY29kZUxhbmcgIT09ICdub25lJyAmJiBQcmlzbS5wbHVnaW5zLmF1dG9sb2FkZXIpIHtcbiAgICAgICAgdmFyIGlkID0gJ21kLScgKyBuZXcgRGF0ZSgpLnZhbHVlT2YoKSArICctJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTYpO1xuICAgICAgICBlbnYuYXR0cmlidXRlc1snaWQnXSA9IGlkO1xuICAgICAgICBQcmlzbS5wbHVnaW5zLmF1dG9sb2FkZXIubG9hZExhbmd1YWdlcyhjb2RlTGFuZywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBlbGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAgICAgICBpZiAoZWxlKSB7XG4gICAgICAgICAgICBlbGUuaW5uZXJIVE1MID0gUHJpc20uaGlnaGxpZ2h0KGVsZS50ZXh0Q29udGVudCwgUHJpc20ubGFuZ3VhZ2VzW2NvZGVMYW5nXSwgY29kZUxhbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudi5jb250ZW50ID0gUHJpc20uaGlnaGxpZ2h0KHRleHRDb250ZW50KGVudi5jb250ZW50KSwgZ3JhbW1hciwgY29kZUxhbmcpO1xuICAgIH1cbiAgfSk7XG4gIHZhciB0YWdQYXR0ZXJuID0gUmVnRXhwKFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLnBhdHRlcm4uc291cmNlLCAnZ2knKTtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBrbm93biBlbnRpdHkgbmFtZXMuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBhbHdheXMgYmUgaW5jb21wbGV0ZSB0byBzYXZlIHNwYWNlLiBUaGUgY3VycmVudCBsaXN0IGlzIHRoZSBvbmUgdXNlZCBieSBsb3dkYXNoJ3MgdW5lc2NhcGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvMmRhMDI0YzNiNGY5OTQ3YTQ4NTE3NjM5ZGU3NTYwNDU3Y2Q0ZWM2Yy91bmVzY2FwZS5qcyNMMn1cbiAgICovXG5cbiAgdmFyIEtOT1dOX0VOVElUWV9OQU1FUyA9IHtcbiAgICAnYW1wJzogJyYnLFxuICAgICdsdCc6ICc8JyxcbiAgICAnZ3QnOiAnPicsXG4gICAgJ3F1b3QnOiAnXCInXG4gIH07IC8vIElFIDExIGRvZXNuJ3Qgc3VwcG9ydCBgU3RyaW5nLmZyb21Db2RlUG9pbnRgXG5cbiAgdmFyIGZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dCBjb250ZW50IG9mIGEgZ2l2ZW4gSFRNTCBzb3VyY2UgY29kZSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRleHRDb250ZW50KGh0bWwpIHtcbiAgICAvLyByZW1vdmUgYWxsIHRhZ3NcbiAgICB2YXIgdGV4dCA9IGh0bWwucmVwbGFjZSh0YWdQYXR0ZXJuLCAnJyk7IC8vIGRlY29kZSBrbm93biBlbnRpdGllc1xuXG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSgvJihcXHd7MSw4fXwjeD9bXFxkYS1mXXsxLDh9KTsvZ2ksIGZ1bmN0aW9uIChtLCBjb2RlKSB7XG4gICAgICBjb2RlID0gY29kZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAoY29kZVswXSA9PT0gJyMnKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoY29kZVsxXSA9PT0gJ3gnKSB7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUludChjb2RlLnNsaWNlKDIpLCAxNik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBOdW1iZXIoY29kZS5zbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnJvbUNvZGVQb2ludCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga25vd24gPSBLTk9XTl9FTlRJVFlfTkFNRVNbY29kZV07XG5cbiAgICAgICAgaWYgKGtub3duKSB7XG4gICAgICAgICAgcmV0dXJuIGtub3duO1xuICAgICAgICB9IC8vIHVuYWJsZSB0byBkZWNvZGVcblxuXG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgUHJpc20ubGFuZ3VhZ2VzLm1kID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmtkb3duO1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tZ3JhcGhxbFwiICovXG5cblxucHJpc20ubGFuZ3VhZ2VzLmdyYXBocWwgPSB7XG4gICdjb21tZW50JzogLyMuKi8sXG4gICdkZXNjcmlwdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKD86XCJcIlwiKD86W15cIl18KD8hXCJcIlwiKVwiKSpcIlwiXCJ8XCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiKSg/PVxccypbYS16X10pL2ksXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGFsaWFzOiAnc3RyaW5nJyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdsYW5ndWFnZS1tYXJrZG93bic6IHtcbiAgICAgICAgcGF0dGVybjogLyheXCIoPzpcIlwiKT8pKD8hXFwxKVtcXHNcXFNdKyg/PVxcMSQpLyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiBwcmlzbS5sYW5ndWFnZXMubWFya2Rvd25cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogL1wiXCJcIig/OlteXCJdfCg/IVwiXCJcIilcIikqXCJcIlwifFwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIi8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdudW1iZXInOiAvKD86XFxCLXxcXGIpXFxkKyg/OlxcLlxcZCspPyg/OmVbKy1dP1xcZCspP1xcYi9pLFxuICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICd2YXJpYWJsZSc6IC9cXCRbYS16X11cXHcqL2ksXG4gICdkaXJlY3RpdmUnOiB7XG4gICAgcGF0dGVybjogL0BbYS16X11cXHcqL2ksXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ2F0dHItbmFtZSc6IHtcbiAgICBwYXR0ZXJuOiAvXFxiW2Etel9dXFx3Kig/PVxccyooPzpcXCgoPzpbXigpXCJdfFwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIikqXFwpKT86KS9pLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnYXRvbS1pbnB1dCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxiW0EtWl1cXHcqSW5wdXRcXGIvLFxuICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgfSxcbiAgJ3NjYWxhcic6IC9cXGIoPzpCb29sZWFufEZsb2F0fElEfEludHxTdHJpbmcpXFxiLyxcbiAgJ2NvbnN0YW50JzogL1xcYltBLVpdW0EtWl9cXGRdKlxcYi8sXG4gICdjbGFzcy1uYW1lJzoge1xuICAgIHBhdHRlcm46IC8oXFxiKD86ZW51bXxpbXBsZW1lbnRzfGludGVyZmFjZXxvbnxzY2FsYXJ8dHlwZXx1bmlvbilcXHMrfCZcXHMqfDpcXHMqfFxcWylbQS1aX11cXHcqLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdmcmFnbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYmZyYWdtZW50XFxzK3xcXC57M31cXHMqKD8hb25cXGIpKVthLXpBLVpfXVxcdyovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6ICdmdW5jdGlvbidcbiAgfSxcbiAgJ2RlZmluaXRpb24tbXV0YXRpb24nOiB7XG4gICAgcGF0dGVybjogLyhcXGJtdXRhdGlvblxccyspW2EtekEtWl9dXFx3Ki8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICB9LFxuICAnZGVmaW5pdGlvbi1xdWVyeSc6IHtcbiAgICBwYXR0ZXJuOiAvKFxcYnF1ZXJ5XFxzKylbYS16QS1aX11cXHcqLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/OmRpcmVjdGl2ZXxlbnVtfGV4dGVuZHxmcmFnbWVudHxpbXBsZW1lbnRzfGlucHV0fGludGVyZmFjZXxtdXRhdGlvbnxvbnxxdWVyeXxyZXBlYXRhYmxlfHNjYWxhcnxzY2hlbWF8c3Vic2NyaXB0aW9ufHR5cGV8dW5pb24pXFxiLyxcbiAgJ29wZXJhdG9yJzogL1shPXwmXXxcXC57M30vLFxuICAncHJvcGVydHktcXVlcnknOiAvXFx3Kyg/PVxccypcXCgpLyxcbiAgJ29iamVjdCc6IC9cXHcrKD89XFxzKlxceykvLFxuICAncHVuY3R1YXRpb24nOiAvWyEoKXt9XFxbXFxdOj0sXS8sXG4gICdwcm9wZXJ0eSc6IC9cXHcrL1xufTtcbnByaXNtLmhvb2tzLmFkZCgnYWZ0ZXItdG9rZW5pemUnLCBmdW5jdGlvbiBhZnRlclRva2VuaXplR3JhcGhxbChlbnYpIHtcbiAgaWYgKGVudi5sYW5ndWFnZSAhPT0gJ2dyYXBocWwnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgdGhlIGdyYXBocWwgdG9rZW4gc3RyZWFtIHRoYXQgd2Ugd2FudCB0byBjdXN0b21pemVcbiAgICpcbiAgICogQHR5cGVkZWYge0luc3RhbmNlVHlwZTxpbXBvcnQoXCIuL3ByaXNtLWNvcmVcIilbXCJUb2tlblwiXT59IFRva2VuXG4gICAqIEB0eXBlIHtUb2tlbltdfVxuICAgKi9cblxuXG4gIHZhciB2YWxpZFRva2VucyA9IGVudi50b2tlbnMuZmlsdGVyKGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHJldHVybiB0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnICYmIHRva2VuLnR5cGUgIT09ICdjb21tZW50JyAmJiB0b2tlbi50eXBlICE9PSAnc2NhbGFyJztcbiAgfSk7XG4gIHZhciBjdXJyZW50SW5kZXggPSAwO1xuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSB0b2tlbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBpbmRleCBoYXMgdGhlIGdpdmVuIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybnMge1Rva2VuIHwgdW5kZWZpbmVkfVxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRUb2tlbihvZmZzZXQpIHtcbiAgICByZXR1cm4gdmFsaWRUb2tlbnNbY3VycmVudEluZGV4ICsgb2Zmc2V0XTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSB0b2tlbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBpbmRleCBoYXMgdGhlIGdpdmVuIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7cmVhZG9ubHkgc3RyaW5nW119IHR5cGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGlzVG9rZW5UeXBlKHR5cGVzLCBvZmZzZXQpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IGdldFRva2VuKGkgKyBvZmZzZXQpO1xuXG4gICAgICBpZiAoIXRva2VuIHx8IHRva2VuLnR5cGUgIT09IHR5cGVzW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGNsb3NpbmcgYnJhY2tldCB0byBhbiBvcGVuaW5nIGJyYWNrZXQuXG4gICAqXG4gICAqIEl0IGlzIGFzc3VtZWQgdGhhdCBgdG9rZW5bY3VycmVudEluZGV4IC0gMV1gIGlzIGFuIG9wZW5pbmcgYnJhY2tldC5cbiAgICpcbiAgICogSWYgbm8gY2xvc2luZyBicmFja2V0IGNvdWxkIGJlIGZvdW5kLCBgLTFgIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBvcGVuXG4gICAqIEBwYXJhbSB7UmVnRXhwfSBjbG9zZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChvcGVuLCBjbG9zZSkge1xuICAgIHZhciBzdGFja0hlaWdodCA9IDE7XG5cbiAgICBmb3IgKHZhciBpID0gY3VycmVudEluZGV4OyBpIDwgdmFsaWRUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHZhbGlkVG9rZW5zW2ldO1xuICAgICAgdmFyIGNvbnRlbnQgPSB0b2tlbi5jb250ZW50O1xuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3B1bmN0dWF0aW9uJyAmJiB0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKG9wZW4udGVzdChjb250ZW50KSkge1xuICAgICAgICAgIHN0YWNrSGVpZ2h0Kys7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xvc2UudGVzdChjb250ZW50KSkge1xuICAgICAgICAgIHN0YWNrSGVpZ2h0LS07XG5cbiAgICAgICAgICBpZiAoc3RhY2tIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhbiBhbGlhcyB0byB0aGUgZ2l2ZW4gdG9rZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7VG9rZW59IHRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhc1xuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG5cblxuICBmdW5jdGlvbiBhZGRBbGlhcyh0b2tlbiwgYWxpYXMpIHtcbiAgICB2YXIgYWxpYXNlcyA9IHRva2VuLmFsaWFzO1xuXG4gICAgaWYgKCFhbGlhc2VzKSB7XG4gICAgICB0b2tlbi5hbGlhcyA9IGFsaWFzZXMgPSBbXTtcbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGFsaWFzZXMpKSB7XG4gICAgICB0b2tlbi5hbGlhcyA9IGFsaWFzZXMgPSBbYWxpYXNlc107XG4gICAgfVxuXG4gICAgYWxpYXNlcy5wdXNoKGFsaWFzKTtcbiAgfVxuXG4gIGZvciAoOyBjdXJyZW50SW5kZXggPCB2YWxpZFRva2Vucy5sZW5ndGg7KSB7XG4gICAgdmFyIHN0YXJ0VG9rZW4gPSB2YWxpZFRva2Vuc1tjdXJyZW50SW5kZXgrK107IC8vIGFkZCBzcGVjaWFsIGFsaWFzZXMgZm9yIG11dGF0aW9uIHRva2Vuc1xuXG4gICAgaWYgKHN0YXJ0VG9rZW4udHlwZSA9PT0gJ2tleXdvcmQnICYmIHN0YXJ0VG9rZW4uY29udGVudCA9PT0gJ211dGF0aW9uJykge1xuICAgICAgLy8gYW55IGFycmF5IG9mIHRoZSBuYW1lcyBvZiBhbGwgaW5wdXQgdmFyaWFibGVzIChpZiBhbnkpXG4gICAgICB2YXIgaW5wdXRWYXJpYWJsZXMgPSBbXTtcblxuICAgICAgaWYgKGlzVG9rZW5UeXBlKFsnZGVmaW5pdGlvbi1tdXRhdGlvbicsICdwdW5jdHVhdGlvbiddKSAmJiBnZXRUb2tlbigxKS5jb250ZW50ID09PSAnKCcpIHtcbiAgICAgICAgLy8gZGVmaW5pdGlvblxuICAgICAgICBjdXJyZW50SW5kZXggKz0gMjsgLy8gc2tpcCAnZGVmaW5pdGlvbi1tdXRhdGlvbicgYW5kICdwdW5jdHVhdGlvbidcblxuICAgICAgICB2YXIgZGVmaW5pdGlvbkVuZCA9IGZpbmRDbG9zaW5nQnJhY2tldCgvXlxcKCQvLCAvXlxcKSQvKTtcblxuICAgICAgICBpZiAoZGVmaW5pdGlvbkVuZCA9PT0gLTEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBmaW5kIGFsbCBpbnB1dCB2YXJpYWJsZXNcblxuXG4gICAgICAgIGZvciAoOyBjdXJyZW50SW5kZXggPCBkZWZpbml0aW9uRW5kOyBjdXJyZW50SW5kZXgrKykge1xuICAgICAgICAgIHZhciB0ID0gZ2V0VG9rZW4oMCk7XG5cbiAgICAgICAgICBpZiAodC50eXBlID09PSAndmFyaWFibGUnKSB7XG4gICAgICAgICAgICBhZGRBbGlhcyh0LCAndmFyaWFibGUtaW5wdXQnKTtcbiAgICAgICAgICAgIGlucHV0VmFyaWFibGVzLnB1c2godC5jb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50SW5kZXggPSBkZWZpbml0aW9uRW5kICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVG9rZW5UeXBlKFsncHVuY3R1YXRpb24nLCAncHJvcGVydHktcXVlcnknXSkgJiYgZ2V0VG9rZW4oMCkuY29udGVudCA9PT0gJ3snKSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCsrOyAvLyBza2lwIG9wZW5pbmcgYnJhY2tldFxuXG4gICAgICAgIGFkZEFsaWFzKGdldFRva2VuKDApLCAncHJvcGVydHktbXV0YXRpb24nKTtcblxuICAgICAgICBpZiAoaW5wdXRWYXJpYWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBtdXRhdGlvbkVuZCA9IGZpbmRDbG9zaW5nQnJhY2tldCgvXlxceyQvLCAvXlxcfSQvKTtcblxuICAgICAgICAgIGlmIChtdXRhdGlvbkVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gLy8gZ2l2ZSByZWZlcmVuY2VzIHRvIGlucHV0IHZhcmlhYmxlcyBhIHNwZWNpYWwgYWxpYXNcblxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IGN1cnJlbnRJbmRleDsgaSA8IG11dGF0aW9uRW5kOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YXJUb2tlbiA9IHZhbGlkVG9rZW5zW2ldO1xuXG4gICAgICAgICAgICBpZiAodmFyVG9rZW4udHlwZSA9PT0gJ3ZhcmlhYmxlJyAmJiBpbnB1dFZhcmlhYmxlcy5pbmRleE9mKHZhclRva2VuLmNvbnRlbnQpID49IDApIHtcbiAgICAgICAgICAgICAgYWRkQWxpYXModmFyVG9rZW4sICd2YXJpYWJsZS1pbnB1dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1zcWxcIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMuc3FsID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSkoPzpcXC9cXCpbXFxzXFxTXSo/XFwqXFwvfCg/Oi0tfFxcL1xcL3wjKS4qKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAndmFyaWFibGUnOiBbe1xuICAgIHBhdHRlcm46IC9AKFtcIidgXSkoPzpcXFxcW1xcc1xcU118KD8hXFwxKVteXFxcXF0pK1xcMS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sIC9AW1xcdy4kXSsvXSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15AXFxcXF0pKFwifCcpKD86XFxcXFtcXHNcXFNdfCg/IVxcMilbXlxcXFxdfFxcMlxcMikqXFwyLyxcbiAgICBncmVlZHk6IHRydWUsXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnaWRlbnRpZmllcic6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15AXFxcXF0pYCg/OlxcXFxbXFxzXFxTXXxbXmBcXFxcXXxgYCkqYC8sXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgaW5zaWRlOiB7XG4gICAgICAncHVuY3R1YXRpb24nOiAvXmB8YCQvXG4gICAgfVxuICB9LFxuICAnZnVuY3Rpb24nOiAvXFxiKD86QVZHfENPVU5UfEZJUlNUfEZPUk1BVHxMQVNUfExDQVNFfExFTnxNQVh8TUlEfE1JTnxNT0R8Tk9XfFJPVU5EfFNVTXxVQ0FTRSkoPz1cXHMqXFwoKS9pLFxuICAvLyBTaG91bGQgd2UgaGlnaGxpZ2h0IHVzZXIgZGVmaW5lZCBmdW5jdGlvbnMgdG9vP1xuICAna2V5d29yZCc6IC9cXGIoPzpBQ1RJT058QUREfEFGVEVSfEFMR09SSVRITXxBTEx8QUxURVJ8QU5BTFlaRXxBTll8QVBQTFl8QVN8QVNDfEFVVEhPUklaQVRJT058QVVUT19JTkNSRU1FTlR8QkFDS1VQfEJEQnxCRUdJTnxCRVJLRUxFWURCfEJJR0lOVHxCSU5BUll8QklUfEJMT0J8Qk9PTHxCT09MRUFOfEJSRUFLfEJST1dTRXxCVFJFRXxCVUxLfEJZfENBTEx8Q0FTQ0FERUQ/fENBU0V8Q0hBSU58Q0hBUig/OkFDVEVSfFNFVCk/fENIRUNLKD86UE9JTlQpP3xDTE9TRXxDTFVTVEVSRUR8Q09BTEVTQ0V8Q09MTEFURXxDT0xVTU5TP3xDT01NRU5UfENPTU1JVCg/OlRFRCk/fENPTVBVVEV8Q09OTkVDVHxDT05TSVNURU5UfENPTlNUUkFJTlR8Q09OVEFJTlMoPzpUQUJMRSk/fENPTlRJTlVFfENPTlZFUlR8Q1JFQVRFfENST1NTfENVUlJFTlQoPzpfREFURXxfVElNRXxfVElNRVNUQU1QfF9VU0VSKT98Q1VSU09SfENZQ0xFfERBVEEoPzpCQVNFUz8pP3xEQVRFKD86VElNRSk/fERBWXxEQkNDfERFQUxMT0NBVEV8REVDfERFQ0lNQUx8REVDTEFSRXxERUZBVUxUfERFRklORVJ8REVMQVlFRHxERUxFVEV8REVMSU1JVEVSUz98REVOWXxERVNDfERFU0NSSUJFfERFVEVSTUlOSVNUSUN8RElTQUJMRXxESVNDQVJEfERJU0t8RElTVElOQ1R8RElTVElOQ1RST1d8RElTVFJJQlVURUR8RE98RE9VQkxFfERST1B8RFVNTVl8RFVNUCg/OkZJTEUpP3xEVVBMSUNBVEV8RUxTRSg/OklGKT98RU5BQkxFfEVOQ0xPU0VEfEVORHxFTkdJTkV8RU5VTXxFUlJMVkx8RVJST1JTfEVTQ0FQRUQ/fEVYQ0VQVHxFWEVDKD86VVRFKT98RVhJU1RTfEVYSVR8RVhQTEFJTnxFWFRFTkRFRHxGRVRDSHxGSUVMRFN8RklMRXxGSUxMRkFDVE9SfEZJUlNUfEZJWEVEfEZMT0FUfEZPTExPV0lOR3xGT1IoPzogRUFDSCBST1cpP3xGT1JDRXxGT1JFSUdOfEZSRUVURVhUKD86VEFCTEUpP3xGUk9NfEZVTEx8RlVOQ1RJT058R0VPTUVUUlkoPzpDT0xMRUNUSU9OKT98R0xPQkFMfEdPVE98R1JBTlR8R1JPVVB8SEFORExFUnxIQVNIfEhBVklOR3xIT0xETE9DS3xIT1VSfElERU5USVRZKD86Q09MfF9JTlNFUlQpP3xJRnxJR05PUkV8SU1QT1JUfElOREVYfElORklMRXxJTk5FUnxJTk5PREJ8SU5PVVR8SU5TRVJUfElOVHxJTlRFR0VSfElOVEVSU0VDVHxJTlRFUlZBTHxJTlRPfElOVk9LRVJ8SVNPTEFUSU9OfElURVJBVEV8Sk9JTnxLRVlTP3xLSUxMfExBTkdVQUdFfExBU1R8TEVBVkV8TEVGVHxMRVZFTHxMSU1JVHxMSU5FTk98TElORVN8TElORVNUUklOR3xMT0FEfExPQ0FMfExPQ0t8TE9ORyg/OkJMT0J8VEVYVCl8TE9PUHxNQVRDSCg/OkVEKT98TUVESVVNKD86QkxPQnxJTlR8VEVYVCl8TUVSR0V8TUlERExFSU5UfE1JTlVURXxNT0RFfE1PRElGSUVTfE1PRElGWXxNT05USHxNVUxUSSg/OkxJTkVTVFJJTkd8UE9JTlR8UE9MWUdPTil8TkFUSU9OQUx8TkFUVVJBTHxOQ0hBUnxORVhUfE5PfE5PTkNMVVNURVJFRHxOVUxMSUZ8TlVNRVJJQ3xPRkY/fE9GRlNFVFM/fE9OfE9QRU4oPzpEQVRBU09VUkNFfFFVRVJZfFJPV1NFVCk/fE9QVElNSVpFfE9QVElPTig/OkFMTFkpP3xPUkRFUnxPVVQoPzpFUnxGSUxFKT98T1ZFUnxQQVJUSUFMfFBBUlRJVElPTnxQRVJDRU5UfFBJVk9UfFBMQU58UE9JTlR8UE9MWUdPTnxQUkVDRURJTkd8UFJFQ0lTSU9OfFBSRVBBUkV8UFJFVnxQUklNQVJZfFBSSU5UfFBSSVZJTEVHRVN8UFJPQyg/OkVEVVJFKT98UFVCTElDfFBVUkdFfFFVSUNLfFJBSVNFUlJPUnxSRUFEUz98UkVBTHxSRUNPTkZJR1VSRXxSRUZFUkVOQ0VTfFJFTEVBU0V8UkVOQU1FfFJFUEVBVCg/OkFCTEUpP3xSRVBMQUNFfFJFUExJQ0FUSU9OfFJFUVVJUkV8UkVTSUdOQUx8UkVTVE9SRXxSRVNUUklDVHxSRVRVUk4oPzpJTkd8Uyk/fFJFVk9LRXxSSUdIVHxST0xMQkFDS3xST1VUSU5FfFJPVyg/OkNPVU5UfEdVSURDT0x8Uyk/fFJUUkVFfFJVTEV8U0FWRSg/OlBPSU5UKT98U0NIRU1BfFNFQ09ORHxTRUxFQ1R8U0VSSUFMKD86SVpBQkxFKT98U0VTU0lPTig/Ol9VU0VSKT98U0VUKD86VVNFUik/fFNIQVJFfFNIT1d8U0hVVERPV058U0lNUExFfFNNQUxMSU5UfFNOQVBTSE9UfFNPTUV8U09OQU1FfFNRTHxTVEFSVCg/OklORyk/fFNUQVRJU1RJQ1N8U1RBVFVTfFNUUklQRUR8U1lTVEVNX1VTRVJ8VEFCTEVTP3xUQUJMRVNQQUNFfFRFTVAoPzpPUkFSWXxUQUJMRSk/fFRFUk1JTkFURUR8VEVYVCg/OlNJWkUpP3xUSEVOfFRJTUUoPzpTVEFNUCk/fFRJTlkoPzpCTE9CfElOVHxURVhUKXxUT1A/fFRSQU4oPzpTQUNUSU9OUz8pP3xUUklHR0VSfFRSVU5DQVRFfFRTRVFVQUx8VFlQRVM/fFVOQk9VTkRFRHxVTkNPTU1JVFRFRHxVTkRFRklORUR8VU5JT058VU5JUVVFfFVOTE9DS3xVTlBJVk9UfFVOU0lHTkVEfFVQREFURSg/OlRFWFQpP3xVU0FHRXxVU0V8VVNFUnxVU0lOR3xWQUxVRVM/fFZBUig/OkJJTkFSWXxDSEFSfENIQVJBQ1RFUnxZSU5HKXxWSUVXfFdBSVRGT1J8V0FSTklOR1N8V0hFTnxXSEVSRXxXSElMRXxXSVRIKD86IFJPTExVUHxJTik/fFdPUkt8V1JJVEUoPzpURVhUKT98WUVBUilcXGIvaSxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86RkFMU0V8TlVMTHxUUlVFKVxcYi9pLFxuICAnbnVtYmVyJzogL1xcYjB4W1xcZGEtZl0rXFxifFxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkK1xcYi9pLFxuICAnb3BlcmF0b3InOiAvWy0rKlxcLz0lXn5dfCYmP3xcXHxcXHw/fCE9P3w8KD86PT4/fDx8Pik/fD5bPj1dP3xcXGIoPzpBTkR8QkVUV0VFTnxESVZ8SUxJS0V8SU58SVN8TElLRXxOT1R8T1J8UkVHRVhQfFJMSUtFfFNPVU5EUyBMSUtFfFhPUilcXGIvaSxcbiAgJ3B1bmN0dWF0aW9uJzogL1s7W1xcXSgpYCwuXS9cbn07XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qcy10ZW1wbGF0ZXNcIiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciB0ZW1wbGF0ZVN0cmluZyA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0Wyd0ZW1wbGF0ZS1zdHJpbmcnXTsgLy8gc2VlIHRoZSBwYXR0ZXJuIGluIHByaXNtLWphdmFzY3JpcHQuanNcblxuICB2YXIgdGVtcGxhdGVMaXRlcmFsUGF0dGVybiA9IHRlbXBsYXRlU3RyaW5nLnBhdHRlcm4uc291cmNlO1xuICB2YXIgaW50ZXJwb2xhdGlvbk9iamVjdCA9IHRlbXBsYXRlU3RyaW5nLmluc2lkZVsnaW50ZXJwb2xhdGlvbiddO1xuICB2YXIgaW50ZXJwb2xhdGlvblB1bmN0dWF0aW9uT2JqZWN0ID0gaW50ZXJwb2xhdGlvbk9iamVjdC5pbnNpZGVbJ2ludGVycG9sYXRpb24tcHVuY3R1YXRpb24nXTtcbiAgdmFyIGludGVycG9sYXRpb25QYXR0ZXJuID0gaW50ZXJwb2xhdGlvbk9iamVjdC5wYXR0ZXJuLnNvdXJjZTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcGF0dGVybiB0byBtYXRjaCBhIHRlbXBsYXRlIHN0cmluZyB3aXRoIGEgc3BlY2lhbCB0YWcuXG4gICAqXG4gICAqIFRoaXMgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaWYgdGhlcmUgaXMgbm8gZ3JhbW1hciB3aXRoIHRoZSBnaXZlbiBsYW5ndWFnZSBpZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBsYW5ndWFnZSBpZCBvZiB0aGUgZW1iZWRkZWQgbGFuZ3VhZ2UuIEUuZy4gYG1hcmtkb3duYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgcmVnZXggcGF0dGVybiB0byBtYXRjaCB0aGUgdGFnLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0IHwgdW5kZWZpbmVkfVxuICAgKiBAZXhhbXBsZVxuICAgKiBjcmVhdGVUZW1wbGF0ZSgnY3NzJywgL1xcYmNzcy8uc291cmNlKTtcbiAgICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGUobGFuZ3VhZ2UsIHRhZykge1xuICAgIGlmICghUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCcoKD86JyArIHRhZyArICcpXFxcXHMqKScgKyB0ZW1wbGF0ZUxpdGVyYWxQYXR0ZXJuKSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3RlbXBsYXRlLXB1bmN0dWF0aW9uJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9eYHxgJC8sXG4gICAgICAgICAgYWxpYXM6ICdzdHJpbmcnXG4gICAgICAgIH0sXG4gICAgICAgICdlbWJlZGRlZC1jb2RlJzoge1xuICAgICAgICAgIHBhdHRlcm46IC9bXFxzXFxTXSsvLFxuICAgICAgICAgIGFsaWFzOiBsYW5ndWFnZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0Wyd0ZW1wbGF0ZS1zdHJpbmcnXSA9IFsvLyBzdHlsZWQtanN4OlxuICAvLyAgIGNzc2BhIHsgY29sb3I6ICMyNUY7IH1gXG4gIC8vIHN0eWxlZC1jb21wb25lbnRzOlxuICAvLyAgIHN0eWxlZC5oMWBjb2xvcjogcmVkO2BcbiAgY3JlYXRlVGVtcGxhdGUoJ2NzcycsIC9cXGIoPzpzdHlsZWQoPzpcXChbXildKlxcKSk/KD86XFxzKlxcLlxccypcXHcrKD86XFwoW14pXSpcXCkpKikqfGNzcyg/OlxccypcXC5cXHMqKD86Z2xvYmFsfHJlc29sdmUpKT98Y3JlYXRlR2xvYmFsU3R5bGV8a2V5ZnJhbWVzKS8uc291cmNlKSwgLy8gaHRtbGA8cD48L3A+YFxuICAvLyBkaXYuaW5uZXJIVE1MID0gYDxwPjwvcD5gXG4gIGNyZWF0ZVRlbXBsYXRlKCdodG1sJywgL1xcYmh0bWx8XFwuXFxzKig/OmlubmVyfG91dGVyKUhUTUxcXHMqXFwrPz0vLnNvdXJjZSksIC8vIHN2Z2A8cGF0aCBmaWxsPVwiI2ZmZlwiIGQ9XCJNNTUuMzcgLi4uXCIvPmBcbiAgY3JlYXRlVGVtcGxhdGUoJ3N2ZycsIC9cXGJzdmcvLnNvdXJjZSksIC8vIG1kYCMgaDFgLCBtYXJrZG93bmAjIyBoMmBcbiAgY3JlYXRlVGVtcGxhdGUoJ21hcmtkb3duJywgL1xcYig/Om1hcmtkb3dufG1kKS8uc291cmNlKSwgLy8gZ3FsYC4uLmAsIGdyYXBocWxgLi4uYCwgZ3JhcGhxbC5leHBlcmltZW50YWxgLi4uYFxuICBjcmVhdGVUZW1wbGF0ZSgnZ3JhcGhxbCcsIC9cXGIoPzpncWx8Z3JhcGhxbCg/OlxccypcXC5cXHMqZXhwZXJpbWVudGFsKT8pLy5zb3VyY2UpLCAvLyBzcWxgLi4uYFxuICBjcmVhdGVUZW1wbGF0ZSgnc3FsJywgL1xcYnNxbC8uc291cmNlKSwgLy8gdmFuaWxsYSB0ZW1wbGF0ZSBzdHJpbmdcbiAgdGVtcGxhdGVTdHJpbmddLmZpbHRlcihCb29sZWFuKTtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpYyBwbGFjZWhvbGRlciBsaXRlcmFsIGZvciB0aGUgZ2l2ZW4gbGFuZ3VhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRQbGFjZWhvbGRlcihjb3VudGVyLCBsYW5ndWFnZSkge1xuICAgIHJldHVybiAnX19fJyArIGxhbmd1YWdlLnRvVXBwZXJDYXNlKCkgKyAnXycgKyBjb3VudGVyICsgJ19fXyc7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRva2VucyBvZiBgUHJpc20udG9rZW5pemVgIGJ1dCBhbHNvIHJ1bnMgdGhlIGBiZWZvcmUtdG9rZW5pemVgIGFuZCBgYWZ0ZXItdG9rZW5pemVgIGhvb2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICAgKiBAcGFyYW0ge2FueX0gZ3JhbW1hclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICogQHJldHVybnMgeyhzdHJpbmd8VG9rZW4pW119XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVXaXRoSG9va3MoY29kZSwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgZW52ID0ge1xuICAgICAgY29kZTogY29kZSxcbiAgICAgIGdyYW1tYXI6IGdyYW1tYXIsXG4gICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VcbiAgICB9O1xuICAgIFByaXNtLmhvb2tzLnJ1bignYmVmb3JlLXRva2VuaXplJywgZW52KTtcbiAgICBlbnYudG9rZW5zID0gUHJpc20udG9rZW5pemUoZW52LmNvZGUsIGVudi5ncmFtbWFyKTtcbiAgICBQcmlzbS5ob29rcy5ydW4oJ2FmdGVyLXRva2VuaXplJywgZW52KTtcbiAgICByZXR1cm4gZW52LnRva2VucztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG9rZW4gb2YgdGhlIGdpdmVuIEphdmFTY3JpcHQgaW50ZXJwb2xhdGlvbiBleHByZXNzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBUaGUgY29kZSBvZiB0aGUgZXhwcmVzc2lvbi4gRS5nLiBgXCIkezQyfVwiYFxuICAgKiBAcmV0dXJucyB7VG9rZW59XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVJbnRlcnBvbGF0aW9uRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgdmFyIHRlbXBHcmFtbWFyID0ge307XG4gICAgdGVtcEdyYW1tYXJbJ2ludGVycG9sYXRpb24tcHVuY3R1YXRpb24nXSA9IGludGVycG9sYXRpb25QdW5jdHVhdGlvbk9iamVjdDtcbiAgICAvKiogQHR5cGUge0FycmF5fSAqL1xuXG4gICAgdmFyIHRva2VucyA9IFByaXNtLnRva2VuaXplKGV4cHJlc3Npb24sIHRlbXBHcmFtbWFyKTtcblxuICAgIGlmICh0b2tlbnMubGVuZ3RoID09PSAzKSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSB0b2tlbiBhcnJheSB3aWxsIGxvb2sgbGlrZSB0aGlzXG4gICAgICAgKiBbXG4gICAgICAgKiAgICAgW1wiaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvblwiLCBcIiR7XCJdXG4gICAgICAgKiAgICAgXCIuLi5cIiAvLyBKYXZhU2NyaXB0IGV4cHJlc3Npb24gb2YgdGhlIGludGVycG9sYXRpb25cbiAgICAgICAqICAgICBbXCJpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uXCIsIFwifVwiXVxuICAgICAgICogXVxuICAgICAgICovXG4gICAgICB2YXIgYXJncyA9IFsxLCAxXTtcbiAgICAgIGFyZ3MucHVzaC5hcHBseShhcmdzLCB0b2tlbml6ZVdpdGhIb29rcyh0b2tlbnNbMV0sIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0LCAnamF2YXNjcmlwdCcpKTtcbiAgICAgIHRva2Vucy5zcGxpY2UuYXBwbHkodG9rZW5zLCBhcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByaXNtLlRva2VuKCdpbnRlcnBvbGF0aW9uJywgdG9rZW5zLCBpbnRlcnBvbGF0aW9uT2JqZWN0LmFsaWFzLCBleHByZXNzaW9uKTtcbiAgfVxuICAvKipcbiAgICogVG9rZW5pemVzIHRoZSBnaXZlbiBjb2RlIHdpdGggc3VwcG9ydCBmb3IgSmF2YVNjcmlwdCBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb25zIG1peGVkIGluLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGhhcyAzIHBoYXNlczpcbiAgICpcbiAgICogMS4gUmVwbGFjZSBhbGwgSmF2YVNjcmlwdCBpbnRlcnBvbGF0aW9uIGV4cHJlc3Npb24gd2l0aCBhIHBsYWNlaG9sZGVyLlxuICAgKiAgICBUaGUgcGxhY2Vob2xkZXIgd2lsbCBoYXZlIHRoZSBzeW50YXggb2YgYSBpZGVudGlmeSBvZiB0aGUgdGFyZ2V0IGxhbmd1YWdlLlxuICAgKiAyLiBUb2tlbml6ZSB0aGUgY29kZSB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICogMy4gVG9rZW5pemUgdGhlIGludGVycG9sYXRpb24gZXhwcmVzc2lvbnMgYW5kIHJlLWluc2VydCB0aGVtIGludG8gdGhlIHRva2VuaXplIGNvZGUuXG4gICAqICAgIFRoZSBpbnNlcnRpb24gb25seSB3b3JrcyBpZiBhIHBsYWNlaG9sZGVyIGhhc24ndCBiZWVuIFwicmlwcGVkIGFwYXJ0XCIgbWVhbmluZyB0aGF0IHRoZSBwbGFjZWhvbGRlciBoYXMgYmVlblxuICAgKiAgICB0b2tlbml6ZWQgYXMgdHdvIHRva2VucyBieSB0aGUgZ3JhbW1hciBvZiB0aGUgZW1iZWRkZWQgbGFuZ3VhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBncmFtbWFyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZVxuICAgKiBAcmV0dXJucyB7VG9rZW59XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdG9rZW5pemVFbWJlZGRlZChjb2RlLCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgIC8vIDEuIEZpcnN0IGZpbHRlciBvdXQgYWxsIGludGVycG9sYXRpb25zXG4gICAgLy8gYmVjYXVzZSB0aGV5IG1pZ2h0IGJlIGVzY2FwZWQsIHdlIG5lZWQgYSBsb29rYmVoaW5kLCBzbyB3ZSB1c2UgUHJpc21cblxuICAgIC8qKiBAdHlwZSB7KFRva2VufHN0cmluZylbXX0gKi9cbiAgICB2YXIgX3Rva2VucyA9IFByaXNtLnRva2VuaXplKGNvZGUsIHtcbiAgICAgICdpbnRlcnBvbGF0aW9uJzoge1xuICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoaW50ZXJwb2xhdGlvblBhdHRlcm4pLFxuICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICB9XG4gICAgfSk7IC8vIHJlcGxhY2UgYWxsIGludGVycG9sYXRpb25zIHdpdGggYSBwbGFjZWhvbGRlciB3aGljaCBpcyBub3QgaW4gdGhlIGNvZGUgYWxyZWFkeVxuXG5cbiAgICB2YXIgcGxhY2Vob2xkZXJDb3VudGVyID0gMDtcbiAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsIHN0cmluZz59ICovXG5cbiAgICB2YXIgcGxhY2Vob2xkZXJNYXAgPSB7fTtcblxuICAgIHZhciBlbWJlZGRlZENvZGUgPSBfdG9rZW5zLm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbnRlcnBvbGF0aW9uRXhwcmVzc2lvbiA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgIHZhciBwbGFjZWhvbGRlcjtcblxuICAgICAgICB3aGlsZSAoY29kZS5pbmRleE9mKHBsYWNlaG9sZGVyID0gZ2V0UGxhY2Vob2xkZXIocGxhY2Vob2xkZXJDb3VudGVyKyssIGxhbmd1YWdlKSkgIT09IC0xKSB7XG4gICAgICAgICAgLyogbm9vcCAqL1xuICAgICAgICB9XG5cbiAgICAgICAgcGxhY2Vob2xkZXJNYXBbcGxhY2Vob2xkZXJdID0gaW50ZXJwb2xhdGlvbkV4cHJlc3Npb247XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICAgIH1cbiAgICB9KS5qb2luKCcnKTsgLy8gMi4gVG9rZW5pemUgdGhlIGVtYmVkZGVkIGNvZGVcblxuXG4gICAgdmFyIGVtYmVkZGVkVG9rZW5zID0gdG9rZW5pemVXaXRoSG9va3MoZW1iZWRkZWRDb2RlLCBncmFtbWFyLCBsYW5ndWFnZSk7IC8vIDMuIFJlLWluc2VydCB0aGUgaW50ZXJwb2xhdGlvblxuXG4gICAgdmFyIHBsYWNlaG9sZGVycyA9IE9iamVjdC5rZXlzKHBsYWNlaG9sZGVyTWFwKTtcbiAgICBwbGFjZWhvbGRlckNvdW50ZXIgPSAwO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsoVG9rZW58c3RyaW5nKVtdfSB0b2tlbnNcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHdhbGtUb2tlbnModG9rZW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGxhY2Vob2xkZXJDb3VudGVyID49IHBsYWNlaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHRva2VuLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXJzW3BsYWNlaG9sZGVyQ291bnRlcl07XG4gICAgICAgICAgdmFyIHMgPSB0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnID8gdG9rZW4gOlxuICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcy5pbmRleE9mKHBsYWNlaG9sZGVyKTtcblxuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICsrcGxhY2Vob2xkZXJDb3VudGVyO1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHMuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIHZhciBtaWRkbGUgPSB0b2tlbml6ZUludGVycG9sYXRpb25FeHByZXNzaW9uKHBsYWNlaG9sZGVyTWFwW3BsYWNlaG9sZGVyXSk7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSBzLnN1YnN0cmluZyhpbmRleCArIHBsYWNlaG9sZGVyLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgICAgICByZXBsYWNlbWVudC5wdXNoKGJlZm9yZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2gobWlkZGxlKTtcblxuICAgICAgICAgICAgaWYgKGFmdGVyKSB7XG4gICAgICAgICAgICAgIHZhciBhZnRlclRva2VucyA9IFthZnRlcl07XG4gICAgICAgICAgICAgIHdhbGtUb2tlbnMoYWZ0ZXJUb2tlbnMpO1xuICAgICAgICAgICAgICByZXBsYWNlbWVudC5wdXNoLmFwcGx5KHJlcGxhY2VtZW50LCBhZnRlclRva2Vucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRva2Vucy5zcGxpY2UuYXBwbHkodG9rZW5zLCBbaSwgMV0uY29uY2F0KHJlcGxhY2VtZW50KSk7XG4gICAgICAgICAgICAgIGkgKz0gcmVwbGFjZW1lbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSB0b2tlbi5jb250ZW50O1xuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgICAgIHdhbGtUb2tlbnMoY29udGVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhbGtUb2tlbnMoW2NvbnRlbnRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YWxrVG9rZW5zKGVtYmVkZGVkVG9rZW5zKTtcbiAgICByZXR1cm4gbmV3IFByaXNtLlRva2VuKGxhbmd1YWdlLCBlbWJlZGRlZFRva2VucywgJ2xhbmd1YWdlLScgKyBsYW5ndWFnZSwgY29kZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsYW5ndWFnZXMgZm9yIHdoaWNoIEpTIHRlbXBsYXRpbmcgd2lsbCBoYW5kbGUgdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxzLlxuICAgKlxuICAgKiBKUyB0ZW1wbGF0aW5nIGlzbid0IGFjdGl2ZSBmb3Igb25seSBKYXZhU2NyaXB0IGJ1dCBhbHNvIHJlbGF0ZWQgbGFuZ3VhZ2VzIGxpa2UgVHlwZVNjcmlwdCwgSlNYLCBhbmQgVFNYLlxuICAgKi9cblxuXG4gIHZhciBzdXBwb3J0ZWRMYW5ndWFnZXMgPSB7XG4gICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICdqcyc6IHRydWUsXG4gICAgJ3R5cGVzY3JpcHQnOiB0cnVlLFxuICAgICd0cyc6IHRydWUsXG4gICAgJ2pzeCc6IHRydWUsXG4gICAgJ3RzeCc6IHRydWVcbiAgfTtcbiAgUHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBpZiAoIShlbnYubGFuZ3VhZ2UgaW4gc3VwcG9ydGVkTGFuZ3VhZ2VzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbmQgdG9rZW5pemVzIGFsbCB0ZW1wbGF0ZSBzdHJpbmdzIHdpdGggYW4gZW1iZWRkZWQgbGFuZ3VhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsoVG9rZW4gfCBzdHJpbmcpW119IHRva2Vuc1xuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBmaW5kVGVtcGxhdGVTdHJpbmdzKHRva2Vucykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0b2tlbi5jb250ZW50O1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb250ZW50KSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZpbmRUZW1wbGF0ZVN0cmluZ3MoW2NvbnRlbnRdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAndGVtcGxhdGUtc3RyaW5nJykge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEEgSmF2YVNjcmlwdCB0ZW1wbGF0ZS1zdHJpbmcgdG9rZW4gd2lsbCBsb29rIGxpa2UgdGhpczpcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFtcInRlbXBsYXRlLXN0cmluZ1wiLCBbXG4gICAgICAgICAgICogICAgIFtcInRlbXBsYXRlLXB1bmN0dWF0aW9uXCIsIFwiYFwiXSxcbiAgICAgICAgICAgKiAgICAgKFxuICAgICAgICAgICAqICAgICAgICAgQW4gYXJyYXkgb2YgXCJzdHJpbmdcIiBhbmQgXCJpbnRlcnBvbGF0aW9uXCIgdG9rZW5zLiBUaGlzIGlzIHRoZSBzaW1wbGUgc3RyaW5nIGNhc2UuXG4gICAgICAgICAgICogICAgICAgICBvclxuICAgICAgICAgICAqICAgICAgICAgW1wiZW1iZWRkZWQtY29kZVwiLCBcIi4uLlwiXSBUaGlzIGlzIHRoZSB0b2tlbiBjb250YWluaW5nIHRoZSBlbWJlZGRlZCBjb2RlLlxuICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEl0IGFsc28gaGFzIGFuIGFsaWFzIHdoaWNoIGlzIHRoZSBsYW5ndWFnZSBvZiB0aGUgZW1iZWRkZWQgY29kZS5cbiAgICAgICAgICAgKiAgICAgKSxcbiAgICAgICAgICAgKiAgICAgW1widGVtcGxhdGUtcHVuY3R1YXRpb25cIiwgXCJgXCJdXG4gICAgICAgICAgICogXV1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICB2YXIgZW1iZWRkZWQgPSBjb250ZW50WzFdO1xuXG4gICAgICAgICAgaWYgKGNvbnRlbnQubGVuZ3RoID09PSAzICYmIHR5cGVvZiBlbWJlZGRlZCAhPT0gJ3N0cmluZycgJiYgZW1iZWRkZWQudHlwZSA9PT0gJ2VtYmVkZGVkLWNvZGUnKSB7XG4gICAgICAgICAgICAvLyBnZXQgc3RyaW5nIGNvbnRlbnRcbiAgICAgICAgICAgIHZhciBjb2RlID0gc3RyaW5nQ29udGVudChlbWJlZGRlZCk7XG4gICAgICAgICAgICB2YXIgYWxpYXMgPSBlbWJlZGRlZC5hbGlhcztcbiAgICAgICAgICAgIHZhciBsYW5ndWFnZSA9IEFycmF5LmlzQXJyYXkoYWxpYXMpID8gYWxpYXNbMF0gOiBhbGlhcztcbiAgICAgICAgICAgIHZhciBncmFtbWFyID0gUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXTtcblxuICAgICAgICAgICAgaWYgKCFncmFtbWFyKSB7XG4gICAgICAgICAgICAgIC8vIHRoZSBlbWJlZGRlZCBsYW5ndWFnZSBpc24ndCByZWdpc3RlcmVkLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGVudFsxXSA9IHRva2VuaXplRW1iZWRkZWQoY29kZSwgZ3JhbW1hciwgbGFuZ3VhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaW5kVGVtcGxhdGVTdHJpbmdzKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZmluZFRlbXBsYXRlU3RyaW5ncyhlbnYudG9rZW5zKTtcbiAgfSk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgY29udGVudCBvZiBhIHRva2VuIG9yIHRva2VuIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBUb2tlbiB8IChzdHJpbmcgfCBUb2tlbilbXX0gdmFsdWVcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG5cbiAgZnVuY3Rpb24gc3RyaW5nQ29udGVudCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLm1hcChzdHJpbmdDb250ZW50KS5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cmluZ0NvbnRlbnQodmFsdWUuY29udGVudCk7XG4gICAgfVxuICB9XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS10eXBlc2NyaXB0XCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnamF2YXNjcmlwdCcsIHtcbiAgICAnY2xhc3MtbmFtZSc6IHtcbiAgICAgIHBhdHRlcm46IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ld3x0eXBlKVxccyspKD8ha2V5b2ZcXGIpKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/Olxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+KT8vLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZTogbnVsbCAvLyBzZWUgYmVsb3dcblxuICAgIH0sXG4gICAgJ2J1aWx0aW4nOiAvXFxiKD86QXJyYXl8RnVuY3Rpb258UHJvbWlzZXxhbnl8Ym9vbGVhbnxjb25zb2xlfG5ldmVyfG51bWJlcnxzdHJpbmd8c3ltYm9sfHVua25vd24pXFxiL1xuICB9KTsgLy8gVGhlIGtleXdvcmRzIFR5cGVTY3JpcHQgYWRkcyB0byBKYXZhU2NyaXB0XG5cbiAgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHQua2V5d29yZC5wdXNoKC9cXGIoPzphYnN0cmFjdHxkZWNsYXJlfGlzfGtleW9mfHJlYWRvbmx5fHJlcXVpcmUpXFxiLywgLy8ga2V5d29yZHMgdGhhdCBoYXZlIHRvIGJlIGZvbGxvd2VkIGJ5IGFuIGlkZW50aWZpZXJcbiAgL1xcYig/OmFzc2VydHN8aW5mZXJ8aW50ZXJmYWNlfG1vZHVsZXxuYW1lc3BhY2V8dHlwZSlcXGIoPz1cXHMqKD86W3tfJGEtekEtWlxceEEwLVxcdUZGRkZdfCQpKS8sIC8vIFRoaXMgaXMgZm9yIGBpbXBvcnQgdHlwZSAqLCB7fWBcbiAgL1xcYnR5cGVcXGIoPz1cXHMqKD86W1xceypdfCQpKS8pOyAvLyBkb2Vzbid0IHdvcmsgd2l0aCBUUyBiZWNhdXNlIFRTIGlzIHRvbyBjb21wbGV4XG5cbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0WydwYXJhbWV0ZXInXTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0WydsaXRlcmFsLXByb3BlcnR5J107IC8vIGEgdmVyc2lvbiBvZiB0eXBlc2NyaXB0IHNwZWNpZmljYWxseSBmb3IgaGlnaGxpZ2h0aW5nIHR5cGVzXG5cbiAgdmFyIHR5cGVJbnNpZGUgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCd0eXBlc2NyaXB0Jywge30pO1xuICBkZWxldGUgdHlwZUluc2lkZVsnY2xhc3MtbmFtZSddO1xuICBQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdFsnY2xhc3MtbmFtZSddLmluc2lkZSA9IHR5cGVJbnNpZGU7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3R5cGVzY3JpcHQnLCAnZnVuY3Rpb24nLCB7XG4gICAgJ2RlY29yYXRvcic6IHtcbiAgICAgIHBhdHRlcm46IC9AWyRcXHdcXHhBMC1cXHVGRkZGXSsvLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdhdCc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXkAvLFxuICAgICAgICAgIGFsaWFzOiAnb3BlcmF0b3InXG4gICAgICAgIH0sXG4gICAgICAgICdmdW5jdGlvbic6IC9eW1xcc1xcU10rL1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2dlbmVyaWMtZnVuY3Rpb24nOiB7XG4gICAgICAvLyBlLmcuIGZvbzxUIGV4dGVuZHMgXCJiYXJcIiB8IFwiYmF6XCI+KCAuLi5cbiAgICAgIHBhdHRlcm46IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSpcXHMqPCg/OltePD5dfDwoPzpbXjw+XXw8W148Pl0qPikqPikqPig/PVxccypcXCgpLyxcbiAgICAgIGdyZWVkeTogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnZnVuY3Rpb24nOiAvXiM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKi8sXG4gICAgICAgICdnZW5lcmljJzoge1xuICAgICAgICAgIHBhdHRlcm46IC88W1xcc1xcU10rLyxcbiAgICAgICAgICAvLyBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCA8XG4gICAgICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJyxcbiAgICAgICAgICBpbnNpZGU6IHR5cGVJbnNpZGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy50cyA9IFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0O1xufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tanMtZXh0cmFzXCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnZnVuY3Rpb24tdmFyaWFibGUnLCB7XG4gICAgJ21ldGhvZC12YXJpYWJsZSc6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cCgnKFxcXFwuXFxcXHMqKScgKyBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsnZnVuY3Rpb24tdmFyaWFibGUnXS5wYXR0ZXJuLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6IFsnZnVuY3Rpb24tdmFyaWFibGUnLCAnbWV0aG9kJywgJ2Z1bmN0aW9uJywgJ3Byb3BlcnR5LWFjY2VzcyddXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnamF2YXNjcmlwdCcsICdmdW5jdGlvbicsIHtcbiAgICAnbWV0aG9kJzoge1xuICAgICAgcGF0dGVybjogUmVnRXhwKCcoXFxcXC5cXFxccyopJyArIFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0WydmdW5jdGlvbiddLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgYWxpYXM6IFsnZnVuY3Rpb24nLCAncHJvcGVydHktYWNjZXNzJ11cbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2NvbnN0YW50Jywge1xuICAgICdrbm93bi1jbGFzcy1uYW1lJzogW3tcbiAgICAgIC8vIHN0YW5kYXJkIGJ1aWx0LWluc1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHNcbiAgICAgIHBhdHRlcm46IC9cXGIoPzooPzpGbG9hdCg/OjMyfDY0KXwoPzpJbnR8VWludCkoPzo4fDE2fDMyKXxVaW50OENsYW1wZWQpP0FycmF5fEFycmF5QnVmZmVyfEJpZ0ludHxCb29sZWFufERhdGFWaWV3fERhdGV8RXJyb3J8RnVuY3Rpb258SW50bHxKU09OfCg/OldlYWspPyg/Ok1hcHxTZXQpfE1hdGh8TnVtYmVyfE9iamVjdHxQcm9taXNlfFByb3h5fFJlZmxlY3R8UmVnRXhwfFN0cmluZ3xTeW1ib2x8V2ViQXNzZW1ibHkpXFxiLyxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9LCB7XG4gICAgICAvLyBlcnJvcnNcbiAgICAgIHBhdHRlcm46IC9cXGIoPzpbQS1aXVxcdyopRXJyb3JcXGIvLFxuICAgICAgYWxpYXM6ICdjbGFzcy1uYW1lJ1xuICAgIH1dXG4gIH0pO1xuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGA8SUQ+YCBwbGFjZWhvbGRlciBpbiB0aGUgZ2l2ZW4gcGF0dGVybiB3aXRoIGEgcGF0dGVybiBmb3IgZ2VuZXJhbCBKUyBpZGVudGlmaWVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZsYWdzXVxuICAgKiBAcmV0dXJucyB7UmVnRXhwfVxuICAgKi9cblxuICBmdW5jdGlvbiB3aXRoSWQoc291cmNlLCBmbGFncykge1xuICAgIHJldHVybiBSZWdFeHAoc291cmNlLnJlcGxhY2UoLzxJRD4vZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIC8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqLy5zb3VyY2U7XG4gICAgfSksIGZsYWdzKTtcbiAgfVxuXG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAna2V5d29yZCcsIHtcbiAgICAnaW1wb3J0cyc6IHtcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaW1wb3J0c1xuICAgICAgcGF0dGVybjogd2l0aElkKC8oXFxiaW1wb3J0XFxiXFxzKikoPzo8SUQ+KD86XFxzKixcXHMqKD86XFwqXFxzKmFzXFxzKzxJRD58XFx7W157fV0qXFx9KSk/fFxcKlxccyphc1xccys8SUQ+fFxce1tee31dKlxcfSkoPz1cXHMqXFxiZnJvbVxcYikvLnNvdXJjZSksXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuICAgIH0sXG4gICAgJ2V4cG9ydHMnOiB7XG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWV4cG9ydHNcbiAgICAgIHBhdHRlcm46IHdpdGhJZCgvKFxcYmV4cG9ydFxcYlxccyopKD86XFwqKD86XFxzKmFzXFxzKzxJRD4pPyg/PVxccypcXGJmcm9tXFxiKXxcXHtbXnt9XSpcXH0pLy5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICB9XG4gIH0pO1xuICBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFsna2V5d29yZCddLnVuc2hpZnQoe1xuICAgIHBhdHRlcm46IC9cXGIoPzphc3xkZWZhdWx0fGV4cG9ydHxmcm9tfGltcG9ydClcXGIvLFxuICAgIGFsaWFzOiAnbW9kdWxlJ1xuICB9LCB7XG4gICAgcGF0dGVybjogL1xcYig/OmF3YWl0fGJyZWFrfGNhdGNofGNvbnRpbnVlfGRvfGVsc2V8ZmluYWxseXxmb3J8aWZ8cmV0dXJufHN3aXRjaHx0aHJvd3x0cnl8d2hpbGV8eWllbGQpXFxiLyxcbiAgICBhbGlhczogJ2NvbnRyb2wtZmxvdydcbiAgfSwge1xuICAgIHBhdHRlcm46IC9cXGJudWxsXFxiLyxcbiAgICBhbGlhczogWydudWxsJywgJ25pbCddXG4gIH0sIHtcbiAgICBwYXR0ZXJuOiAvXFxidW5kZWZpbmVkXFxiLyxcbiAgICBhbGlhczogJ25pbCdcbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnb3BlcmF0b3InLCB7XG4gICAgJ3NwcmVhZCc6IHtcbiAgICAgIHBhdHRlcm46IC9cXC57M30vLFxuICAgICAgYWxpYXM6ICdvcGVyYXRvcidcbiAgICB9LFxuICAgICdhcnJvdyc6IHtcbiAgICAgIHBhdHRlcm46IC89Pi8sXG4gICAgICBhbGlhczogJ29wZXJhdG9yJ1xuICAgIH1cbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAncHVuY3R1YXRpb24nLCB7XG4gICAgJ3Byb3BlcnR5LWFjY2Vzcyc6IHtcbiAgICAgIHBhdHRlcm46IHdpdGhJZCgvKFxcLlxccyopIz88SUQ+Ly5zb3VyY2UpLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ21heWJlLWNsYXNzLW5hbWUnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pW0EtWl1bJFxcd1xceEEwLVxcdUZGRkZdKy8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnZG9tJzoge1xuICAgICAgLy8gdGhpcyBjb250YWlucyBvbmx5IGEgZmV3IGNvbW1vbmx5IHVzZWQgRE9NIHZhcmlhYmxlc1xuICAgICAgcGF0dGVybjogL1xcYig/OmRvY3VtZW50fCg/OmxvY2FsfHNlc3Npb24pU3RvcmFnZXxsb2NhdGlvbnxuYXZpZ2F0b3J8cGVyZm9ybWFuY2V8d2luZG93KVxcYi8sXG4gICAgICBhbGlhczogJ3ZhcmlhYmxlJ1xuICAgIH0sXG4gICAgJ2NvbnNvbGUnOiB7XG4gICAgICBwYXR0ZXJuOiAvXFxiY29uc29sZSg/PVxccypcXC4pLyxcbiAgICAgIGFsaWFzOiAnY2xhc3MtbmFtZSdcbiAgICB9XG4gIH0pOyAvLyBhZGQgJ21heWJlLWNsYXNzLW5hbWUnIHRvIHRva2VucyB3aGljaCBtaWdodCBiZSBhIGNsYXNzIG5hbWVcblxuICB2YXIgbWF5YmVDbGFzc05hbWVUb2tlbnMgPSBbJ2Z1bmN0aW9uJywgJ2Z1bmN0aW9uLXZhcmlhYmxlJywgJ21ldGhvZCcsICdtZXRob2QtdmFyaWFibGUnLCAncHJvcGVydHktYWNjZXNzJ107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXliZUNsYXNzTmFtZVRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IG1heWJlQ2xhc3NOYW1lVG9rZW5zW2ldO1xuICAgIHZhciB2YWx1ZSA9IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0W3Rva2VuXTsgLy8gY29udmVydCByZWdleCB0byBvYmplY3RcblxuICAgIGlmIChQcmlzbS51dGlsLnR5cGUodmFsdWUpID09PSAnUmVnRXhwJykge1xuICAgICAgdmFsdWUgPSBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFt0b2tlbl0gPSB7XG4gICAgICAgIHBhdHRlcm46IHZhbHVlXG4gICAgICB9O1xuICAgIH0gLy8ga2VlcCBpbiBtaW5kIHRoYXQgd2UgZG9uJ3Qgc3VwcG9ydCBhcnJheXNcblxuXG4gICAgdmFyIGluc2lkZSA9IHZhbHVlLmluc2lkZSB8fCB7fTtcbiAgICB2YWx1ZS5pbnNpZGUgPSBpbnNpZGU7XG4gICAgaW5zaWRlWydtYXliZS1jbGFzcy1uYW1lJ10gPSAvXltBLVpdW1xcc1xcU10qLztcbiAgfVxufSkocHJpc20pO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tanN4XCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIHZhciBqYXZhc2NyaXB0ID0gUHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCk7XG4gIHZhciBzcGFjZSA9IC8oPzpcXHN8XFwvXFwvLiooPyEuKXxcXC9cXCooPzpbXipdfFxcKig/IVxcLykpXFwqXFwvKS8uc291cmNlO1xuICB2YXIgYnJhY2VzID0gLyg/Olxceyg/Olxceyg/Olxce1tee31dKlxcfXxbXnt9XSkqXFx9fFtee31dKSpcXH0pLy5zb3VyY2U7XG4gIHZhciBzcHJlYWQgPSAvKD86XFx7PFM+KlxcLnszfSg/Oltee31dfDxCUkFDRVM+KSpcXH0pLy5zb3VyY2U7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZmxhZ3NdXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHJlKHNvdXJjZSwgZmxhZ3MpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2UucmVwbGFjZSgvPFM+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzcGFjZTtcbiAgICB9KS5yZXBsYWNlKC88QlJBQ0VTPi9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYnJhY2VzO1xuICAgIH0pLnJlcGxhY2UoLzxTUFJFQUQ+L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzcHJlYWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIFJlZ0V4cChzb3VyY2UsIGZsYWdzKTtcbiAgfVxuXG4gIHNwcmVhZCA9IHJlKHNwcmVhZCkuc291cmNlO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnbWFya3VwJywgamF2YXNjcmlwdCk7XG4gIFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLnBhdHRlcm4gPSByZSgvPFxcLz8oPzpbXFx3LjotXSsoPzo8Uz4rKD86W1xcdy46JC1dKyg/Oj0oPzpcIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwifCcoPzpcXFxcW1xcc1xcU118W15cXFxcJ10pKid8W15cXHN7J1wiLz49XSt8PEJSQUNFUz4pKT98PFNQUkVBRD4pKSo8Uz4qXFwvPyk/Pi8uc291cmNlKTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcuaW5zaWRlWyd0YWcnXS5wYXR0ZXJuID0gL148XFwvP1teXFxzPlxcL10qLztcbiAgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcuaW5zaWRlWydhdHRyLXZhbHVlJ10ucGF0dGVybiA9IC89KD8hXFx7KSg/OlwiKD86XFxcXFtcXHNcXFNdfFteXFxcXFwiXSkqXCJ8Jyg/OlxcXFxbXFxzXFxTXXxbXlxcXFwnXSkqJ3xbXlxccydcIj5dKykvO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ3RhZyddLmluc2lkZVsnY2xhc3MtbmFtZSddID0gL15bQS1aXVxcdyooPzpcXC5bQS1aXVxcdyopKiQvO1xuICBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5pbnNpZGVbJ2NvbW1lbnQnXSA9IGphdmFzY3JpcHRbJ2NvbW1lbnQnXTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ2F0dHItbmFtZScsIHtcbiAgICAnc3ByZWFkJzoge1xuICAgICAgcGF0dGVybjogcmUoLzxTUFJFQUQ+Ly5zb3VyY2UpLFxuICAgICAgaW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuanN4XG4gICAgfVxuICB9LCBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZyk7XG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2luc2lkZScsICdzcGVjaWFsLWF0dHInLCB7XG4gICAgJ3NjcmlwdCc6IHtcbiAgICAgIC8vIEFsbG93IGZvciB0d28gbGV2ZWxzIG9mIG5lc3RpbmdcbiAgICAgIHBhdHRlcm46IHJlKC89PEJSQUNFUz4vLnNvdXJjZSksXG4gICAgICBhbGlhczogJ2xhbmd1YWdlLWphdmFzY3JpcHQnLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdzY3JpcHQtcHVuY3R1YXRpb24nOiB7XG4gICAgICAgICAgcGF0dGVybjogL149KD89XFx7KS8sXG4gICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdDogUHJpc20ubGFuZ3VhZ2VzLmpzeFxuICAgICAgfVxuICAgIH1cbiAgfSwgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcpOyAvLyBUaGUgZm9sbG93aW5nIHdpbGwgaGFuZGxlIHBsYWluIHRleHQgaW5zaWRlIHRhZ3NcblxuICB2YXIgc3RyaW5naWZ5VG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRva2VuLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdG9rZW4uY29udGVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9rZW4uY29udGVudC5tYXAoc3RyaW5naWZ5VG9rZW4pLmpvaW4oJycpO1xuICB9O1xuXG4gIHZhciB3YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2Vucykge1xuICAgIHZhciBvcGVuZWRUYWdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgdmFyIG5vdFRhZ05vckJyYWNlID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAndGFnJyAmJiB0b2tlbi5jb250ZW50WzBdICYmIHRva2VuLmNvbnRlbnRbMF0udHlwZSA9PT0gJ3RhZycpIHtcbiAgICAgICAgICAvLyBXZSBmb3VuZCBhIHRhZywgbm93IGZpbmQgaXRzIGtpbmRcbiAgICAgICAgICBpZiAodG9rZW4uY29udGVudFswXS5jb250ZW50WzBdLmNvbnRlbnQgPT09ICc8LycpIHtcbiAgICAgICAgICAgIC8vIENsb3NpbmcgdGFnXG4gICAgICAgICAgICBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS50YWdOYW1lID09PSBzdHJpbmdpZnlUb2tlbih0b2tlbi5jb250ZW50WzBdLmNvbnRlbnRbMV0pKSB7XG4gICAgICAgICAgICAgIC8vIFBvcCBtYXRjaGluZyBvcGVuaW5nIHRhZ1xuICAgICAgICAgICAgICBvcGVuZWRUYWdzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodG9rZW4uY29udGVudFt0b2tlbi5jb250ZW50Lmxlbmd0aCAtIDFdLmNvbnRlbnQgPT09ICcvPicpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE9wZW5pbmcgdGFnXG4gICAgICAgICAgICAgIG9wZW5lZFRhZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogc3RyaW5naWZ5VG9rZW4odG9rZW4uY29udGVudFswXS5jb250ZW50WzFdKSxcbiAgICAgICAgICAgICAgICBvcGVuZWRCcmFjZXM6IDBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9wZW5lZFRhZ3MubGVuZ3RoID4gMCAmJiB0b2tlbi50eXBlID09PSAncHVuY3R1YXRpb24nICYmIHRva2VuLmNvbnRlbnQgPT09ICd7Jykge1xuICAgICAgICAgIC8vIEhlcmUgd2UgbWlnaHQgaGF2ZSBlbnRlcmVkIGEgSlNYIGNvbnRleHQgaW5zaWRlIGEgdGFnXG4gICAgICAgICAgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLm9wZW5lZEJyYWNlcysrO1xuICAgICAgICB9IGVsc2UgaWYgKG9wZW5lZFRhZ3MubGVuZ3RoID4gMCAmJiBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzID4gMCAmJiB0b2tlbi50eXBlID09PSAncHVuY3R1YXRpb24nICYmIHRva2VuLmNvbnRlbnQgPT09ICd9Jykge1xuICAgICAgICAgIC8vIEhlcmUgd2UgbWlnaHQgaGF2ZSBsZWZ0IGEgSlNYIGNvbnRleHQgaW5zaWRlIGEgdGFnXG4gICAgICAgICAgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLm9wZW5lZEJyYWNlcy0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vdFRhZ05vckJyYWNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm90VGFnTm9yQnJhY2UgfHwgdHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS5vcGVuZWRCcmFjZXMgPT09IDApIHtcbiAgICAgICAgICAvLyBIZXJlIHdlIGFyZSBpbnNpZGUgYSB0YWcsIGFuZCBub3QgaW5zaWRlIGEgSlNYIGNvbnRleHQuXG4gICAgICAgICAgLy8gVGhhdCdzIHBsYWluIHRleHQ6IGRyb3AgYW55IHRva2VucyBtYXRjaGVkLlxuICAgICAgICAgIHZhciBwbGFpblRleHQgPSBzdHJpbmdpZnlUb2tlbih0b2tlbik7IC8vIEFuZCBtZXJnZSB0ZXh0IHdpdGggYWRqYWNlbnQgdGV4dFxuXG4gICAgICAgICAgaWYgKGkgPCB0b2tlbnMubGVuZ3RoIC0gMSAmJiAodHlwZW9mIHRva2Vuc1tpICsgMV0gPT09ICdzdHJpbmcnIHx8IHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3BsYWluLXRleHQnKSkge1xuICAgICAgICAgICAgcGxhaW5UZXh0ICs9IHN0cmluZ2lmeVRva2VuKHRva2Vuc1tpICsgMV0pO1xuICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGkgPiAwICYmICh0eXBlb2YgdG9rZW5zW2kgLSAxXSA9PT0gJ3N0cmluZycgfHwgdG9rZW5zW2kgLSAxXS50eXBlID09PSAncGxhaW4tdGV4dCcpKSB7XG4gICAgICAgICAgICBwbGFpblRleHQgPSBzdHJpbmdpZnlUb2tlbih0b2tlbnNbaSAtIDFdKSArIHBsYWluVGV4dDtcbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSAtIDEsIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2Vuc1tpXSA9IG5ldyBQcmlzbS5Ub2tlbigncGxhaW4tdGV4dCcsIHBsYWluVGV4dCwgbnVsbCwgcGxhaW5UZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4uY29udGVudCAmJiB0eXBlb2YgdG9rZW4uY29udGVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgd2Fsa1Rva2Vucyh0b2tlbi5jb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgUHJpc20uaG9va3MuYWRkKCdhZnRlci10b2tlbml6ZScsIGZ1bmN0aW9uIChlbnYpIHtcbiAgICBpZiAoZW52Lmxhbmd1YWdlICE9PSAnanN4JyAmJiBlbnYubGFuZ3VhZ2UgIT09ICd0c3gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2Fsa1Rva2VucyhlbnYudG9rZW5zKTtcbiAgfSk7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1kaWZmXCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5kaWZmID0ge1xuICAgICdjb29yZCc6IFsvLyBNYXRjaCBhbGwga2luZHMgb2YgY29vcmQgbGluZXMgKHByZWZpeGVkIGJ5IFwiKysrXCIsIFwiLS0tXCIgb3IgXCIqKipcIikuXG4gICAgL14oPzpcXCp7M318LXszfXxcXCt7M30pLiokL20sIC8vIE1hdGNoIFwiQEAgLi4uIEBAXCIgY29vcmQgbGluZXMgaW4gdW5pZmllZCBkaWZmLlxuICAgIC9eQEAuKkBAJC9tLCAvLyBNYXRjaCBjb29yZCBsaW5lcyBpbiBub3JtYWwgZGlmZiAoc3RhcnRzIHdpdGggYSBudW1iZXIpLlxuICAgIC9eXFxkLiokL21dIC8vIGRlbGV0ZWQsIGluc2VydGVkLCB1bmNoYW5nZWQsIGRpZmZcblxuICB9O1xuICAvKipcbiAgICogQSBtYXAgZnJvbSB0aGUgbmFtZSBvZiBhIGJsb2NrIHRvIGl0cyBsaW5lIHByZWZpeC5cbiAgICpcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gICAqL1xuXG4gIHZhciBQUkVGSVhFUyA9IHtcbiAgICAnZGVsZXRlZC1zaWduJzogJy0nLFxuICAgICdkZWxldGVkLWFycm93JzogJzwnLFxuICAgICdpbnNlcnRlZC1zaWduJzogJysnLFxuICAgICdpbnNlcnRlZC1hcnJvdyc6ICc+JyxcbiAgICAndW5jaGFuZ2VkJzogJyAnLFxuICAgICdkaWZmJzogJyEnXG4gIH07IC8vIGFkZCBhIHRva2VuIGZvciBlYWNoIHByZWZpeFxuXG4gIE9iamVjdC5rZXlzKFBSRUZJWEVTKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHByZWZpeCA9IFBSRUZJWEVTW25hbWVdO1xuICAgIHZhciBhbGlhcyA9IFtdO1xuXG4gICAgaWYgKCEvXlxcdyskLy50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBcImRlbGV0ZWQtc2lnblwiIC0+IFwiZGVsZXRlZFwiXG4gICAgICBhbGlhcy5wdXNoKC9cXHcrLy5leGVjKG5hbWUpWzBdKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2RpZmYnKSB7XG4gICAgICBhbGlhcy5wdXNoKCdib2xkJyk7XG4gICAgfVxuXG4gICAgUHJpc20ubGFuZ3VhZ2VzLmRpZmZbbmFtZV0gPSB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoJ14oPzpbJyArIHByZWZpeCArICddLiooPzpcXHJcXG4/fFxcbnwoPyFbXFxcXHNcXFxcU10pKSkrJywgJ20nKSxcbiAgICAgIGFsaWFzOiBhbGlhcyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAnbGluZSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvKC4pKD89W1xcc1xcU10pLiooPzpcXHJcXG4/fFxcbik/LyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgICdwcmVmaXgnOiB7XG4gICAgICAgICAgcGF0dGVybjogL1tcXHNcXFNdLyxcbiAgICAgICAgICBhbGlhczogL1xcdysvLmV4ZWMobmFtZSlbMF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0pOyAvLyBtYWtlIHByZWZpeGVzIGF2YWlsYWJsZSB0byBEaWZmIHBsdWdpblxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmlzbS5sYW5ndWFnZXMuZGlmZiwgJ1BSRUZJWEVTJywge1xuICAgIHZhbHVlOiBQUkVGSVhFU1xuICB9KTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWdpdFwiICovXG5cblxucHJpc20ubGFuZ3VhZ2VzLmdpdCA9IHtcbiAgLypcbiAgICogQSBzaW1wbGUgb25lIGxpbmUgY29tbWVudCBsaWtlIGluIGEgZ2l0IHN0YXR1cyBjb21tYW5kXG4gICAqIEZvciBpbnN0YW5jZTpcbiAgICogJCBnaXQgc3RhdHVzXG4gICAqICMgT24gYnJhbmNoIGluZmluaXRlLXNjcm9sbFxuICAgKiAjIFlvdXIgYnJhbmNoIGFuZCAnb3JpZ2luL3NoYXJlZEJyYW5jaGVzL2Zyb250ZW5kVGVhbS9pbmZpbml0ZS1zY3JvbGwnIGhhdmUgZGl2ZXJnZWQsXG4gICAqICMgYW5kIGhhdmUgMSBhbmQgMiBkaWZmZXJlbnQgY29tbWl0cyBlYWNoLCByZXNwZWN0aXZlbHkuXG4gICAqIG5vdGhpbmcgdG8gY29tbWl0ICh3b3JraW5nIGRpcmVjdG9yeSBjbGVhbilcbiAgICovXG4gICdjb21tZW50JzogL14jLiovbSxcblxuICAvKlxuICAgKiBSZWdleHAgdG8gbWF0Y2ggdGhlIGNoYW5nZWQgbGluZXMgaW4gYSBnaXQgZGlmZiBvdXRwdXQuIENoZWNrIHRoZSBleGFtcGxlIGJlbG93LlxuICAgKi9cbiAgJ2RlbGV0ZWQnOiAvXlst4oCTXS4qL20sXG4gICdpbnNlcnRlZCc6IC9eXFwrLiovbSxcblxuICAvKlxuICAgKiBhIHN0cmluZyAoZG91YmxlIGFuZCBzaW1wbGUgcXVvdGUpXG4gICAqL1xuICAnc3RyaW5nJzogLyhcInwnKSg/OlxcXFwufCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuXG4gIC8qXG4gICAqIGEgZ2l0IGNvbW1hbmQuIEl0IHN0YXJ0cyB3aXRoIGEgcmFuZG9tIHByb21wdCBmaW5pc2hpbmcgYnkgYSAkLCB0aGVuIFwiZ2l0XCIgdGhlbiBzb21lIG90aGVyIHBhcmFtZXRlcnNcbiAgICogRm9yIGluc3RhbmNlOlxuICAgKiAkIGdpdCBhZGQgZmlsZS50eHRcbiAgICovXG4gICdjb21tYW5kJzoge1xuICAgIHBhdHRlcm46IC9eLipcXCQgZ2l0IC4qJC9tLFxuICAgIGluc2lkZToge1xuICAgICAgLypcbiAgICAgICAqIEEgZ2l0IGNvbW1hbmQgY2FuIGNvbnRhaW4gYSBwYXJhbWV0ZXIgc3RhcnRpbmcgYnkgYSBzaW5nbGUgb3IgYSBkb3VibGUgZGFzaCBmb2xsb3dlZCBieSBhIHN0cmluZ1xuICAgICAgICogRm9yIGluc3RhbmNlOlxuICAgICAgICogJCBnaXQgZGlmZiAtLWNhY2hlZFxuICAgICAgICogJCBnaXQgbG9nIC1wXG4gICAgICAgKi9cbiAgICAgICdwYXJhbWV0ZXInOiAvXFxzLS0/XFx3Ky9cbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICogQ29vcmRpbmF0ZXMgZGlzcGxheWVkIGluIGEgZ2l0IGRpZmYgY29tbWFuZFxuICAgKiBGb3IgaW5zdGFuY2U6XG4gICAqICQgZ2l0IGRpZmZcbiAgICogZGlmZiAtLWdpdCBmaWxlLnR4dCBmaWxlLnR4dFxuICAgKiBpbmRleCA2MjE0OTUzLi4xZDU0YTUyIDEwMDY0NFxuICAgKiAtLS0gZmlsZS50eHRcbiAgICogKysrIGZpbGUudHh0XG4gICAqIEBAIC0xICsxLDIgQEBcbiAgICogLUhlcmUncyBteSB0ZXR4IGZpbGVcbiAgICogK0hlcmUncyBteSB0ZXh0IGZpbGVcbiAgICogK0FuZCB0aGlzIGlzIHRoZSBzZWNvbmQgbGluZVxuICAgKi9cbiAgJ2Nvb3JkJzogL15AQC4qQEAkL20sXG5cbiAgLypcbiAgICogTWF0Y2ggYSBcImNvbW1pdCBbU0hBMV1cIiBsaW5lIGluIGEgZ2l0IGxvZyBvdXRwdXQuXG4gICAqIEZvciBpbnN0YW5jZTpcbiAgICogJCBnaXQgbG9nXG4gICAqIGNvbW1pdCBhMTFhMTRlZjdlMjZmMmNhNjJkNGIzNWVhYzQ1NWNlNjM2ZDBkYzA5XG4gICAqIEF1dGhvcjogbGdpcmF1ZGVsXG4gICAqIERhdGU6ICAgTW9uIEZlYiAxNyAxMToxODozNCAyMDE0ICswMTAwXG4gICAqXG4gICAqICAgICBBZGQgb2YgYSBuZXcgbGluZVxuICAgKi9cbiAgJ2NvbW1pdC1zaGExJzogL15jb21taXQgXFx3ezQwfSQvbVxufTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWdvXCIgKi9cblxucHJpc20ubGFuZ3VhZ2VzLmdvID0gcHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY2xpa2UnLCB7XG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pXCIoPzpcXFxcLnxbXlwiXFxcXFxcclxcbl0pKlwifGBbXmBdKmAvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/OmJyZWFrfGNhc2V8Y2hhbnxjb25zdHxjb250aW51ZXxkZWZhdWx0fGRlZmVyfGVsc2V8ZmFsbHRocm91Z2h8Zm9yfGZ1bmN8Z28oPzp0byk/fGlmfGltcG9ydHxpbnRlcmZhY2V8bWFwfHBhY2thZ2V8cmFuZ2V8cmV0dXJufHNlbGVjdHxzdHJ1Y3R8c3dpdGNofHR5cGV8dmFyKVxcYi8sXG4gICdib29sZWFuJzogL1xcYig/Ol98ZmFsc2V8aW90YXxuaWx8dHJ1ZSlcXGIvLFxuICAnbnVtYmVyJzogWy8vIGJpbmFyeSBhbmQgb2N0YWwgaW50ZWdlcnNcbiAgL1xcYjAoPzpiWzAxX10rfG9bMC03X10rKWk/XFxiL2ksIC8vIGhleGFkZWNpbWFsIGludGVnZXJzIGFuZCBmbG9hdHNcbiAgL1xcYjB4KD86W2EtZlxcZF9dKyg/OlxcLlthLWZcXGRfXSopP3xcXC5bYS1mXFxkX10rKSg/OnBbKy1dP1xcZCsoPzpfXFxkKykqKT9pPyg/IVxcdykvaSwgLy8gZGVjaW1hbCBpbnRlZ2VycyBhbmQgZmxvYXRzXG4gIC8oPzpcXGJcXGRbXFxkX10qKD86XFwuW1xcZF9dKik/fFxcQlxcLlxcZFtcXGRfXSopKD86ZVsrLV0/W1xcZF9dKyk/aT8oPyFcXHcpL2ldLFxuICAnb3BlcmF0b3InOiAvWypcXC8lXiE9XT0/fFxcK1s9K10/fC1bPS1dP3xcXHxbPXxdP3wmKD86PXwmfFxcXj0/KT98Pig/Oj49P3w9KT98PCg/Ojw9P3w9fC0pP3w6PXxcXC5cXC5cXC4vLFxuICAnYnVpbHRpbic6IC9cXGIoPzphcHBlbmR8Ym9vbHxieXRlfGNhcHxjbG9zZXxjb21wbGV4fGNvbXBsZXgoPzo2NHwxMjgpfGNvcHl8ZGVsZXRlfGVycm9yfGZsb2F0KD86MzJ8NjQpfHU/aW50KD86OHwxNnwzMnw2NCk/fGltYWd8bGVufG1ha2V8bmV3fHBhbmljfHByaW50KD86bG4pP3xyZWFsfHJlY292ZXJ8cnVuZXxzdHJpbmd8dWludHB0cilcXGIvXG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2dvJywgJ3N0cmluZycsIHtcbiAgJ2NoYXInOiB7XG4gICAgcGF0dGVybjogLycoPzpcXFxcLnxbXidcXFxcXFxyXFxuXSl7MCwxMH0nLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfVxufSk7XG5kZWxldGUgcHJpc20ubGFuZ3VhZ2VzLmdvWydjbGFzcy1uYW1lJ107XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1tYXJrdXAtdGVtcGxhdGluZ1wiICovXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIGZvciB0aGUgZ2l2ZW4gbGFuZ3VhZ2UgaWQgYW5kIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIobGFuZ3VhZ2UsIGluZGV4KSB7XG4gICAgcmV0dXJuICdfX18nICsgbGFuZ3VhZ2UudG9VcHBlckNhc2UoKSArIGluZGV4ICsgJ19fXyc7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhQcmlzbS5sYW5ndWFnZXNbJ21hcmt1cC10ZW1wbGF0aW5nJ10gPSB7fSwge1xuICAgIGJ1aWxkUGxhY2Vob2xkZXJzOiB7XG4gICAgICAvKipcbiAgICAgICAqIFRva2VuaXplIGFsbCBpbmxpbmUgdGVtcGxhdGluZyBleHByZXNzaW9ucyBtYXRjaGluZyBgcGxhY2Vob2xkZXJQYXR0ZXJuYC5cbiAgICAgICAqXG4gICAgICAgKiBJZiBgcmVwbGFjZUZpbHRlcmAgaXMgcHJvdmlkZWQsIG9ubHkgbWF0Y2hlcyBvZiBgcGxhY2Vob2xkZXJQYXR0ZXJuYCBmb3Igd2hpY2ggYHJlcGxhY2VGaWx0ZXJgIHJldHVybnNcbiAgICAgICAqIGB0cnVlYCB3aWxsIGJlIHJlcGxhY2VkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBlbnYgVGhlIGVudmlyb25tZW50IG9mIHRoZSBgYmVmb3JlLXRva2VuaXplYCBob29rLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBsYW5ndWFnZSBpZC5cbiAgICAgICAqIEBwYXJhbSB7UmVnRXhwfSBwbGFjZWhvbGRlclBhdHRlcm4gVGhlIG1hdGNoZXMgb2YgdGhpcyBwYXR0ZXJuIHdpbGwgYmUgcmVwbGFjZWQgYnkgcGxhY2Vob2xkZXJzLlxuICAgICAgICogQHBhcmFtIHsobWF0Y2g6IHN0cmluZykgPT4gYm9vbGVhbn0gW3JlcGxhY2VGaWx0ZXJdXG4gICAgICAgKi9cbiAgICAgIHZhbHVlOiBmdW5jdGlvbiAoZW52LCBsYW5ndWFnZSwgcGxhY2Vob2xkZXJQYXR0ZXJuLCByZXBsYWNlRmlsdGVyKSB7XG4gICAgICAgIGlmIChlbnYubGFuZ3VhZ2UgIT09IGxhbmd1YWdlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuU3RhY2sgPSBlbnYudG9rZW5TdGFjayA9IFtdO1xuICAgICAgICBlbnYuY29kZSA9IGVudi5jb2RlLnJlcGxhY2UocGxhY2Vob2xkZXJQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VGaWx0ZXIgPT09ICdmdW5jdGlvbicgJiYgIXJlcGxhY2VGaWx0ZXIobWF0Y2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGkgPSB0b2tlblN0YWNrLmxlbmd0aDtcbiAgICAgICAgICB2YXIgcGxhY2Vob2xkZXI7IC8vIENoZWNrIGZvciBleGlzdGluZyBzdHJpbmdzXG5cbiAgICAgICAgICB3aGlsZSAoZW52LmNvZGUuaW5kZXhPZihwbGFjZWhvbGRlciA9IGdldFBsYWNlaG9sZGVyKGxhbmd1YWdlLCBpKSkgIT09IC0xKSB7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgfSAvLyBDcmVhdGUgYSBzcGFyc2UgYXJyYXlcblxuXG4gICAgICAgICAgdG9rZW5TdGFja1tpXSA9IG1hdGNoO1xuICAgICAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICAgICAgfSk7IC8vIFN3aXRjaCB0aGUgZ3JhbW1hciB0byBtYXJrdXBcblxuICAgICAgICBlbnYuZ3JhbW1hciA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b2tlbml6ZVBsYWNlaG9sZGVyczoge1xuICAgICAgLyoqXG4gICAgICAgKiBSZXBsYWNlIHBsYWNlaG9sZGVycyB3aXRoIHByb3BlciB0b2tlbnMgYWZ0ZXIgdG9rZW5pemluZy5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gZW52IFRoZSBlbnZpcm9ubWVudCBvZiB0aGUgYGFmdGVyLXRva2VuaXplYCBob29rLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBsYW5ndWFnZSBpZC5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIChlbnYsIGxhbmd1YWdlKSB7XG4gICAgICAgIGlmIChlbnYubGFuZ3VhZ2UgIT09IGxhbmd1YWdlIHx8ICFlbnYudG9rZW5TdGFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTd2l0Y2ggdGhlIGdyYW1tYXIgYmFja1xuXG5cbiAgICAgICAgZW52LmdyYW1tYXIgPSBQcmlzbS5sYW5ndWFnZXNbbGFuZ3VhZ2VdO1xuICAgICAgICB2YXIgaiA9IDA7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZW52LnRva2VuU3RhY2spO1xuXG4gICAgICAgIGZ1bmN0aW9uIHdhbGtUb2tlbnModG9rZW5zKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGFsbCBwbGFjZWhvbGRlcnMgYXJlIHJlcGxhY2VkIGFscmVhZHlcbiAgICAgICAgICAgIGlmIChqID49IGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnIHx8IHRva2VuLmNvbnRlbnQgJiYgdHlwZW9mIHRva2VuLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciBrID0ga2V5c1tqXTtcbiAgICAgICAgICAgICAgdmFyIHQgPSBlbnYudG9rZW5TdGFja1trXTtcbiAgICAgICAgICAgICAgdmFyIHMgPSB0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnID8gdG9rZW4gOiB0b2tlbi5jb250ZW50O1xuICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRQbGFjZWhvbGRlcihsYW5ndWFnZSwgayk7XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IHMuaW5kZXhPZihwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICArK2o7XG4gICAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHMuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB2YXIgbWlkZGxlID0gbmV3IFByaXNtLlRva2VuKGxhbmd1YWdlLCBQcmlzbS50b2tlbml6ZSh0LCBlbnYuZ3JhbW1hciksICdsYW5ndWFnZS0nICsgbGFuZ3VhZ2UsIHQpO1xuICAgICAgICAgICAgICAgIHZhciBhZnRlciA9IHMuc3Vic3RyaW5nKGluZGV4ICsgcGxhY2Vob2xkZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBbXTtcblxuICAgICAgICAgICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2guYXBwbHkocmVwbGFjZW1lbnQsIHdhbGtUb2tlbnMoW2JlZm9yZV0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wdXNoKG1pZGRsZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50LnB1c2guYXBwbHkocmVwbGFjZW1lbnQsIHdhbGtUb2tlbnMoW2FmdGVyXSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbnMuc3BsaWNlLmFwcGx5KHRva2VucywgW2ksIDFdLmNvbmNhdChyZXBsYWNlbWVudCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuLmNvbnRlbnRcbiAgICAgICAgICAgIC8qICYmIHR5cGVvZiB0b2tlbi5jb250ZW50ICE9PSAnc3RyaW5nJyAqL1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgd2Fsa1Rva2Vucyh0b2tlbi5jb250ZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgIH1cblxuICAgICAgICB3YWxrVG9rZW5zKGVudi50b2tlbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1oYW5kbGViYXJzXCIgKi9cblxuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5oYW5kbGViYXJzID0ge1xuICAgICdjb21tZW50JzogL1xce1xceyFbXFxzXFxTXSo/XFx9XFx9LyxcbiAgICAnZGVsaW1pdGVyJzoge1xuICAgICAgcGF0dGVybjogL15cXHtcXHtcXHs/fFxcfVxcfVxcfT8kLyxcbiAgICAgIGFsaWFzOiAncHVuY3R1YXRpb24nXG4gICAgfSxcbiAgICAnc3RyaW5nJzogLyhbXCInXSkoPzpcXFxcLnwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcbiAgICAnbnVtYmVyJzogL1xcYjB4W1xcZEEtRmEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzpbRWVdWystXT9cXGQrKT8vLFxuICAgICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgICAnYmxvY2snOiB7XG4gICAgICBwYXR0ZXJuOiAvXihcXHMqKD86flxccyopPylbI1xcL11cXFMrPyg/PVxccyooPzp+XFxzKik/JHxcXHMpLyxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBhbGlhczogJ2tleXdvcmQnXG4gICAgfSxcbiAgICAnYnJhY2tldHMnOiB7XG4gICAgICBwYXR0ZXJuOiAvXFxbW15cXF1dK1xcXS8sXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgcHVuY3R1YXRpb246IC9cXFt8XFxdLyxcbiAgICAgICAgdmFyaWFibGU6IC9bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSxcbiAgICAncHVuY3R1YXRpb24nOiAvWyFcIiMlJic6KCkqKywuXFwvOzw9PkBcXFtcXFxcXFxdXmB7fH1+XS8sXG4gICAgJ3ZhcmlhYmxlJzogL1teIVwiIyUmJygpKissXFwvOzw9PkBcXFtcXFxcXFxdXmB7fH1+XFxzXSsvXG4gIH07XG4gIFByaXNtLmhvb2tzLmFkZCgnYmVmb3JlLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuICAgIHZhciBoYW5kbGViYXJzUGF0dGVybiA9IC9cXHtcXHtcXHtbXFxzXFxTXSs/XFx9XFx9XFx9fFxce1xce1tcXHNcXFNdKz9cXH1cXH0vZztcbiAgICBQcmlzbS5sYW5ndWFnZXNbJ21hcmt1cC10ZW1wbGF0aW5nJ10uYnVpbGRQbGFjZWhvbGRlcnMoZW52LCAnaGFuZGxlYmFycycsIGhhbmRsZWJhcnNQYXR0ZXJuKTtcbiAgfSk7XG4gIFByaXNtLmhvb2tzLmFkZCgnYWZ0ZXItdG9rZW5pemUnLCBmdW5jdGlvbiAoZW52KSB7XG4gICAgUHJpc20ubGFuZ3VhZ2VzWydtYXJrdXAtdGVtcGxhdGluZyddLnRva2VuaXplUGxhY2Vob2xkZXJzKGVudiwgJ2hhbmRsZWJhcnMnKTtcbiAgfSk7XG4gIFByaXNtLmxhbmd1YWdlcy5oYnMgPSBQcmlzbS5sYW5ndWFnZXMuaGFuZGxlYmFycztcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWpzb25cIiAqL1xuLy8gaHR0cHM6Ly93d3cuanNvbi5vcmcvanNvbi1lbi5odG1sXG5cblxucHJpc20ubGFuZ3VhZ2VzLmpzb24gPSB7XG4gICdwcm9wZXJ0eSc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcIig/OlxcXFwufFteXFxcXFwiXFxyXFxuXSkqXCIoPz1cXHMqOikvLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pXCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiKD8hXFxzKjopLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvXFwvXFwvLip8XFwvXFwqW1xcc1xcU10qPyg/OlxcKlxcL3wkKS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdudW1iZXInOiAvLT9cXGJcXGQrKD86XFwuXFxkKyk/KD86ZVsrLV0/XFxkKyk/XFxiL2ksXG4gICdwdW5jdHVhdGlvbic6IC9be31bXFxdLF0vLFxuICAnb3BlcmF0b3InOiAvOi8sXG4gICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgJ251bGwnOiB7XG4gICAgcGF0dGVybjogL1xcYm51bGxcXGIvLFxuICAgIGFsaWFzOiAna2V5d29yZCdcbiAgfVxufTtcbnByaXNtLmxhbmd1YWdlcy53ZWJtYW5pZmVzdCA9IHByaXNtLmxhbmd1YWdlcy5qc29uO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tbGVzc1wiICovXG5cbi8qIEZJWE1FIDpcbiA6ZXh0ZW5kKCkgaXMgbm90IGhhbmRsZWQgc3BlY2lmaWNhbGx5IDogaXRzIGhpZ2hsaWdodGluZyBpcyBidWdneS5cbiBNaXhpbiB1c2FnZSBtdXN0IGJlIGluc2lkZSBhIHJ1bGVzZXQgdG8gYmUgaGlnaGxpZ2h0ZWQuXG4gQXQtcnVsZXMgKGUuZy4gaW1wb3J0KSBjb250YWluaW5nIGludGVycG9sYXRpb25zIGFyZSBidWdneS5cbiBEZXRhY2hlZCBydWxlc2V0cyBhcmUgaGlnaGxpZ2h0ZWQgYXMgYXQtcnVsZXMuXG4gQSBjb21tZW50IGJlZm9yZSBhIG1peGluIHVzYWdlIHByZXZlbnRzIHRoZSBsYXR0ZXIgdG8gYmUgcHJvcGVybHkgaGlnaGxpZ2h0ZWQuXG4gKi9cblxucHJpc20ubGFuZ3VhZ2VzLmxlc3MgPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjc3MnLCB7XG4gICdjb21tZW50JzogWy9cXC9cXCpbXFxzXFxTXSo/XFwqXFwvLywge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVxcL1xcLy4qLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH1dLFxuICAnYXRydWxlJzoge1xuICAgIHBhdHRlcm46IC9AW1xcdy1dKD86XFwoKD86W14oKXt9XXxcXChbXigpe31dKlxcKSkqXFwpfFteKCl7fTtcXHNdfFxccysoPyFcXHMpKSo/KD89XFxzKlxceykvLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL1s6KCldL1xuICAgIH1cbiAgfSxcbiAgLy8gc2VsZWN0b3JzIGFuZCBtaXhpbnMgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAgJ3NlbGVjdG9yJzoge1xuICAgIHBhdHRlcm46IC8oPzpAXFx7W1xcdy1dK1xcfXxbXnt9O1xcc0BdKSg/OkBcXHtbXFx3LV0rXFx9fFxcKCg/OlteKCl7fV18XFwoW14oKXt9XSpcXCkpKlxcKXxbXigpe307QFxcc118XFxzKyg/IVxccykpKj8oPz1cXHMqXFx7KS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAvLyBtaXhpbiBwYXJhbWV0ZXJzXG4gICAgICAndmFyaWFibGUnOiAvQCtbXFx3LV0rL1xuICAgIH1cbiAgfSxcbiAgJ3Byb3BlcnR5JzogLyg/OkBcXHtbXFx3LV0rXFx9fFtcXHctXSkrKD86XFwrXz8pPyg/PVxccyo6KS8sXG4gICdvcGVyYXRvcic6IC9bK1xcLSpcXC9dL1xufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdsZXNzJywgJ3Byb3BlcnR5Jywge1xuICAndmFyaWFibGUnOiBbLy8gVmFyaWFibGUgZGVjbGFyYXRpb24gKHRoZSBjb2xvbiBtdXN0IGJlIGNvbnN1bWVkISlcbiAge1xuICAgIHBhdHRlcm46IC9AW1xcdy1dK1xccyo6LyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdwdW5jdHVhdGlvbic6IC86L1xuICAgIH1cbiAgfSwgLy8gVmFyaWFibGUgdXNhZ2VcbiAgL0BAP1tcXHctXSsvXSxcbiAgJ21peGluLXVzYWdlJzoge1xuICAgIHBhdHRlcm46IC8oW3s7XVxccyopWy4jXSg/IVxcZClbXFx3LV0uKj8oPz1bKDtdKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICBhbGlhczogJ2Z1bmN0aW9uJ1xuICB9XG59KTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLW1ha2VmaWxlXCIgKi9cblxucHJpc20ubGFuZ3VhZ2VzLm1ha2VmaWxlID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSkjKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cXFxcXFxyXFxuXSkqLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogLyhbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDEpW15cXFxcXFxyXFxuXSkqXFwxLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2J1aWx0aW4tdGFyZ2V0Jzoge1xuICAgIHBhdHRlcm46IC9cXC5bQS1aXVteOiM9XFxzXSsoPz1cXHMqOig/IT0pKS8sXG4gICAgYWxpYXM6ICdidWlsdGluJ1xuICB9LFxuICAndGFyZ2V0Jzoge1xuICAgIHBhdHRlcm46IC9eKD86W146PVxcc118WyBcXHRdKyg/IVtcXHM6XSkpKyg/PVxccyo6KD8hPSkpL20sXG4gICAgYWxpYXM6ICdzeW1ib2wnLFxuICAgIGluc2lkZToge1xuICAgICAgJ3ZhcmlhYmxlJzogL1xcJCsoPzooPyFcXCQpW14oKXt9OiM9XFxzXSt8KD89Wyh7XSkpL1xuICAgIH1cbiAgfSxcbiAgJ3ZhcmlhYmxlJzogL1xcJCsoPzooPyFcXCQpW14oKXt9OiM9XFxzXSt8XFwoW0AqJTxeKz9dW0RGXVxcKXwoPz1bKHtdKSkvLFxuICAvLyBEaXJlY3RpdmVzXG4gICdrZXl3b3JkJzogLy1pbmNsdWRlXFxifFxcYig/OmRlZmluZXxlbHNlfGVuZGVmfGVuZGlmfGV4cG9ydHxpZm4/ZGVmfGlmbj9lcXxpbmNsdWRlfG92ZXJyaWRlfHByaXZhdGV8c2luY2x1ZGV8dW5kZWZpbmV8dW5leHBvcnR8dnBhdGgpXFxiLyxcbiAgJ2Z1bmN0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oXFwoKSg/OmFic3BhdGh8YWRkc3VmZml4fGFuZHxiYXNlbmFtZXxjYWxsfGRpcnxlcnJvcnxldmFsfGZpbGV8ZmlsdGVyKD86LW91dCk/fGZpbmRzdHJpbmd8Zmlyc3R3b3JkfGZsYXZvcnxmb3JlYWNofGd1aWxlfGlmfGluZm98am9pbnxsYXN0d29yZHxsb2FkfG5vdGRpcnxvcnxvcmlnaW58cGF0c3Vic3R8cmVhbHBhdGh8c2hlbGx8c29ydHxzdHJpcHxzdWJzdHxzdWZmaXh8dmFsdWV8d2FybmluZ3x3aWxkY2FyZHx3b3JkKD86bGlzdHxzKT8pKD89WyBcXHRdKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnb3BlcmF0b3InOiAvKD86Ojp8Wz86KyFdKT89fFt8QF0vLFxuICAncHVuY3R1YXRpb24nOiAvWzo7KCl7fV0vXG59O1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tb2JqZWN0aXZlY1wiICovXG5cbnByaXNtLmxhbmd1YWdlcy5vYmplY3RpdmVjID0gcHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnYycsIHtcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvQD9cIig/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfFteXCJcXFxcXFxyXFxuXSkqXCIvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAna2V5d29yZCc6IC9cXGIoPzphc218YXV0b3xicmVha3xjYXNlfGNoYXJ8Y29uc3R8Y29udGludWV8ZGVmYXVsdHxkb3xkb3VibGV8ZWxzZXxlbnVtfGV4dGVybnxmbG9hdHxmb3J8Z290b3xpZnxpbnxpbmxpbmV8aW50fGxvbmd8cmVnaXN0ZXJ8cmV0dXJufHNlbGZ8c2hvcnR8c2lnbmVkfHNpemVvZnxzdGF0aWN8c3RydWN0fHN1cGVyfHN3aXRjaHx0eXBlZGVmfHR5cGVvZnx1bmlvbnx1bnNpZ25lZHx2b2lkfHZvbGF0aWxlfHdoaWxlKVxcYnwoPzpAaW50ZXJmYWNlfEBlbmR8QGltcGxlbWVudGF0aW9ufEBwcm90b2NvbHxAY2xhc3N8QHB1YmxpY3xAcHJvdGVjdGVkfEBwcml2YXRlfEBwcm9wZXJ0eXxAdHJ5fEBjYXRjaHxAZmluYWxseXxAdGhyb3d8QHN5bnRoZXNpemV8QGR5bmFtaWN8QHNlbGVjdG9yKVxcYi8sXG4gICdvcGVyYXRvcic6IC8tWy0+XT98XFwrXFwrP3whPT98PDw/PT98Pj4/PT98PT0/fCYmP3xcXHxcXHw/fFt+XiU/KlxcL0BdL1xufSk7XG5kZWxldGUgcHJpc20ubGFuZ3VhZ2VzLm9iamVjdGl2ZWNbJ2NsYXNzLW5hbWUnXTtcbnByaXNtLmxhbmd1YWdlcy5vYmpjID0gcHJpc20ubGFuZ3VhZ2VzLm9iamVjdGl2ZWM7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1vY2FtbFwiICovXG4vLyBodHRwczovL29jYW1sLm9yZy9tYW51YWwvbGV4Lmh0bWxcblxucHJpc20ubGFuZ3VhZ2VzLm9jYW1sID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvXFwoXFwqW1xcc1xcU10qP1xcKlxcKS8sXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdjaGFyJzoge1xuICAgIHBhdHRlcm46IC8nKD86W15cXFxcXFxyXFxuJ118XFxcXCg/Oi58W294XT9bMC05YS1mXXsxLDN9KSknL2ksXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdzdHJpbmcnOiBbe1xuICAgIHBhdHRlcm46IC9cIig/OlxcXFwoPzpbXFxzXFxTXXxcXHJcXG4pfFteXFxcXFxcclxcblwiXSkqXCIvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LCB7XG4gICAgcGF0dGVybjogL1xceyhbYS16X10qKVxcfFtcXHNcXFNdKj9cXHxcXDFcXH0vLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9XSxcbiAgJ251bWJlcic6IFsvLyBiaW5hcnkgYW5kIG9jdGFsXG4gIC9cXGIoPzowYlswMV1bMDFfXSp8MG9bMC03XVswLTdfXSopXFxiL2ksIC8vIGhleGFkZWNpbWFsXG4gIC9cXGIweFthLWYwLTldW2EtZjAtOV9dKig/OlxcLlthLWYwLTlfXSopPyg/OnBbKy1dP1xcZFtcXGRfXSopPyg/IVxcdykvaSwgLy8gZGVjaW1hbFxuICAvXFxiXFxkW1xcZF9dKig/OlxcLltcXGRfXSopPyg/OmVbKy1dP1xcZFtcXGRfXSopPyg/IVxcdykvaV0sXG4gICdkaXJlY3RpdmUnOiB7XG4gICAgcGF0dGVybjogL1xcQiNcXHcrLyxcbiAgICBhbGlhczogJ3Byb3BlcnR5J1xuICB9LFxuICAnbGFiZWwnOiB7XG4gICAgcGF0dGVybjogL1xcQn5cXHcrLyxcbiAgICBhbGlhczogJ3Byb3BlcnR5J1xuICB9LFxuICAndHlwZS12YXJpYWJsZSc6IHtcbiAgICBwYXR0ZXJuOiAvXFxCJ1xcdysvLFxuICAgIGFsaWFzOiAnZnVuY3Rpb24nXG4gIH0sXG4gICd2YXJpYW50Jzoge1xuICAgIHBhdHRlcm46IC9gXFx3Ky8sXG4gICAgYWxpYXM6ICdzeW1ib2wnXG4gIH0sXG4gIC8vIEZvciB0aGUgbGlzdCBvZiBrZXl3b3JkcyBhbmQgb3BlcmF0b3JzLFxuICAvLyBzZWU6IGh0dHA6Ly9jYW1sLmlucmlhLmZyL3B1Yi9kb2NzL21hbnVhbC1vY2FtbC9sZXguaHRtbCNzZWM4NFxuICAna2V5d29yZCc6IC9cXGIoPzphc3xhc3NlcnR8YmVnaW58Y2xhc3N8Y29uc3RyYWludHxkb3xkb25lfGRvd250b3xlbHNlfGVuZHxleGNlcHRpb258ZXh0ZXJuYWx8Zm9yfGZ1bnxmdW5jdGlvbnxmdW5jdG9yfGlmfGlufGluY2x1ZGV8aW5oZXJpdHxpbml0aWFsaXplcnxsYXp5fGxldHxtYXRjaHxtZXRob2R8bW9kdWxlfG11dGFibGV8bmV3fG5vbnJlY3xvYmplY3R8b2Z8b3Blbnxwcml2YXRlfHJlY3xzaWd8c3RydWN0fHRoZW58dG98dHJ5fHR5cGV8dmFsfHZhbHVlfHZpcnR1YWx8d2hlbnx3aGVyZXx3aGlsZXx3aXRoKVxcYi8sXG4gICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgJ29wZXJhdG9yLWxpa2UtcHVuY3R1YXRpb24nOiB7XG4gICAgcGF0dGVybjogL1xcW1s8PnxdfFs+fF1cXF18XFx7PHw+XFx9LyxcbiAgICBhbGlhczogJ3B1bmN0dWF0aW9uJ1xuICB9LFxuICAvLyBDdXN0b20gb3BlcmF0b3JzIGFyZSBhbGxvd2VkXG4gICdvcGVyYXRvcic6IC9cXC5bLn5dfDpbPT5dfFs9PD5AXnwmK1xcLSpcXC8kJSE/fl1bISQlJiorXFwtLlxcLzo8PT4/QF58fl0qfFxcYig/OmFuZHxhc3J8bGFuZHxsb3J8bHNsfGxzcnxseG9yfG1vZHxvcilcXGIvLFxuICAncHVuY3R1YXRpb24nOiAvOzt8Ojp8Wygpe31cXFtcXF0uLDo7I118XFxiX1xcYi9cbn07XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS1weXRob25cIiAqL1xuXG5wcmlzbS5sYW5ndWFnZXMucHl0aG9uID0ge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSkjLiovLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgZ3JlZWR5OiB0cnVlXG4gIH0sXG4gICdzdHJpbmctaW50ZXJwb2xhdGlvbic6IHtcbiAgICBwYXR0ZXJuOiAvKD86ZnxmcnxyZikoPzooXCJcIlwifCcnJylbXFxzXFxTXSo/XFwxfChcInwnKSg/OlxcXFwufCg/IVxcMilbXlxcXFxcXHJcXG5dKSpcXDIpL2ksXG4gICAgZ3JlZWR5OiB0cnVlLFxuICAgIGluc2lkZToge1xuICAgICAgJ2ludGVycG9sYXRpb24nOiB7XG4gICAgICAgIC8vIFwie1wiIDxleHByZXNzaW9uPiA8b3B0aW9uYWwgXCIhc1wiLCBcIiFyXCIsIG9yIFwiIWFcIj4gPG9wdGlvbmFsIFwiOlwiIGZvcm1hdCBzcGVjaWZpZXI+IFwifVwiXG4gICAgICAgIHBhdHRlcm46IC8oKD86XnxbXntdKSg/Olxce1xceykqKVxceyg/IVxceykoPzpbXnt9XXxcXHsoPyFcXHspKD86W157fV18XFx7KD8hXFx7KSg/Oltee31dKStcXH0pK1xcfSkrXFx9LyxcbiAgICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgJ2Zvcm1hdC1zcGVjJzoge1xuICAgICAgICAgICAgcGF0dGVybjogLyg6KVteOigpe31dKyg/PVxcfSQpLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgICdjb252ZXJzaW9uLW9wdGlvbic6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC8hW3NyYV0oPz1bOn1dJCkvLFxuICAgICAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc3Q6IG51bGxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICdzdHJpbmcnOiAvW1xcc1xcU10rL1xuICAgIH1cbiAgfSxcbiAgJ3RyaXBsZS1xdW90ZWQtc3RyaW5nJzoge1xuICAgIHBhdHRlcm46IC8oPzpbcnViXXxicnxyYik/KFwiXCJcInwnJycpW1xcc1xcU10qP1xcMS9pLFxuICAgIGdyZWVkeTogdHJ1ZSxcbiAgICBhbGlhczogJ3N0cmluZydcbiAgfSxcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvKD86W3J1Yl18YnJ8cmIpPyhcInwnKSg/OlxcXFwufCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvaSxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgJ2Z1bmN0aW9uJzoge1xuICAgIHBhdHRlcm46IC8oKD86XnxcXHMpZGVmWyBcXHRdKylbYS16QS1aX11cXHcqKD89XFxzKlxcKCkvZyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdjbGFzcy1uYW1lJzoge1xuICAgIHBhdHRlcm46IC8oXFxiY2xhc3NcXHMrKVxcdysvaSxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH0sXG4gICdkZWNvcmF0b3InOiB7XG4gICAgcGF0dGVybjogLyheW1xcdCBdKilAXFx3Kyg/OlxcLlxcdyspKi9tLFxuICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgYWxpYXM6IFsnYW5ub3RhdGlvbicsICdwdW5jdHVhdGlvbiddLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi9cbiAgICB9XG4gIH0sXG4gICdrZXl3b3JkJzogL1xcYig/Ol8oPz1cXHMqOil8YW5kfGFzfGFzc2VydHxhc3luY3xhd2FpdHxicmVha3xjYXNlfGNsYXNzfGNvbnRpbnVlfGRlZnxkZWx8ZWxpZnxlbHNlfGV4Y2VwdHxleGVjfGZpbmFsbHl8Zm9yfGZyb218Z2xvYmFsfGlmfGltcG9ydHxpbnxpc3xsYW1iZGF8bWF0Y2h8bm9ubG9jYWx8bm90fG9yfHBhc3N8cHJpbnR8cmFpc2V8cmV0dXJufHRyeXx3aGlsZXx3aXRofHlpZWxkKVxcYi8sXG4gICdidWlsdGluJzogL1xcYig/Ol9faW1wb3J0X198YWJzfGFsbHxhbnl8YXBwbHl8YXNjaWl8YmFzZXN0cmluZ3xiaW58Ym9vbHxidWZmZXJ8Ynl0ZWFycmF5fGJ5dGVzfGNhbGxhYmxlfGNocnxjbGFzc21ldGhvZHxjbXB8Y29lcmNlfGNvbXBpbGV8Y29tcGxleHxkZWxhdHRyfGRpY3R8ZGlyfGRpdm1vZHxlbnVtZXJhdGV8ZXZhbHxleGVjZmlsZXxmaWxlfGZpbHRlcnxmbG9hdHxmb3JtYXR8ZnJvemVuc2V0fGdldGF0dHJ8Z2xvYmFsc3xoYXNhdHRyfGhhc2h8aGVscHxoZXh8aWR8aW5wdXR8aW50fGludGVybnxpc2luc3RhbmNlfGlzc3ViY2xhc3N8aXRlcnxsZW58bGlzdHxsb2NhbHN8bG9uZ3xtYXB8bWF4fG1lbW9yeXZpZXd8bWlufG5leHR8b2JqZWN0fG9jdHxvcGVufG9yZHxwb3d8cHJvcGVydHl8cmFuZ2V8cmF3X2lucHV0fHJlZHVjZXxyZWxvYWR8cmVwcnxyZXZlcnNlZHxyb3VuZHxzZXR8c2V0YXR0cnxzbGljZXxzb3J0ZWR8c3RhdGljbWV0aG9kfHN0cnxzdW18c3VwZXJ8dHVwbGV8dHlwZXx1bmljaHJ8dW5pY29kZXx2YXJzfHhyYW5nZXx6aXApXFxiLyxcbiAgJ2Jvb2xlYW4nOiAvXFxiKD86RmFsc2V8Tm9uZXxUcnVlKVxcYi8sXG4gICdudW1iZXInOiAvXFxiMCg/OmIoPzpfP1swMV0pK3xvKD86Xz9bMC03XSkrfHgoPzpfP1thLWYwLTldKSspXFxifCg/OlxcYlxcZCsoPzpfXFxkKykqKD86XFwuKD86XFxkKyg/Ol9cXGQrKSopPyk/fFxcQlxcLlxcZCsoPzpfXFxkKykqKSg/OmVbKy1dP1xcZCsoPzpfXFxkKykqKT9qPyg/IVxcdykvaSxcbiAgJ29wZXJhdG9yJzogL1stKyU9XT0/fCE9fDo9fFxcKlxcKj89P3xcXC9cXC8/PT98PFs8PT5dP3w+Wz0+XT98WyZ8Xn5dLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcbnByaXNtLmxhbmd1YWdlcy5weXRob25bJ3N0cmluZy1pbnRlcnBvbGF0aW9uJ10uaW5zaWRlWydpbnRlcnBvbGF0aW9uJ10uaW5zaWRlLnJlc3QgPSBwcmlzbS5sYW5ndWFnZXMucHl0aG9uO1xucHJpc20ubGFuZ3VhZ2VzLnB5ID0gcHJpc20ubGFuZ3VhZ2VzLnB5dGhvbjtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXJlYXNvblwiICovXG5cbnByaXNtLmxhbmd1YWdlcy5yZWFzb24gPSBwcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcbiAgJ3N0cmluZyc6IHtcbiAgICBwYXR0ZXJuOiAvXCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlxcXFxcXHJcXG5cIl0pKlwiLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgLy8gJ2NsYXNzLW5hbWUnIG11c3QgYmUgbWF0Y2hlZCAqYWZ0ZXIqICdjb25zdHJ1Y3RvcicgZGVmaW5lZCBiZWxvd1xuICAnY2xhc3MtbmFtZSc6IC9cXGJbQS1aXVxcdyovLFxuICAna2V5d29yZCc6IC9cXGIoPzphbmR8YXN8YXNzZXJ0fGJlZ2lufGNsYXNzfGNvbnN0cmFpbnR8ZG98ZG9uZXxkb3dudG98ZWxzZXxlbmR8ZXhjZXB0aW9ufGV4dGVybmFsfGZvcnxmdW58ZnVuY3Rpb258ZnVuY3RvcnxpZnxpbnxpbmNsdWRlfGluaGVyaXR8aW5pdGlhbGl6ZXJ8bGF6eXxsZXR8bWV0aG9kfG1vZHVsZXxtdXRhYmxlfG5ld3xub25yZWN8b2JqZWN0fG9mfG9wZW58b3J8cHJpdmF0ZXxyZWN8c2lnfHN0cnVjdHxzd2l0Y2h8dGhlbnx0b3x0cnl8dHlwZXx2YWx8dmlydHVhbHx3aGVufHdoaWxlfHdpdGgpXFxiLyxcbiAgJ29wZXJhdG9yJzogL1xcLnszfXw6Wzo9XXxcXHw+fC0+fD0oPzo9PT98Pik/fDw9P3w+PT98W3xePycjIX5gXXxbK1xcLSpcXC9dXFwuP3xcXGIoPzphc3J8bGFuZHxsb3J8bHNsfGxzcnxseG9yfG1vZClcXGIvXG59KTtcbnByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3JlYXNvbicsICdjbGFzcy1uYW1lJywge1xuICAnY2hhcic6IHtcbiAgICBwYXR0ZXJuOiAvJyg/OlxcXFx4W1xcZGEtZl17Mn18XFxcXG9bMC0zXVswLTddWzAtN118XFxcXFxcZHszfXxcXFxcLnxbXidcXFxcXFxyXFxuXSknLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfSxcbiAgLy8gTmVnYXRpdmUgbG9vay1haGVhZCBwcmV2ZW50cyBmcm9tIG1hdGNoaW5nIHRoaW5ncyBsaWtlIFN0cmluZy5jYXBpdGFsaXplXG4gICdjb25zdHJ1Y3Rvcic6IC9cXGJbQS1aXVxcdypcXGIoPyFcXHMqXFwuKS8sXG4gICdsYWJlbCc6IHtcbiAgICBwYXR0ZXJuOiAvXFxiW2Etel1cXHcqKD89OjopLyxcbiAgICBhbGlhczogJ3N5bWJvbCdcbiAgfVxufSk7IC8vIFdlIGNhbid0IG1hdGNoIGZ1bmN0aW9ucyBwcm9wZXJ0eSwgc28gbGV0J3Mgbm90IGV2ZW4gdHJ5LlxuXG5kZWxldGUgcHJpc20ubGFuZ3VhZ2VzLnJlYXNvbi5mdW5jdGlvbjtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXNhc3NcIiAqL1xuXG4oZnVuY3Rpb24gKFByaXNtKSB7XG4gIFByaXNtLmxhbmd1YWdlcy5zYXNzID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3NzJywge1xuICAgIC8vIFNhc3MgY29tbWVudHMgZG9uJ3QgbmVlZCB0byBiZSBjbG9zZWQsIG9ubHkgaW5kZW50ZWRcbiAgICAnY29tbWVudCc6IHtcbiAgICAgIHBhdHRlcm46IC9eKFsgXFx0XSopXFwvW1xcLypdLiooPzooPzpcXHI/XFxufFxccilcXDFbIFxcdF0uKykqL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfVxuICB9KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2FzcycsICdhdHJ1bGUnLCB7XG4gICAgLy8gV2Ugd2FudCB0byBjb25zdW1lIHRoZSB3aG9sZSBsaW5lXG4gICAgJ2F0cnVsZS1saW5lJzoge1xuICAgICAgLy8gSW5jbHVkZXMgc3VwcG9ydCBmb3IgPSBhbmQgKyBzaG9ydGN1dHNcbiAgICAgIHBhdHRlcm46IC9eKD86WyBcXHRdKilbQCs9XS4rL20sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2F0cnVsZSc6IC8oPzpAW1xcdy1dK3xbKz1dKS9cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnNhc3MuYXRydWxlO1xuICB2YXIgdmFyaWFibGUgPSAvXFwkWy1cXHddK3wjXFx7XFwkWy1cXHddK1xcfS87XG4gIHZhciBvcGVyYXRvciA9IFsvWysqXFwvJV18Wz0hXT18PD0/fD49P3xcXGIoPzphbmR8bm90fG9yKVxcYi8sIHtcbiAgICBwYXR0ZXJuOiAvKFxccyktKD89XFxzKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XTtcbiAgUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2FzcycsICdwcm9wZXJ0eScsIHtcbiAgICAvLyBXZSB3YW50IHRvIGNvbnN1bWUgdGhlIHdob2xlIGxpbmVcbiAgICAndmFyaWFibGUtbGluZSc6IHtcbiAgICAgIHBhdHRlcm46IC9eWyBcXHRdKlxcJC4rL20sXG4gICAgICBncmVlZHk6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3B1bmN0dWF0aW9uJzogLzovLFxuICAgICAgICAndmFyaWFibGUnOiB2YXJpYWJsZSxcbiAgICAgICAgJ29wZXJhdG9yJzogb3BlcmF0b3JcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFdlIHdhbnQgdG8gY29uc3VtZSB0aGUgd2hvbGUgbGluZVxuICAgICdwcm9wZXJ0eS1saW5lJzoge1xuICAgICAgcGF0dGVybjogL15bIFxcdF0qKD86W146XFxzXSsgKjouKnw6W146XFxzXS4qKS9tLFxuICAgICAgZ3JlZWR5OiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwcm9wZXJ0eSc6IFsvW146XFxzXSsoPz1cXHMqOikvLCB7XG4gICAgICAgICAgcGF0dGVybjogLyg6KVteOlxcc10rLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgICAgIH1dLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvOi8sXG4gICAgICAgICd2YXJpYWJsZSc6IHZhcmlhYmxlLFxuICAgICAgICAnb3BlcmF0b3InOiBvcGVyYXRvcixcbiAgICAgICAgJ2ltcG9ydGFudCc6IFByaXNtLmxhbmd1YWdlcy5zYXNzLmltcG9ydGFudFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMuc2Fzcy5wcm9wZXJ0eTtcbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy5zYXNzLmltcG9ydGFudDsgLy8gTm93IHRoYXQgd2hvbGUgbGluZXMgZm9yIG90aGVyIHBhdHRlcm5zIGFyZSBjb25zdW1lZCxcbiAgLy8gd2hhdCdzIGxlZnQgc2hvdWxkIGJlIHNlbGVjdG9yc1xuXG4gIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3Nhc3MnLCAncHVuY3R1YXRpb24nLCB7XG4gICAgJ3NlbGVjdG9yJzoge1xuICAgICAgcGF0dGVybjogL14oWyBcXHRdKilcXFMoPzosW14sXFxyXFxuXSt8W14sXFxyXFxuXSopKD86LFteLFxcclxcbl0rKSooPzosKD86XFxyP1xcbnxcXHIpXFwxWyBcXHRdK1xcUyg/OixbXixcXHJcXG5dK3xbXixcXHJcXG5dKikoPzosW14sXFxyXFxuXSspKikqL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfVxuICB9KTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXNjc3NcIiAqL1xuXG5cbnByaXNtLmxhbmd1YWdlcy5zY3NzID0gcHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3NzJywge1xuICAnY29tbWVudCc6IHtcbiAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSkoPzpcXC9cXCpbXFxzXFxTXSo/XFwqXFwvfFxcL1xcLy4qKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9LFxuICAnYXRydWxlJzoge1xuICAgIHBhdHRlcm46IC9AW1xcdy1dKD86XFwoW14oKV0rXFwpfFteKClcXHNdfFxccysoPyFcXHMpKSo/KD89XFxzK1t7O10pLyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdydWxlJzogL0BbXFx3LV0rLyAvLyBTZWUgcmVzdCBiZWxvd1xuXG4gICAgfVxuICB9LFxuICAvLyB1cmwsIGNvbXBhc3NpZmllZFxuICAndXJsJzogLyg/OlstYS16XSstKT91cmwoPz1cXCgpL2ksXG4gIC8vIENTUyBzZWxlY3RvciByZWdleCBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIFNhc3NcbiAgLy8gc2luY2UgdGhlcmUgY2FuIGJlIGxvdCBtb3JlIHRoaW5ncyAodmFyLCBAIGRpcmVjdGl2ZSwgbmVzdGluZy4uKVxuICAvLyBhIHNlbGVjdG9yIG11c3Qgc3RhcnQgYXQgdGhlIGVuZCBvZiBhIHByb3BlcnR5IG9yIGFmdGVyIGEgYnJhY2UgKGVuZCBvZiBvdGhlciBydWxlcyBvciBuZXN0aW5nKVxuICAvLyBpdCBjYW4gY29udGFpbiBzb21lIGNoYXJhY3RlcnMgdGhhdCBhcmVuJ3QgdXNlZCBmb3IgZGVmaW5pbmcgcnVsZXMgb3IgZW5kIG9mIHNlbGVjdG9yLCAmIChwYXJlbnQgc2VsZWN0b3IpLCBvciBpbnRlcnBvbGF0ZWQgdmFyaWFibGVcbiAgLy8gdGhlIGVuZCBvZiBhIHNlbGVjdG9yIGlzIGZvdW5kIHdoZW4gdGhlcmUgaXMgbm8gcnVsZXMgaW4gaXQgKCB7fSBvciB7XFxzfSkgb3IgaWYgdGhlcmUgaXMgYSBwcm9wZXJ0eSAoYmVjYXVzZSBhbiBpbnRlcnBvbGF0ZWQgdmFyXG4gIC8vIGNhbiBcInBhc3NcIiBhcyBhIHNlbGVjdG9yLSBlLmc6IHByb3BlciN7JGVydHl9KVxuICAvLyB0aGlzIG9uZSB3YXMgaGFyZCB0byBkbywgc28gcGxlYXNlIGJlIGNhcmVmdWwgaWYgeW91IGVkaXQgdGhpcyBvbmUgOilcbiAgJ3NlbGVjdG9yJzoge1xuICAgIC8vIEluaXRpYWwgbG9vay1haGVhZCBpcyB1c2VkIHRvIHByZXZlbnQgbWF0Y2hpbmcgb2YgYmxhbmsgc2VsZWN0b3JzXG4gICAgcGF0dGVybjogLyg/PVxcUylbXkA7e30oKV0/KD86W15AO3t9KClcXHNdfFxccysoPyFcXHMpfCNcXHtcXCRbLVxcd10rXFx9KSsoPz1cXHMqXFx7KD86XFx9fFxcc3xbXn1dW146e31dKls6e11bXn1dKSkvLFxuICAgIGluc2lkZToge1xuICAgICAgJ3BhcmVudCc6IHtcbiAgICAgICAgcGF0dGVybjogLyYvLFxuICAgICAgICBhbGlhczogJ2ltcG9ydGFudCdcbiAgICAgIH0sXG4gICAgICAncGxhY2Vob2xkZXInOiAvJVstXFx3XSsvLFxuICAgICAgJ3ZhcmlhYmxlJzogL1xcJFstXFx3XSt8I1xce1xcJFstXFx3XStcXH0vXG4gICAgfVxuICB9LFxuICAncHJvcGVydHknOiB7XG4gICAgcGF0dGVybjogLyg/OlstXFx3XXxcXCRbLVxcd118I1xce1xcJFstXFx3XStcXH0pKyg/PVxccyo6KS8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAndmFyaWFibGUnOiAvXFwkWy1cXHddK3wjXFx7XFwkWy1cXHddK1xcfS9cbiAgICB9XG4gIH1cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2NzcycsICdhdHJ1bGUnLCB7XG4gICdrZXl3b3JkJzogWy9AKD86Y29udGVudHxkZWJ1Z3xlYWNofGVsc2UoPzogaWYpP3xleHRlbmR8Zm9yfGZvcndhcmR8ZnVuY3Rpb258aWZ8aW1wb3J0fGluY2x1ZGV8bWl4aW58cmV0dXJufHVzZXx3YXJufHdoaWxlKVxcYi9pLCB7XG4gICAgcGF0dGVybjogLyggKSg/OmZyb218dGhyb3VnaCkoPz0gKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XVxufSk7XG5wcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdzY3NzJywgJ2ltcG9ydGFudCcsIHtcbiAgLy8gdmFyIGFuZCBpbnRlcnBvbGF0ZWQgdmFyc1xuICAndmFyaWFibGUnOiAvXFwkWy1cXHddK3wjXFx7XFwkWy1cXHddK1xcfS9cbn0pO1xucHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnc2NzcycsICdmdW5jdGlvbicsIHtcbiAgJ21vZHVsZS1tb2RpZmllcic6IHtcbiAgICBwYXR0ZXJuOiAvXFxiKD86YXN8aGlkZXxzaG93fHdpdGgpXFxiL2ksXG4gICAgYWxpYXM6ICdrZXl3b3JkJ1xuICB9LFxuICAncGxhY2Vob2xkZXInOiB7XG4gICAgcGF0dGVybjogLyVbLVxcd10rLyxcbiAgICBhbGlhczogJ3NlbGVjdG9yJ1xuICB9LFxuICAnc3RhdGVtZW50Jzoge1xuICAgIHBhdHRlcm46IC9cXEIhKD86ZGVmYXVsdHxvcHRpb25hbClcXGIvaSxcbiAgICBhbGlhczogJ2tleXdvcmQnXG4gIH0sXG4gICdib29sZWFuJzogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgJ251bGwnOiB7XG4gICAgcGF0dGVybjogL1xcYm51bGxcXGIvLFxuICAgIGFsaWFzOiAna2V5d29yZCdcbiAgfSxcbiAgJ29wZXJhdG9yJzoge1xuICAgIHBhdHRlcm46IC8oXFxzKSg/OlstKypcXC8lXXxbPSFdPXw8PT98Pj0/fGFuZHxub3R8b3IpKD89XFxzKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9XG59KTtcbnByaXNtLmxhbmd1YWdlcy5zY3NzWydhdHJ1bGUnXS5pbnNpZGUucmVzdCA9IHByaXNtLmxhbmd1YWdlcy5zY3NzO1xuLyogXCJwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tc3R5bHVzXCIgKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuICB2YXIgdW5pdCA9IHtcbiAgICBwYXR0ZXJuOiAvKFxcYlxcZCspKD86JXxbYS16XSspLyxcbiAgICBsb29rYmVoaW5kOiB0cnVlXG4gIH07IC8vIDEyMyAtMTIzIC4xMjMgLS4xMjMgMTIuMyAtMTIuM1xuXG4gIHZhciBudW1iZXIgPSB7XG4gICAgcGF0dGVybjogLyhefFteXFx3Li1dKS0/KD86XFxkKyg/OlxcLlxcZCspP3xcXC5cXGQrKS8sXG4gICAgbG9va2JlaGluZDogdHJ1ZVxuICB9O1xuICB2YXIgaW5zaWRlID0ge1xuICAgICdjb21tZW50Jzoge1xuICAgICAgcGF0dGVybjogLyhefFteXFxcXF0pKD86XFwvXFwqW1xcc1xcU10qP1xcKlxcL3xcXC9cXC8uKikvLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZVxuICAgIH0sXG4gICAgJ3VybCc6IHtcbiAgICAgIHBhdHRlcm46IC9cXGJ1cmxcXCgoW1wiJ10/KS4qP1xcMVxcKS9pLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAnc3RyaW5nJzoge1xuICAgICAgcGF0dGVybjogLyhcInwnKSg/Oig/IVxcMSlbXlxcXFxcXHJcXG5dfFxcXFwoPzpcXHJcXG58W1xcc1xcU10pKSpcXDEvLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAnaW50ZXJwb2xhdGlvbic6IG51bGwsXG4gICAgLy8gU2VlIGJlbG93XG4gICAgJ2Z1bmMnOiBudWxsLFxuICAgIC8vIFNlZSBiZWxvd1xuICAgICdpbXBvcnRhbnQnOiAvXFxCISg/OmltcG9ydGFudHxvcHRpb25hbClcXGIvaSxcbiAgICAna2V5d29yZCc6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxcXHMrKSg/Oig/OmVsc2V8Zm9yfGlmfHJldHVybnx1bmxlc3MpKD89XFxzfCQpfEBbXFx3LV0rKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlXG4gICAgfSxcbiAgICAnaGV4Y29kZSc6IC8jW1xcZGEtZl17Myw2fS9pLFxuICAgICdjb2xvcic6IFsvXFxiKD86QWxpY2VCbHVlfEFudGlxdWVXaGl0ZXxBcXVhfEFxdWFtYXJpbmV8QXp1cmV8QmVpZ2V8QmlzcXVlfEJsYWNrfEJsYW5jaGVkQWxtb25kfEJsdWV8Qmx1ZVZpb2xldHxCcm93bnxCdXJseVdvb2R8Q2FkZXRCbHVlfENoYXJ0cmV1c2V8Q2hvY29sYXRlfENvcmFsfENvcm5mbG93ZXJCbHVlfENvcm5zaWxrfENyaW1zb258Q3lhbnxEYXJrQmx1ZXxEYXJrQ3lhbnxEYXJrR29sZGVuUm9kfERhcmtHclthZV15fERhcmtHcmVlbnxEYXJrS2hha2l8RGFya01hZ2VudGF8RGFya09saXZlR3JlZW58RGFya09yYW5nZXxEYXJrT3JjaGlkfERhcmtSZWR8RGFya1NhbG1vbnxEYXJrU2VhR3JlZW58RGFya1NsYXRlQmx1ZXxEYXJrU2xhdGVHclthZV15fERhcmtUdXJxdW9pc2V8RGFya1Zpb2xldHxEZWVwUGlua3xEZWVwU2t5Qmx1ZXxEaW1HclthZV15fERvZGdlckJsdWV8RmlyZUJyaWNrfEZsb3JhbFdoaXRlfEZvcmVzdEdyZWVufEZ1Y2hzaWF8R2FpbnNib3JvfEdob3N0V2hpdGV8R29sZHxHb2xkZW5Sb2R8R3JbYWVdeXxHcmVlbnxHcmVlblllbGxvd3xIb25leURld3xIb3RQaW5rfEluZGlhblJlZHxJbmRpZ298SXZvcnl8S2hha2l8TGF2ZW5kZXJ8TGF2ZW5kZXJCbHVzaHxMYXduR3JlZW58TGVtb25DaGlmZm9ufExpZ2h0Qmx1ZXxMaWdodENvcmFsfExpZ2h0Q3lhbnxMaWdodEdvbGRlblJvZFllbGxvd3xMaWdodEdyW2FlXXl8TGlnaHRHcmVlbnxMaWdodFBpbmt8TGlnaHRTYWxtb258TGlnaHRTZWFHcmVlbnxMaWdodFNreUJsdWV8TGlnaHRTbGF0ZUdyW2FlXXl8TGlnaHRTdGVlbEJsdWV8TGlnaHRZZWxsb3d8TGltZXxMaW1lR3JlZW58TGluZW58TWFnZW50YXxNYXJvb258TWVkaXVtQXF1YU1hcmluZXxNZWRpdW1CbHVlfE1lZGl1bU9yY2hpZHxNZWRpdW1QdXJwbGV8TWVkaXVtU2VhR3JlZW58TWVkaXVtU2xhdGVCbHVlfE1lZGl1bVNwcmluZ0dyZWVufE1lZGl1bVR1cnF1b2lzZXxNZWRpdW1WaW9sZXRSZWR8TWlkbmlnaHRCbHVlfE1pbnRDcmVhbXxNaXN0eVJvc2V8TW9jY2FzaW58TmF2YWpvV2hpdGV8TmF2eXxPbGRMYWNlfE9saXZlfE9saXZlRHJhYnxPcmFuZ2V8T3JhbmdlUmVkfE9yY2hpZHxQYWxlR29sZGVuUm9kfFBhbGVHcmVlbnxQYWxlVHVycXVvaXNlfFBhbGVWaW9sZXRSZWR8UGFwYXlhV2hpcHxQZWFjaFB1ZmZ8UGVydXxQaW5rfFBsdW18UG93ZGVyQmx1ZXxQdXJwbGV8UmVkfFJvc3lCcm93bnxSb3lhbEJsdWV8U2FkZGxlQnJvd258U2FsbW9ufFNhbmR5QnJvd258U2VhR3JlZW58U2VhU2hlbGx8U2llbm5hfFNpbHZlcnxTa3lCbHVlfFNsYXRlQmx1ZXxTbGF0ZUdyW2FlXXl8U25vd3xTcHJpbmdHcmVlbnxTdGVlbEJsdWV8VGFufFRlYWx8VGhpc3RsZXxUb21hdG98VHJhbnNwYXJlbnR8VHVycXVvaXNlfFZpb2xldHxXaGVhdHxXaGl0ZXxXaGl0ZVNtb2tlfFllbGxvd3xZZWxsb3dHcmVlbilcXGIvaSwge1xuICAgICAgcGF0dGVybjogL1xcYig/OmhzbHxyZ2IpXFwoXFxzKlxcZHsxLDN9XFxzKixcXHMqXFxkezEsM30lP1xccyosXFxzKlxcZHsxLDN9JT9cXHMqXFwpXFxCfFxcYig/OmhzbHxyZ2IpYVxcKFxccypcXGR7MSwzfVxccyosXFxzKlxcZHsxLDN9JT9cXHMqLFxccypcXGR7MSwzfSU/XFxzKixcXHMqKD86MHwwP1xcLlxcZCt8MSlcXHMqXFwpXFxCL2ksXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ3VuaXQnOiB1bml0LFxuICAgICAgICAnbnVtYmVyJzogbnVtYmVyLFxuICAgICAgICAnZnVuY3Rpb24nOiAvW1xcdy1dKyg/PVxcKCkvLFxuICAgICAgICAncHVuY3R1YXRpb24nOiAvWygpLF0vXG4gICAgICB9XG4gICAgfV0sXG4gICAgJ2VudGl0eSc6IC9cXFxcW1xcZGEtZl17MSw4fS9pLFxuICAgICd1bml0JzogdW5pdCxcbiAgICAnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG4gICAgJ29wZXJhdG9yJzogWy8vIFdlIHdhbnQgbm9uLXdvcmQgY2hhcnMgYXJvdW5kIFwiLVwiIGJlY2F1c2UgaXQgaXNcbiAgICAvLyBhY2NlcHRlZCBpbiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAvfnxbKyFcXC8lPD4/PV09P3xbLTpdPXxcXCpbKj1dP3xcXC57MiwzfXwmJnxcXHxcXHx8XFxCLVxcQnxcXGIoPzphbmR8aW58aXMoPzogYXwgZGVmaW5lZHwgbm90fG50KT98bm90fG9yKVxcYi9dLFxuICAgICdudW1iZXInOiBudW1iZXIsXG4gICAgJ3B1bmN0dWF0aW9uJzogL1t7fSgpXFxbXFxdOzosXS9cbiAgfTtcbiAgaW5zaWRlWydpbnRlcnBvbGF0aW9uJ10gPSB7XG4gICAgcGF0dGVybjogL1xce1teXFxyXFxufTpdK1xcfS8sXG4gICAgYWxpYXM6ICd2YXJpYWJsZScsXG4gICAgaW5zaWRlOiB7XG4gICAgICAnZGVsaW1pdGVyJzoge1xuICAgICAgICBwYXR0ZXJuOiAvXlxce3xcXH0kLyxcbiAgICAgICAgYWxpYXM6ICdwdW5jdHVhdGlvbidcbiAgICAgIH0sXG4gICAgICByZXN0OiBpbnNpZGVcbiAgICB9XG4gIH07XG4gIGluc2lkZVsnZnVuYyddID0ge1xuICAgIHBhdHRlcm46IC9bXFx3LV0rXFwoW14pXSpcXCkuKi8sXG4gICAgaW5zaWRlOiB7XG4gICAgICAnZnVuY3Rpb24nOiAvXlteKF0rLyxcbiAgICAgIHJlc3Q6IGluc2lkZVxuICAgIH1cbiAgfTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnN0eWx1cyA9IHtcbiAgICAnYXRydWxlLWRlY2xhcmF0aW9uJzoge1xuICAgICAgcGF0dGVybjogLyheWyBcXHRdKilALisvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2F0cnVsZSc6IC9eQFtcXHctXSsvLFxuICAgICAgICByZXN0OiBpbnNpZGVcbiAgICAgIH1cbiAgICB9LFxuICAgICd2YXJpYWJsZS1kZWNsYXJhdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oXlsgXFx0XSopW1xcdyQtXStcXHMqLj89WyBcXHRdKig/Olxce1tee31dKlxcfXxcXFMuKnwkKS9tLFxuICAgICAgbG9va2JlaGluZDogdHJ1ZSxcbiAgICAgIGluc2lkZToge1xuICAgICAgICAndmFyaWFibGUnOiAvXlxcUysvLFxuICAgICAgICByZXN0OiBpbnNpZGVcbiAgICAgIH1cbiAgICB9LFxuICAgICdzdGF0ZW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF5bIFxcdF0qKSg/OmVsc2V8Zm9yfGlmfHJldHVybnx1bmxlc3MpWyBcXHRdLisvbSxcbiAgICAgIGxvb2tiZWhpbmQ6IHRydWUsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgJ2tleXdvcmQnOiAvXlxcUysvLFxuICAgICAgICByZXN0OiBpbnNpZGVcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIEEgcHJvcGVydHkvdmFsdWUgcGFpciBjYW5ub3QgZW5kIHdpdGggYSBjb21tYSBvciBhIGJyYWNlXG4gICAgLy8gSXQgY2Fubm90IGhhdmUgaW5kZW50ZWQgY29udGVudCB1bmxlc3MgaXQgZW5kZWQgd2l0aCBhIHNlbWljb2xvblxuICAgICdwcm9wZXJ0eS1kZWNsYXJhdGlvbic6IHtcbiAgICAgIHBhdHRlcm46IC8oKD86XnxcXHspKFsgXFx0XSopKSg/OltcXHctXXxcXHtbXn1cXHJcXG5dK1xcfSkrKD86XFxzKjpcXHMqfFsgXFx0XSspKD8hXFxzKVtee1xcclxcbl0qKD86O3xbXntcXHJcXG4sXSQoPyEoPzpcXHI/XFxufFxccikoPzpcXHt8XFwyWyBcXHRdKSkpL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdwcm9wZXJ0eSc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXlteXFxzOl0rLyxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW5zaWRlLmludGVycG9sYXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3Q6IGluc2lkZVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gQSBzZWxlY3RvciBjYW4gY29udGFpbiBwYXJlbnRoZXNlcyBvbmx5IGFzIHBhcnQgb2YgYSBwc2V1ZG8tZWxlbWVudFxuICAgIC8vIEl0IGNhbiBzcGFuIG11bHRpcGxlIGxpbmVzLlxuICAgIC8vIEl0IG11c3QgZW5kIHdpdGggYSBjb21tYSBvciBhbiBhY2NvbGFkZSBvciBoYXZlIGluZGVudGVkIGNvbnRlbnQuXG4gICAgJ3NlbGVjdG9yJzoge1xuICAgICAgcGF0dGVybjogLyheWyBcXHRdKikoPzooPz1cXFMpKD86W157fVxcclxcbjooKV18Ojo/W1xcdy1dKyg/OlxcKFteKVxcclxcbl0qXFwpfCg/IVtcXHctXSkpfFxce1tefVxcclxcbl0rXFx9KSspKD86KD86XFxyP1xcbnxcXHIpKD86XFwxKD86KD89XFxTKSg/Oltee31cXHJcXG46KCldfDo6P1tcXHctXSsoPzpcXChbXilcXHJcXG5dKlxcKXwoPyFbXFx3LV0pKXxcXHtbXn1cXHJcXG5dK1xcfSkrKSkpKig/OiwkfFxce3woPz0oPzpcXHI/XFxufFxccikoPzpcXHt8XFwxWyBcXHRdKSkpL20sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgICdpbnRlcnBvbGF0aW9uJzogaW5zaWRlLmludGVycG9sYXRpb24sXG4gICAgICAgICdjb21tZW50JzogaW5zaWRlLmNvbW1lbnQsXG4gICAgICAgICdwdW5jdHVhdGlvbic6IC9be30sXS9cbiAgICAgIH1cbiAgICB9LFxuICAgICdmdW5jJzogaW5zaWRlLmZ1bmMsXG4gICAgJ3N0cmluZyc6IGluc2lkZS5zdHJpbmcsXG4gICAgJ2NvbW1lbnQnOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSkoPzpcXC9cXCpbXFxzXFxTXSo/XFwqXFwvfFxcL1xcLy4qKS8sXG4gICAgICBsb29rYmVoaW5kOiB0cnVlLFxuICAgICAgZ3JlZWR5OiB0cnVlXG4gICAgfSxcbiAgICAnaW50ZXJwb2xhdGlvbic6IGluc2lkZS5pbnRlcnBvbGF0aW9uLFxuICAgICdwdW5jdHVhdGlvbic6IC9be30oKVxcW1xcXTs6Ll0vXG4gIH07XG59KShwcmlzbSk7XG4vKiBcInByaXNtanMvY29tcG9uZW50cy9wcmlzbS10c3hcIiAqL1xuXG5cbihmdW5jdGlvbiAoUHJpc20pIHtcbiAgdmFyIHR5cGVzY3JpcHQgPSBQcmlzbS51dGlsLmNsb25lKFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0KTtcbiAgUHJpc20ubGFuZ3VhZ2VzLnRzeCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2pzeCcsIHR5cGVzY3JpcHQpOyAvLyBkb2Vzbid0IHdvcmsgd2l0aCBUUyBiZWNhdXNlIFRTIGlzIHRvbyBjb21wbGV4XG5cbiAgZGVsZXRlIFByaXNtLmxhbmd1YWdlcy50c3hbJ3BhcmFtZXRlciddO1xuICBkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnRzeFsnbGl0ZXJhbC1wcm9wZXJ0eSddOyAvLyBUaGlzIHdpbGwgcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gVFNYIHRhZ3MgYW5kIFRTIGdlbmVyaWMgdHlwZXMuXG4gIC8vIElkZWEgYnkgaHR0cHM6Ly9naXRodWIuY29tL2thcmxob3JreVxuICAvLyBEaXNjdXNzaW9uOiBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9pc3N1ZXMvMjU5NCNpc3N1ZWNvbW1lbnQtNzEwNjY2OTI4XG5cbiAgdmFyIHRhZyA9IFByaXNtLmxhbmd1YWdlcy50c3gudGFnO1xuICB0YWcucGF0dGVybiA9IFJlZ0V4cCgvKF58W15cXHckXXwoPz08XFwvKSkvLnNvdXJjZSArICcoPzonICsgdGFnLnBhdHRlcm4uc291cmNlICsgJyknLCB0YWcucGF0dGVybi5mbGFncyk7XG4gIHRhZy5sb29rYmVoaW5kID0gdHJ1ZTtcbn0pKHByaXNtKTtcbi8qIFwicHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXdhc21cIiAqL1xuXG5cbnByaXNtLmxhbmd1YWdlcy53YXNtID0ge1xuICAnY29tbWVudCc6IFsvXFwoO1tcXHNcXFNdKj87XFwpLywge1xuICAgIHBhdHRlcm46IC87Oy4qLyxcbiAgICBncmVlZHk6IHRydWVcbiAgfV0sXG4gICdzdHJpbmcnOiB7XG4gICAgcGF0dGVybjogL1wiKD86XFxcXFtcXHNcXFNdfFteXCJcXFxcXSkqXCIvLFxuICAgIGdyZWVkeTogdHJ1ZVxuICB9LFxuICAna2V5d29yZCc6IFt7XG4gICAgcGF0dGVybjogL1xcYig/OmFsaWdufG9mZnNldCk9LyxcbiAgICBpbnNpZGU6IHtcbiAgICAgICdvcGVyYXRvcic6IC89L1xuICAgIH1cbiAgfSwge1xuICAgIHBhdHRlcm46IC9cXGIoPzooPzpmMzJ8ZjY0fGkzMnxpNjQpKD86XFwuKD86YWJzfGFkZHxhbmR8Y2VpbHxjbHp8Y29uc3R8Y29udmVydF9bc3VdXFwvaSg/OjMyfDY0KXxjb3B5c2lnbnxjdHp8ZGVtb3RlXFwvZjY0fGRpdig/Ol9bc3VdKT98ZXF6P3xleHRlbmRfW3N1XVxcL2kzMnxmbG9vcnxnZSg/Ol9bc3VdKT98Z3QoPzpfW3N1XSk/fGxlKD86X1tzdV0pP3xsb2FkKD86KD86OHwxNnwzMilfW3N1XSk/fGx0KD86X1tzdV0pP3xtYXh8bWlufG11bHxuZWc/fG5lYXJlc3R8b3J8cG9wY250fHByb21vdGVcXC9mMzJ8cmVpbnRlcnByZXRcXC9bZmldKD86MzJ8NjQpfHJlbV9bc3VdfHJvdFtscl18c2hsfHNocl9bc3VdfHNxcnR8c3RvcmUoPzo4fDE2fDMyKT98c3VifHRydW5jKD86X1tzdV1cXC9mKD86MzJ8NjQpKT98d3JhcFxcL2k2NHx4b3IpKT98bWVtb3J5XFwuKD86Z3Jvd3xzaXplKSlcXGIvLFxuICAgIGluc2lkZToge1xuICAgICAgJ3B1bmN0dWF0aW9uJzogL1xcLi9cbiAgICB9XG4gIH0sIC9cXGIoPzphbnlmdW5jfGJsb2NrfGJyKD86X2lmfF90YWJsZSk/fGNhbGwoPzpfaW5kaXJlY3QpP3xkYXRhfGRyb3B8ZWxlbXxlbHNlfGVuZHxleHBvcnR8ZnVuY3xnZXRfKD86Z2xvYmFsfGxvY2FsKXxnbG9iYWx8aWZ8aW1wb3J0fGxvY2FsfGxvb3B8bWVtb3J5fG1vZHVsZXxtdXR8bm9wfG9mZnNldHxwYXJhbXxyZXN1bHR8cmV0dXJufHNlbGVjdHxzZXRfKD86Z2xvYmFsfGxvY2FsKXxzdGFydHx0YWJsZXx0ZWVfbG9jYWx8dGhlbnx0eXBlfHVucmVhY2hhYmxlKVxcYi9dLFxuICAndmFyaWFibGUnOiAvXFwkW1xcdyEjJCUmJyorXFwtLi86PD0+P0BcXFxcXmB8fl0rLyxcbiAgJ251bWJlcic6IC9bKy1dP1xcYig/OlxcZCg/Ol8/XFxkKSooPzpcXC5cXGQoPzpfP1xcZCkqKT8oPzpbZUVdWystXT9cXGQoPzpfP1xcZCkqKT98MHhbXFxkYS1mQS1GXSg/Ol8/W1xcZGEtZkEtRl0pKig/OlxcLltcXGRhLWZBLUZdKD86Xz9bXFxkYS1mQS1EXSkqKT8oPzpbcFBdWystXT9cXGQoPzpfP1xcZCkqKT8pXFxifFxcYmluZlxcYnxcXGJuYW4oPzo6MHhbXFxkYS1mQS1GXSg/Ol8/W1xcZGEtZkEtRF0pKik/XFxiLyxcbiAgJ3B1bmN0dWF0aW9uJzogL1soKV0vXG59O1xuXG5leHBvcnQgZGVmYXVsdCBwcmlzbTtcbiIsIi8vIER1b3RvbmUgRGFya1xuLy8gQXV0aG9yOiBTaW11cmFpLCBhZGFwdGVkIGZyb20gRHVvVG9uZSB0aGVtZXMgZm9yIEF0b20gKGh0dHA6Ly9zaW11cmFpLmNvbS9wcm9qZWN0cy8yMDE2LzAxLzAxL2R1b3RvbmUtdGhlbWVzKVxuLy8gQ29udmVyc2lvbjogQnJhbSBkZSBIYWFuIChodHRwOi8vYXRlbGllcmJyYW0uZ2l0aHViLmlvL0Jhc2UyVG9uZS1wcmlzbS9vdXRwdXQvcHJpc20vcHJpc20tYmFzZTJ0b25lLWV2ZW5pbmctZGFyay5jc3MpXG4vLyBHZW5lcmF0ZWQgd2l0aCBCYXNlMTYgQnVpbGRlciAoaHR0cHM6Ly9naXRodWIuY29tL2Jhc2UxNi1idWlsZGVyL2Jhc2UxNi1idWlsZGVyKVxudmFyIHRoZW1lID0ge1xuICBwbGFpbjoge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjMmEyNzM0XCIsXG4gICAgY29sb3I6IFwiIzlhODZmZFwiXG4gIH0sXG4gIHN0eWxlczogW3tcbiAgICB0eXBlczogW1wiY29tbWVudFwiLCBcInByb2xvZ1wiLCBcImRvY3R5cGVcIiwgXCJjZGF0YVwiLCBcInB1bmN0dWF0aW9uXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjNmM2NzgzXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wibmFtZXNwYWNlXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBvcGFjaXR5OiAwLjdcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1widGFnXCIsIFwib3BlcmF0b3JcIiwgXCJudW1iZXJcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcIiNlMDkxNDJcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJwcm9wZXJ0eVwiLCBcImZ1bmN0aW9uXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjOWE4NmZkXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1widGFnLWlkXCIsIFwic2VsZWN0b3JcIiwgXCJhdHJ1bGUtaWRcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcIiNlZWViZmZcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJhdHRyLW5hbWVcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcIiNjNGI5ZmVcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJib29sZWFuXCIsIFwic3RyaW5nXCIsIFwiZW50aXR5XCIsIFwidXJsXCIsIFwiYXR0ci12YWx1ZVwiLCBcImtleXdvcmRcIiwgXCJjb250cm9sXCIsIFwiZGlyZWN0aXZlXCIsIFwidW5pdFwiLCBcInN0YXRlbWVudFwiLCBcInJlZ2V4XCIsIFwiYXRydWxlXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJ2YXJpYWJsZVwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiI2ZmY2M5OVwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcImRlbGV0ZWRcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHRleHREZWNvcmF0aW9uTGluZTogXCJsaW5lLXRocm91Z2hcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJpbnNlcnRlZFwiXSxcbiAgICBzdHlsZToge1xuICAgICAgdGV4dERlY29yYXRpb25MaW5lOiBcInVuZGVybGluZVwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcIml0YWxpY1wiXSxcbiAgICBzdHlsZToge1xuICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcImltcG9ydGFudFwiLCBcImJvbGRcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcImltcG9ydGFudFwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiI2M0YjlmZVwiXG4gICAgfVxuICB9XVxufTtcblxuZXhwb3J0IGRlZmF1bHQgdGhlbWU7XG4iLCJpbXBvcnQgcHJpc20gZnJvbSAnLi4vcHJpc20vaW5kZXguanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQcmlzbSB9IGZyb20gJy4uL3ByaXNtL2luZGV4LmpzJztcbmltcG9ydCB0aGVtZSBmcm9tICcuLi90aGVtZXMvZHVvdG9uZURhcmsnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuXG52YXIgZGVmYXVsdFByb3BzID0ge1xuICAvLyAkRmxvd0ZpeE1lXG4gIFByaXNtOiBwcmlzbSxcbiAgdGhlbWU6IHRoZW1lXG59O1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIG5ld2xpbmVSZSA9IC9cXHJcXG58XFxyfFxcbi87IC8vIEVtcHR5IGxpbmVzIG5lZWQgdG8gY29udGFpbiBhIHNpbmdsZSBlbXB0eSB0b2tlbiwgZGVub3RlZCB3aXRoIHsgZW1wdHk6IHRydWUgfVxuXG52YXIgbm9ybWFsaXplRW1wdHlMaW5lcyA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gIGlmIChsaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgIGxpbmUucHVzaCh7XG4gICAgICB0eXBlczogW1wicGxhaW5cIl0sXG4gICAgICBjb250ZW50OiBcIlxcblwiLFxuICAgICAgZW1wdHk6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChsaW5lLmxlbmd0aCA9PT0gMSAmJiBsaW5lWzBdLmNvbnRlbnQgPT09IFwiXCIpIHtcbiAgICBsaW5lWzBdLmNvbnRlbnQgPSBcIlxcblwiO1xuICAgIGxpbmVbMF0uZW1wdHkgPSB0cnVlO1xuICB9XG59O1xuXG52YXIgYXBwZW5kVHlwZXMgPSBmdW5jdGlvbiAodHlwZXMsIGFkZCkge1xuICB2YXIgdHlwZXNTaXplID0gdHlwZXMubGVuZ3RoO1xuXG4gIGlmICh0eXBlc1NpemUgPiAwICYmIHR5cGVzW3R5cGVzU2l6ZSAtIDFdID09PSBhZGQpIHtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH1cblxuICByZXR1cm4gdHlwZXMuY29uY2F0KGFkZCk7XG59OyAvLyBUYWtlcyBhbiBhcnJheSBvZiBQcmlzbSdzIHRva2VucyBhbmQgZ3JvdXBzIHRoZW0gYnkgbGluZSwgdHVybmluZyBwbGFpblxuLy8gc3RyaW5ncyBpbnRvIHRva2VucyBhcyB3ZWxsLiBUb2tlbnMgY2FuIGJlY29tZSByZWN1cnNpdmUgaW4gc29tZSBjYXNlcyxcbi8vIHdoaWNoIG1lYW5zIHRoYXQgdGhlaXIgdHlwZXMgYXJlIGNvbmNhdGVuYXRlZC4gUGxhaW4tc3RyaW5nIHRva2VucyBob3dldmVyXG4vLyBhcmUgYWx3YXlzIG9mIHR5cGUgXCJwbGFpblwiLlxuLy8gVGhpcyBpcyBub3QgcmVjdXJzaXZlIHRvIGF2b2lkIGV4Y2VlZGluZyB0aGUgY2FsbC1zdGFjayBsaW1pdCwgc2luY2UgaXQncyB1bmNsZWFyXG4vLyBob3cgbmVzdGVkIFByaXNtJ3MgdG9rZW5zIGNhbiBiZWNvbWVcblxuXG52YXIgbm9ybWFsaXplVG9rZW5zID0gZnVuY3Rpb24gKHRva2Vucykge1xuICB2YXIgdHlwZUFyclN0YWNrID0gW1tdXTtcbiAgdmFyIHRva2VuQXJyU3RhY2sgPSBbdG9rZW5zXTtcbiAgdmFyIHRva2VuQXJySW5kZXhTdGFjayA9IFswXTtcbiAgdmFyIHRva2VuQXJyU2l6ZVN0YWNrID0gW3Rva2Vucy5sZW5ndGhdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzdGFja0luZGV4ID0gMDtcbiAgdmFyIGN1cnJlbnRMaW5lID0gW107XG4gIHZhciBhY2MgPSBbY3VycmVudExpbmVdO1xuXG4gIHdoaWxlIChzdGFja0luZGV4ID4gLTEpIHtcbiAgICB3aGlsZSAoKGkgPSB0b2tlbkFyckluZGV4U3RhY2tbc3RhY2tJbmRleF0rKykgPCB0b2tlbkFyclNpemVTdGFja1tzdGFja0luZGV4XSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSB2b2lkIDA7XG4gICAgICB2YXIgdHlwZXMgPSB0eXBlQXJyU3RhY2tbc3RhY2tJbmRleF07XG4gICAgICB2YXIgdG9rZW5BcnIgPSB0b2tlbkFyclN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5BcnJbaV07IC8vIERldGVybWluZSBjb250ZW50IGFuZCBhcHBlbmQgdHlwZSB0byB0eXBlcyBpZiBuZWNlc3NhcnlcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0eXBlcyA9IHN0YWNrSW5kZXggPiAwID8gdHlwZXMgOiBbXCJwbGFpblwiXTtcbiAgICAgICAgY29udGVudCA9IHRva2VuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZXMgPSBhcHBlbmRUeXBlcyh0eXBlcywgdG9rZW4udHlwZSk7XG5cbiAgICAgICAgaWYgKHRva2VuLmFsaWFzKSB7XG4gICAgICAgICAgdHlwZXMgPSBhcHBlbmRUeXBlcyh0eXBlcywgdG9rZW4uYWxpYXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGVudCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICB9IC8vIElmIHRva2VuLmNvbnRlbnQgaXMgYW4gYXJyYXksIGluY3JlYXNlIHRoZSBzdGFjayBkZXB0aCBhbmQgcmVwZWF0IHRoaXMgd2hpbGUtbG9vcFxuXG5cbiAgICAgIGlmICh0eXBlb2YgY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBzdGFja0luZGV4Kys7XG4gICAgICAgIHR5cGVBcnJTdGFjay5wdXNoKHR5cGVzKTtcbiAgICAgICAgdG9rZW5BcnJTdGFjay5wdXNoKGNvbnRlbnQpO1xuICAgICAgICB0b2tlbkFyckluZGV4U3RhY2sucHVzaCgwKTtcbiAgICAgICAgdG9rZW5BcnJTaXplU3RhY2sucHVzaChjb250ZW50Lmxlbmd0aCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBTcGxpdCBieSBuZXdsaW5lc1xuXG5cbiAgICAgIHZhciBzcGxpdEJ5TmV3bGluZXMgPSBjb250ZW50LnNwbGl0KG5ld2xpbmVSZSk7XG4gICAgICB2YXIgbmV3bGluZUNvdW50ID0gc3BsaXRCeU5ld2xpbmVzLmxlbmd0aDtcbiAgICAgIGN1cnJlbnRMaW5lLnB1c2goe1xuICAgICAgICB0eXBlczogdHlwZXMsXG4gICAgICAgIGNvbnRlbnQ6IHNwbGl0QnlOZXdsaW5lc1swXVxuICAgICAgfSk7IC8vIENyZWF0ZSBhIG5ldyBsaW5lIGZvciBlYWNoIHN0cmluZyBvbiBhIG5ldyBsaW5lXG5cbiAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IG5ld2xpbmVDb3VudDsgaSQxKyspIHtcbiAgICAgICAgbm9ybWFsaXplRW1wdHlMaW5lcyhjdXJyZW50TGluZSk7XG4gICAgICAgIGFjYy5wdXNoKGN1cnJlbnRMaW5lID0gW10pO1xuICAgICAgICBjdXJyZW50TGluZS5wdXNoKHtcbiAgICAgICAgICB0eXBlczogdHlwZXMsXG4gICAgICAgICAgY29udGVudDogc3BsaXRCeU5ld2xpbmVzW2kkMV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBEZWNyZWF0ZSB0aGUgc3RhY2sgZGVwdGhcblxuXG4gICAgc3RhY2tJbmRleC0tO1xuICAgIHR5cGVBcnJTdGFjay5wb3AoKTtcbiAgICB0b2tlbkFyclN0YWNrLnBvcCgpO1xuICAgIHRva2VuQXJySW5kZXhTdGFjay5wb3AoKTtcbiAgICB0b2tlbkFyclNpemVTdGFjay5wb3AoKTtcbiAgfVxuXG4gIG5vcm1hbGl6ZUVtcHR5TGluZXMoY3VycmVudExpbmUpO1xuICByZXR1cm4gYWNjO1xufTtcblxudmFyIHRoZW1lVG9EaWN0ID0gZnVuY3Rpb24gKHRoZW1lLCBsYW5ndWFnZSkge1xuICB2YXIgcGxhaW4gPSB0aGVtZS5wbGFpbjsgLy8gJEZsb3dGaXhNZVxuXG4gIHZhciBiYXNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHRoZW1lRGljdCA9IHRoZW1lLnN0eWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdGhlbWVFbnRyeSkge1xuICAgIHZhciBsYW5ndWFnZXMgPSB0aGVtZUVudHJ5Lmxhbmd1YWdlcztcbiAgICB2YXIgc3R5bGUgPSB0aGVtZUVudHJ5LnN0eWxlO1xuXG4gICAgaWYgKGxhbmd1YWdlcyAmJiAhbGFuZ3VhZ2VzLmluY2x1ZGVzKGxhbmd1YWdlKSkge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICB0aGVtZUVudHJ5LnR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHZhciBhY2NTdHlsZSA9IF9leHRlbmRzKHt9LCBhY2NbdHlwZV0sIHN0eWxlKTtcblxuICAgICAgYWNjW3R5cGVdID0gYWNjU3R5bGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwgYmFzZSk7IC8vICRGbG93Rml4TWVcblxuICB0aGVtZURpY3Qucm9vdCA9IHBsYWluOyAvLyAkRmxvd0ZpeE1lXG5cbiAgdGhlbWVEaWN0LnBsYWluID0gX2V4dGVuZHMoe30sIHBsYWluLCB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBudWxsXG4gIH0pO1xuICByZXR1cm4gdGhlbWVEaWN0O1xufTtcblxuZnVuY3Rpb24gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBleGNsdWRlKSB7XG4gIHZhciB0YXJnZXQgPSB7fTtcblxuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHRhcmdldFtrXSA9IG9ialtrXTtcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgSGlnaGxpZ2h0ID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChDb21wb25lbnQpIHtcbiAgZnVuY3Rpb24gSGlnaGxpZ2h0KCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuLS0pIGFyZ3NbbGVuXSA9IGFyZ3VtZW50c1tsZW5dO1xuXG4gICAgQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0VGhlbWVEaWN0XCIsIGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgaWYgKHRoaXMkMS50aGVtZURpY3QgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy50aGVtZSA9PT0gdGhpcyQxLnByZXZUaGVtZSAmJiBwcm9wcy5sYW5ndWFnZSA9PT0gdGhpcyQxLnByZXZMYW5ndWFnZSkge1xuICAgICAgICByZXR1cm4gdGhpcyQxLnRoZW1lRGljdDtcbiAgICAgIH1cblxuICAgICAgdGhpcyQxLnByZXZUaGVtZSA9IHByb3BzLnRoZW1lO1xuICAgICAgdGhpcyQxLnByZXZMYW5ndWFnZSA9IHByb3BzLmxhbmd1YWdlO1xuICAgICAgdmFyIHRoZW1lRGljdCA9IHByb3BzLnRoZW1lID8gdGhlbWVUb0RpY3QocHJvcHMudGhlbWUsIHByb3BzLmxhbmd1YWdlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzJDEudGhlbWVEaWN0ID0gdGhlbWVEaWN0O1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0TGluZVByb3BzXCIsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBrZXkgPSByZWYua2V5O1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IHJlZi5jbGFzc05hbWU7XG4gICAgICB2YXIgc3R5bGUgPSByZWYuc3R5bGU7XG4gICAgICB2YXIgcmVzdCQxID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmVmLCBbXCJrZXlcIiwgXCJjbGFzc05hbWVcIiwgXCJzdHlsZVwiLCBcImxpbmVcIl0pO1xuICAgICAgdmFyIHJlc3QgPSByZXN0JDE7XG5cbiAgICAgIHZhciBvdXRwdXQgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgICBjbGFzc05hbWU6IFwidG9rZW4tbGluZVwiLFxuICAgICAgICBzdHlsZTogdW5kZWZpbmVkLFxuICAgICAgICBrZXk6IHVuZGVmaW5lZFxuICAgICAgfSk7XG5cbiAgICAgIHZhciB0aGVtZURpY3QgPSB0aGlzJDEuZ2V0VGhlbWVEaWN0KHRoaXMkMS5wcm9wcyk7XG5cbiAgICAgIGlmICh0aGVtZURpY3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQuc3R5bGUgPSB0aGVtZURpY3QucGxhaW47XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5zdHlsZSA9IG91dHB1dC5zdHlsZSAhPT0gdW5kZWZpbmVkID8gX2V4dGVuZHMoe30sIG91dHB1dC5zdHlsZSwgc3R5bGUpIDogc3R5bGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQua2V5ID0ga2V5O1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIG91dHB1dC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRTdHlsZUZvclRva2VuXCIsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciB0eXBlcyA9IHJlZi50eXBlcztcbiAgICAgIHZhciBlbXB0eSA9IHJlZi5lbXB0eTtcbiAgICAgIHZhciB0eXBlc1NpemUgPSB0eXBlcy5sZW5ndGg7XG4gICAgICB2YXIgdGhlbWVEaWN0ID0gdGhpcyQxLmdldFRoZW1lRGljdCh0aGlzJDEucHJvcHMpO1xuXG4gICAgICBpZiAodGhlbWVEaWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZXNTaXplID09PSAxICYmIHR5cGVzWzBdID09PSBcInBsYWluXCIpIHtcbiAgICAgICAgcmV0dXJuIGVtcHR5ID8ge1xuICAgICAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCJcbiAgICAgICAgfSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZXNTaXplID09PSAxICYmICFlbXB0eSkge1xuICAgICAgICByZXR1cm4gdGhlbWVEaWN0W3R5cGVzWzBdXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJhc2VTdHlsZSA9IGVtcHR5ID8ge1xuICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiXG4gICAgICB9IDoge307IC8vICRGbG93Rml4TWVcblxuICAgICAgdmFyIHR5cGVTdHlsZXMgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoZW1lRGljdFt0eXBlXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbYmFzZVN0eWxlXS5jb25jYXQodHlwZVN0eWxlcykpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0VG9rZW5Qcm9wc1wiLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSByZWYuY2xhc3NOYW1lO1xuICAgICAgdmFyIHN0eWxlID0gcmVmLnN0eWxlO1xuICAgICAgdmFyIHRva2VuID0gcmVmLnRva2VuO1xuICAgICAgdmFyIHJlc3QkMSA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJlZiwgW1wia2V5XCIsIFwiY2xhc3NOYW1lXCIsIFwic3R5bGVcIiwgXCJ0b2tlblwiXSk7XG4gICAgICB2YXIgcmVzdCA9IHJlc3QkMTtcblxuICAgICAgdmFyIG91dHB1dCA9IF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJ0b2tlbiBcIiArIHRva2VuLnR5cGVzLmpvaW4oXCIgXCIpLFxuICAgICAgICBjaGlsZHJlbjogdG9rZW4uY29udGVudCxcbiAgICAgICAgc3R5bGU6IHRoaXMkMS5nZXRTdHlsZUZvclRva2VuKHRva2VuKSxcbiAgICAgICAga2V5OiB1bmRlZmluZWRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQuc3R5bGUgPSBvdXRwdXQuc3R5bGUgIT09IHVuZGVmaW5lZCA/IF9leHRlbmRzKHt9LCBvdXRwdXQuc3R5bGUsIHN0eWxlKSA6IHN0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0LmtleSA9IGtleTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBvdXRwdXQuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidG9rZW5pemVcIiwgZnVuY3Rpb24gKFByaXNtLCBjb2RlLCBncmFtbWFyLCBsYW5ndWFnZSkge1xuICAgICAgdmFyIGVudiA9IHtcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgZ3JhbW1hcjogZ3JhbW1hcixcbiAgICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlLFxuICAgICAgICB0b2tlbnM6IFtdXG4gICAgICB9O1xuICAgICAgUHJpc20uaG9va3MucnVuKFwiYmVmb3JlLXRva2VuaXplXCIsIGVudik7XG4gICAgICB2YXIgdG9rZW5zID0gZW52LnRva2VucyA9IFByaXNtLnRva2VuaXplKGVudi5jb2RlLCBlbnYuZ3JhbW1hciwgZW52Lmxhbmd1YWdlKTtcbiAgICAgIFByaXNtLmhvb2tzLnJ1bihcImFmdGVyLXRva2VuaXplXCIsIGVudik7XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKENvbXBvbmVudCkgSGlnaGxpZ2h0Ll9fcHJvdG9fXyA9IENvbXBvbmVudDtcbiAgSGlnaGxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ29tcG9uZW50ICYmIENvbXBvbmVudC5wcm90b3R5cGUpO1xuICBIaWdobGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGlnaGxpZ2h0O1xuXG4gIEhpZ2hsaWdodC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciByZWYgPSB0aGlzLnByb3BzO1xuICAgIHZhciBQcmlzbSA9IHJlZi5QcmlzbTtcbiAgICB2YXIgbGFuZ3VhZ2UgPSByZWYubGFuZ3VhZ2U7XG4gICAgdmFyIGNvZGUgPSByZWYuY29kZTtcbiAgICB2YXIgY2hpbGRyZW4gPSByZWYuY2hpbGRyZW47XG4gICAgdmFyIHRoZW1lRGljdCA9IHRoaXMuZ2V0VGhlbWVEaWN0KHRoaXMucHJvcHMpO1xuICAgIHZhciBncmFtbWFyID0gUHJpc20ubGFuZ3VhZ2VzW2xhbmd1YWdlXTtcbiAgICB2YXIgbWl4ZWRUb2tlbnMgPSBncmFtbWFyICE9PSB1bmRlZmluZWQgPyB0aGlzLnRva2VuaXplKFByaXNtLCBjb2RlLCBncmFtbWFyLCBsYW5ndWFnZSkgOiBbY29kZV07XG4gICAgdmFyIHRva2VucyA9IG5vcm1hbGl6ZVRva2VucyhtaXhlZFRva2Vucyk7XG4gICAgcmV0dXJuIGNoaWxkcmVuKHtcbiAgICAgIHRva2VuczogdG9rZW5zLFxuICAgICAgY2xhc3NOYW1lOiBcInByaXNtLWNvZGUgbGFuZ3VhZ2UtXCIgKyBsYW5ndWFnZSxcbiAgICAgIHN0eWxlOiB0aGVtZURpY3QgIT09IHVuZGVmaW5lZCA/IHRoZW1lRGljdC5yb290IDoge30sXG4gICAgICBnZXRMaW5lUHJvcHM6IHRoaXMuZ2V0TGluZVByb3BzLFxuICAgICAgZ2V0VG9rZW5Qcm9wczogdGhpcy5nZXRUb2tlblByb3BzXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEhpZ2hsaWdodDtcbn0oQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgSGlnaGxpZ2h0O1xuZXhwb3J0IHsgZGVmYXVsdFByb3BzIH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3Mpw\n")},AqCL:function(module,exports){eval("module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanM/MDJhMCJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIl0sIm1hcHBpbmdzIjoiQUFBQUEsTUFBTSxDQUFDQyxPQUFQLEdBQWlCQyxLQUFLLENBQUNDLE9BQU4sSUFBaUIsVUFBVUMsR0FBVixFQUFlO0VBQy9DLE9BQU9DLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCSixHQUEvQixLQUF1QyxnQkFBOUM7QUFDRCxDQUZEIiwiZmlsZSI6IkFxQ0wuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///AqCL\n")},MgzW:function(module,exports,__webpack_require__){"use strict";eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n/* eslint-disable no-unused-vars */\n\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n  if (val === null || val === undefined) {\n    throw new TypeError('Object.assign cannot be called with null or undefined');\n  }\n\n  return Object(val);\n}\n\nfunction shouldUseNative() {\n  try {\n    if (!Object.assign) {\n      return false;\n    } // Detect buggy property enumeration order in older V8 versions.\n    // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\n\n    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers\n\n    test1[5] = 'de';\n\n    if (Object.getOwnPropertyNames(test1)[0] === '5') {\n      return false;\n    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n    var test2 = {};\n\n    for (var i = 0; i < 10; i++) {\n      test2['_' + String.fromCharCode(i)] = i;\n    }\n\n    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n      return test2[n];\n    });\n\n    if (order2.join('') !== '0123456789') {\n      return false;\n    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\n\n    var test3 = {};\n    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n      test3[letter] = letter;\n    });\n\n    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n      return false;\n    }\n\n    return true;\n  } catch (err) {\n    // We don't expect any of the above to throw, but better to be safe.\n    return false;\n  }\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n  var from;\n  var to = toObject(target);\n  var symbols;\n\n  for (var s = 1; s < arguments.length; s++) {\n    from = Object(arguments[s]);\n\n    for (var key in from) {\n      if (hasOwnProperty.call(from, key)) {\n        to[key] = from[key];\n      }\n    }\n\n    if (getOwnPropertySymbols) {\n      symbols = getOwnPropertySymbols(from);\n\n      for (var i = 0; i < symbols.length; i++) {\n        if (propIsEnumerable.call(from, symbols[i])) {\n          to[symbols[i]] = from[symbols[i]];\n        }\n      }\n    }\n  }\n\n  return to;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcz8zMjBjIl0sIm5hbWVzIjpbImdldE93blByb3BlcnR5U3ltYm9scyIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwicHJvdG90eXBlIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJ2YWwiLCJ1bmRlZmluZWQiLCJUeXBlRXJyb3IiLCJzaG91bGRVc2VOYXRpdmUiLCJhc3NpZ24iLCJ0ZXN0MSIsIlN0cmluZyIsImdldE93blByb3BlcnR5TmFtZXMiLCJ0ZXN0MiIsImkiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJtYXAiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJmb3JFYWNoIiwibGV0dGVyIiwia2V5cyIsImVyciIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0YXJnZXQiLCJzb3VyY2UiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImtleSIsImNhbGwiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFYTtBQUNiOztBQUNBLElBQUlBLHFCQUFxQixHQUFHQyxNQUFNLENBQUNELHFCQUFuQztBQUNBLElBQUlFLGNBQWMsR0FBR0QsTUFBTSxDQUFDRSxTQUFQLENBQWlCRCxjQUF0QztBQUNBLElBQUlFLGdCQUFnQixHQUFHSCxNQUFNLENBQUNFLFNBQVAsQ0FBaUJFLG9CQUF4Qzs7QUFFQSxTQUFTQyxRQUFULENBQWtCQyxHQUFsQixFQUF1QjtFQUN0QixJQUFJQSxHQUFHLEtBQUssSUFBUixJQUFnQkEsR0FBRyxLQUFLQyxTQUE1QixFQUF1QztJQUN0QyxNQUFNLElBQUlDLFNBQUosQ0FBYyx1REFBZCxDQUFOO0VBQ0E7O0VBRUQsT0FBT1IsTUFBTSxDQUFDTSxHQUFELENBQWI7QUFDQTs7QUFFRCxTQUFTRyxlQUFULEdBQTJCO0VBQzFCLElB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QUE2QztVQUM1Q2lCLEVBQUUsQ0FBQ0MsT0FBTyxDQUFDbEIsQ0FBRCxDQUFSLENBQUYsR0FBaUJnQixJQUFJLENBQUNFLE9BQU8sQ0FBQ2xCLENBQUQsQ0FBUixDQUFyQjtRQUNBO01BQ0Q7SUFDRDtFQUNEOztFQUVELE9BQU9pQixFQUFQO0FBQ0EsQ0F6QkQiLCJmaWxlIjoiTWd6Vy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///MgzW\n")},Q2Ig:function(module,exports,__webpack_require__){eval("exports.nextTick = function nextTick(fn) {\n  var args = Array.prototype.slice.call(arguments);\n  args.shift();\n  setTimeout(function () {\n    fn.apply(null, args);\n  }, 0);\n};\n\nexports.platform = exports.arch = exports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n  throw new Error('No such module. (Possibly not yet loaded)');\n};\n\n(function () {\n  var cwd = '/';\n  var path;\n\n  exports.cwd = function () {\n    return cwd;\n  };\n\n  exports.chdir = function (dir) {\n    if (!path) path = __webpack_require__(\"33yf\");\n    cwd = path.resolve(dir, cwd);\n  };\n})();\n\nexports.exit = exports.kill = exports.umask = exports.dlopen = exports.uptime = exports.memoryUsage = exports.uvCounters = function () {};\n\nexports.features = {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbW9jay9wcm9jZXNzLmpzPzQzNjIiXSwibmFtZXMiOlsiZXhwb3J0cyIsIm5leHRUaWNrIiwiZm4iLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJzaGlmdCIsInNldFRpbWVvdXQiLCJhcHBseSIsInBsYXRmb3JtIiwiYXJjaCIsImV4ZWNQYXRoIiwidGl0bGUiLCJwaWQiLCJicm93c2VyIiwiZW52IiwiYXJndiIsImJpbmRpbmciLCJuYW1lIiwiRXJyb3IiLCJjd2QiLCJwYXRoIiwiY2hkaXIiLCJkaXIiLCJyZXF1aXJlIiwicmVzb2x2ZSIsImV4aXQiLCJraWxsIiwidW1hc2siLCJkbG9wZW4iLCJ1cHRpbWUiLCJtZW1vcnlVc2FnZSIsInV2Q291bnRlcnMiLCJmZWF0dXJlcyJdLCJtYXBwaW5ncyI6IkFBQUFBLE9BQU8sQ0FBQ0MsUUFBUixHQUFtQixTQUFTQSxRQUFULENBQWtCQyxFQUFsQixFQUFzQjtFQUNyQyxJQUFJQyxJQUFJLEdBQUdDLEtBQUssQ0FBQ0MsU0FBTixDQUFnQkMsS0FBaEIsQ0FBc0JDLElBQXRCLENBQTJCQyxTQUEzQixDQUFYO0VBQ0FMLElBQUksQ0FBQ00sS0FBTDtFQUNBQyxVQUFVLENBQUMsWUFBWTtJQUNuQlIsRUFBRSxDQUFDUyxLQUFILENBQVMsSUFBVCxFQUFlUixJQUFmO0VBQ0gsQ0FGUyxFQUVQLENBRk8sQ0FBVjtBQUdILENBTkQ7O0FBUUFILE9BQU8sQ0FBQ1ksUUFBUixHQUFtQlosT0FBTyxDQUFDYSxJQUFSLEdBQ25CYixPQUFPLENBQUNjLFFBQVIsR0FBbUJkLE9BQU8sQ0FBQ2UsS0FBUixHQUFnQixTQURuQztBQUVBZixPQUFPLENBQUNnQixHQUFSLEdBQWMsQ0FBZDtBQUNBaEIsT0FBTyxDQUFDaUIsT0FBUixHQUFrQixJQUFsQjtBQUNBakIsT0FBTyxDQUFDa0IsR0FBUixHQUFjLEVBQWQ7QUFDQWxCLE9BQU8sQ0FBQ21CLElBQVIsR0FBZSxFQUFmOztBQUVBbkIsT0FBTyxDQUFDb0IsT0FBUixHQUFrQixVQUFVQyxJQUFWLEVBQWdCO0VBQ2pDLE1BQU0sSUFBSUMsS0FBSixDQUFVLDJDQUFWLENBQU47QUFDQSxDQUZEOztBQUlBLENBQUMsWUFBWTtFQUNULElBQUlDLEdBQUcsR0FBRyxHQUFWO0VBQ0EsSUFBSUMsSUFBSjs7RUFDQXhCLE9BQU8sQ0FBQ3VCLEdBQVIsR0FBYyxZQUFZO0lBQUUsT0FBT0EsR0FBUDtFQUFZLENBQXhDOztFQUNBdkIsT0FBTyxDQUFDeUIsS0FBUixHQUFnQixVQUFVQyxHQUFWLEVBQWU7SUFDM0IsSUFBSSxDQUFDRixJQUFMLEVBQVdBLElBQUksR0FBR0csbUJBQU8sQ0FBQyxNQUFELENBQWQ7SUFDWEosR0FBRyxHQUFHQyxJQUFJLENBQUNJLE9BQUwsQ0FBYUYsR0FBYixFQUFrQkgsR0FBbEIsQ0FBTjtFQUNILENBSEQ7QUFJSCxDQVJEOztBQVVBdkIsT0FBTyxDQUFDNkIsSUFBUixHQUFlN0IsT0FBTyxDQUFDOEIsSUFBUixHQUNmOUIsT0FBTyxDQUFDK0IsS0FBUixHQUFnQi9CLE9BQU8sQ0FBQ2dDLE1BQVIsR0FDaEJoQyxPQUFPLENBQUNpQyxNQUFSLEdBQWlCakMsT0FBTyxDQUFDa0MsV0FBUixHQUNqQmxDLE9BQU8sQ0FBQ21DLFVBQVIsR0FBcUIsWUFBVyxDQUFFLENBSGxDOztBQUlBbkMsT0FBTyxDQUFDb0MsUUFBUixHQUFtQixFQUFuQiIsImZpbGUiOiJRMklnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5uZXh0VGljayA9IGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGFyZ3Muc2hpZnQoKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgMCk7XG59O1xuXG5leHBvcnRzLnBsYXRmb3JtID0gZXhwb3J0cy5hcmNoID0gXG5leHBvcnRzLmV4ZWNQYXRoID0gZXhwb3J0cy50aXRsZSA9ICdicm93c2VyJztcbmV4cG9ydHMucGlkID0gMTtcbmV4cG9ydHMuYnJvd3NlciA9IHRydWU7XG5leHBvcnRzLmVudiA9IHt9O1xuZXhwb3J0cy5hcmd2ID0gW107XG5cbmV4cG9ydHMuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdHRocm93IG5ldyBFcnJvcignTm8gc3VjaCBtb2R1bGUuIChQb3NzaWJseSBub3QgeWV0IGxvYWRlZCknKVxufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3dkID0gJy8nO1xuICAgIHZhciBwYXRoO1xuICAgIGV4cG9ydHMuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY3dkIH07XG4gICAgZXhwb3J0cy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgICAgaWYgKCFwYXRoKSBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuICAgICAgICBjd2QgPSBwYXRoLnJlc29sdmUoZGlyLCBjd2QpO1xuICAgIH07XG59KSgpO1xuXG5leHBvcnRzLmV4aXQgPSBleHBvcnRzLmtpbGwgPSBcbmV4cG9ydHMudW1hc2sgPSBleHBvcnRzLmRsb3BlbiA9IFxuZXhwb3J0cy51cHRpbWUgPSBleHBvcnRzLm1lbW9yeVVzYWdlID0gXG5leHBvcnRzLnV2Q291bnRlcnMgPSBmdW5jdGlvbigpIHt9O1xuZXhwb3J0cy5mZWF0dXJlcyA9IHt9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///Q2Ig\n")},WbBG:function(module,exports,__webpack_require__){"use strict";eval("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\nmodule.exports = ReactPropTypesSecret;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanM/NTliMCJdLCJuYW1lcyI6WyJSZWFjdFByb3BUeXBlc1NlY3JldCIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVhOztBQUViLElBQUlBLG9CQUFvQixHQUFHLDhDQUEzQjtBQUVBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJGLG9CQUFqQiIsImZpbGUiOiJXYkJHLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///WbBG\n")},Wxvo:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export QRCodeCanvas */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return QRCodeSVG; });\n/* unused harmony export default */\n/* harmony import */ var _home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ODXe");\n/* harmony import */ var _home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("1OyB");\n/* harmony import */ var _home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("vuIU");\n/* harmony import */ var _home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("uFwe");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("kM82");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols) {\n    var _iterator = Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(__getOwnPropSymbols(b)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return a;\n};\n\nvar __objRest = function __objRest(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols) {\n    var _iterator2 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(__getOwnPropSymbols(source)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var prop = _step2.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return target;\n}; // src/index.tsx\n\n\n // src/third-party/qrcodegen/index.ts\n\n/**\n * @license QR Code generator library (TypeScript)\n * Copyright (c) Project Nayuki.\n * SPDX-License-Identifier: MIT\n */\n\nvar qrcodegen;\n\n(function (qrcodegen2) {\n  var _QrCode = /*#__PURE__*/function () {\n    function _QrCode(version, errorCorrectionLevel, dataCodewords, msk) {\n      Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, _QrCode);\n\n      this.version = version;\n      this.errorCorrectionLevel = errorCorrectionLevel;\n      this.modules = [];\n      this.isFunction = [];\n      if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION) throw new RangeError("Version value out of range");\n      if (msk < -1 || msk > 7) throw new RangeError("Mask value out of range");\n      this.size = version * 4 + 17;\n      var row = [];\n\n      for (var i = 0; i < this.size; i++) {\n        row.push(false);\n      }\n\n      for (var _i = 0; _i < this.size; _i++) {\n        this.modules.push(row.slice());\n        this.isFunction.push(row.slice());\n      }\n\n      this.drawFunctionPatterns();\n      var allCodewords = this.addEccAndInterleave(dataCodewords);\n      this.drawCodewords(allCodewords);\n\n      if (msk == -1) {\n        var minPenalty = 1e9;\n\n        for (var _i2 = 0; _i2 < 8; _i2++) {\n          this.applyMask(_i2);\n          this.drawFormatBits(_i2);\n          var penalty = this.getPenaltyScore();\n\n          if (penalty < minPenalty) {\n            msk = _i2;\n            minPenalty = penalty;\n          }\n\n          this.applyMask(_i2);\n        }\n      }\n\n      assert(0 <= msk && msk <= 7);\n      this.mask = msk;\n      this.applyMask(msk);\n      this.drawFormatBits(msk);\n      this.isFunction = [];\n    }\n\n    Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(_QrCode, [{\n      key: "getModule",\n      value: function getModule(x, y) {\n        return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n      }\n    }, {\n      key: "getModules",\n      value: function getModules() {\n        return this.modules;\n      }\n    }, {\n      key: "drawFunctionPatterns",\n      value: function drawFunctionPatterns() {\n        for (var i = 0; i < this.size; i++) {\n          this.setFunctionModule(6, i, i % 2 == 0);\n          this.setFunctionModule(i, 6, i % 2 == 0);\n        }\n\n        this.drawFinderPattern(3, 3);\n        this.drawFinderPattern(this.size - 4, 3);\n        this.drawFinderPattern(3, this.size - 4);\n        var alignPatPos = this.getAlignmentPatternPositions();\n        var numAlign = alignPatPos.length;\n\n        for (var _i3 = 0; _i3 < numAlign; _i3++) {\n          for (var j = 0; j < numAlign; j++) {\n            if (!(_i3 == 0 && j == 0 || _i3 == 0 && j == numAlign - 1 || _i3 == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[_i3], alignPatPos[j]);\n          }\n        }\n\n        this.drawFormatBits(0);\n        this.drawVersion();\n      }\n    }, {\n      key: "drawFormatBits",\n      value: function drawFormatBits(mask) {\n        var data = this.errorCorrectionLevel.formatBits << 3 | mask;\n        var rem = data;\n\n        for (var i = 0; i < 10; i++) {\n          rem = rem << 1 ^ (rem >>> 9) * 1335;\n        }\n\n        var bits = (data << 10 | rem) ^ 21522;\n        assert(bits >>> 15 == 0);\n\n        for (var _i4 = 0; _i4 <= 5; _i4++) {\n          this.setFunctionModule(8, _i4, getBit(bits, _i4));\n        }\n\n        this.setFunctionModule(8, 7, getBit(bits, 6));\n        this.setFunctionModule(8, 8, getBit(bits, 7));\n        this.setFunctionModule(7, 8, getBit(bits, 8));\n\n        for (var _i5 = 9; _i5 < 15; _i5++) {\n          this.setFunctionModule(14 - _i5, 8, getBit(bits, _i5));\n        }\n\n        for (var _i6 = 0; _i6 < 8; _i6++) {\n          this.setFunctionModule(this.size - 1 - _i6, 8, getBit(bits, _i6));\n        }\n\n        for (var _i7 = 8; _i7 < 15; _i7++) {\n          this.setFunctionModule(8, this.size - 15 + _i7, getBit(bits, _i7));\n        }\n\n        this.setFunctionModule(8, this.size - 8, true);\n      }\n    }, {\n      key: "drawVersion",\n      value: function drawVersion() {\n        if (this.version < 7) return;\n        var rem = this.version;\n\n        for (var i = 0; i < 12; i++) {\n          rem = rem << 1 ^ (rem >>> 11) * 7973;\n        }\n\n        var bits = this.version << 12 | rem;\n        assert(bits >>> 18 == 0);\n\n        for (var _i8 = 0; _i8 < 18; _i8++) {\n          var color = getBit(bits, _i8);\n          var a = this.size - 11 + _i8 % 3;\n          var b = Math.floor(_i8 / 3);\n          this.setFunctionModule(a, b, color);\n          this.setFunctionModule(b, a, color);\n        }\n      }\n    }, {\n      key: "drawFinderPattern",\n      value: function drawFinderPattern(x, y) {\n        for (var dy = -4; dy <= 4; dy++) {\n          for (var dx = -4; dx <= 4; dx++) {\n            var dist = Math.max(Math.abs(dx), Math.abs(dy));\n            var xx = x + dx;\n            var yy = y + dy;\n            if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n          }\n        }\n      }\n    }, {\n      key: "drawAlignmentPattern",\n      value: function drawAlignmentPattern(x, y) {\n        for (var dy = -2; dy <= 2; dy++) {\n          for (var dx = -2; dx <= 2; dx++) {\n            this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n          }\n        }\n      }\n    }, {\n      key: "setFunctionModule",\n      value: function setFunctionModule(x, y, isDark) {\n        this.modules[y][x] = isDark;\n        this.isFunction[y][x] = true;\n      }\n    }, {\n      key: "addEccAndInterleave",\n      value: function addEccAndInterleave(data) {\n        var ver = this.version;\n        var ecl = this.errorCorrectionLevel;\n        if (data.length != _QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError("Invalid argument");\n        var numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n        var blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n        var rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);\n        var numShortBlocks = numBlocks - rawCodewords % numBlocks;\n        var shortBlockLen = Math.floor(rawCodewords / numBlocks);\n        var blocks = [];\n\n        var rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);\n\n        for (var i = 0, k = 0; i < numBlocks; i++) {\n          var dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n          k += dat.length;\n\n          var ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n\n          if (i < numShortBlocks) dat.push(0);\n          blocks.push(dat.concat(ecc));\n        }\n\n        var result = [];\n\n        var _loop = function _loop(_i9) {\n          blocks.forEach(function (block, j) {\n            if (_i9 != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[_i9]);\n          });\n        };\n\n        for (var _i9 = 0; _i9 < blocks[0].length; _i9++) {\n          _loop(_i9);\n        }\n\n        assert(result.length == rawCodewords);\n        return result;\n      }\n    }, {\n      key: "drawCodewords",\n      value: function drawCodewords(data) {\n        if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");\n        var i = 0;\n\n        for (var right = this.size - 1; right >= 1; right -= 2) {\n          if (right == 6) right = 5;\n\n          for (var vert = 0; vert < this.size; vert++) {\n            for (var j = 0; j < 2; j++) {\n              var x = right - j;\n              var upward = (right + 1 & 2) == 0;\n              var y = upward ? this.size - 1 - vert : vert;\n\n              if (!this.isFunction[y][x] && i < data.length * 8) {\n                this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n                i++;\n              }\n            }\n          }\n        }\n\n        assert(i == data.length * 8);\n      }\n    }, {\n      key: "applyMask",\n      value: function applyMask(mask) {\n        if (mask < 0 || mask > 7) throw new RangeError("Mask value out of range");\n\n        for (var y = 0; y < this.size; y++) {\n          for (var x = 0; x < this.size; x++) {\n            var invert = void 0;\n\n            switch (mask) {\n              case 0:\n                invert = (x + y) % 2 == 0;\n                break;\n\n              case 1:\n                invert = y % 2 == 0;\n                break;\n\n              case 2:\n                invert = x % 3 == 0;\n                break;\n\n              case 3:\n                invert = (x + y) % 3 == 0;\n                break;\n\n              case 4:\n                invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n                break;\n\n              case 5:\n                invert = x * y % 2 + x * y % 3 == 0;\n                break;\n\n              case 6:\n                invert = (x * y % 2 + x * y % 3) % 2 == 0;\n                break;\n\n              case 7:\n                invert = ((x + y) % 2 + x * y % 3) % 2 == 0;\n                break;\n\n              default:\n                throw new Error("Unreachable");\n            }\n\n            if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];\n          }\n        }\n      }\n    }, {\n      key: "getPenaltyScore",\n      value: function getPenaltyScore() {\n        var result = 0;\n\n        for (var y = 0; y < this.size; y++) {\n          var runColor = false;\n          var runX = 0;\n          var runHistory = [0, 0, 0, 0, 0, 0, 0];\n\n          for (var x = 0; x < this.size; x++) {\n            if (this.modules[y][x] == runColor) {\n              runX++;\n              if (runX == 5) result += _QrCode.PENALTY_N1;else if (runX > 5) result++;\n            } else {\n              this.finderPenaltyAddHistory(runX, runHistory);\n              if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n              runColor = this.modules[y][x];\n              runX = 1;\n            }\n          }\n\n          result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;\n        }\n\n        for (var _x = 0; _x < this.size; _x++) {\n          var _runColor = false;\n          var runY = 0;\n          var _runHistory = [0, 0, 0, 0, 0, 0, 0];\n\n          for (var _y = 0; _y < this.size; _y++) {\n            if (this.modules[_y][_x] == _runColor) {\n              runY++;\n              if (runY == 5) result += _QrCode.PENALTY_N1;else if (runY > 5) result++;\n            } else {\n              this.finderPenaltyAddHistory(runY, _runHistory);\n              if (!_runColor) result += this.finderPenaltyCountPatterns(_runHistory) * _QrCode.PENALTY_N3;\n              _runColor = this.modules[_y][_x];\n              runY = 1;\n            }\n          }\n\n          result += this.finderPenaltyTerminateAndCount(_runColor, runY, _runHistory) * _QrCode.PENALTY_N3;\n        }\n\n        for (var _y2 = 0; _y2 < this.size - 1; _y2++) {\n          for (var _x2 = 0; _x2 < this.size - 1; _x2++) {\n            var color = this.modules[_y2][_x2];\n            if (color == this.modules[_y2][_x2 + 1] && color == this.modules[_y2 + 1][_x2] && color == this.modules[_y2 + 1][_x2 + 1]) result += _QrCode.PENALTY_N2;\n          }\n        }\n\n        var dark = 0;\n\n        var _iterator3 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(this.modules),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var row = _step3.value;\n            dark = row.reduce(function (sum, color) {\n              return sum + (color ? 1 : 0);\n            }, dark);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        var total = this.size * this.size;\n        var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n        assert(0 <= k && k <= 9);\n        result += k * _QrCode.PENALTY_N4;\n        assert(0 <= result && result <= 2568888);\n        return result;\n      }\n    }, {\n      key: "getAlignmentPatternPositions",\n      value: function getAlignmentPatternPositions() {\n        if (this.version == 1) return [];else {\n          var numAlign = Math.floor(this.version / 7) + 2;\n          var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n          var result = [6];\n\n          for (var pos = this.size - 7; result.length < numAlign; pos -= step) {\n            result.splice(1, 0, pos);\n          }\n\n          return result;\n        }\n      }\n    }, {\n      key: "finderPenaltyCountPatterns",\n      value: function finderPenaltyCountPatterns(runHistory) {\n        var n = runHistory[1];\n        assert(n <= this.size * 3);\n        var core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n        return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n      }\n    }, {\n      key: "finderPenaltyTerminateAndCount",\n      value: function finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n        if (currentRunColor) {\n          this.finderPenaltyAddHistory(currentRunLength, runHistory);\n          currentRunLength = 0;\n        }\n\n        currentRunLength += this.size;\n        this.finderPenaltyAddHistory(currentRunLength, runHistory);\n        return this.finderPenaltyCountPatterns(runHistory);\n      }\n    }, {\n      key: "finderPenaltyAddHistory",\n      value: function finderPenaltyAddHistory(currentRunLength, runHistory) {\n        if (runHistory[0] == 0) currentRunLength += this.size;\n        runHistory.pop();\n        runHistory.unshift(currentRunLength);\n      }\n    }], [{\n      key: "encodeText",\n      value: function encodeText(text, ecl) {\n        var segs = qrcodegen2.QrSegment.makeSegments(text);\n        return _QrCode.encodeSegments(segs, ecl);\n      }\n    }, {\n      key: "encodeBinary",\n      value: function encodeBinary(data, ecl) {\n        var seg = qrcodegen2.QrSegment.makeBytes(data);\n        return _QrCode.encodeSegments([seg], ecl);\n      }\n    }, {\n      key: "encodeSegments",\n      value: function encodeSegments(segs, ecl) {\n        var minVersion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var maxVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 40;\n        var mask = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n        var boostEcl = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n        if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError("Invalid value");\n        var version;\n        var dataUsedBits;\n\n        for (version = minVersion;; version++) {\n          var dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;\n          var usedBits = QrSegment.getTotalBits(segs, version);\n\n          if (usedBits <= dataCapacityBits2) {\n            dataUsedBits = usedBits;\n            break;\n          }\n\n          if (version >= maxVersion) throw new RangeError("Data too long");\n        }\n\n        for (var _i10 = 0, _arr = [_QrCode.Ecc.MEDIUM, _QrCode.Ecc.QUARTILE, _QrCode.Ecc.HIGH]; _i10 < _arr.length; _i10++) {\n          var newEcl = _arr[_i10];\n          if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;\n        }\n\n        var bb = [];\n\n        var _iterator4 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(segs),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var seg = _step4.value;\n            appendBits(seg.mode.modeBits, 4, bb);\n            appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n\n            var _iterator5 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(seg.getData()),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var b = _step5.value;\n                bb.push(b);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        assert(bb.length == dataUsedBits);\n        var dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;\n        assert(bb.length <= dataCapacityBits);\n        appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n        appendBits(0, (8 - bb.length % 8) % 8, bb);\n        assert(bb.length % 8 == 0);\n\n        for (var padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17) {\n          appendBits(padByte, 8, bb);\n        }\n\n        var dataCodewords = [];\n\n        while (dataCodewords.length * 8 < bb.length) {\n          dataCodewords.push(0);\n        }\n\n        bb.forEach(function (b, i) {\n          return dataCodewords[i >>> 3] |= b << 7 - (i & 7);\n        });\n        return new _QrCode(version, ecl, dataCodewords, mask);\n      }\n    }, {\n      key: "getNumRawDataModules",\n      value: function getNumRawDataModules(ver) {\n        if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION) throw new RangeError("Version number out of range");\n        var result = (16 * ver + 128) * ver + 64;\n\n        if (ver >= 2) {\n          var numAlign = Math.floor(ver / 7) + 2;\n          result -= (25 * numAlign - 10) * numAlign - 55;\n          if (ver >= 7) result -= 36;\n        }\n\n        assert(208 <= result && result <= 29648);\n        return result;\n      }\n    }, {\n      key: "getNumDataCodewords",\n      value: function getNumDataCodewords(ver, ecl) {\n        return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n      }\n    }, {\n      key: "reedSolomonComputeDivisor",\n      value: function reedSolomonComputeDivisor(degree) {\n        if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");\n        var result = [];\n\n        for (var i = 0; i < degree - 1; i++) {\n          result.push(0);\n        }\n\n        result.push(1);\n        var root = 1;\n\n        for (var _i11 = 0; _i11 < degree; _i11++) {\n          for (var j = 0; j < result.length; j++) {\n            result[j] = _QrCode.reedSolomonMultiply(result[j], root);\n            if (j + 1 < result.length) result[j] ^= result[j + 1];\n          }\n\n          root = _QrCode.reedSolomonMultiply(root, 2);\n        }\n\n        return result;\n      }\n    }, {\n      key: "reedSolomonComputeRemainder",\n      value: function reedSolomonComputeRemainder(data, divisor) {\n        var result = divisor.map(function (_) {\n          return 0;\n        });\n\n        var _iterator6 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(data),\n            _step6;\n\n        try {\n          var _loop2 = function _loop2() {\n            var b = _step6.value;\n            var factor = b ^ result.shift();\n            result.push(0);\n            divisor.forEach(function (coef, i) {\n              return result[i] ^= _QrCode.reedSolomonMultiply(coef, factor);\n            });\n          };\n\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            _loop2();\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        return result;\n      }\n    }, {\n      key: "reedSolomonMultiply",\n      value: function reedSolomonMultiply(x, y) {\n        if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError("Byte out of range");\n        var z = 0;\n\n        for (var i = 7; i >= 0; i--) {\n          z = z << 1 ^ (z >>> 7) * 285;\n          z ^= (y >>> i & 1) * x;\n        }\n\n        assert(z >>> 8 == 0);\n        return z;\n      }\n    }]);\n\n    return _QrCode;\n  }();\n\n  var QrCode = _QrCode;\n  QrCode.MIN_VERSION = 1;\n  QrCode.MAX_VERSION = 40;\n  QrCode.PENALTY_N1 = 3;\n  QrCode.PENALTY_N2 = 3;\n  QrCode.PENALTY_N3 = 40;\n  QrCode.PENALTY_N4 = 10;\n  QrCode.ECC_CODEWORDS_PER_BLOCK = [[-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]];\n  QrCode.NUM_ERROR_CORRECTION_BLOCKS = [[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]];\n  qrcodegen2.QrCode = QrCode;\n\n  function appendBits(val, len, bb) {\n    if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError("Value out of range");\n\n    for (var i = len - 1; i >= 0; i--) {\n      bb.push(val >>> i & 1);\n    }\n  }\n\n  function getBit(x, i) {\n    return (x >>> i & 1) != 0;\n  }\n\n  function assert(cond) {\n    if (!cond) throw new Error("Assertion error");\n  }\n\n  var _QrSegment = /*#__PURE__*/function () {\n    function _QrSegment(mode, numChars, bitData) {\n      Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, _QrSegment);\n\n      this.mode = mode;\n      this.numChars = numChars;\n      this.bitData = bitData;\n      if (numChars < 0) throw new RangeError("Invalid argument");\n      this.bitData = bitData.slice();\n    }\n\n    Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(_QrSegment, [{\n      key: "getData",\n      value: function getData() {\n        return this.bitData.slice();\n      }\n    }], [{\n      key: "makeBytes",\n      value: function makeBytes(data) {\n        var bb = [];\n\n        var _iterator7 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(data),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var b = _step7.value;\n            appendBits(b, 8, bb);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);\n      }\n    }, {\n      key: "makeNumeric",\n      value: function makeNumeric(digits) {\n        if (!_QrSegment.isNumeric(digits)) throw new RangeError("String contains non-numeric characters");\n        var bb = [];\n\n        for (var i = 0; i < digits.length;) {\n          var n = Math.min(digits.length - i, 3);\n          appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);\n          i += n;\n        }\n\n        return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);\n      }\n    }, {\n      key: "makeAlphanumeric",\n      value: function makeAlphanumeric(text) {\n        if (!_QrSegment.isAlphanumeric(text)) throw new RangeError("String contains unencodable characters in alphanumeric mode");\n        var bb = [];\n        var i;\n\n        for (i = 0; i + 2 <= text.length; i += 2) {\n          var temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n          temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n          appendBits(temp, 11, bb);\n        }\n\n        if (i < text.length) appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n        return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);\n      }\n    }, {\n      key: "makeSegments",\n      value: function makeSegments(text) {\n        if (text == "") return [];else if (_QrSegment.isNumeric(text)) return [_QrSegment.makeNumeric(text)];else if (_QrSegment.isAlphanumeric(text)) return [_QrSegment.makeAlphanumeric(text)];else return [_QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))];\n      }\n    }, {\n      key: "makeEci",\n      value: function makeEci(assignVal) {\n        var bb = [];\n        if (assignVal < 0) throw new RangeError("ECI assignment value out of range");else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);else if (assignVal < 1 << 14) {\n          appendBits(2, 2, bb);\n          appendBits(assignVal, 14, bb);\n        } else if (assignVal < 1e6) {\n          appendBits(6, 3, bb);\n          appendBits(assignVal, 21, bb);\n        } else throw new RangeError("ECI assignment value out of range");\n        return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);\n      }\n    }, {\n      key: "isNumeric",\n      value: function isNumeric(text) {\n        return _QrSegment.NUMERIC_REGEX.test(text);\n      }\n    }, {\n      key: "isAlphanumeric",\n      value: function isAlphanumeric(text) {\n        return _QrSegment.ALPHANUMERIC_REGEX.test(text);\n      }\n    }, {\n      key: "getTotalBits",\n      value: function getTotalBits(segs, version) {\n        var result = 0;\n\n        var _iterator8 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createForOfIteratorHelper_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(segs),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var seg = _step8.value;\n            var ccbits = seg.mode.numCharCountBits(version);\n            if (seg.numChars >= 1 << ccbits) return Infinity;\n            result += 4 + ccbits + seg.bitData.length;\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n\n        return result;\n      }\n    }, {\n      key: "toUtf8ByteArray",\n      value: function toUtf8ByteArray(str) {\n        str = encodeURI(str);\n        var result = [];\n\n        for (var i = 0; i < str.length; i++) {\n          if (str.charAt(i) != "%") result.push(str.charCodeAt(i));else {\n            result.push(parseInt(str.substr(i + 1, 2), 16));\n            i += 2;\n          }\n        }\n\n        return result;\n      }\n    }]);\n\n    return _QrSegment;\n  }();\n\n  var QrSegment = _QrSegment;\n  QrSegment.NUMERIC_REGEX = /^[0-9]*$/;\n  QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\n  QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";\n  qrcodegen2.QrSegment = QrSegment;\n})(qrcodegen || (qrcodegen = {}));\n\n(function (qrcodegen2) {\n  var QrCode;\n\n  (function (QrCode2) {\n    var _Ecc = /*#__PURE__*/Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(function _Ecc(ordinal, formatBits) {\n      Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, _Ecc);\n\n      this.ordinal = ordinal;\n      this.formatBits = formatBits;\n    });\n\n    var Ecc = _Ecc;\n    Ecc.LOW = new _Ecc(0, 1);\n    Ecc.MEDIUM = new _Ecc(1, 0);\n    Ecc.QUARTILE = new _Ecc(2, 3);\n    Ecc.HIGH = new _Ecc(3, 2);\n    QrCode2.Ecc = Ecc;\n  })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));\n})(qrcodegen || (qrcodegen = {}));\n\n(function (qrcodegen2) {\n  var QrSegment;\n\n  (function (QrSegment2) {\n    var _Mode = /*#__PURE__*/function () {\n      function _Mode(modeBits, numBitsCharCount) {\n        Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_classCallCheck_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(this, _Mode);\n\n        this.modeBits = modeBits;\n        this.numBitsCharCount = numBitsCharCount;\n      }\n\n      Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_createClass_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(_Mode, [{\n        key: "numCharCountBits",\n        value: function numCharCountBits(ver) {\n          return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n        }\n      }]);\n\n      return _Mode;\n    }();\n\n    var Mode = _Mode;\n    Mode.NUMERIC = new _Mode(1, [10, 12, 14]);\n    Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);\n    Mode.BYTE = new _Mode(4, [8, 16, 16]);\n    Mode.KANJI = new _Mode(8, [8, 10, 12]);\n    Mode.ECI = new _Mode(7, [0, 0, 0]);\n    QrSegment2.Mode = Mode;\n  })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));\n})(qrcodegen || (qrcodegen = {}));\n\nvar qrcodegen_default = qrcodegen; // src/index.tsx\n\n/**\n * @license qrcode.react\n * Copyright (c) Paul O\'Shannessy\n * SPDX-License-Identifier: ISC\n */\n\nvar ERROR_LEVEL_MAP = {\n  L: qrcodegen_default.QrCode.Ecc.LOW,\n  M: qrcodegen_default.QrCode.Ecc.MEDIUM,\n  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,\n  H: qrcodegen_default.QrCode.Ecc.HIGH\n};\nvar DEFAULT_SIZE = 128;\nvar DEFAULT_LEVEL = "L";\nvar DEFAULT_BGCOLOR = "#FFFFFF";\nvar DEFAULT_FGCOLOR = "#000000";\nvar DEFAULT_INCLUDEMARGIN = false;\nvar MARGIN_SIZE = 4;\nvar DEFAULT_IMG_SCALE = 0.1;\n\nfunction generatePath(modules) {\n  var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var ops = [];\n  modules.forEach(function (row, y) {\n    var start = null;\n    row.forEach(function (cell, x) {\n      if (!cell && start !== null) {\n        ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));\n        start = null;\n        return;\n      }\n\n      if (x === row.length - 1) {\n        if (!cell) {\n          return;\n        }\n\n        if (start === null) {\n          ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));\n        } else {\n          ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));\n        }\n\n        return;\n      }\n\n      if (cell && start === null) {\n        start = x;\n      }\n    });\n  });\n  return ops.join("");\n}\n\nfunction excavateModules(modules, excavation) {\n  return modules.slice().map(function (row, y) {\n    if (y < excavation.y || y >= excavation.y + excavation.h) {\n      return row;\n    }\n\n    return row.map(function (cell, x) {\n      if (x < excavation.x || x >= excavation.x + excavation.w) {\n        return cell;\n      }\n\n      return false;\n    });\n  });\n}\n\nfunction getImageSettings(cells, size, includeMargin, imageSettings) {\n  if (imageSettings == null) {\n    return null;\n  }\n\n  var margin = includeMargin ? MARGIN_SIZE : 0;\n  var numCells = cells.length + margin * 2;\n  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n  var scale = numCells / size;\n  var w = (imageSettings.width || defaultSize) * scale;\n  var h = (imageSettings.height || defaultSize) * scale;\n  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n  var excavation = null;\n\n  if (imageSettings.excavate) {\n    var floorX = Math.floor(x);\n    var floorY = Math.floor(y);\n    var ceilW = Math.ceil(w + x - floorX);\n    var ceilH = Math.ceil(h + y - floorY);\n    excavation = {\n      x: floorX,\n      y: floorY,\n      w: ceilW,\n      h: ceilH\n    };\n  }\n\n  return {\n    x: x,\n    y: y,\n    h: h,\n    w: w,\n    excavation: excavation\n  };\n}\n\nvar SUPPORTS_PATH2D = function () {\n  try {\n    new Path2D().addPath(new Path2D());\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}();\n\nfunction QRCodeCanvas(props) {\n  var _a = props,\n      value = _a.value,\n      _a$size = _a.size,\n      size = _a$size === void 0 ? DEFAULT_SIZE : _a$size,\n      _a$level = _a.level,\n      level = _a$level === void 0 ? DEFAULT_LEVEL : _a$level,\n      _a$bgColor = _a.bgColor,\n      bgColor = _a$bgColor === void 0 ? DEFAULT_BGCOLOR : _a$bgColor,\n      _a$fgColor = _a.fgColor,\n      fgColor = _a$fgColor === void 0 ? DEFAULT_FGCOLOR : _a$fgColor,\n      _a$includeMargin = _a.includeMargin,\n      includeMargin = _a$includeMargin === void 0 ? DEFAULT_INCLUDEMARGIN : _a$includeMargin,\n      style = _a.style,\n      imageSettings = _a.imageSettings,\n      otherProps = __objRest(_a, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "style", "imageSettings"]);\n\n  var imgSrc = imageSettings == null ? void 0 : imageSettings.src;\n\n  var _canvas = Object(react__WEBPACK_IMPORTED_MODULE_4__["useRef"])(null);\n\n  var _image = Object(react__WEBPACK_IMPORTED_MODULE_4__["useRef"])(null);\n\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_4__["useState"])(false),\n      _useState2 = Object(_home_runner_work_fast_ui_fast_ui_node_modules_babel_runtime_helpers_esm_slicedToArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(_useState, 2),\n      isImgLoaded = _useState2[0],\n      setIsImageLoaded = _useState2[1];\n\n  Object(react__WEBPACK_IMPORTED_MODULE_4__["useEffect"])(function () {\n    if (_canvas.current != null) {\n      var canvas = _canvas.current;\n      var ctx = canvas.getContext("2d");\n\n      if (!ctx) {\n        return;\n      }\n\n      var cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n      var margin = includeMargin ? MARGIN_SIZE : 0;\n      var numCells = cells.length + margin * 2;\n      var calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);\n      var image = _image.current;\n      var haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n\n      if (haveImageToRender) {\n        if (calculatedImageSettings.excavation != null) {\n          cells = excavateModules(cells, calculatedImageSettings.excavation);\n        }\n      }\n\n      var pixelRatio = window.devicePixelRatio || 1;\n      canvas.height = canvas.width = size * pixelRatio;\n      var scale = size / numCells * pixelRatio;\n      ctx.scale(scale, scale);\n      ctx.fillStyle = bgColor;\n      ctx.fillRect(0, 0, numCells, numCells);\n      ctx.fillStyle = fgColor;\n\n      if (SUPPORTS_PATH2D) {\n        ctx.fill(new Path2D(generatePath(cells, margin)));\n      } else {\n        cells.forEach(function (row, rdx) {\n          row.forEach(function (cell, cdx) {\n            if (cell) {\n              ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n            }\n          });\n        });\n      }\n\n      if (haveImageToRender) {\n        ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n      }\n    }\n  });\n  Object(react__WEBPACK_IMPORTED_MODULE_4__["useEffect"])(function () {\n    setIsImageLoaded(false);\n  }, [imgSrc]);\n\n  var canvasStyle = __spreadValues({\n    height: size,\n    width: size\n  }, style);\n\n  var img = null;\n\n  if (imgSrc != null) {\n    img = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement("img", {\n      src: imgSrc,\n      key: imgSrc,\n      style: {\n        display: "none"\n      },\n      onLoad: function onLoad() {\n        setIsImageLoaded(true);\n      },\n      ref: _image\n    });\n  }\n\n  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_4___default.a.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement("canvas", __spreadValues({\n    style: canvasStyle,\n    height: size,\n    width: size,\n    ref: _canvas\n  }, otherProps)), img);\n}\n\nfunction QRCodeSVG(props) {\n  var _a = props,\n      value = _a.value,\n      _a$size2 = _a.size,\n      size = _a$size2 === void 0 ? DEFAULT_SIZE : _a$size2,\n      _a$level2 = _a.level,\n      level = _a$level2 === void 0 ? DEFAULT_LEVEL : _a$level2,\n      _a$bgColor2 = _a.bgColor,\n      bgColor = _a$bgColor2 === void 0 ? DEFAULT_BGCOLOR : _a$bgColor2,\n      _a$fgColor2 = _a.fgColor,\n      fgColor = _a$fgColor2 === void 0 ? DEFAULT_FGCOLOR : _a$fgColor2,\n      _a$includeMargin2 = _a.includeMargin,\n      includeMargin = _a$includeMargin2 === void 0 ? DEFAULT_INCLUDEMARGIN : _a$includeMargin2,\n      imageSettings = _a.imageSettings,\n      otherProps = __objRest(_a, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"]);\n\n  var cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n  var margin = includeMargin ? MARGIN_SIZE : 0;\n  var numCells = cells.length + margin * 2;\n  var calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);\n  var image = null;\n\n  if (imageSettings != null && calculatedImageSettings != null) {\n    if (calculatedImageSettings.excavation != null) {\n      cells = excavateModules(cells, calculatedImageSettings.excavation);\n    }\n\n    image = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement("image", {\n      xlinkHref: imageSettings.src,\n      height: calculatedImageSettings.h,\n      width: calculatedImageSettings.w,\n      x: calculatedImageSettings.x + margin,\n      y: calculatedImageSettings.y + margin,\n      preserveAspectRatio: "none"\n    });\n  }\n\n  var fgPath = generatePath(cells, margin);\n  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement("svg", __spreadValues({\n    height: size,\n    width: size,\n    viewBox: "0 0 ".concat(numCells, " ").concat(numCells)\n  }, otherProps), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement("path", {\n    fill: bgColor,\n    d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z"),\n    shapeRendering: "crispEdges"\n  }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement("path", {\n    fill: fgColor,\n    d: fgPath,\n    shapeRendering: "crispEdges"\n  }), image);\n}\n\nvar QRCode = function QRCode(props) {\n  var _a = props,\n      renderAs = _a.renderAs,\n      otherProps = __objRest(_a, ["renderAs"]);\n\n  if (renderAs === "svg") {\n    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement(QRCodeSVG, __spreadValues({}, otherProps));\n  }\n\n  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_4___default.a.createElement(QRCodeCanvas, __spreadValues({}, otherProps));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXJjb2RlLnJlYWN0L2xpYi9lc20vaW5kZXguanM/NWIxYiJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZ2V0T3duUHJvcFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJfX2hhc093blByb3AiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsIl9fcHJvcElzRW51bSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19kZWZOb3JtYWxQcm9wIiwib2JqIiwia2V5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfX3NwcmVhZFZhbHVlcyIsImEiLCJiIiwicHJvcCIsImNhbGwiLCJfX29ialJlc3QiLCJzb3VyY2UiLCJleGNsdWRlIiwidGFyZ2V0IiwiaW5kZXhPZiIsInFyY29kZWdlbiIsInFyY29kZWdlbjIiLCJfUXJDb2RlIiwidmVyc2lvbiIsImVycm9yQ29ycmVjdGlvbkxldmVsIiwiZGF0YUNvZGV3b3JkcyIsIm1zayIsIm1vZHVsZXMiLCJpc0Z1bmN0aW9uIiwiTUlOX1ZFUlNJT04iLCJNQVhfVkVSU0lPTiIsIlJhbmdlRXJyb3IiLCJzaXplIiwicm93IiwiaSIsInB1c2giLCJzbGljZSIsImRyYXdGdW5jdGlvblBhdHRlcm5zIiwiYWxsQ29kZXdvcmRzIiwiYWRkRWNjQW5kSW50ZXJsZWF2ZSIsImRyYXdDb2Rld29yZHMiLCJtaW5QZW5hbHR5IiwiYXBwbHlNYXNrIiwiZHJhd0Zvcm1hdEJpdHMiLCJwZW5hbHR5IiwiZ2V0UGVuYWx0eVNjb3JlIiwiYXNzZXJ0IiwibWFzayIsIngiLCJ5Iiwic2V0RnVuY3Rpb25Nb2R1bGUiLCJkcmF3RmluZGVyUGF0dGVybiIsImFsaWduUGF0UG9zIiwiZ2V0QWxpZ25tZW50UGF0dGVyblBvc2l0aW9ucyIsIm51bUFsaWduIiwibGVuZ3RoIiwiaiIsImRyYXdBbGlnbm1lbnRQYXR0ZXJuIiwiZHJhd1ZlcnNpb24iLCJkYXRhIiwiZm9ybWF0Qml0cyIsInJlbSIsImJpdHMiLCJnZXRCaXQiLCJjb2xvciIsIk1hdGgiLCJmbG9vciIsImR5IiwiZHgiLCJkaXN0IiwibWF4IiwiYWJzIiwieHgiLCJ5eSIsImlzRGFyayIsInZlciIsImVjbCIsImdldE51bURhdGFDb2Rld29yZHMiLCJudW1CbG9ja3MiLCJOVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1MiLCJvcmRpbmFsIiwiYmxvY2tFY2NMZW4iLCJFQ0NfQ09ERVdPUkRTX1BFUl9CTE9DSyIsInJhd0NvZGV3b3JkcyIsImdldE51bVJhd0RhdGFNb2R1bGVzIiwibnVtU2hvcnRCbG9ja3MiLCJzaG9ydEJsb2NrTGVuIiwiYmxvY2tzIiwicnNEaXYiLCJyZWVkU29sb21vbkNvbXB1dGVEaXZpc29yIiwiayIsImRhdCIsImVjYyIsInJlZWRTb2xvbW9uQ29tcHV0ZVJlbWFpbmRlciIsImNvbmNhdCIsInJlc3VsdCIsImZvckVhY2giLCJibG9jayIsInJpZ2h0IiwidmVydCIsInVwd2FyZCIsImludmVydCIsIkVycm9yIiwicnVuQ29sb3IiLCJydW5YIiwicnVuSGlzdG9yeSIsIlBFTkFMVFlfTjEiLCJmaW5kZXJQZW5hbHR5QWRkSGlzdG9yeSIsImZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zIiwiUEVOQUxUWV9OMyIsImZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudCIsInJ1blkiLCJQRU5BTFRZX04yIiwiZGFyayIsInJlZHVjZSIsInN1bSIsInRvdGFsIiwiY2VpbCIsIlBFTkFMVFlfTjQiLCJzdGVwIiwicG9zIiwic3BsaWNlIiwibiIsImNvcmUiLCJjdXJyZW50UnVuQ29sb3IiLCJjdXJyZW50UnVuTGVuZ3RoIiwicG9wIiwidW5zaGlmdCIsInRleHQiLCJzZWdzIiwiUXJTZWdtZW50IiwibWFrZVNlZ21lbnRzIiwiZW5jb2RlU2VnbWVudHMiLCJzZWciLCJtYWtlQnl0ZXMiLCJtaW5WZXJzaW9uIiwibWF4VmVyc2lvbiIsImJvb3N0RWNsIiwiZGF0YVVzZWRCaXRzIiwiZGF0YUNhcGFjaXR5Qml0czIiLCJ1c2VkQml0cyIsImdldFRvdGFsQml0cyIsIkVjYyIsIk1FRElVTSIsIlFVQVJUSUxFIiwiSElHSCIsIm5ld0VjbCIsImJiIiwiYXBwZW5kQml0cyIsIm1vZGUiLCJtb2RlQml0cyIsIm51bUNoYXJzIiwibnVtQ2hhckNvdW50Qml0cyIsImdldERhdGEiLCJkYXRhQ2FwYWNpdHlCaXRzIiwibWluIiwicGFkQnl0ZSIsImRlZ3JlZSIsInJvb3QiLCJyZWVkU29sb21vbk11bHRpcGx5IiwiZGl2aXNvciIsIm1hcCIsIl8iLCJmYWN0b3IiLCJzaGlmdCIsImNvZWYiLCJ6IiwiUXJDb2RlIiwidmFsIiwibGVuIiwiY29uZCIsIl9RclNlZ21lbnQiLCJiaXREYXRhIiwiTW9kZSIsIkJZVEUiLCJkaWdpdHMiLCJpc051bWVyaWMiLCJwYXJzZUludCIsInN1YnN0ciIsIk5VTUVSSUMiLCJpc0FscGhhbnVtZXJpYyIsInRlbXAiLCJBTFBIQU5VTUVSSUNfQ0hBUlNFVCIsImNoYXJBdCIsIkFMUEhBTlVNRVJJQyIsIm1ha2VOdW1lcmljIiwibWFrZUFscGhhbnVtZXJpYyIsInRvVXRmOEJ5dGVBcnJheSIsImFzc2lnblZhbCIsIkVDSSIsIk5VTUVSSUNfUkVHRVgiLCJ0ZXN0IiwiQUxQSEFOVU1FUklDX1JFR0VYIiwiY2NiaXRzIiwiSW5maW5pdHkiLCJzdHIiLCJlbmNvZGVVUkkiLCJjaGFyQ29kZUF0IiwiUXJDb2RlMiIsIl9FY2MiLCJMT1ciLCJRclNlZ21lbnQyIiwiX01vZGUiLCJudW1CaXRzQ2hhckNvdW50IiwiS0FOSkkiLCJxcmNvZGVnZW5fZGVmYXVsdCIsIkVSUk9SX0xFVkVMX01BUCIsIkwiLCJNIiwiUSIsIkgiLCJERUZBVUxUX1NJWkUiLCJERUZBVUxUX0xFVkVMIiwiREVGQVVMVF9CR0NPTE9SIiwiREVGQVVMVF9GR0NPTE9SIiwiREVGQVVMVF9JTkNMVURFTUFSR0lOIiwiTUFSR0lOX1NJWkUiLCJERUZBVUxUX0lNR19TQ0FMRSIsImdlbmVyYXRlUGF0aCIsIm1hcmdpbiIsIm9wcyIsInN0YXJ0IiwiY2VsbCIsImpvaW4iLCJleGNhdmF0ZU1vZHVsZXMiLCJleGNhdmF0aW9uIiwiaCIsInciLCJnZXRJbWFnZVNldHRpbmdzIiwiY2VsbHMiLCJpbmNsdWRlTWFyZ2luIiwiaW1hZ2VTZXR0aW5ncyIsIm51bUNlbGxzIiwiZGVmYXVsdFNpemUiLCJzY2FsZSIsIndpZHRoIiwiaGVpZ2h0IiwiZXhjYXZhdGUiLCJmbG9vclgiLCJmbG9vclkiLCJjZWlsVyIsImNlaWxIIiwiU1VQUE9SVFNfUEFUSDJEIiwiUGF0aDJEIiwiYWRkUGF0aCIsImUiLCJRUkNvZGVDYW52YXMiLCJwcm9wcyIsIl9hIiwibGV2ZWwiLCJiZ0NvbG9yIiwiZmdDb2xvciIsInN0eWxlIiwib3RoZXJQcm9wcyIsImltZ1NyYyIsInNyYyIsIl9jYW52YXMiLCJ1c2VSZWYiLCJfaW1hZ2UiLCJ1c2VTdGF0ZSIsImlzSW1nTG9hZGVkIiwic2V0SXNJbWFnZUxvYWRlZCIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZW5jb2RlVGV4dCIsImdldE1vZHVsZXMiLCJjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyIsImltYWdlIiwiaGF2ZUltYWdlVG9SZW5kZXIiLCJjb21wbGV0ZSIsIm5hdHVyYWxIZWlnaHQiLCJuYXR1cmFsV2lkdGgiLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZmlsbCIsInJkeCIsImNkeCIsImRyYXdJbWFnZSIsImNhbnZhc1N0eWxlIiwiaW1nIiwiUmVhY3QiLCJjcmVhdGVFbGVtZW50IiwiZGlzcGxheSIsIm9uTG9hZCIsInJlZiIsIkZyYWdtZW50IiwiUVJDb2RlU1ZHIiwieGxpbmtIcmVmIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsImZnUGF0aCIsInZpZXdCb3giLCJkIiwic2hhcGVSZW5kZXJpbmciLCJRUkNvZGUiLCJyZW5kZXJBcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFNBQVMsR0FBR0MsTUFBTSxDQUFDQyxjQUF2QjtBQUNBLElBQUlDLG1CQUFtQixHQUFHRixNQUFNLENBQUNHLHFCQUFqQztBQUNBLElBQUlDLFlBQVksR0FBR0osTUFBTSxDQUFDSyxTQUFQLENBQWlCQyxjQUFwQztBQUNBLElBQUlDLFlBQVksR0FBR1AsTUFBTSxDQUFDSyxTQUFQLENBQWlCRyxvQkFBcEM7O0FBQ0EsSUFBSUMsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFDQyxHQUFELEVBQU1DLEdBQU4sRUFBV0MsS0FBWDtFQUFBLE9BQXFCRCxHQUFHLElBQUlELEdBQVAsR0FBYVgsU0FBUyxDQUFDVyxHQUFELEVBQU1DLEdBQU4sRUFBVztJQUFFRSxVQUFVLEVBQUUsSUFBZDtJQUFvQkMsWUFBWSxFQUFFLElBQWxDO0lBQXdDQyxRQUFRLEVBQUUsSUFBbEQ7SUFBd0RILEtBQUssRUFBTEE7RUFBeEQsQ0FBWCxDQUF0QixHQUFvR0YsR0FBRyxDQUFDQyxHQUFELENBQUgsR0FBV0MsS0FBcEk7QUFBQSxDQUF0Qjs7QUFDQSxJQUFJSSxjQUFjLEdBQUcsU0FBakJBLGNBQWlCLENBQUNDLENBQUQsRUFBSUMsQ0FBSixFQUFVO0VBQzdCLEtBQUssSUFBSUMsSUFBVCxJQUFpQkQsQ0FBQyxLQUFLQSxDQUFDLEdBQUcsRUFBVCxDQUFsQjtJQUNFLElBQUlkLFlBQVksQ0FBQ2dCLElBQWIsQ0FBa0JGLENBQWxCLEVBQXFCQyxJQUFyQixDQUFKLEVBQ0VWLGVBQWUsQ0FBQ1EsQ0FBRCxFQUFJRSxJQUFKLEVBQVVELENBQUMsQ0FBQ0MsSUFBRCxDQUFYLENBQWY7RUFGSjs7RUFHQSxJQUFJakIsbUJBQUo7SUFBQSw4S0FDbUJBLG1CQUFtQixDQUFDZ0IsQ0FBRCxDQUR0QztJQUFBOztJQUFBO01BQ0Usb0RBQXlDO1FBQUEsSUFBaENDLElBQWdDO1FBQ3ZDLElBQUlaLFlBQVksQ0FBQ2EsSUFBYixDQUFrQkYsQ0FBbEIsRUFBcUJDLElBQXJCLENBQUosRUFDRVYsZUFBZSxDQUFDUSxDQUFELEVBQUlFLElBQUosRUFBVUQsQ0FBQyxDQUFDQyxJQUFELENBQVgsQ0FBZjtNQUNIO0lBSkg7TUFBQTtJQUFBO01BQUE7SUFBQTtFQUFBOztFQUtBLE9BQU9GLENBQVA7QUFDRCxDQVZEOztBQVdBLElBQUlJLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQUNDLE1BQUQsRUFBU0MsT0FBVCxFQUFxQjtFQUNuQyxJQUFJQyxNQUFNLEdBQUcsRUFBYjs7RUFDQSxLQUFLLElBQUlMLElBQVQsSUFBaUJHLE1BQWpCO0lBQ0UsSUFBSWxCLFlBQVksQ0FBQ2dCLElBQWIsQ0FBa0JFLE1BQWxCLEVBQTBCSCxJQUExQixLQUFtQ0ksT0FBTyxDQUFDRSxPQUFSLENBQWdCTixJQUFoQixJQUF3QixDQUEvRCxFQUNFSyxNQUFNLENBQUNMLElBQUQsQ0FBTixHQUFlRyxNQUFNLENBQUNILElBQUQsQ0FBckI7RUFGSjs7RUFHQSxJQUFJRyxNQUFNLElBQUksSUFBVixJQUFrQnBCLG1CQUF0QjtJQUFBLCtLQUNtQkEsbUJBQW1CLENBQUNvQixNQUFELENBRHRDO0lBQUE7O0lBQUE7TUFDRSx1REFBOEM7UUFBQSxJQUFyQ0gsSUFBcUM7UUFDNUMsSUFBSUksT0FBTyxDQUFDRSxPQUFSLENBQWdCTixJQUFoQixJQUF3QixDQUF4QixJQUE2QlosWUFBWSxDQUFDYSxJQUFiLENBQWtCRSxNQUFsQixFQUEwQkgsSUFBMUIsQ0FBakMsRUFDRUssTUFBTSxDQUFDTCxJQUFELENBQU4sR0FBZUcsTUFBTSxDQUFDSCxJQUFELENBQXJCO01BQ0g7SUFKSDtNQUFBO0lBQUE7TUFBQTtJQUFBO0VBQUE7O0VBS0EsT0FBT0ssTUFBUDtBQUNELENBWEQsQyxDQWFBOzs7Q0FHQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLElBQUlFLFNBQUo7O0FBQ0EsQ0FBQyxVQUFDQyxVQUFELEVBQWdCO0VBQ2YsSUFBTUMsT0FBTztJQUNYLGlCQUFZQyxPQUFaLEVBQXFCQyxvQkFBckIsRUFBMkNDLGFBQTNDLEVBQTBEQyxHQUExRCxFQUErRDtNQUFBOztNQUM3RCxLQUFLSCxPQUFMLEdBQWVBLE9BQWY7TUFDQSxLQUFLQyxvQkFBTCxHQUE0QkEsb0JBQTVCO01BQ0EsS0FBS0csT0FBTCxHQUFlLEVBQWY7TUFDQSxLQUFLQyxVQUFMLEdBQWtCLEVBQWxCO01BQ0EsSUFBSUwsT0FBTyxHQUFHRCxPQUFPLENBQUNPLFdBQWxCLElBQWlDTixPQUFPLEdBQUdELE9BQU8sQ0FBQ1EsV0FBdkQsRUFDRSxNQUFNLElBQUlDLFVBQUosQ0FBZSw0QkFBZixDQUFOO01BQ0YsSUFBSUwsR0FBRyxHQUFHLENBQUMsQ0FBUCxJQUFZQSxHQUFHLEdBQUcsQ0FBdEIsRUFDRSxNQUFNLElBQUlLLFVBQUosQ0FBZSx5QkFBZixDQUFOO01BQ0YsS0FBS0MsSUFBTCxHQUFZVCxPQUFPLEdBQUcsQ0FBVixHQUFjLEVBQTFCO01BQ0EsSUFBSVUsR0FBRyxHQUFHLEVBQVY7O01BQ0EsS0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtGLElBQXpCLEVBQStCRSxDQUFDLEVBQWhDO1FBQ0VELEdBQUcsQ0FBQ0UsSUFBSixDQUFTLEtBQVQ7TUFERjs7TUFFQSxLQUFLLElBQUlELEVBQUMsR0FBRyxDQUFiLEVBQWdCQSxFQUFDLEdBQUcsS0FBS0YsSUFBekIsRUFBK0JFLEVBQUMsRUFBaEMsRUFBb0M7UUFDbEMsS0FBS1AsT0FBTCxDQUFhUSxJQUFiLENBQWtCRixHQUFHLENBQUNHLEtBQUosRUFBbEI7UUFDQSxLQUFLUixVQUFMLENBQWdCTyxJQUFoQixDQUFxQkYsR0FBRyxDQUFDRyxLQUFKLEVBQXJCO01BQ0Q7O01BQ0QsS0FBS0Msb0JBQUw7TUFDQSxJQUFNQyxZQUFZLEdBQUcsS0FBS0MsbUJBQUwsQ0FBeUJkLGFBQXpCLENBQXJCO01BQ0EsS0FBS2UsYUFBTCxDQUFtQkYsWUFBbkI7O01BQ0EsSUFBSVosR0FBRyxJQUFJLENBQUMsQ0FBWixFQUFlO1FBQ2IsSUFBSWUsVUFBVSxHQUFHLEdBQWpCOztRQUNBLEtBQUssSUFBSVAsR0FBQyxHQUFHLENBQWIsRUFBZ0JBLEdBQUMsR0FBRyxDQUFwQixFQUF1QkEsR0FBQyxFQUF4QixFQUE0QjtVQUMxQixLQUFLUSxTQUFMLENBQWVSLEdBQWY7VUFDQSxLQUFLUyxjQUFMLENBQW9CVCxHQUFwQjtVQUNBLElBQU1VLE9BQU8sR0FBRyxLQUFLQyxlQUFMLEVBQWhCOztVQUNBLElBQUlELE9BQU8sR0FBR0gsVUFBZCxFQUEwQjtZQUN4QmYsR0FBRyxHQUFHUSxHQUFOO1lBQ0FPLFVBQVUsR0FBR0csT0FBYjtVQUNEOztVQUNELEtBQUtGLFNBQUwsQ0FBZVIsR0FBZjtRQUNEO01BQ0Y7O01BQ0RZLE1BQU0sQ0FBQyxLQUFLcEIsR0FBTCxJQUFZQSxHQUFHLElBQUksQ0FBcEIsQ0FBTjtNQUNBLEtBQUtxQixJQUFMLEdBQVlyQixHQUFaO01BQ0EsS0FBS2dCLFNBQUwsQ0FBZWhCLEdBQWY7TUFDQSxLQUFLaUIsY0FBTCxDQUFvQmpCLEdBQXBCO01BQ0EsS0FBS0UsVUFBTCxHQUFrQixFQUFsQjtJQUNEOztJQXZDVTtNQUFBO01BQUEsT0F3RlgsbUJBQVVvQixDQUFWLEVBQWFDLENBQWIsRUFBZ0I7UUFDZCxPQUFPLEtBQUtELENBQUwsSUFBVUEsQ0FBQyxHQUFHLEtBQUtoQixJQUFuQixJQUEyQixLQUFLaUIsQ0FBaEMsSUFBcUNBLENBQUMsR0FBRyxLQUFLakIsSUFBOUMsSUFBc0QsS0FBS0wsT0FBTCxDQUFhc0IsQ0FBYixFQUFnQkQsQ0FBaEIsQ0FBN0Q7TUFDRDtJQTFGVTtNQUFBO01BQUEsT0EyRlgsc0JBQWE7UUFDWCxPQUFPLEtBQUtyQixPQUFaO01BQ0Q7SUE3RlU7TUFBQTtNQUFBLE9BOEZYLGdDQUF1QjtRQUNyQixLQUFLLElBQUlPLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS0YsSUFBekIsRUFBK0JFLENBQUMsRUFBaEMsRUFBb0M7VUFDbEMsS0FBS2dCLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCaEIsQ0FBMUIsRUFBNkJBLENBQUMsR0FBRyxDQUFKLElBQVMsQ0FBdEM7VUFDQSxLQUFLZ0IsaUJBQUwsQ0FBdUJoQixDQUF2QixFQUEwQixDQUExQixFQUE2QkEsQ0FBQyxHQUFHLENBQUosSUFBUyxDQUF0QztRQUNEOztRQUNELEtBQUtpQixpQkFBTCxDQUF1QixDQUF2QixFQUEwQixDQUExQjtRQUNBLEtBQUtBLGlCQUFMLENBQXVCLEtBQUtuQixJQUFMLEdBQVksQ0FBbkMsRUFBc0MsQ0FBdEM7UUFDQSxLQUFLbUIsaUJBQUwsQ0FBdUIsQ0FBdkIsRUFBMEIsS0FBS25CLElBQUwsR0FBWSxDQUF0QztRQUNBLElBQU1vQixXQUFXLEdBQUcsS0FBS0MsNEJBQUwsRUFBcEI7UUFDQSxJQUFNQyxRQUFRLEdBQUdGLFdBQVcsQ0FBQ0csTUFBN0I7O1FBQ0EsS0FBSyxJQUFJckIsR0FBQyxHQUFHLENBQWIsRUFBZ0JBLEdBQUMsR0FBR29CLFFBQXBCLEVBQThCcEIsR0FBQyxFQUEvQixFQUFtQztVQUNqQyxLQUFLLElBQUlzQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHRixRQUFwQixFQUE4QkUsQ0FBQyxFQUEvQixFQUFtQztZQUNqQyxJQUFJLEVBQUV0QixHQUFDLElBQUksQ0FBTCxJQUFVc0IsQ0FBQyxJQUFJLENBQWYsSUFBb0J0QixHQUFDLElBQUksQ0FBTCxJQUFVc0IsQ0FBQyxJQUFJRixRQUFRLEdBQUcsQ0FBOUMsSUFBbURwQixHQUFDLElBQUlvQixRQUFRLEdBQUcsQ0FBaEIsSUFBcUJFLENBQUMsSUFBSSxDQUEvRSxDQUFKLEVBQ0UsS0FBS0Msb0JBQUwsQ0FBMEJMLFdBQVcsQ0FBQ2xCLEdBQUQsQ0FBckMsRUFBMENrQixXQUFXLENBQUNJLENBQUQsQ0FBckQ7VUFDSDtRQUNGOztRQUNELEtBQUtiLGNBQUwsQ0FBb0IsQ0FBcEI7UUFDQSxLQUFLZSxXQUFMO01BQ0Q7SUFoSFU7TUFBQTtNQUFBLE9BaUhYLHdCQUFlWCxJQUFmLEVBQXFCO1FBQ25CLElBQU1ZLElBQUksR0FBRyxLQUFLbkMsb0JBQUwsQ0FBMEJvQyxVQUExQixJQUF3QyxDQUF4QyxHQUE0Q2IsSUFBekQ7UUFDQSxJQUFJYyxHQUFHLEdBQUdGLElBQVY7O1FBQ0EsS0FBSyxJQUFJekIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxFQUFwQixFQUF3QkEsQ0FBQyxFQUF6QjtVQUNFMkIsR0FBRyxHQUFHQSxHQUFHLElBQUksQ0FBUCxHQUFXLENBQUNBLEdBQUcsS0FBSyxDQUFULElBQWMsSUFBL0I7UUFERjs7UUFFQSxJQUFNQyxJQUFJLEdBQUcsQ0FBQ0gsSUFBSSxJQUFJLEVBQVIsR0FBYUUsR0FBZCxJQUFxQixLQUFsQztRQUNBZixNQUFNLENBQUNnQixJQUFJLEtBQUssRUFBVCxJQUFlLENBQWhCLENBQU47O1FBQ0EsS0FBSyxJQUFJNUIsR0FBQyxHQUFHLENBQWIsRUFBZ0JBLEdBQUMsSUFBSSxDQUFyQixFQUF3QkEsR0FBQyxFQUF6QjtVQUNFLEtBQUtnQixpQkFBTCxDQUF1QixDQUF2QixFQUEwQmhCLEdBQTFCLEVBQTZCNkIsTUFBTSxDQUFDRCxJQUFELEVBQU81QixHQUFQLENBQW5DO1FBREY7O1FBRUEsS0FBS2dCLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCYSxNQUFNLENBQUNELElBQUQsRUFBTyxDQUFQLENBQW5DO1FBQ0EsS0FBS1osaUJBQUwsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkJhLE1BQU0sQ0FBQ0QsSUFBRCxFQUFPLENBQVAsQ0FBbkM7UUFDQSxLQUFLWixpQkFBTCxDQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QmEsTUFBTSxDQUFDRCxJQUFELEVBQU8sQ0FBUCxDQUFuQzs7UUFDQSxLQUFLLElBQUk1QixHQUFDLEdBQUcsQ0FBYixFQUFnQkEsR0FBQyxHQUFHLEVBQXBCLEVBQXdCQSxHQUFDLEVBQXpCO1VBQ0UsS0FBS2dCLGlCQUFMLENBQXVCLEtBQUtoQixHQUE1QixFQUErQixDQUEvQixFQUFrQzZCLE1BQU0sQ0FBQ0QsSUFBRCxFQUFPNUIsR0FBUCxDQUF4QztRQURGOztRQUVBLEtBQUssSUFBSUEsR0FBQyxHQUFHLENBQWIsRUFBZ0JBLEdBQUMsR0FBRyxDQUFwQixFQUF1QkEsR0FBQyxFQUF4QjtVQUNFLEtBQUtnQixpQkFBTCxDQUF1QixLQUFLbEIsSUFBTCxHQUFZLENBQVosR0FBZ0JFLEdBQXZDLEVBQTBDLENBQTFDLEVBQTZDNkIsTUFBTSxDQUFDRCxJQUFELEVBQU81QixHQUFQLENBQW5EO1FBREY7O1FBRUEsS0FBSyxJQUFJQSxHQUFDLEdBQUcsQ0FBYixFQUFnQkEsR0FBQyxHQUFHLEVBQXBCLEVBQXdCQSxHQUFDLEVBQXpCO1VBQ0UsS0FBS2dCLGlCQUFMLENBQXVCLENBQXZCLEVBQTBCLEtBQUtsQixJQUFMLEdBQVksRUFBWixHQUFpQkUsR0FBM0MsRUFBOEM2QixNQUFNLENBQUNELElBQUQsRUFBTzVCLEdBQVAsQ0FBcEQ7UUFERjs7UUFFQSxLQUFLZ0IsaUJBQUwsQ0FBdUIsQ0FBdkIsRUFBMEIsS0FBS2xCLElBQUwsR0FBWSxDQUF0QyxFQUF5QyxJQUF6QztNQUNEO0lBcElVO01BQUE7TUFBQSxPQXFJWCx1QkFBYztRQUNaLElBQUksS0FBS1QsT0FBTCxHQUFlLENBQW5CLEVBQ0U7UUFDRixJQUFJc0MsR0FBRyxHQUFHLEtBQUt0QyxPQUFmOztRQUNBLEtBQUssSUFBSVcsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxFQUFwQixFQUF3QkEsQ0FBQyxFQUF6QjtVQUNFMkIsR0FBRyxHQUFHQSxHQUFHLElBQUksQ0FBUCxHQUFXLENBQUNBLEdBQUcsS0FBSyxFQUFULElBQWUsSUFBaEM7UUFERjs7UUFFQSxJQUFNQyxJQUFJLEdBQUcsS0FBS3ZDLE9BQUwsSUFBZ0IsRUFBaEIsR0FBcUJzQyxHQUFsQztRQUNBZixNQUFNLENBQUNnQixJQUFJLEtBQUssRUFBVCxJQUFlLENBQWhCLENBQU47O1FBQ0EsS0FBSyxJQUFJNUIsR0FBQyxHQUFHLENBQWIsRUFBZ0JBLEdBQUMsR0FBRyxFQUFwQixFQUF3QkEsR0FBQyxFQUF6QixFQUE2QjtVQUMzQixJQUFNOEIsS0FBSyxHQUFHRCxNQUFNLENBQUNELElBQUQsRUFBTzVCLEdBQVAsQ0FBcEI7VUFDQSxJQUFNdkIsQ0FBQyxHQUFHLEtBQUtxQixJQUFMLEdBQVksRUFBWixHQUFpQkUsR0FBQyxHQUFHLENBQS9CO1VBQ0EsSUFBTXRCLENBQUMsR0FBR3FELElBQUksQ0FBQ0MsS0FBTCxDQUFXaEMsR0FBQyxHQUFHLENBQWYsQ0FBVjtVQUNBLEtBQUtnQixpQkFBTCxDQUF1QnZDLENBQXZCLEVBQTBCQyxDQUExQixFQUE2Qm9ELEtBQTdCO1VBQ0EsS0FBS2QsaUJBQUwsQ0FBdUJ0QyxDQUF2QixFQUEwQkQsQ0FBMUIsRUFBNkJxRCxLQUE3QjtRQUNEO01BQ0Y7SUFwSlU7TUFBQTtNQUFBLE9BcUpYLDJCQUFrQmhCLENBQWxCLEVBQXFCQyxDQUFyQixFQUF3QjtRQUN0QixLQUFLLElBQUlrQixFQUFFLEdBQUcsQ0FBQyxDQUFmLEVBQWtCQSxFQUFFLElBQUksQ0FBeEIsRUFBMkJBLEVBQUUsRUFBN0IsRUFBaUM7VUFDL0IsS0FBSyxJQUFJQyxFQUFFLEdBQUcsQ0FBQyxDQUFmLEVBQWtCQSxFQUFFLElBQUksQ0FBeEIsRUFBMkJBLEVBQUUsRUFBN0IsRUFBaUM7WUFDL0IsSUFBTUMsSUFBSSxHQUFHSixJQUFJLENBQUNLLEdBQUwsQ0FBU0wsSUFBSSxDQUFDTSxHQUFMLENBQVNILEVBQVQsQ0FBVCxFQUF1QkgsSUFBSSxDQUFDTSxHQUFMLENBQVNKLEVBQVQsQ0FBdkIsQ0FBYjtZQUNBLElBQU1LLEVBQUUsR0FBR3hCLENBQUMsR0FBR29CLEVBQWY7WUFDQSxJQUFNSyxFQUFFLEdBQUd4QixDQUFDLEdBQUdrQixFQUFmO1lBQ0EsSUFBSSxLQUFLSyxFQUFMLElBQVdBLEVBQUUsR0FBRyxLQUFLeEMsSUFBckIsSUFBNkIsS0FBS3lDLEVBQWxDLElBQXdDQSxFQUFFLEdBQUcsS0FBS3pDLElBQXRELEVBQ0UsS0FBS2tCLGlCQUFMLENBQXVCc0IsRUFBdkIsRUFBMkJDLEVBQTNCLEVBQStCSixJQUFJLElBQUksQ0FBUixJQUFhQSxJQUFJLElBQUksQ0FBcEQ7VUFDSDtRQUNGO01BQ0Y7SUEvSlU7TUFBQTtNQUFBLE9BZ0tYLDhCQUFxQnJCLENBQXJCLEVBQXdCQyxDQUF4QixFQUEyQjtRQUN6QixLQUFLLElBQUlrQixFQUFFLEdBQUcsQ0FBQyxDQUFmLEVBQWtCQSxFQUFFLElBQUksQ0FBeEIsRUFBMkJBLEVBQUUsRUFBN0IsRUFBaUM7VUFDL0IsS0FBSyxJQUFJQyxFQUFFLEdBQUcsQ0FBQyxDQUFmLEVBQWtCQSxFQUFFLElBQUksQ0FBeEIsRUFBMkJBLEVBQUUsRUFBN0I7WUFDRSxLQUFLbEIsaUJBQUwsQ0FBdUJGLENBQUMsR0FBR29CLEVBQTNCLEVBQStCbkIsQ0FBQyxHQUFHa0IsRUFBbkMsRUFBdUNGLElBQUksQ0FBQ0ssR0FBTCxDQUFTTCxJQUFJLENBQUNNLEdBQUwsQ0FBU0gsRUFBVCxDQUFULEVBQXVCSCxJQUFJLENBQUNNLEdBQUwsQ0FBU0osRUFBVCxDQUF2QixLQUF3QyxDQUEvRTtVQURGO1FBRUQ7TUFDRjtJQXJLVTtNQUFBO01BQUEsT0FzS1gsMkJBQWtCbkIsQ0FBbEIsRUFBcUJDLENBQXJCLEVBQXdCeUIsTUFBeEIsRUFBZ0M7UUFDOUIsS0FBSy9DLE9BQUwsQ0FBYXNCLENBQWIsRUFBZ0JELENBQWhCLElBQXFCMEIsTUFBckI7UUFDQSxLQUFLOUMsVUFBTCxDQUFnQnFCLENBQWhCLEVBQW1CRCxDQUFuQixJQUF3QixJQUF4QjtNQUNEO0lBektVO01BQUE7TUFBQSxPQTBLWCw2QkFBb0JXLElBQXBCLEVBQTBCO1FBQ3hCLElBQU1nQixHQUFHLEdBQUcsS0FBS3BELE9BQWpCO1FBQ0EsSUFBTXFELEdBQUcsR0FBRyxLQUFLcEQsb0JBQWpCO1FBQ0EsSUFBSW1DLElBQUksQ0FBQ0osTUFBTCxJQUFlakMsT0FBTyxDQUFDdUQsbUJBQVIsQ0FBNEJGLEdBQTVCLEVBQWlDQyxHQUFqQyxDQUFuQixFQUNFLE1BQU0sSUFBSTdDLFVBQUosQ0FBZSxrQkFBZixDQUFOO1FBQ0YsSUFBTStDLFNBQVMsR0FBR3hELE9BQU8sQ0FBQ3lELDJCQUFSLENBQW9DSCxHQUFHLENBQUNJLE9BQXhDLEVBQWlETCxHQUFqRCxDQUFsQjtRQUNBLElBQU1NLFdBQVcsR0FBRzNELE9BQU8sQ0FBQzRELHVCQUFSLENBQWdDTixHQUFHLENBQUNJLE9BQXBDLEVBQTZDTCxHQUE3QyxDQUFwQjtRQUNBLElBQU1RLFlBQVksR0FBR2xCLElBQUksQ0FBQ0MsS0FBTCxDQUFXNUMsT0FBTyxDQUFDOEQsb0JBQVIsQ0FBNkJULEdBQTdCLElBQW9DLENBQS9DLENBQXJCO1FBQ0EsSUFBTVUsY0FBYyxHQUFHUCxTQUFTLEdBQUdLLFlBQVksR0FBR0wsU0FBbEQ7UUFDQSxJQUFNUSxhQUFhLEdBQUdyQixJQUFJLENBQUNDLEtBQUwsQ0FBV2lCLFlBQVksR0FBR0wsU0FBMUIsQ0FBdEI7UUFDQSxJQUFJUyxNQUFNLEdBQUcsRUFBYjs7UUFDQSxJQUFNQyxLQUFLLEdBQUdsRSxPQUFPLENBQUNtRSx5QkFBUixDQUFrQ1IsV0FBbEMsQ0FBZDs7UUFDQSxLQUFLLElBQUkvQyxDQUFDLEdBQUcsQ0FBUixFQUFXd0QsQ0FBQyxHQUFHLENBQXBCLEVBQXVCeEQsQ0FBQyxHQUFHNEMsU0FBM0IsRUFBc0M1QyxDQUFDLEVBQXZDLEVBQTJDO1VBQ3pDLElBQUl5RCxHQUFHLEdBQUdoQyxJQUFJLENBQUN2QixLQUFMLENBQVdzRCxDQUFYLEVBQWNBLENBQUMsR0FBR0osYUFBSixHQUFvQkwsV0FBcEIsSUFBbUMvQyxDQUFDLEdBQUdtRCxjQUFKLEdBQXFCLENBQXJCLEdBQXlCLENBQTVELENBQWQsQ0FBVjtVQUNBSyxDQUFDLElBQUlDLEdBQUcsQ0FBQ3BDLE1BQVQ7O1VBQ0EsSUFBTXFDLEdBQUcsR0FBR3RFLE9BQU8sQ0FBQ3VFLDJCQUFSLENBQW9DRixHQUFwQyxFQUF5Q0gsS0FBekMsQ0FBWjs7VUFDQSxJQUFJdEQsQ0FBQyxHQUFHbUQsY0FBUixFQUNFTSxHQUFHLENBQUN4RCxJQUFKLENBQVMsQ0FBVDtVQUNGb0QsTUFBTSxDQUFDcEQsSUFBUCxDQUFZd0QsR0FBRyxDQUFDRyxNQUFKLENBQVdGLEdBQVgsQ0FBWjtRQUNEOztRQUNELElBQUlHLE1BQU0sR0FBRyxFQUFiOztRQXBCd0IsMkJBcUJmN0QsR0FyQmU7VUFzQnRCcUQsTUFBTSxDQUFDUyxPQUFQLENBQWUsVUFBQ0MsS0FBRCxFQUFRekMsQ0FBUixFQUFjO1lBQzNCLElBQUl0QixHQUFDLElBQUlvRCxhQUFhLEdBQUdMLFdBQXJCLElBQW9DekIsQ0FBQyxJQUFJNkIsY0FBN0MsRUFDRVUsTUFBTSxDQUFDNUQsSUFBUCxDQUFZOEQsS0FBSyxDQUFDL0QsR0FBRCxDQUFqQjtVQUNILENBSEQ7UUF0QnNCOztRQXFCeEIsS0FBSyxJQUFJQSxHQUFDLEdBQUcsQ0FBYixFQUFnQkEsR0FBQyxHQUFHcUQsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVaEMsTUFBOUIsRUFBc0NyQixHQUFDLEVBQXZDLEVBQTJDO1VBQUEsTUFBbENBLEdBQWtDO1FBSzFDOztRQUNEWSxNQUFNLENBQUNpRCxNQUFNLENBQUN4QyxNQUFQLElBQWlCNEIsWUFBbEIsQ0FBTjtRQUNBLE9BQU9ZLE1BQVA7TUFDRDtJQXZNVTtNQUFBO01BQUEsT0F3TVgsdUJBQWNwQyxJQUFkLEVBQW9CO1FBQ2xCLElBQUlBLElBQUksQ0FBQ0osTUFBTCxJQUFlVSxJQUFJLENBQUNDLEtBQUwsQ0FBVzVDLE9BQU8sQ0FBQzhELG9CQUFSLENBQTZCLEtBQUs3RCxPQUFsQyxJQUE2QyxDQUF4RCxDQUFuQixFQUNFLE1BQU0sSUFBSVEsVUFBSixDQUFlLGtCQUFmLENBQU47UUFDRixJQUFJRyxDQUFDLEdBQUcsQ0FBUjs7UUFDQSxLQUFLLElBQUlnRSxLQUFLLEdBQUcsS0FBS2xFLElBQUwsR0FBWSxDQUE3QixFQUFnQ2tFLEtBQUssSUFBSSxDQUF6QyxFQUE0Q0EsS0FBSyxJQUFJLENBQXJELEVBQXdEO1VBQ3RELElBQUlBLEtBQUssSUFBSSxDQUFiLEVBQ0VBLEtBQUssR0FBRyxDQUFSOztVQUNGLEtBQUssSUFBSUMsSUFBSSxHQUFHLENBQWhCLEVBQW1CQSxJQUFJLEdBQUcsS0FBS25FLElBQS9CLEVBQXFDbUUsSUFBSSxFQUF6QyxFQUE2QztZQUMzQyxLQUFLLElBQUkzQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLENBQXBCLEVBQXVCQSxDQUFDLEVBQXhCLEVBQTRCO2NBQzFCLElBQU1SLENBQUMsR0FBR2tELEtBQUssR0FBRzFDLENBQWxCO2NBQ0EsSUFBTTRDLE1BQU0sR0FBRyxDQUFDRixLQUFLLEdBQUcsQ0FBUixHQUFZLENBQWIsS0FBbUIsQ0FBbEM7Y0FDQSxJQUFNakQsQ0FBQyxHQUFHbUQsTUFBTSxHQUFHLEtBQUtwRSxJQUFMLEdBQVksQ0FBWixHQUFnQm1FLElBQW5CLEdBQTBCQSxJQUExQzs7Y0FDQSxJQUFJLENBQUMsS0FBS3ZFLFVBQUwsQ0FBZ0JxQixDQUFoQixFQUFtQkQsQ0FBbkIsQ0FBRCxJQUEwQmQsQ0FBQyxHQUFHeUIsSUFBSSxDQUFDSixNQUFMLEdBQWMsQ0FBaEQsRUFBbUQ7Z0JBQ2pELEtBQUs1QixPQUFMLENBQWFzQixDQUFiLEVBQWdCRCxDQUFoQixJQUFxQmUsTUFBTSxDQUFDSixJQUFJLENBQUN6QixDQUFDLEtBQUssQ0FBUCxDQUFMLEVBQWdCLEtBQUtBLENBQUMsR0FBRyxDQUFULENBQWhCLENBQTNCO2dCQUNBQSxDQUFDO2NBQ0Y7WUFDRjtVQUNGO1FBQ0Y7O1FBQ0RZLE1BQU0sQ0FBQ1osQ0FBQyxJQUFJeUIsSUFBSSxDQUFDSixNQUFMLEdBQWMsQ0FBcEIsQ0FBTjtNQUNEO0lBNU5VO01BQUE7TUFBQSxPQTZOWCxtQkFBVVIsSUFBVixFQUFnQjtRQUNkLElBQUlBLElBQUksR0FBRyxDQUFQLElBQVlBLElBQUksR0FBRyxDQUF2QixFQUNFLE1BQU0sSUFBSWhCLFVBQUosQ0FBZSx5QkFBZixDQUFOOztRQUNGLEtBQUssSUFBSWtCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS2pCLElBQXpCLEVBQStCaUIsQ0FBQyxFQUFoQyxFQUFvQztVQUNsQyxLQUFLLElBQUlELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS2hCLElBQXpCLEVBQStCZ0IsQ0FBQyxFQUFoQyxFQUFvQztZQUNsQyxJQUFJcUQsTUFBTSxTQUFWOztZQUNBLFFBQVF0RCxJQUFSO2NBQ0UsS0FBSyxDQUFMO2dCQUNFc0QsTUFBTSxHQUFHLENBQUNyRCxDQUFDLEdBQUdDLENBQUwsSUFBVSxDQUFWLElBQWUsQ0FBeEI7Z0JBQ0E7O2NBQ0YsS0FBSyxDQUFMO2dCQUNFb0QsTUFBTSxHQUFHcEQsQ0FBQyxHQUFHLENBQUosSUFBUyxDQUFsQjtnQkFDQTs7Y0FDRixLQUFLLENBQUw7Z0JBQ0VvRCxNQUFNLEdBQUdyRCxDQUFDLEdBQUcsQ0FBSixJQUFTLENBQWxCO2dCQUNBOztjQUNGLEtBQUssQ0FBTDtnQkFDRXFELE1BQU0sR0FBRyxDQUFDckQsQ0FBQyxHQUFHQyxDQUFMLElBQVUsQ0FBVixJQUFlLENBQXhCO2dCQUNBOztjQUNGLEtBQUssQ0FBTDtnQkFDRW9ELE1BQU0sR0FBRyxDQUFDcEMsSUFBSSxDQUFDQyxLQUFMLENBQVdsQixDQUFDLEdBQUcsQ0FBZixJQUFvQmlCLElBQUksQ0FBQ0MsS0FBTCxDQUFXakIsQ0FBQyxHQUFHLENBQWYsQ0FBckIsSUFBMEMsQ0FBMUMsSUFBK0MsQ0FBeEQ7Z0JBQ0E7O2NBQ0YsS0FBSyxDQUFMO2dCQUNFb0QsTUFBTSxHQUFHckQsQ0FBQyxHQUFHQyxDQUFKLEdBQVEsQ0FBUixHQUFZRCxDQUFDLEdBQUdDLENBQUosR0FBUSxDQUFwQixJQUF5QixDQUFsQztnQkFDQTs7Y0FDRixLQUFLLENBQUw7Z0JBQ0VvRCxNQUFNLEdBQUcsQ0FBQ3JELENBQUMsR0FBR0MsQ0FBSixHQUFRLENBQVIsR0FBWUQsQ0FBQyxHQUFHQyxDQUFKLEdBQVEsQ0FBckIsSUFBMEIsQ0FBMUIsSUFBK0IsQ0FBeEM7Z0JBQ0E7O2NBQ0YsS0FBSyxDQUFMO2dCQUNFb0QsTUFBTSxHQUFHLENBQUMsQ0FBQ3JELENBQUMsR0FBR0MsQ0FBTCxJQUFVLENBQVYsR0FBY0QsQ0FBQyxHQUFHQyxDQUFKLEdBQVEsQ0FBdkIsSUFBNEIsQ0FBNUIsSUFBaUMsQ0FBMUM7Z0JBQ0E7O2NBQ0Y7Z0JBQ0UsTUFBTSxJQUFJcUQsS0FBSixDQUFVLGFBQVYsQ0FBTjtZQTFCSjs7WUE0QkEsSUFBSSxDQUFDLEtBQUsxRSxVQUFMLENBQWdCcUIsQ0FBaEIsRUFBbUJELENBQW5CLENBQUQsSUFBMEJxRCxNQUE5QixFQUNFLEtBQUsxRSxPQUFMLENBQWFzQixDQUFiLEVBQWdCRCxDQUFoQixJQUFxQixDQUFDLEtBQUtyQixPQUFMLENBQWFzQixDQUFiLEVBQWdCRCxDQUFoQixDQUF0QjtVQUNIO1FBQ0Y7TUFDRjtJQW5RVTtNQUFBO01BQUEsT0FvUVgsMkJBQWtCO1FBQ2hCLElBQUkrQyxNQUFNLEdBQUcsQ0FBYjs7UUFDQSxLQUFLLElBQUk5QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtqQixJQUF6QixFQUErQmlCLENBQUMsRUFBaEMsRUFBb0M7VUFDbEMsSUFBSXNELFFBQVEsR0FBRyxLQUFmO1VBQ0EsSUFBSUMsSUFBSSxHQUFHLENBQVg7VUFDQSxJQUFJQyxVQUFVLEdBQUcsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixDQUFqQjs7VUFDQSxLQUFLLElBQUl6RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtoQixJQUF6QixFQUErQmdCLENBQUMsRUFBaEMsRUFBb0M7WUFDbEMsSUFBSSxLQUFLckIsT0FBTCxDQUFhc0IsQ0FBYixFQUFnQkQsQ0FBaEIsS0FBc0J1RCxRQUExQixFQUFvQztjQUNsQ0MsSUFBSTtjQUNKLElBQUlBLElBQUksSUFBSSxDQUFaLEVBQ0VULE1BQU0sSUFBSXpFLE9BQU8sQ0FBQ29GLFVBQWxCLENBREYsS0FFSyxJQUFJRixJQUFJLEdBQUcsQ0FBWCxFQUNIVCxNQUFNO1lBQ1QsQ0FORCxNQU1PO2NBQ0wsS0FBS1ksdUJBQUwsQ0FBNkJILElBQTdCLEVBQW1DQyxVQUFuQztjQUNBLElBQUksQ0FBQ0YsUUFBTCxFQUNFUixNQUFNLElBQUksS0FBS2EsMEJBQUwsQ0FBZ0NILFVBQWhDLElBQThDbkYsT0FBTyxDQUFDdUYsVUFBaEU7Y0FDRk4sUUFBUSxHQUFHLEtBQUs1RSxPQUFMLENBQWFzQixDQUFiLEVBQWdCRCxDQUFoQixDQUFYO2NBQ0F3RCxJQUFJLEdBQUcsQ0FBUDtZQUNEO1VBQ0Y7O1VBQ0RULE1BQU0sSUFBSSxLQUFLZSw4QkFBTCxDQUFvQ1AsUUFBcEMsRUFBOENDLElBQTlDLEVBQW9EQyxVQUFwRCxJQUFrRW5GLE9BQU8sQ0FBQ3VGLFVBQXBGO1FBQ0Q7O1FBQ0QsS0FBSyxJQUFJN0QsRUFBQyxHQUFHLENBQWIsRUFBZ0JBLEVBQUMsR0FBRyxLQUFLaEIsSUFBekIsRUFBK0JnQixFQUFDLEVBQWhDLEVBQW9DO1VBQ2xDLElBQUl1RCxTQUFRLEdBQUcsS0FBZjtVQUNBLElBQUlRLElBQUksR0FBRyxDQUFYO1VBQ0EsSUFBSU4sV0FBVSxHQUFHLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsQ0FBbkIsQ0FBakI7O1VBQ0EsS0FBSyxJQUFJeEQsRUFBQyxHQUFHLENBQWIsRUFBZ0JBLEVBQUMsR0FBRyxLQUFLakIsSUFBekIsRUFBK0JpQixFQUFDLEVBQWhDLEVBQW9DO1lBQ2xDLElBQUksS0FBS3RCLE9BQUwsQ0FBYXNCLEVBQWIsRUFBZ0JELEVBQWhCLEtBQXNCdUQsU0FBMUIsRUFBb0M7Y0FDbENRLElBQUk7Y0FDSixJQUFJQSxJQUFJLElBQUksQ0FBWixFQUNFaEIsTUFBTSxJQUFJekUsT0FBTyxDQUFDb0YsVUFBbEIsQ0FERixLQUVLLElBQUlLLElBQUksR0FBRyxDQUFYLEVBQ0hoQixNQUFNO1lBQ1QsQ0FORCxNQU1PO2NBQ0wsS0FBS1ksdUJBQUwsQ0FBNkJJLElBQTdCLEVBQW1DTixXQUFuQztjQUNBLElBQUksQ0FBQ0YsU0FBTCxFQUNFUixNQUFNLElBQUksS0FBS2EsMEJBQUwsQ0FBZ0NILFdBQWhDLElBQThDbkYsT0FBTyxDQUFDdUYsVUFBaEU7Y0FDRk4sU0FBUSxHQUFHLEtBQUs1RSxPQUFMLENBQWFzQixFQUFiLEVBQWdCRCxFQUFoQixDQUFYO2NBQ0ErRCxJQUFJLEdBQUcsQ0FBUDtZQUNEO1VBQ0Y7O1VBQ0RoQixNQUFNLElBQUksS0FBS2UsOEJBQUwsQ0FBb0NQLFNBQXBDLEVBQThDUSxJQUE5QyxFQUFvRE4sV0FBcEQsSUFBa0VuRixPQUFPLENBQUN1RixVQUFwRjtRQUNEOztRQUNELEtBQUssSUFBSTVELEdBQUMsR0FBRyxDQUFiLEVBQWdCQSxHQUFDLEdBQUcsS0FBS2pCLElBQUwsR0FBWSxDQUFoQyxFQUFtQ2lCLEdBQUMsRUFBcEMsRUFBd0M7VUFDdEMsS0FBSyxJQUFJRCxHQUFDLEdBQUcsQ0FBYixFQUFnQkEsR0FBQyxHQUFHLEtBQUtoQixJQUFMLEdBQVksQ0FBaEMsRUFBbUNnQixHQUFDLEVBQXBDLEVBQXdDO1lBQ3RDLElBQU1nQixLQUFLLEdBQUcsS0FBS3JDLE9BQUwsQ0FBYXNCLEdBQWIsRUFBZ0JELEdBQWhCLENBQWQ7WUFDQSxJQUFJZ0IsS0FBSyxJQUFJLEtBQUtyQyxPQUFMLENBQWFzQixHQUFiLEVBQWdCRCxHQUFDLEdBQUcsQ0FBcEIsQ0FBVCxJQUFtQ2dCLEtBQUssSUFBSSxLQUFLckMsT0FBTCxDQUFhc0IsR0FBQyxHQUFHLENBQWpCLEVBQW9CRCxHQUFwQixDQUE1QyxJQUFzRWdCLEtBQUssSUFBSSxLQUFLckMsT0FBTCxDQUFhc0IsR0FBQyxHQUFHLENBQWpCLEVBQW9CRCxHQUFDLEdBQUcsQ0FBeEIsQ0FBbkYsRUFDRStDLE1BQU0sSUFBSXpFLE9BQU8sQ0FBQzBGLFVBQWxCO1VBQ0g7UUFDRjs7UUFDRCxJQUFJQyxJQUFJLEdBQUcsQ0FBWDs7UUFuRGdCLCtLQW9ERSxLQUFLdEYsT0FwRFA7UUFBQTs7UUFBQTtVQW9EaEIsdURBQ0U7WUFBQSxJQURTTSxHQUNUO1lBQUFnRixJQUFJLEdBQUdoRixHQUFHLENBQUNpRixNQUFKLENBQVcsVUFBQ0MsR0FBRCxFQUFNbkQsS0FBTjtjQUFBLE9BQWdCbUQsR0FBRyxJQUFJbkQsS0FBSyxHQUFHLENBQUgsR0FBTyxDQUFoQixDQUFuQjtZQUFBLENBQVgsRUFBa0RpRCxJQUFsRCxDQUFQO1VBQStEO1FBckRqRDtVQUFBO1FBQUE7VUFBQTtRQUFBOztRQXNEaEIsSUFBTUcsS0FBSyxHQUFHLEtBQUtwRixJQUFMLEdBQVksS0FBS0EsSUFBL0I7UUFDQSxJQUFNMEQsQ0FBQyxHQUFHekIsSUFBSSxDQUFDb0QsSUFBTCxDQUFVcEQsSUFBSSxDQUFDTSxHQUFMLENBQVMwQyxJQUFJLEdBQUcsRUFBUCxHQUFZRyxLQUFLLEdBQUcsRUFBN0IsSUFBbUNBLEtBQTdDLElBQXNELENBQWhFO1FBQ0F0RSxNQUFNLENBQUMsS0FBSzRDLENBQUwsSUFBVUEsQ0FBQyxJQUFJLENBQWhCLENBQU47UUFDQUssTUFBTSxJQUFJTCxDQUFDLEdBQUdwRSxPQUFPLENBQUNnRyxVQUF0QjtRQUNBeEUsTUFBTSxDQUFDLEtBQUtpRCxNQUFMLElBQWVBLE1BQU0sSUFBSSxPQUExQixDQUFOO1FBQ0EsT0FBT0EsTUFBUDtNQUNEO0lBaFVVO01BQUE7TUFBQSxPQWlVWCx3Q0FBK0I7UUFDN0IsSUFBSSxLQUFLeEUsT0FBTCxJQUFnQixDQUFwQixFQUNFLE9BQU8sRUFBUCxDQURGLEtBRUs7VUFDSCxJQUFNK0IsUUFBUSxHQUFHVyxJQUFJLENBQUNDLEtBQUwsQ0FBVyxLQUFLM0MsT0FBTCxHQUFlLENBQTFCLElBQStCLENBQWhEO1VBQ0EsSUFBTWdHLElBQUksR0FBRyxLQUFLaEcsT0FBTCxJQUFnQixFQUFoQixHQUFxQixFQUFyQixHQUEwQjBDLElBQUksQ0FBQ29ELElBQUwsQ0FBVSxDQUFDLEtBQUs5RixPQUFMLEdBQWUsQ0FBZixHQUFtQixDQUFwQixLQUEwQitCLFFBQVEsR0FBRyxDQUFYLEdBQWUsQ0FBekMsQ0FBVixJQUF5RCxDQUFoRztVQUNBLElBQUl5QyxNQUFNLEdBQUcsQ0FBQyxDQUFELENBQWI7O1VBQ0EsS0FBSyxJQUFJeUIsR0FBRyxHQUFHLEtBQUt4RixJQUFMLEdBQVksQ0FBM0IsRUFBOEIrRCxNQUFNLENBQUN4QyxNQUFQLEdBQWdCRCxRQUE5QyxFQUF3RGtFLEdBQUcsSUFBSUQsSUFBL0Q7WUFDRXhCLE1BQU0sQ0FBQzBCLE1BQVAsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CRCxHQUFwQjtVQURGOztVQUVBLE9BQU96QixNQUFQO1FBQ0Q7TUFDRjtJQTVVVTtNQUFBO01BQUEsT0FtWVgsb0NBQTJCVSxVQUEzQixFQUF1QztRQUNyQyxJQUFNaUIsQ0FBQyxHQUFHakIsVUFBVSxDQUFDLENBQUQsQ0FBcEI7UUFDQTNELE1BQU0sQ0FBQzRFLENBQUMsSUFBSSxLQUFLMUYsSUFBTCxHQUFZLENBQWxCLENBQU47UUFDQSxJQUFNMkYsSUFBSSxHQUFHRCxDQUFDLEdBQUcsQ0FBSixJQUFTakIsVUFBVSxDQUFDLENBQUQsQ0FBVixJQUFpQmlCLENBQTFCLElBQStCakIsVUFBVSxDQUFDLENBQUQsQ0FBVixJQUFpQmlCLENBQUMsR0FBRyxDQUFwRCxJQUF5RGpCLFVBQVUsQ0FBQyxDQUFELENBQVYsSUFBaUJpQixDQUExRSxJQUErRWpCLFVBQVUsQ0FBQyxDQUFELENBQVYsSUFBaUJpQixDQUE3RztRQUNBLE9BQU8sQ0FBQ0MsSUFBSSxJQUFJbEIsVUFBVSxDQUFDLENBQUQsQ0FBVixJQUFpQmlCLENBQUMsR0FBRyxDQUE3QixJQUFrQ2pCLFVBQVUsQ0FBQyxDQUFELENBQVYsSUFBaUJpQixDQUFuRCxHQUF1RCxDQUF2RCxHQUEyRCxDQUE1RCxLQUFrRUMsSUFBSSxJQUFJbEIsVUFBVSxDQUFDLENBQUQsQ0FBVixJQUFpQmlCLENBQUMsR0FBRyxDQUE3QixJQUFrQ2pCLFVBQVUsQ0FBQyxDQUFELENBQVYsSUFBaUJpQixDQUFuRCxHQUF1RCxDQUF2RCxHQUEyRCxDQUE3SCxDQUFQO01BQ0Q7SUF4WVU7TUFBQTtNQUFBLE9BeVlYLHdDQUErQkUsZUFBL0IsRUFBZ0RDLGdCQUFoRCxFQUFrRXBCLFVBQWxFLEVBQThFO1FBQzVFLElBQUltQixlQUFKLEVBQXFCO1VBQ25CLEtBQUtqQix1QkFBTCxDQUE2QmtCLGdCQUE3QixFQUErQ3BCLFVBQS9DO1VBQ0FvQixnQkFBZ0IsR0FBRyxDQUFuQjtRQUNEOztRQUNEQSxnQkFBZ0IsSUFBSSxLQUFLN0YsSUFBekI7UUFDQSxLQUFLMkUsdUJBQUwsQ0FBNkJrQixnQkFBN0IsRUFBK0NwQixVQUEvQztRQUNBLE9BQU8sS0FBS0csMEJBQUwsQ0FBZ0NILFVBQWhDLENBQVA7TUFDRDtJQWpaVTtNQUFBO01BQUEsT0FrWlgsaUNBQXdCb0IsZ0JBQXhCLEVBQTBDcEIsVUFBMUMsRUFBc0Q7UUFDcEQsSUFBSUEsVUFBVSxDQUFDLENBQUQsQ0FBVixJQUFpQixDQUFyQixFQUNFb0IsZ0JBQWdCLElBQUksS0FBSzdGLElBQXpCO1FBQ0Z5RSxVQUFVLENBQUNxQixHQUFYO1FBQ0FyQixVQUFVLENBQUNzQixPQUFYLENBQW1CRixnQkFBbkI7TUFDRDtJQXZaVTtNQUFBO01BQUEsT0F3Q1gsb0JBQWtCRyxJQUFsQixFQUF3QnBELEdBQXhCLEVBQTZCO1FBQzNCLElBQU1xRCxJQUFJLEdBQUc1RyxVQUFVLENBQUM2RyxTQUFYLENBQXFCQyxZQUFyQixDQUFrQ0gsSUFBbEMsQ0FBYjtRQUNBLE9BQU8xRyxPQUFPLENBQUM4RyxjQUFSLENBQXVCSCxJQUF2QixFQUE2QnJELEdBQTdCLENBQVA7TUFDRDtJQTNDVTtNQUFBO01BQUEsT0E0Q1gsc0JBQW9CakIsSUFBcEIsRUFBMEJpQixHQUExQixFQUErQjtRQUM3QixJQUFNeUQsR0FBRyxHQUFHaEgsVUFBVSxDQUFDNkcsU0FBWCxDQUFxQkksU0FBckIsQ0FBK0IzRSxJQUEvQixDQUFaO1FBQ0EsT0FBT3JDLE9BQU8sQ0FBQzhHLGNBQVIsQ0FBdUIsQ0FBQ0MsR0FBRCxDQUF2QixFQUE4QnpELEdBQTlCLENBQVA7TUFDRDtJQS9DVTtNQUFBO01BQUEsT0FnRFgsd0JBQXNCcUQsSUFBdEIsRUFBNEJyRCxHQUE1QixFQUE4RjtRQUFBLElBQTdEMkQsVUFBNkQsdUVBQWhELENBQWdEO1FBQUEsSUFBN0NDLFVBQTZDLHVFQUFoQyxFQUFnQztRQUFBLElBQTVCekYsSUFBNEIsdUVBQXJCLENBQUMsQ0FBb0I7UUFBQSxJQUFqQjBGLFFBQWlCLHVFQUFOLElBQU07UUFDNUYsSUFBSSxFQUFFbkgsT0FBTyxDQUFDTyxXQUFSLElBQXVCMEcsVUFBdkIsSUFBcUNBLFVBQVUsSUFBSUMsVUFBbkQsSUFBaUVBLFVBQVUsSUFBSWxILE9BQU8sQ0FBQ1EsV0FBekYsS0FBeUdpQixJQUFJLEdBQUcsQ0FBQyxDQUFqSCxJQUFzSEEsSUFBSSxHQUFHLENBQWpJLEVBQ0UsTUFBTSxJQUFJaEIsVUFBSixDQUFlLGVBQWYsQ0FBTjtRQUNGLElBQUlSLE9BQUo7UUFDQSxJQUFJbUgsWUFBSjs7UUFDQSxLQUFLbkgsT0FBTyxHQUFHZ0gsVUFBZixHQUE2QmhILE9BQU8sRUFBcEMsRUFBd0M7VUFDdEMsSUFBTW9ILGlCQUFpQixHQUFHckgsT0FBTyxDQUFDdUQsbUJBQVIsQ0FBNEJ0RCxPQUE1QixFQUFxQ3FELEdBQXJDLElBQTRDLENBQXRFO1VBQ0EsSUFBTWdFLFFBQVEsR0FBR1YsU0FBUyxDQUFDVyxZQUFWLENBQXVCWixJQUF2QixFQUE2QjFHLE9BQTdCLENBQWpCOztVQUNBLElBQUlxSCxRQUFRLElBQUlELGlCQUFoQixFQUFtQztZQUNqQ0QsWUFBWSxHQUFHRSxRQUFmO1lBQ0E7VUFDRDs7VUFDRCxJQUFJckgsT0FBTyxJQUFJaUgsVUFBZixFQUNFLE1BQU0sSUFBSXpHLFVBQUosQ0FBZSxlQUFmLENBQU47UUFDSDs7UUFDRCwwQkFBcUIsQ0FBQ1QsT0FBTyxDQUFDd0gsR0FBUixDQUFZQyxNQUFiLEVBQXFCekgsT0FBTyxDQUFDd0gsR0FBUixDQUFZRSxRQUFqQyxFQUEyQzFILE9BQU8sQ0FBQ3dILEdBQVIsQ0FBWUcsSUFBdkQsQ0FBckIsOEJBQW1GO1VBQTlFLElBQU1DLE1BQU0sYUFBWjtVQUNILElBQUlULFFBQVEsSUFBSUMsWUFBWSxJQUFJcEgsT0FBTyxDQUFDdUQsbUJBQVIsQ0FBNEJ0RCxPQUE1QixFQUFxQzJILE1BQXJDLElBQStDLENBQS9FLEVBQ0V0RSxHQUFHLEdBQUdzRSxNQUFOO1FBQ0g7O1FBQ0QsSUFBSUMsRUFBRSxHQUFHLEVBQVQ7O1FBbkI0RiwrS0FvQjFFbEIsSUFwQjBFO1FBQUE7O1FBQUE7VUFvQjVGLHVEQUF3QjtZQUFBLElBQWJJLEdBQWE7WUFDdEJlLFVBQVUsQ0FBQ2YsR0FBRyxDQUFDZ0IsSUFBSixDQUFTQyxRQUFWLEVBQW9CLENBQXBCLEVBQXVCSCxFQUF2QixDQUFWO1lBQ0FDLFVBQVUsQ0FBQ2YsR0FBRyxDQUFDa0IsUUFBTCxFQUFlbEIsR0FBRyxDQUFDZ0IsSUFBSixDQUFTRyxnQkFBVCxDQUEwQmpJLE9BQTFCLENBQWYsRUFBbUQ0SCxFQUFuRCxDQUFWOztZQUZzQiwrS0FHTmQsR0FBRyxDQUFDb0IsT0FBSixFQUhNO1lBQUE7O1lBQUE7Y0FHdEIsdURBQ0U7Z0JBQUEsSUFEUzdJLENBQ1Q7Z0JBQUF1SSxFQUFFLENBQUNoSCxJQUFILENBQVF2QixDQUFSO2NBQVc7WUFKUztjQUFBO1lBQUE7Y0FBQTtZQUFBO1VBS3ZCO1FBekIyRjtVQUFBO1FBQUE7VUFBQTtRQUFBOztRQTBCNUZrQyxNQUFNLENBQUNxRyxFQUFFLENBQUM1RixNQUFILElBQWFtRixZQUFkLENBQU47UUFDQSxJQUFNZ0IsZ0JBQWdCLEdBQUdwSSxPQUFPLENBQUN1RCxtQkFBUixDQUE0QnRELE9BQTVCLEVBQXFDcUQsR0FBckMsSUFBNEMsQ0FBckU7UUFDQTlCLE1BQU0sQ0FBQ3FHLEVBQUUsQ0FBQzVGLE1BQUgsSUFBYW1HLGdCQUFkLENBQU47UUFDQU4sVUFBVSxDQUFDLENBQUQsRUFBSW5GLElBQUksQ0FBQzBGLEdBQUwsQ0FBUyxDQUFULEVBQVlELGdCQUFnQixHQUFHUCxFQUFFLENBQUM1RixNQUFsQyxDQUFKLEVBQStDNEYsRUFBL0MsQ0FBVjtRQUNBQyxVQUFVLENBQUMsQ0FBRCxFQUFJLENBQUMsSUFBSUQsRUFBRSxDQUFDNUYsTUFBSCxHQUFZLENBQWpCLElBQXNCLENBQTFCLEVBQTZCNEYsRUFBN0IsQ0FBVjtRQUNBckcsTUFBTSxDQUFDcUcsRUFBRSxDQUFDNUYsTUFBSCxHQUFZLENBQVosSUFBaUIsQ0FBbEIsQ0FBTjs7UUFDQSxLQUFLLElBQUlxRyxPQUFPLEdBQUcsR0FBbkIsRUFBd0JULEVBQUUsQ0FBQzVGLE1BQUgsR0FBWW1HLGdCQUFwQyxFQUFzREUsT0FBTyxJQUFJLE1BQU0sRUFBdkU7VUFDRVIsVUFBVSxDQUFDUSxPQUFELEVBQVUsQ0FBVixFQUFhVCxFQUFiLENBQVY7UUFERjs7UUFFQSxJQUFJMUgsYUFBYSxHQUFHLEVBQXBCOztRQUNBLE9BQU9BLGFBQWEsQ0FBQzhCLE1BQWQsR0FBdUIsQ0FBdkIsR0FBMkI0RixFQUFFLENBQUM1RixNQUFyQztVQUNFOUIsYUFBYSxDQUFDVSxJQUFkLENBQW1CLENBQW5CO1FBREY7O1FBRUFnSCxFQUFFLENBQUNuRCxPQUFILENBQVcsVUFBQ3BGLENBQUQsRUFBSXNCLENBQUo7VUFBQSxPQUFVVCxhQUFhLENBQUNTLENBQUMsS0FBSyxDQUFQLENBQWIsSUFBMEJ0QixDQUFDLElBQUksS0FBS3NCLENBQUMsR0FBRyxDQUFULENBQXpDO1FBQUEsQ0FBWDtRQUNBLE9BQU8sSUFBSVosT0FBSixDQUFZQyxPQUFaLEVBQXFCcUQsR0FBckIsRUFBMEJuRCxhQUExQixFQUF5Q3NCLElBQXpDLENBQVA7TUFDRDtJQXZGVTtNQUFBO01BQUEsT0E2VVgsOEJBQTRCNEIsR0FBNUIsRUFBaUM7UUFDL0IsSUFBSUEsR0FBRyxHQUFHckQsT0FBTyxDQUFDTyxXQUFkLElBQTZCOEMsR0FBRyxHQUFHckQsT0FBTyxDQUFDUSxXQUEvQyxFQUNFLE1BQU0sSUFBSUMsVUFBSixDQUFlLDZCQUFmLENBQU47UUFDRixJQUFJZ0UsTUFBTSxHQUFHLENBQUMsS0FBS3BCLEdBQUwsR0FBVyxHQUFaLElBQW1CQSxHQUFuQixHQUF5QixFQUF0Qzs7UUFDQSxJQUFJQSxHQUFHLElBQUksQ0FBWCxFQUFjO1VBQ1osSUFBTXJCLFFBQVEsR0FBR1csSUFBSSxDQUFDQyxLQUFMLENBQVdTLEdBQUcsR0FBRyxDQUFqQixJQUFzQixDQUF2QztVQUNBb0IsTUFBTSxJQUFJLENBQUMsS0FBS3pDLFFBQUwsR0FBZ0IsRUFBakIsSUFBdUJBLFFBQXZCLEdBQWtDLEVBQTVDO1VBQ0EsSUFBSXFCLEdBQUcsSUFBSSxDQUFYLEVBQ0VvQixNQUFNLElBQUksRUFBVjtRQUNIOztRQUNEakQsTUFBTSxDQUFDLE9BQU9pRCxNQUFQLElBQWlCQSxNQUFNLElBQUksS0FBNUIsQ0FBTjtRQUNBLE9BQU9BLE1BQVA7TUFDRDtJQXpWVTtNQUFBO01BQUEsT0EwVlgsNkJBQTJCcEIsR0FBM0IsRUFBZ0NDLEdBQWhDLEVBQXFDO1FBQ25DLE9BQU9YLElBQUksQ0FBQ0MsS0FBTCxDQUFXNUMsT0FBTyxDQUFDOEQsb0JBQVIsQ0FBNkJULEdBQTdCLElBQW9DLENBQS9DLElBQW9EckQsT0FBTyxDQUFDNEQsdUJBQVIsQ0FBZ0NOLEdBQUcsQ0FBQ0ksT0FBcEMsRUFBNkNMLEdBQTdDLElBQW9EckQsT0FBTyxDQUFDeUQsMkJBQVIsQ0FBb0NILEdBQUcsQ0FBQ0ksT0FBeEMsRUFBaURMLEdBQWpELENBQS9HO01BQ0Q7SUE1VlU7TUFBQTtNQUFBLE9BNlZYLG1DQUFpQ2tGLE1BQWpDLEVBQXlDO1FBQ3ZDLElBQUlBLE1BQU0sR0FBRyxDQUFULElBQWNBLE1BQU0sR0FBRyxHQUEzQixFQUNFLE1BQU0sSUFBSTlILFVBQUosQ0FBZSxxQkFBZixDQUFOO1FBQ0YsSUFBSWdFLE1BQU0sR0FBRyxFQUFiOztRQUNBLEtBQUssSUFBSTdELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcySCxNQUFNLEdBQUcsQ0FBN0IsRUFBZ0MzSCxDQUFDLEVBQWpDO1VBQ0U2RCxNQUFNLENBQUM1RCxJQUFQLENBQVksQ0FBWjtRQURGOztRQUVBNEQsTUFBTSxDQUFDNUQsSUFBUCxDQUFZLENBQVo7UUFDQSxJQUFJMkgsSUFBSSxHQUFHLENBQVg7O1FBQ0EsS0FBSyxJQUFJNUgsSUFBQyxHQUFHLENBQWIsRUFBZ0JBLElBQUMsR0FBRzJILE1BQXBCLEVBQTRCM0gsSUFBQyxFQUE3QixFQUFpQztVQUMvQixLQUFLLElBQUlzQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdUMsTUFBTSxDQUFDeEMsTUFBM0IsRUFBbUNDLENBQUMsRUFBcEMsRUFBd0M7WUFDdEN1QyxNQUFNLENBQUN2QyxDQUFELENBQU4sR0FBWWxDLE9BQU8sQ0FBQ3lJLG1CQUFSLENBQTRCaEUsTUFBTSxDQUFDdkMsQ0FBRCxDQUFsQyxFQUF1Q3NHLElBQXZDLENBQVo7WUFDQSxJQUFJdEcsQ0FBQyxHQUFHLENBQUosR0FBUXVDLE1BQU0sQ0FBQ3hDLE1BQW5CLEVBQ0V3QyxNQUFNLENBQUN2QyxDQUFELENBQU4sSUFBYXVDLE1BQU0sQ0FBQ3ZDLENBQUMsR0FBRyxDQUFMLENBQW5CO1VBQ0g7O1VBQ0RzRyxJQUFJLEdBQUd4SSxPQUFPLENBQUN5SSxtQkFBUixDQUE0QkQsSUFBNUIsRUFBa0MsQ0FBbEMsQ0FBUDtRQUNEOztRQUNELE9BQU8vRCxNQUFQO01BQ0Q7SUE5V1U7TUFBQTtNQUFBLE9BK1dYLHFDQUFtQ3BDLElBQW5DLEVBQXlDcUcsT0FBekMsRUFBa0Q7UUFDaEQsSUFBSWpFLE1BQU0sR0FBR2lFLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLFVBQUNDLENBQUQ7VUFBQSxPQUFPLENBQVA7UUFBQSxDQUFaLENBQWI7O1FBRGdELCtLQUVoQ3ZHLElBRmdDO1FBQUE7O1FBQUE7VUFBQTtZQUFBLElBRXJDL0MsQ0FGcUM7WUFHOUMsSUFBTXVKLE1BQU0sR0FBR3ZKLENBQUMsR0FBR21GLE1BQU0sQ0FBQ3FFLEtBQVAsRUFBbkI7WUFDQXJFLE1BQU0sQ0FBQzVELElBQVAsQ0FBWSxDQUFaO1lBQ0E2SCxPQUFPLENBQUNoRSxPQUFSLENBQWdCLFVBQUNxRSxJQUFELEVBQU9uSSxDQUFQO2NBQUEsT0FBYTZELE1BQU0sQ0FBQzdELENBQUQsQ0FBTixJQUFhWixPQUFPLENBQUN5SSxtQkFBUixDQUE0Qk0sSUFBNUIsRUFBa0NGLE1BQWxDLENBQTFCO1lBQUEsQ0FBaEI7VUFMOEM7O1VBRWhELHVEQUFzQjtZQUFBO1VBSXJCO1FBTitDO1VBQUE7UUFBQTtVQUFBO1FBQUE7O1FBT2hELE9BQU9wRSxNQUFQO01BQ0Q7SUF2WFU7TUFBQTtNQUFBLE9Bd1hYLDZCQUEyQi9DLENBQTNCLEVBQThCQyxDQUE5QixFQUFpQztRQUMvQixJQUFJRCxDQUFDLEtBQUssQ0FBTixJQUFXLENBQVgsSUFBZ0JDLENBQUMsS0FBSyxDQUFOLElBQVcsQ0FBL0IsRUFDRSxNQUFNLElBQUlsQixVQUFKLENBQWUsbUJBQWYsQ0FBTjtRQUNGLElBQUl1SSxDQUFDLEdBQUcsQ0FBUjs7UUFDQSxLQUFLLElBQUlwSSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxJQUFJLENBQXJCLEVBQXdCQSxDQUFDLEVBQXpCLEVBQTZCO1VBQzNCb0ksQ0FBQyxHQUFHQSxDQUFDLElBQUksQ0FBTCxHQUFTLENBQUNBLENBQUMsS0FBSyxDQUFQLElBQVksR0FBekI7VUFDQUEsQ0FBQyxJQUFJLENBQUNySCxDQUFDLEtBQUtmLENBQU4sR0FBVSxDQUFYLElBQWdCYyxDQUFyQjtRQUNEOztRQUNERixNQUFNLENBQUN3SCxDQUFDLEtBQUssQ0FBTixJQUFXLENBQVosQ0FBTjtRQUNBLE9BQU9BLENBQVA7TUFDRDtJQWxZVTs7SUFBQTtFQUFBLEdBQWI7O0VBeVpBLElBQUlDLE1BQU0sR0FBR2pKLE9BQWI7RUFDQWlKLE1BQU0sQ0FBQzFJLFdBQVAsR0FBcUIsQ0FBckI7RUFDQTBJLE1BQU0sQ0FBQ3pJLFdBQVAsR0FBcUIsRUFBckI7RUFDQXlJLE1BQU0sQ0FBQzdELFVBQVAsR0FBb0IsQ0FBcEI7RUFDQTZELE1BQU0sQ0FBQ3ZELFVBQVAsR0FBb0IsQ0FBcEI7RUFDQXVELE1BQU0sQ0FBQzFELFVBQVAsR0FBb0IsRUFBcEI7RUFDQTBELE1BQU0sQ0FBQ2pELFVBQVAsR0FBb0IsRUFBcEI7RUFDQWlELE1BQU0sQ0FBQ3JGLHVCQUFQLEdBQWlDLENBQy9CLENBQUMsQ0FBQyxDQUFGLEVBQUssQ0FBTCxFQUFRLEVBQVIsRUFBWSxFQUFaLEVBQWdCLEVBQWhCLEVBQW9CLEVBQXBCLEVBQXdCLEVBQXhCLEVBQTRCLEVBQTVCLEVBQWdDLEVBQWhDLEVBQW9DLEVBQXBDLEVBQXdDLEVBQXhDLEVBQTRDLEVBQTVDLEVBQWdELEVBQWhELEVBQW9ELEVBQXBELEVBQXdELEVBQXhELEVBQTRELEVBQTVELEVBQWdFLEVBQWhFLEVBQW9FLEVBQXBFLEVBQXdFLEVBQXhFLEVBQTRFLEVBQTVFLEVBQWdGLEVBQWhGLEVBQW9GLEVBQXBGLEVBQXdGLEVBQXhGLEVBQTRGLEVBQTVGLEVBQWdHLEVBQWhHLEVBQW9HLEVBQXBHLEVBQXdHLEVBQXhHLEVBQTRHLEVBQTVHLEVBQWdILEVBQWhILEVBQW9ILEVBQXBILEVBQXdILEVBQXhILEVBQTRILEVBQTVILEVBQWdJLEVBQWhJLEVBQW9JLEVBQXBJLEVBQXdJLEVBQXhJLEVBQTRJLEVBQTVJLEVBQWdKLEVBQWhKLEVBQW9KLEVBQXBKLEVBQXdKLEVBQXhKLEVBQTRKLEVBQTVKLEVBQWdLLEVBQWhLLENBRCtCLEVBRS9CLENBQUMsQ0FBQyxDQUFGLEVBQUssRUFBTCxFQUFTLEVBQVQsRUFBYSxFQUFiLEVBQWlCLEVBQWpCLEVBQXFCLEVBQXJCLEVBQXlCLEVBQXpCLEVBQTZCLEVBQTdCLEVBQWlDLEVBQWpDLEVBQXFDLEVBQXJDLEVBQXlDLEVBQXpDLEVBQTZDLEVBQTdDLEVBQWlELEVBQWpELEVBQXFELEVBQXJELEVBQXlELEVBQXpELEVBQTZELEVBQTdELEVBQWlFLEVBQWpFLEVBQXFFLEVBQXJFLEVBQXlFLEVBQXpFLEVBQTZFLEVBQTdFLEVBQWlGLEVBQWpGLEVBQXFGLEVBQXJGLEVBQXlGLEVBQXpGLEVBQTZGLEVBQTdGLEVBQWlHLEVBQWpHLEVBQXFHLEVBQXJHLEVBQXlHLEVBQXpHLEVBQTZHLEVBQTdHLEVBQWlILEVBQWpILEVBQXFILEVBQXJILEVBQXlILEVBQXpILEVBQTZILEVBQTdILEVBQWlJLEVBQWpJLEVBQXFJLEVBQXJJLEVBQXlJLEVBQXpJLEVBQTZJLEVBQTdJLEVBQWlKLEVBQWpKLEVBQXFKLEVBQXJKLEVBQXlKLEVBQXpKLEVBQTZKLEVBQTdKLEVBQWlLLEVBQWpLLENBRitCLEVBRy9CLENBQUMsQ0FBQyxDQUFGLEVBQUssRUFBTCxFQUFTLEVBQVQsRUFBYSxFQUFiLEVBQWlCLEVBQWpCLEVBQXFCLEVBQXJCLEVBQXlCLEVBQXpCLEVBQTZCLEVBQTdCLEVBQWlDLEVBQWpDLEVBQXFDLEVBQXJDLEVBQXlDLEVBQXpDLEVBQTZDLEVBQTdDLEVBQWlELEVBQWpELEVBQXFELEVBQXJELEVBQXlELEVBQXpELEVBQTZELEVBQTdELEVBQWlFLEVBQWpFLEVBQXFFLEVBQXJFLEVBQXlFLEVBQXpFLEVBQTZFLEVBQTdFLEVBQWlGLEVBQWpGLEVBQXFGLEVBQXJGLEVBQXlGLEVBQXpGLEVBQTZGLEVBQTdGLEVBQWlHLEVBQWpHLEVBQXFHLEVBQXJHLEVBQXlHLEVBQXpHLEVBQTZHLEVBQTdHLEVBQWlILEVBQWpILEVBQXFILEVBQXJILEVBQXlILEVBQXpILEVBQTZILEVBQTdILEVBQWlJLEVBQWpJLEVBQXFJLEVBQXJJLEVBQXlJLEVBQXpJLEVBQTZJLEVBQTdJLEVBQWlKLEVBQWpKLEVBQXFKLEVBQXJKLEVBQXlKLEVBQXpKLEVBQTZKLEVBQTdKLEVBQWlLLEVBQWpLLENBSCtCLEVBSS9CLENBQUMsQ0FBQyxDQUFGLEVBQUssRUFBTCxFQUFTLEVBQVQsRUFBYSxFQUFiLEVBQWlCLEVBQWpCLEVBQXFCLEVBQXJCLEVBQXlCLEVBQXpCLEVBQTZCLEVBQTdCLEVBQWlDLEVBQWpDLEVBQXFDLEVBQXJDLEVBQXlDLEVBQXpDLEVBQTZDLEVBQTdDLEVBQWlELEVBQWpELEVBQXFELEVBQXJELEVBQXlELEVBQXpELEVBQTZELEVBQTdELEVBQWlFLEVBQWpFLEVBQXFFLEVBQXJFLEVBQXlFLEVBQXpFLEVB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d0QsQ0FBRCxFQUk3RHFCLFVBSjZELENBQXpDLEVBSVAsZUFBZ0JpQyw0Q0FBSyxDQUFDQyxhQUFOLENBQW9CLE1BQXBCLEVBQTRCO0lBQzFEUCxJQUFJLEVBQUU5QixPQURvRDtJQUUxRCtDLENBQUMsa0JBQVdqRSxRQUFYLGNBQXVCQSxRQUF2QixRQUZ5RDtJQUcxRGtFLGNBQWMsRUFBRTtFQUgwQyxDQUE1QixDQUpULEVBUW5CLGVBQWdCWiw0Q0FBSyxDQUFDQyxhQUFOLENBQW9CLE1BQXBCLEVBQTRCO0lBQzlDUCxJQUFJLEVBQUU3QixPQUR3QztJQUU5QzhDLENBQUMsRUFBRUYsTUFGMkM7SUFHOUNHLGNBQWMsRUFBRTtFQUg4QixDQUE1QixDQVJHLEVBWW5CNUIsS0FabUIsQ0FBdkI7QUFhRDs7QUFDRCxJQUFJNkIsTUFBTSxHQUFHLFNBQVRBLE1BQVMsQ0FBQ3BELEtBQUQsRUFBVztFQUNoQixJQUFBQyxFQUFFLEdBQUdELEtBQUw7RUFBQSxJQUFjcUQsUUFBZCxHQUEyQnBELEVBQTNCLENBQWNvRCxRQUFkO0VBQUEsSUFBK0IvQyxVQUEvQixHQUE0QzlPLFNBQVMsQ0FBQ3lPLEVBQUQsRUFBSyxDQUFDLFVBQUQsQ0FBTCxDQUFyRDs7RUFDTixJQUFJb0QsUUFBUSxLQUFLLEtBQWpCLEVBQXdCO0lBQ3RCLE9BQU8sZUFBZ0JkLDRDQUFLLENBQUNDLGFBQU4sQ0FBb0JLLFNBQXBCLEVBQStCMVIsY0FBYyxDQUFDLEVBQUQsRUFBS21QLFVBQUwsQ0FBN0MsQ0FBdkI7RUFDRDs7RUFDRCxPQUFPLGVBQWdCaUMsNENBQUssQ0FBQ0MsYUFBTixDQUFvQnpDLFlBQXBCLEVBQWtDNU8sY0FBYyxDQUFDLEVBQUQsRUFBS21QLFVBQUwsQ0FBaEQsQ0FBdkI7QUFDRCxDQU5EIiwiZmlsZSI6Ild4dm8uanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLy8gc3JjL2luZGV4LnRzeFxuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvdGhpcmQtcGFydHkvcXJjb2RlZ2VuL2luZGV4LnRzXG4vKipcbiAqIEBsaWNlbnNlIFFSIENvZGUgZ2VuZXJhdG9yIGxpYnJhcnkgKFR5cGVTY3JpcHQpXG4gKiBDb3B5cmlnaHQgKGMpIFByb2plY3QgTmF5dWtpLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuICovXG52YXIgcXJjb2RlZ2VuO1xuKChxcmNvZGVnZW4yKSA9PiB7XG4gIGNvbnN0IF9RckNvZGUgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IodmVyc2lvbiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIGRhdGFDb2Rld29yZHMsIG1zaykge1xuICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBlcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgICAgdGhpcy5pc0Z1bmN0aW9uID0gW107XG4gICAgICBpZiAodmVyc2lvbiA8IF9RckNvZGUuTUlOX1ZFUlNJT04gfHwgdmVyc2lvbiA+IF9RckNvZGUuTUFYX1ZFUlNJT04pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVmVyc2lvbiB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBpZiAobXNrIDwgLTEgfHwgbXNrID4gNylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXNrIHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIHRoaXMuc2l6ZSA9IHZlcnNpb24gKiA0ICsgMTc7XG4gICAgICBsZXQgcm93ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKVxuICAgICAgICByb3cucHVzaChmYWxzZSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgIHRoaXMubW9kdWxlcy5wdXNoKHJvdy5zbGljZSgpKTtcbiAgICAgICAgdGhpcy5pc0Z1bmN0aW9uLnB1c2gocm93LnNsaWNlKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3RnVuY3Rpb25QYXR0ZXJucygpO1xuICAgICAgY29uc3QgYWxsQ29kZXdvcmRzID0gdGhpcy5hZGRFY2NBbmRJbnRlcmxlYXZlKGRhdGFDb2Rld29yZHMpO1xuICAgICAgdGhpcy5kcmF3Q29kZXdvcmRzKGFsbENvZGV3b3Jkcyk7XG4gICAgICBpZiAobXNrID09IC0xKSB7XG4gICAgICAgIGxldCBtaW5QZW5hbHR5ID0gMWU5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYXBwbHlNYXNrKGkpO1xuICAgICAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMoaSk7XG4gICAgICAgICAgY29uc3QgcGVuYWx0eSA9IHRoaXMuZ2V0UGVuYWx0eVNjb3JlKCk7XG4gICAgICAgICAgaWYgKHBlbmFsdHkgPCBtaW5QZW5hbHR5KSB7XG4gICAgICAgICAgICBtc2sgPSBpO1xuICAgICAgICAgICAgbWluUGVuYWx0eSA9IHBlbmFsdHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXBwbHlNYXNrKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3NlcnQoMCA8PSBtc2sgJiYgbXNrIDw9IDcpO1xuICAgICAgdGhpcy5tYXNrID0gbXNrO1xuICAgICAgdGhpcy5hcHBseU1hc2sobXNrKTtcbiAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMobXNrKTtcbiAgICAgIHRoaXMuaXNGdW5jdGlvbiA9IFtdO1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlVGV4dCh0ZXh0LCBlY2wpIHtcbiAgICAgIGNvbnN0IHNlZ3MgPSBxcmNvZGVnZW4yLlFyU2VnbWVudC5tYWtlU2VnbWVudHModGV4dCk7XG4gICAgICByZXR1cm4gX1FyQ29kZS5lbmNvZGVTZWdtZW50cyhzZWdzLCBlY2wpO1xuICAgIH1cbiAgICBzdGF0aWMgZW5jb2RlQmluYXJ5KGRhdGEsIGVjbCkge1xuICAgICAgY29uc3Qgc2VnID0gcXJjb2RlZ2VuMi5RclNlZ21lbnQubWFrZUJ5dGVzKGRhdGEpO1xuICAgICAgcmV0dXJuIF9RckNvZGUuZW5jb2RlU2VnbWVudHMoW3NlZ10sIGVjbCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVTZWdtZW50cyhzZWdzLCBlY2wsIG1pblZlcnNpb24gPSAxLCBtYXhWZXJzaW9uID0gNDAsIG1hc2sgPSAtMSwgYm9vc3RFY2wgPSB0cnVlKSB7XG4gICAgICBpZiAoIShfUXJDb2RlLk1JTl9WRVJTSU9OIDw9IG1pblZlcnNpb24gJiYgbWluVmVyc2lvbiA8PSBtYXhWZXJzaW9uICYmIG1heFZlcnNpb24gPD0gX1FyQ29kZS5NQVhfVkVSU0lPTikgfHwgbWFzayA8IC0xIHx8IG1hc2sgPiA3KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWVcIik7XG4gICAgICBsZXQgdmVyc2lvbjtcbiAgICAgIGxldCBkYXRhVXNlZEJpdHM7XG4gICAgICBmb3IgKHZlcnNpb24gPSBtaW5WZXJzaW9uOyA7IHZlcnNpb24rKykge1xuICAgICAgICBjb25zdCBkYXRhQ2FwYWNpdHlCaXRzMiA9IF9RckNvZGUuZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXJzaW9uLCBlY2wpICogODtcbiAgICAgICAgY29uc3QgdXNlZEJpdHMgPSBRclNlZ21lbnQuZ2V0VG90YWxCaXRzKHNlZ3MsIHZlcnNpb24pO1xuICAgICAgICBpZiAodXNlZEJpdHMgPD0gZGF0YUNhcGFjaXR5Qml0czIpIHtcbiAgICAgICAgICBkYXRhVXNlZEJpdHMgPSB1c2VkQml0cztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVyc2lvbiA+PSBtYXhWZXJzaW9uKVxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRGF0YSB0b28gbG9uZ1wiKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbmV3RWNsIG9mIFtfUXJDb2RlLkVjYy5NRURJVU0sIF9RckNvZGUuRWNjLlFVQVJUSUxFLCBfUXJDb2RlLkVjYy5ISUdIXSkge1xuICAgICAgICBpZiAoYm9vc3RFY2wgJiYgZGF0YVVzZWRCaXRzIDw9IF9RckNvZGUuZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXJzaW9uLCBuZXdFY2wpICogOClcbiAgICAgICAgICBlY2wgPSBuZXdFY2w7XG4gICAgICB9XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgYXBwZW5kQml0cyhzZWcubW9kZS5tb2RlQml0cywgNCwgYmIpO1xuICAgICAgICBhcHBlbmRCaXRzKHNlZy5udW1DaGFycywgc2VnLm1vZGUubnVtQ2hhckNvdW50Qml0cyh2ZXJzaW9uKSwgYmIpO1xuICAgICAgICBmb3IgKGNvbnN0IGIgb2Ygc2VnLmdldERhdGEoKSlcbiAgICAgICAgICBiYi5wdXNoKGIpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGJiLmxlbmd0aCA9PSBkYXRhVXNlZEJpdHMpO1xuICAgICAgY29uc3QgZGF0YUNhcGFjaXR5Qml0cyA9IF9RckNvZGUuZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXJzaW9uLCBlY2wpICogODtcbiAgICAgIGFzc2VydChiYi5sZW5ndGggPD0gZGF0YUNhcGFjaXR5Qml0cyk7XG4gICAgICBhcHBlbmRCaXRzKDAsIE1hdGgubWluKDQsIGRhdGFDYXBhY2l0eUJpdHMgLSBiYi5sZW5ndGgpLCBiYik7XG4gICAgICBhcHBlbmRCaXRzKDAsICg4IC0gYmIubGVuZ3RoICUgOCkgJSA4LCBiYik7XG4gICAgICBhc3NlcnQoYmIubGVuZ3RoICUgOCA9PSAwKTtcbiAgICAgIGZvciAobGV0IHBhZEJ5dGUgPSAyMzY7IGJiLmxlbmd0aCA8IGRhdGFDYXBhY2l0eUJpdHM7IHBhZEJ5dGUgXj0gMjM2IF4gMTcpXG4gICAgICAgIGFwcGVuZEJpdHMocGFkQnl0ZSwgOCwgYmIpO1xuICAgICAgbGV0IGRhdGFDb2Rld29yZHMgPSBbXTtcbiAgICAgIHdoaWxlIChkYXRhQ29kZXdvcmRzLmxlbmd0aCAqIDggPCBiYi5sZW5ndGgpXG4gICAgICAgIGRhdGFDb2Rld29yZHMucHVzaCgwKTtcbiAgICAgIGJiLmZvckVhY2goKGIsIGkpID0+IGRhdGFDb2Rld29yZHNbaSA+Pj4gM10gfD0gYiA8PCA3IC0gKGkgJiA3KSk7XG4gICAgICByZXR1cm4gbmV3IF9RckNvZGUodmVyc2lvbiwgZWNsLCBkYXRhQ29kZXdvcmRzLCBtYXNrKTtcbiAgICB9XG4gICAgZ2V0TW9kdWxlKHgsIHkpIHtcbiAgICAgIHJldHVybiAwIDw9IHggJiYgeCA8IHRoaXMuc2l6ZSAmJiAwIDw9IHkgJiYgeSA8IHRoaXMuc2l6ZSAmJiB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgfVxuICAgIGdldE1vZHVsZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2R1bGVzO1xuICAgIH1cbiAgICBkcmF3RnVuY3Rpb25QYXR0ZXJucygpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg2LCBpLCBpICUgMiA9PSAwKTtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShpLCA2LCBpICUgMiA9PSAwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0ZpbmRlclBhdHRlcm4oMywgMyk7XG4gICAgICB0aGlzLmRyYXdGaW5kZXJQYXR0ZXJuKHRoaXMuc2l6ZSAtIDQsIDMpO1xuICAgICAgdGhpcy5kcmF3RmluZGVyUGF0dGVybigzLCB0aGlzLnNpemUgLSA0KTtcbiAgICAgIGNvbnN0IGFsaWduUGF0UG9zID0gdGhpcy5nZXRBbGlnbm1lbnRQYXR0ZXJuUG9zaXRpb25zKCk7XG4gICAgICBjb25zdCBudW1BbGlnbiA9IGFsaWduUGF0UG9zLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQWxpZ247IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUFsaWduOyBqKyspIHtcbiAgICAgICAgICBpZiAoIShpID09IDAgJiYgaiA9PSAwIHx8IGkgPT0gMCAmJiBqID09IG51bUFsaWduIC0gMSB8fCBpID09IG51bUFsaWduIC0gMSAmJiBqID09IDApKVxuICAgICAgICAgICAgdGhpcy5kcmF3QWxpZ25tZW50UGF0dGVybihhbGlnblBhdFBvc1tpXSwgYWxpZ25QYXRQb3Nbal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdGb3JtYXRCaXRzKDApO1xuICAgICAgdGhpcy5kcmF3VmVyc2lvbigpO1xuICAgIH1cbiAgICBkcmF3Rm9ybWF0Qml0cyhtYXNrKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbC5mb3JtYXRCaXRzIDw8IDMgfCBtYXNrO1xuICAgICAgbGV0IHJlbSA9IGRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG4gICAgICAgIHJlbSA9IHJlbSA8PCAxIF4gKHJlbSA+Pj4gOSkgKiAxMzM1O1xuICAgICAgY29uc3QgYml0cyA9IChkYXRhIDw8IDEwIHwgcmVtKSBeIDIxNTIyO1xuICAgICAgYXNzZXJ0KGJpdHMgPj4+IDE1ID09IDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gNTsgaSsrKVxuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIGksIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIDcsIGdldEJpdChiaXRzLCA2KSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIDgsIGdldEJpdChiaXRzLCA3KSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDcsIDgsIGdldEJpdChiaXRzLCA4KSk7XG4gICAgICBmb3IgKGxldCBpID0gOTsgaSA8IDE1OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoMTQgLSBpLCA4LCBnZXRCaXQoYml0cywgaSkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUodGhpcy5zaXplIC0gMSAtIGksIDgsIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICBmb3IgKGxldCBpID0gODsgaSA8IDE1OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgdGhpcy5zaXplIC0gMTUgKyBpLCBnZXRCaXQoYml0cywgaSkpO1xuICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCB0aGlzLnNpemUgLSA4LCB0cnVlKTtcbiAgICB9XG4gICAgZHJhd1ZlcnNpb24oKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uIDwgNylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHJlbSA9IHRoaXMudmVyc2lvbjtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKylcbiAgICAgICAgcmVtID0gcmVtIDw8IDEgXiAocmVtID4+PiAxMSkgKiA3OTczO1xuICAgICAgY29uc3QgYml0cyA9IHRoaXMudmVyc2lvbiA8PCAxMiB8IHJlbTtcbiAgICAgIGFzc2VydChiaXRzID4+PiAxOCA9PSAwKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTg7IGkrKykge1xuICAgICAgICBjb25zdCBjb2xvciA9IGdldEJpdChiaXRzLCBpKTtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuc2l6ZSAtIDExICsgaSAlIDM7XG4gICAgICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKGkgLyAzKTtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShhLCBiLCBjb2xvcik7XG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoYiwgYSwgY29sb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBkcmF3RmluZGVyUGF0dGVybih4LCB5KSB7XG4gICAgICBmb3IgKGxldCBkeSA9IC00OyBkeSA8PSA0OyBkeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGR4ID0gLTQ7IGR4IDw9IDQ7IGR4KyspIHtcbiAgICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpO1xuICAgICAgICAgIGNvbnN0IHh4ID0geCArIGR4O1xuICAgICAgICAgIGNvbnN0IHl5ID0geSArIGR5O1xuICAgICAgICAgIGlmICgwIDw9IHh4ICYmIHh4IDwgdGhpcy5zaXplICYmIDAgPD0geXkgJiYgeXkgPCB0aGlzLnNpemUpXG4gICAgICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKHh4LCB5eSwgZGlzdCAhPSAyICYmIGRpc3QgIT0gNCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZHJhd0FsaWdubWVudFBhdHRlcm4oeCwgeSkge1xuICAgICAgZm9yIChsZXQgZHkgPSAtMjsgZHkgPD0gMjsgZHkrKykge1xuICAgICAgICBmb3IgKGxldCBkeCA9IC0yOyBkeCA8PSAyOyBkeCsrKVxuICAgICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoeCArIGR4LCB5ICsgZHksIE1hdGgubWF4KE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKSAhPSAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RnVuY3Rpb25Nb2R1bGUoeCwgeSwgaXNEYXJrKSB7XG4gICAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSBpc0Rhcms7XG4gICAgICB0aGlzLmlzRnVuY3Rpb25beV1beF0gPSB0cnVlO1xuICAgIH1cbiAgICBhZGRFY2NBbmRJbnRlcmxlYXZlKGRhdGEpIHtcbiAgICAgIGNvbnN0IHZlciA9IHRoaXMudmVyc2lvbjtcbiAgICAgIGNvbnN0IGVjbCA9IHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggIT0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlciwgZWNsKSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgY29uc3QgbnVtQmxvY2tzID0gX1FyQ29kZS5OVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1NbZWNsLm9yZGluYWxdW3Zlcl07XG4gICAgICBjb25zdCBibG9ja0VjY0xlbiA9IF9RckNvZGUuRUNDX0NPREVXT1JEU19QRVJfQkxPQ0tbZWNsLm9yZGluYWxdW3Zlcl07XG4gICAgICBjb25zdCByYXdDb2Rld29yZHMgPSBNYXRoLmZsb29yKF9RckNvZGUuZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSAvIDgpO1xuICAgICAgY29uc3QgbnVtU2hvcnRCbG9ja3MgPSBudW1CbG9ja3MgLSByYXdDb2Rld29yZHMgJSBudW1CbG9ja3M7XG4gICAgICBjb25zdCBzaG9ydEJsb2NrTGVuID0gTWF0aC5mbG9vcihyYXdDb2Rld29yZHMgLyBudW1CbG9ja3MpO1xuICAgICAgbGV0IGJsb2NrcyA9IFtdO1xuICAgICAgY29uc3QgcnNEaXYgPSBfUXJDb2RlLnJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IoYmxvY2tFY2NMZW4pO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGsgPSAwOyBpIDwgbnVtQmxvY2tzOyBpKyspIHtcbiAgICAgICAgbGV0IGRhdCA9IGRhdGEuc2xpY2UoaywgayArIHNob3J0QmxvY2tMZW4gLSBibG9ja0VjY0xlbiArIChpIDwgbnVtU2hvcnRCbG9ja3MgPyAwIDogMSkpO1xuICAgICAgICBrICs9IGRhdC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGVjYyA9IF9RckNvZGUucmVlZFNvbG9tb25Db21wdXRlUmVtYWluZGVyKGRhdCwgcnNEaXYpO1xuICAgICAgICBpZiAoaSA8IG51bVNob3J0QmxvY2tzKVxuICAgICAgICAgIGRhdC5wdXNoKDApO1xuICAgICAgICBibG9ja3MucHVzaChkYXQuY29uY2F0KGVjYykpO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3NbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmxvY2tzLmZvckVhY2goKGJsb2NrLCBqKSA9PiB7XG4gICAgICAgICAgaWYgKGkgIT0gc2hvcnRCbG9ja0xlbiAtIGJsb2NrRWNjTGVuIHx8IGogPj0gbnVtU2hvcnRCbG9ja3MpXG4gICAgICAgICAgICByZXN1bHQucHVzaChibG9ja1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHJlc3VsdC5sZW5ndGggPT0gcmF3Q29kZXdvcmRzKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGRyYXdDb2Rld29yZHMoZGF0YSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoICE9IE1hdGguZmxvb3IoX1FyQ29kZS5nZXROdW1SYXdEYXRhTW9kdWxlcyh0aGlzLnZlcnNpb24pIC8gOCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAobGV0IHJpZ2h0ID0gdGhpcy5zaXplIC0gMTsgcmlnaHQgPj0gMTsgcmlnaHQgLT0gMikge1xuICAgICAgICBpZiAocmlnaHQgPT0gNilcbiAgICAgICAgICByaWdodCA9IDU7XG4gICAgICAgIGZvciAobGV0IHZlcnQgPSAwOyB2ZXJ0IDwgdGhpcy5zaXplOyB2ZXJ0KyspIHtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI7IGorKykge1xuICAgICAgICAgICAgY29uc3QgeCA9IHJpZ2h0IC0gajtcbiAgICAgICAgICAgIGNvbnN0IHVwd2FyZCA9IChyaWdodCArIDEgJiAyKSA9PSAwO1xuICAgICAgICAgICAgY29uc3QgeSA9IHVwd2FyZCA/IHRoaXMuc2l6ZSAtIDEgLSB2ZXJ0IDogdmVydDtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Z1bmN0aW9uW3ldW3hdICYmIGkgPCBkYXRhLmxlbmd0aCAqIDgpIHtcbiAgICAgICAgICAgICAgdGhpcy5tb2R1bGVzW3ldW3hdID0gZ2V0Qml0KGRhdGFbaSA+Pj4gM10sIDcgLSAoaSAmIDcpKTtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPT0gZGF0YS5sZW5ndGggKiA4KTtcbiAgICB9XG4gICAgYXBwbHlNYXNrKG1hc2spIHtcbiAgICAgIGlmIChtYXNrIDwgMCB8fCBtYXNrID4gNylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNYXNrIHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplOyB5KyspIHtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemU7IHgrKykge1xuICAgICAgICAgIGxldCBpbnZlcnQ7XG4gICAgICAgICAgc3dpdGNoIChtYXNrKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGludmVydCA9ICh4ICsgeSkgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBpbnZlcnQgPSB5ICUgMiA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0geCAlIDMgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIGludmVydCA9ICh4ICsgeSkgJSAzID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBpbnZlcnQgPSAoTWF0aC5mbG9vcih4IC8gMykgKyBNYXRoLmZsb29yKHkgLyAyKSkgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBpbnZlcnQgPSB4ICogeSAlIDIgKyB4ICogeSAlIDMgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGludmVydCA9ICh4ICogeSAlIDIgKyB4ICogeSAlIDMpICUgMiA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKCh4ICsgeSkgJSAyICsgeCAqIHkgJSAzKSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmlzRnVuY3Rpb25beV1beF0gJiYgaW52ZXJ0KVxuICAgICAgICAgICAgdGhpcy5tb2R1bGVzW3ldW3hdID0gIXRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBnZXRQZW5hbHR5U2NvcmUoKSB7XG4gICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplOyB5KyspIHtcbiAgICAgICAgbGV0IHJ1bkNvbG9yID0gZmFsc2U7XG4gICAgICAgIGxldCBydW5YID0gMDtcbiAgICAgICAgbGV0IHJ1bkhpc3RvcnkgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplOyB4KyspIHtcbiAgICAgICAgICBpZiAodGhpcy5tb2R1bGVzW3ldW3hdID09IHJ1bkNvbG9yKSB7XG4gICAgICAgICAgICBydW5YKys7XG4gICAgICAgICAgICBpZiAocnVuWCA9PSA1KVxuICAgICAgICAgICAgICByZXN1bHQgKz0gX1FyQ29kZS5QRU5BTFRZX04xO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVuWCA+IDUpXG4gICAgICAgICAgICAgIHJlc3VsdCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KHJ1blgsIHJ1bkhpc3RvcnkpO1xuICAgICAgICAgICAgaWYgKCFydW5Db2xvcilcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuZmluZGVyUGVuYWx0eUNvdW50UGF0dGVybnMocnVuSGlzdG9yeSkgKiBfUXJDb2RlLlBFTkFMVFlfTjM7XG4gICAgICAgICAgICBydW5Db2xvciA9IHRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICAgICAgICAgIHJ1blggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5VGVybWluYXRlQW5kQ291bnQocnVuQ29sb3IsIHJ1blgsIHJ1bkhpc3RvcnkpICogX1FyQ29kZS5QRU5BTFRZX04zO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemU7IHgrKykge1xuICAgICAgICBsZXQgcnVuQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJ1blkgPSAwO1xuICAgICAgICBsZXQgcnVuSGlzdG9yeSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICAgIGlmICh0aGlzLm1vZHVsZXNbeV1beF0gPT0gcnVuQ29sb3IpIHtcbiAgICAgICAgICAgIHJ1blkrKztcbiAgICAgICAgICAgIGlmIChydW5ZID09IDUpXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBfUXJDb2RlLlBFTkFMVFlfTjE7XG4gICAgICAgICAgICBlbHNlIGlmIChydW5ZID4gNSlcbiAgICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkocnVuWSwgcnVuSGlzdG9yeSk7XG4gICAgICAgICAgICBpZiAoIXJ1bkNvbG9yKVxuICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSAqIF9RckNvZGUuUEVOQUxUWV9OMztcbiAgICAgICAgICAgIHJ1bkNvbG9yID0gdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICAgICAgcnVuWSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChydW5Db2xvciwgcnVuWSwgcnVuSGlzdG9yeSkgKiBfUXJDb2RlLlBFTkFMVFlfTjM7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZSAtIDE7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZSAtIDE7IHgrKykge1xuICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICAgIGlmIChjb2xvciA9PSB0aGlzLm1vZHVsZXNbeV1beCArIDFdICYmIGNvbG9yID09IHRoaXMubW9kdWxlc1t5ICsgMV1beF0gJiYgY29sb3IgPT0gdGhpcy5tb2R1bGVzW3kgKyAxXVt4ICsgMV0pXG4gICAgICAgICAgICByZXN1bHQgKz0gX1FyQ29kZS5QRU5BTFRZX04yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgZGFyayA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHJvdyBvZiB0aGlzLm1vZHVsZXMpXG4gICAgICAgIGRhcmsgPSByb3cucmVkdWNlKChzdW0sIGNvbG9yKSA9PiBzdW0gKyAoY29sb3IgPyAxIDogMCksIGRhcmspO1xuICAgICAgY29uc3QgdG90YWwgPSB0aGlzLnNpemUgKiB0aGlzLnNpemU7XG4gICAgICBjb25zdCBrID0gTWF0aC5jZWlsKE1hdGguYWJzKGRhcmsgKiAyMCAtIHRvdGFsICogMTApIC8gdG90YWwpIC0gMTtcbiAgICAgIGFzc2VydCgwIDw9IGsgJiYgayA8PSA5KTtcbiAgICAgIHJlc3VsdCArPSBrICogX1FyQ29kZS5QRU5BTFRZX040O1xuICAgICAgYXNzZXJ0KDAgPD0gcmVzdWx0ICYmIHJlc3VsdCA8PSAyNTY4ODg4KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldEFsaWdubWVudFBhdHRlcm5Qb3NpdGlvbnMoKSB7XG4gICAgICBpZiAodGhpcy52ZXJzaW9uID09IDEpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBudW1BbGlnbiA9IE1hdGguZmxvb3IodGhpcy52ZXJzaW9uIC8gNykgKyAyO1xuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy52ZXJzaW9uID09IDMyID8gMjYgOiBNYXRoLmNlaWwoKHRoaXMudmVyc2lvbiAqIDQgKyA0KSAvIChudW1BbGlnbiAqIDIgLSAyKSkgKiAyO1xuICAgICAgICBsZXQgcmVzdWx0ID0gWzZdO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSB0aGlzLnNpemUgLSA3OyByZXN1bHQubGVuZ3RoIDwgbnVtQWxpZ247IHBvcyAtPSBzdGVwKVxuICAgICAgICAgIHJlc3VsdC5zcGxpY2UoMSwgMCwgcG9zKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldE51bVJhd0RhdGFNb2R1bGVzKHZlcikge1xuICAgICAgaWYgKHZlciA8IF9RckNvZGUuTUlOX1ZFUlNJT04gfHwgdmVyID4gX1FyQ29kZS5NQVhfVkVSU0lPTilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJWZXJzaW9uIG51bWJlciBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBsZXQgcmVzdWx0ID0gKDE2ICogdmVyICsgMTI4KSAqIHZlciArIDY0O1xuICAgICAgaWYgKHZlciA+PSAyKSB7XG4gICAgICAgIGNvbnN0IG51bUFsaWduID0gTWF0aC5mbG9vcih2ZXIgLyA3KSArIDI7XG4gICAgICAgIHJlc3VsdCAtPSAoMjUgKiBudW1BbGlnbiAtIDEwKSAqIG51bUFsaWduIC0gNTU7XG4gICAgICAgIGlmICh2ZXIgPj0gNylcbiAgICAgICAgICByZXN1bHQgLT0gMzY7XG4gICAgICB9XG4gICAgICBhc3NlcnQoMjA4IDw9IHJlc3VsdCAmJiByZXN1bHQgPD0gMjk2NDgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGdldE51bURhdGFDb2Rld29yZHModmVyLCBlY2wpIHtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKF9RckNvZGUuZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSAvIDgpIC0gX1FyQ29kZS5FQ0NfQ09ERVdPUkRTX1BFUl9CTE9DS1tlY2wub3JkaW5hbF1bdmVyXSAqIF9RckNvZGUuTlVNX0VSUk9SX0NPUlJFQ1RJT05fQkxPQ0tTW2VjbC5vcmRpbmFsXVt2ZXJdO1xuICAgIH1cbiAgICBzdGF0aWMgcmVlZFNvbG9tb25Db21wdXRlRGl2aXNvcihkZWdyZWUpIHtcbiAgICAgIGlmIChkZWdyZWUgPCAxIHx8IGRlZ3JlZSA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWdyZWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWdyZWUgLSAxOyBpKyspXG4gICAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgcmVzdWx0LnB1c2goMSk7XG4gICAgICBsZXQgcm9vdCA9IDE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgcmVzdWx0W2pdID0gX1FyQ29kZS5yZWVkU29sb21vbk11bHRpcGx5KHJlc3VsdFtqXSwgcm9vdCk7XG4gICAgICAgICAgaWYgKGogKyAxIDwgcmVzdWx0Lmxlbmd0aClcbiAgICAgICAgICAgIHJlc3VsdFtqXSBePSByZXN1bHRbaiArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSBfUXJDb2RlLnJlZWRTb2xvbW9uTXVsdGlwbHkocm9vdCwgMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgcmVlZFNvbG9tb25Db21wdXRlUmVtYWluZGVyKGRhdGEsIGRpdmlzb3IpIHtcbiAgICAgIGxldCByZXN1bHQgPSBkaXZpc29yLm1hcCgoXykgPT4gMCk7XG4gICAgICBmb3IgKGNvbnN0IGIgb2YgZGF0YSkge1xuICAgICAgICBjb25zdCBmYWN0b3IgPSBiIF4gcmVzdWx0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5wdXNoKDApO1xuICAgICAgICBkaXZpc29yLmZvckVhY2goKGNvZWYsIGkpID0+IHJlc3VsdFtpXSBePSBfUXJDb2RlLnJlZWRTb2xvbW9uTXVsdGlwbHkoY29lZiwgZmFjdG9yKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgcmVlZFNvbG9tb25NdWx0aXBseSh4LCB5KSB7XG4gICAgICBpZiAoeCA+Pj4gOCAhPSAwIHx8IHkgPj4+IDggIT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCeXRlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGxldCB6ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSA3OyBpID49IDA7IGktLSkge1xuICAgICAgICB6ID0geiA8PCAxIF4gKHogPj4+IDcpICogMjg1O1xuICAgICAgICB6IF49ICh5ID4+PiBpICYgMSkgKiB4O1xuICAgICAgfVxuICAgICAgYXNzZXJ0KHogPj4+IDggPT0gMCk7XG4gICAgICByZXR1cm4gejtcbiAgICB9XG4gICAgZmluZGVyUGVuYWx0eUNvdW50UGF0dGVybnMocnVuSGlzdG9yeSkge1xuICAgICAgY29uc3QgbiA9IHJ1bkhpc3RvcnlbMV07XG4gICAgICBhc3NlcnQobiA8PSB0aGlzLnNpemUgKiAzKTtcbiAgICAgIGNvbnN0IGNvcmUgPSBuID4gMCAmJiBydW5IaXN0b3J5WzJdID09IG4gJiYgcnVuSGlzdG9yeVszXSA9PSBuICogMyAmJiBydW5IaXN0b3J5WzRdID09IG4gJiYgcnVuSGlzdG9yeVs1XSA9PSBuO1xuICAgICAgcmV0dXJuIChjb3JlICYmIHJ1bkhpc3RvcnlbMF0gPj0gbiAqIDQgJiYgcnVuSGlzdG9yeVs2XSA+PSBuID8gMSA6IDApICsgKGNvcmUgJiYgcnVuSGlzdG9yeVs2XSA+PSBuICogNCAmJiBydW5IaXN0b3J5WzBdID49IG4gPyAxIDogMCk7XG4gICAgfVxuICAgIGZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChjdXJyZW50UnVuQ29sb3IsIGN1cnJlbnRSdW5MZW5ndGgsIHJ1bkhpc3RvcnkpIHtcbiAgICAgIGlmIChjdXJyZW50UnVuQ29sb3IpIHtcbiAgICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KTtcbiAgICAgICAgY3VycmVudFJ1bkxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBjdXJyZW50UnVuTGVuZ3RoICs9IHRoaXMuc2l6ZTtcbiAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkoY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KTtcbiAgICB9XG4gICAgZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkoY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSkge1xuICAgICAgaWYgKHJ1bkhpc3RvcnlbMF0gPT0gMClcbiAgICAgICAgY3VycmVudFJ1bkxlbmd0aCArPSB0aGlzLnNpemU7XG4gICAgICBydW5IaXN0b3J5LnBvcCgpO1xuICAgICAgcnVuSGlzdG9yeS51bnNoaWZ0KGN1cnJlbnRSdW5MZW5ndGgpO1xuICAgIH1cbiAgfTtcbiAgbGV0IFFyQ29kZSA9IF9RckNvZGU7XG4gIFFyQ29kZS5NSU5fVkVSU0lPTiA9IDE7XG4gIFFyQ29kZS5NQVhfVkVSU0lPTiA9IDQwO1xuICBRckNvZGUuUEVOQUxUWV9OMSA9IDM7XG4gIFFyQ29kZS5QRU5BTFRZX04yID0gMztcbiAgUXJDb2RlLlBFTkFMVFlfTjMgPSA0MDtcbiAgUXJDb2RlLlBFTkFMVFlfTjQgPSAxMDtcbiAgUXJDb2RlLkVDQ19DT0RFV09SRFNfUEVSX0JMT0NLID0gW1xuICAgIFstMSwgNywgMTAsIDE1LCAyMCwgMjYsIDE4LCAyMCwgMjQsIDMwLCAxOCwgMjAsIDI0LCAyNiwgMzAsIDIyLCAyNCwgMjgsIDMwLCAyOCwgMjgsIDI4LCAyOCwgMzAsIDMwLCAyNiwgMjgsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF0sXG4gICAgWy0xLCAxMCwgMTYsIDI2LCAxOCwgMjQsIDE2LCAxOCwgMjIsIDIyLCAyNiwgMzAsIDIyLCAyMiwgMjQsIDI0LCAyOCwgMjgsIDI2LCAyNiwgMjYsIDI2LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOF0sXG4gICAgWy0xLCAxMywgMjIsIDE4LCAyNiwgMTgsIDI0LCAxOCwgMjIsIDIwLCAyNCwgMjgsIDI2LCAyNCwgMjAsIDMwLCAyNCwgMjgsIDI4LCAyNiwgMzAsIDI4LCAzMCwgMzAsIDMwLCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF0sXG4gICAgWy0xLCAxNywgMjgsIDIyLCAxNiwgMjIsIDI4LCAyNiwgMjYsIDI0LCAyOCwgMjQsIDI4LCAyMiwgMjQsIDI0LCAzMCwgMjgsIDI4LCAyNiwgMjgsIDMwLCAyNCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF1cbiAgXTtcbiAgUXJDb2RlLk5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLUyA9IFtcbiAgICBbLTEsIDEsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsIDQsIDQsIDQsIDQsIDQsIDYsIDYsIDYsIDYsIDcsIDgsIDgsIDksIDksIDEwLCAxMiwgMTIsIDEyLCAxMywgMTQsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMTksIDIwLCAyMSwgMjIsIDI0LCAyNV0sXG4gICAgWy0xLCAxLCAxLCAxLCAyLCAyLCA0LCA0LCA0LCA1LCA1LCA1LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMywgMTQsIDE2LCAxNywgMTcsIDE4LCAyMCwgMjEsIDIzLCAyNSwgMjYsIDI4LCAyOSwgMzEsIDMzLCAzNSwgMzcsIDM4LCA0MCwgNDMsIDQ1LCA0NywgNDldLFxuICAgIFstMSwgMSwgMSwgMiwgMiwgNCwgNCwgNiwgNiwgOCwgOCwgOCwgMTAsIDEyLCAxNiwgMTIsIDE3LCAxNiwgMTgsIDIxLCAyMCwgMjMsIDIzLCAyNSwgMjcsIDI5LCAzNCwgMzQsIDM1LCAzOCwgNDAsIDQzLCA0NSwgNDgsIDUxLCA1MywgNTYsIDU5LCA2MiwgNjUsIDY4XSxcbiAgICBbLTEsIDEsIDEsIDIsIDQsIDQsIDQsIDUsIDYsIDgsIDgsIDExLCAxMSwgMTYsIDE2LCAxOCwgMTYsIDE5LCAyMSwgMjUsIDI1LCAyNSwgMzQsIDMwLCAzMiwgMzUsIDM3LCA0MCwgNDIsIDQ1LCA0OCwgNTEsIDU0LCA1NywgNjAsIDYzLCA2NiwgNzAsIDc0LCA3NywgODFdXG4gIF07XG4gIHFyY29kZWdlbjIuUXJDb2RlID0gUXJDb2RlO1xuICBmdW5jdGlvbiBhcHBlbmRCaXRzKHZhbCwgbGVuLCBiYikge1xuICAgIGlmIChsZW4gPCAwIHx8IGxlbiA+IDMxIHx8IHZhbCA+Pj4gbGVuICE9IDApXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICBmb3IgKGxldCBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICBiYi5wdXNoKHZhbCA+Pj4gaSAmIDEpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEJpdCh4LCBpKSB7XG4gICAgcmV0dXJuICh4ID4+PiBpICYgMSkgIT0gMDtcbiAgfVxuICBmdW5jdGlvbiBhc3NlcnQoY29uZCkge1xuICAgIGlmICghY29uZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzc2VydGlvbiBlcnJvclwiKTtcbiAgfVxuICBjb25zdCBfUXJTZWdtZW50ID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKG1vZGUsIG51bUNoYXJzLCBiaXREYXRhKSB7XG4gICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgdGhpcy5udW1DaGFycyA9IG51bUNoYXJzO1xuICAgICAgdGhpcy5iaXREYXRhID0gYml0RGF0YTtcbiAgICAgIGlmIChudW1DaGFycyA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudFwiKTtcbiAgICAgIHRoaXMuYml0RGF0YSA9IGJpdERhdGEuc2xpY2UoKTtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VCeXRlcyhkYXRhKSB7XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgYiBvZiBkYXRhKVxuICAgICAgICBhcHBlbmRCaXRzKGIsIDgsIGJiKTtcbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuQllURSwgZGF0YS5sZW5ndGgsIGJiKTtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VOdW1lcmljKGRpZ2l0cykge1xuICAgICAgaWYgKCFfUXJTZWdtZW50LmlzTnVtZXJpYyhkaWdpdHMpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlN0cmluZyBjb250YWlucyBub24tbnVtZXJpYyBjaGFyYWN0ZXJzXCIpO1xuICAgICAgbGV0IGJiID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpZ2l0cy5sZW5ndGg7ICkge1xuICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oZGlnaXRzLmxlbmd0aCAtIGksIDMpO1xuICAgICAgICBhcHBlbmRCaXRzKHBhcnNlSW50KGRpZ2l0cy5zdWJzdHIoaSwgbiksIDEwKSwgbiAqIDMgKyAxLCBiYik7XG4gICAgICAgIGkgKz0gbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuTlVNRVJJQywgZGlnaXRzLmxlbmd0aCwgYmIpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZUFscGhhbnVtZXJpYyh0ZXh0KSB7XG4gICAgICBpZiAoIV9RclNlZ21lbnQuaXNBbHBoYW51bWVyaWModGV4dCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU3RyaW5nIGNvbnRhaW5zIHVuZW5jb2RhYmxlIGNoYXJhY3RlcnMgaW4gYWxwaGFudW1lcmljIG1vZGVcIik7XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGxldCBpO1xuICAgICAgZm9yIChpID0gMDsgaSArIDIgPD0gdGV4dC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBsZXQgdGVtcCA9IF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpKSkgKiA0NTtcbiAgICAgICAgdGVtcCArPSBfUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19DSEFSU0VULmluZGV4T2YodGV4dC5jaGFyQXQoaSArIDEpKTtcbiAgICAgICAgYXBwZW5kQml0cyh0ZW1wLCAxMSwgYmIpO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCB0ZXh0Lmxlbmd0aClcbiAgICAgICAgYXBwZW5kQml0cyhfUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19DSEFSU0VULmluZGV4T2YodGV4dC5jaGFyQXQoaSkpLCA2LCBiYik7XG4gICAgICByZXR1cm4gbmV3IF9RclNlZ21lbnQoX1FyU2VnbWVudC5Nb2RlLkFMUEhBTlVNRVJJQywgdGV4dC5sZW5ndGgsIGJiKTtcbiAgICB9XG4gICAgc3RhdGljIG1ha2VTZWdtZW50cyh0ZXh0KSB7XG4gICAgICBpZiAodGV4dCA9PSBcIlwiKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICBlbHNlIGlmIChfUXJTZWdtZW50LmlzTnVtZXJpYyh0ZXh0KSlcbiAgICAgICAgcmV0dXJuIFtfUXJTZWdtZW50Lm1ha2VOdW1lcmljKHRleHQpXTtcbiAgICAgIGVsc2UgaWYgKF9RclNlZ21lbnQuaXNBbHBoYW51bWVyaWModGV4dCkpXG4gICAgICAgIHJldHVybiBbX1FyU2VnbWVudC5tYWtlQWxwaGFudW1lcmljKHRleHQpXTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIFtfUXJTZWdtZW50Lm1ha2VCeXRlcyhfUXJTZWdtZW50LnRvVXRmOEJ5dGVBcnJheSh0ZXh0KSldO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZUVjaShhc3NpZ25WYWwpIHtcbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgaWYgKGFzc2lnblZhbCA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRUNJIGFzc2lnbm1lbnQgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgZWxzZSBpZiAoYXNzaWduVmFsIDwgMSA8PCA3KVxuICAgICAgICBhcHBlbmRCaXRzKGFzc2lnblZhbCwgOCwgYmIpO1xuICAgICAgZWxzZSBpZiAoYXNzaWduVmFsIDwgMSA8PCAxNCkge1xuICAgICAgICBhcHBlbmRCaXRzKDIsIDIsIGJiKTtcbiAgICAgICAgYXBwZW5kQml0cyhhc3NpZ25WYWwsIDE0LCBiYik7XG4gICAgICB9IGVsc2UgaWYgKGFzc2lnblZhbCA8IDFlNikge1xuICAgICAgICBhcHBlbmRCaXRzKDYsIDMsIGJiKTtcbiAgICAgICAgYXBwZW5kQml0cyhhc3NpZ25WYWwsIDIxLCBiYik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFQ0kgYXNzaWdubWVudCB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICByZXR1cm4gbmV3IF9RclNlZ21lbnQoX1FyU2VnbWVudC5Nb2RlLkVDSSwgMCwgYmIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNOdW1lcmljKHRleHQpIHtcbiAgICAgIHJldHVybiBfUXJTZWdtZW50Lk5VTUVSSUNfUkVHRVgudGVzdCh0ZXh0KTtcbiAgICB9XG4gICAgc3RhdGljIGlzQWxwaGFudW1lcmljKHRleHQpIHtcbiAgICAgIHJldHVybiBfUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19SRUdFWC50ZXN0KHRleHQpO1xuICAgIH1cbiAgICBnZXREYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYml0RGF0YS5zbGljZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VG90YWxCaXRzKHNlZ3MsIHZlcnNpb24pIHtcbiAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBjb25zdCBjY2JpdHMgPSBzZWcubW9kZS5udW1DaGFyQ291bnRCaXRzKHZlcnNpb24pO1xuICAgICAgICBpZiAoc2VnLm51bUNoYXJzID49IDEgPDwgY2NiaXRzKVxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgcmVzdWx0ICs9IDQgKyBjY2JpdHMgKyBzZWcuYml0RGF0YS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgdG9VdGY4Qnl0ZUFycmF5KHN0cikge1xuICAgICAgc3RyID0gZW5jb2RlVVJJKHN0cik7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdChpKSAhPSBcIiVcIilcbiAgICAgICAgICByZXN1bHQucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHN0ci5zdWJzdHIoaSArIDEsIDIpLCAxNikpO1xuICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG4gIGxldCBRclNlZ21lbnQgPSBfUXJTZWdtZW50O1xuICBRclNlZ21lbnQuTlVNRVJJQ19SRUdFWCA9IC9eWzAtOV0qJC87XG4gIFFyU2VnbWVudC5BTFBIQU5VTUVSSUNfUkVHRVggPSAvXltBLVowLTkgJCUqKy5cXC86LV0qJC87XG4gIFFyU2VnbWVudC5BTFBIQU5VTUVSSUNfQ0hBUlNFVCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaICQlKistLi86XCI7XG4gIHFyY29kZWdlbjIuUXJTZWdtZW50ID0gUXJTZWdtZW50O1xufSkocXJjb2RlZ2VuIHx8IChxcmNvZGVnZW4gPSB7fSkpO1xuKChxcmNvZGVnZW4yKSA9PiB7XG4gIGxldCBRckNvZGU7XG4gICgoUXJDb2RlMikgPT4ge1xuICAgIGNvbnN0IF9FY2MgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3RvcihvcmRpbmFsLCBmb3JtYXRCaXRzKSB7XG4gICAgICAgIHRoaXMub3JkaW5hbCA9IG9yZGluYWw7XG4gICAgICAgIHRoaXMuZm9ybWF0Qml0cyA9IGZvcm1hdEJpdHM7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgRWNjID0gX0VjYztcbiAgICBFY2MuTE9XID0gbmV3IF9FY2MoMCwgMSk7XG4gICAgRWNjLk1FRElVTSA9IG5ldyBfRWNjKDEsIDApO1xuICAgIEVjYy5RVUFSVElMRSA9IG5ldyBfRWNjKDIsIDMpO1xuICAgIEVjYy5ISUdIID0gbmV3IF9FY2MoMywgMik7XG4gICAgUXJDb2RlMi5FY2MgPSBFY2M7XG4gIH0pKFFyQ29kZSA9IHFyY29kZWdlbjIuUXJDb2RlIHx8IChxcmNvZGVnZW4yLlFyQ29kZSA9IHt9KSk7XG59KShxcmNvZGVnZW4gfHwgKHFyY29kZWdlbiA9IHt9KSk7XG4oKHFyY29kZWdlbjIpID0+IHtcbiAgbGV0IFFyU2VnbWVudDtcbiAgKChRclNlZ21lbnQyKSA9PiB7XG4gICAgY29uc3QgX01vZGUgPSBjbGFzcyB7XG4gICAgICBjb25zdHJ1Y3Rvcihtb2RlQml0cywgbnVtQml0c0NoYXJDb3VudCkge1xuICAgICAgICB0aGlzLm1vZGVCaXRzID0gbW9kZUJpdHM7XG4gICAgICAgIHRoaXMubnVtQml0c0NoYXJDb3VudCA9IG51bUJpdHNDaGFyQ291bnQ7XG4gICAgICB9XG4gICAgICBudW1DaGFyQ291bnRCaXRzKHZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1CaXRzQ2hhckNvdW50W01hdGguZmxvb3IoKHZlciArIDcpIC8gMTcpXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBNb2RlID0gX01vZGU7XG4gICAgTW9kZS5OVU1FUklDID0gbmV3IF9Nb2RlKDEsIFsxMCwgMTIsIDE0XSk7XG4gICAgTW9kZS5BTFBIQU5VTUVSSUMgPSBuZXcgX01vZGUoMiwgWzksIDExLCAxM10pO1xuICAgIE1vZGUuQllURSA9IG5ldyBfTW9kZSg0LCBbOCwgMTYsIDE2XSk7XG4gICAgTW9kZS5LQU5KSSA9IG5ldyBfTW9kZSg4LCBbOCwgMTAsIDEyXSk7XG4gICAgTW9kZS5FQ0kgPSBuZXcgX01vZGUoNywgWzAsIDAsIDBdKTtcbiAgICBRclNlZ21lbnQyLk1vZGUgPSBNb2RlO1xuICB9KShRclNlZ21lbnQgPSBxcmNvZGVnZW4yLlFyU2VnbWVudCB8fCAocXJjb2RlZ2VuMi5RclNlZ21lbnQgPSB7fSkpO1xufSkocXJjb2RlZ2VuIHx8IChxcmNvZGVnZW4gPSB7fSkpO1xudmFyIHFyY29kZWdlbl9kZWZhdWx0ID0gcXJjb2RlZ2VuO1xuXG4vLyBzcmMvaW5kZXgudHN4XG4vKipcbiAqIEBsaWNlbnNlIHFyY29kZS5yZWFjdFxuICogQ29weXJpZ2h0IChjKSBQYXVsIE8nU2hhbm5lc3N5XG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogSVNDXG4gKi9cbnZhciBFUlJPUl9MRVZFTF9NQVAgPSB7XG4gIEw6IHFyY29kZWdlbl9kZWZhdWx0LlFyQ29kZS5FY2MuTE9XLFxuICBNOiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuRWNjLk1FRElVTSxcbiAgUTogcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLkVjYy5RVUFSVElMRSxcbiAgSDogcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLkVjYy5ISUdIXG59O1xudmFyIERFRkFVTFRfU0laRSA9IDEyODtcbnZhciBERUZBVUxUX0xFVkVMID0gXCJMXCI7XG52YXIgREVGQVVMVF9CR0NPTE9SID0gXCIjRkZGRkZGXCI7XG52YXIgREVGQVVMVF9GR0NPTE9SID0gXCIjMDAwMDAwXCI7XG52YXIgREVGQVVMVF9JTkNMVURFTUFSR0lOID0gZmFsc2U7XG52YXIgTUFSR0lOX1NJWkUgPSA0O1xudmFyIERFRkFVTFRfSU1HX1NDQUxFID0gMC4xO1xuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG1vZHVsZXMsIG1hcmdpbiA9IDApIHtcbiAgY29uc3Qgb3BzID0gW107XG4gIG1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihyb3csIHkpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwsIHgpIHtcbiAgICAgIGlmICghY2VsbCAmJiBzdGFydCAhPT0gbnVsbCkge1xuICAgICAgICBvcHMucHVzaChgTSR7c3RhcnQgKyBtYXJnaW59ICR7eSArIG1hcmdpbn1oJHt4IC0gc3RhcnR9djFIJHtzdGFydCArIG1hcmdpbn16YCk7XG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHggPT09IHJvdy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICBvcHMucHVzaChgTSR7eCArIG1hcmdpbn0sJHt5ICsgbWFyZ2lufSBoMXYxSCR7eCArIG1hcmdpbn16YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BzLnB1c2goYE0ke3N0YXJ0ICsgbWFyZ2lufSwke3kgKyBtYXJnaW59IGgke3ggKyAxIC0gc3RhcnR9djFIJHtzdGFydCArIG1hcmdpbn16YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNlbGwgJiYgc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgc3RhcnQgPSB4O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9wcy5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZXhjYXZhdGVNb2R1bGVzKG1vZHVsZXMsIGV4Y2F2YXRpb24pIHtcbiAgcmV0dXJuIG1vZHVsZXMuc2xpY2UoKS5tYXAoKHJvdywgeSkgPT4ge1xuICAgIGlmICh5IDwgZXhjYXZhdGlvbi55IHx8IHkgPj0gZXhjYXZhdGlvbi55ICsgZXhjYXZhdGlvbi5oKSB7XG4gICAgICByZXR1cm4gcm93O1xuICAgIH1cbiAgICByZXR1cm4gcm93Lm1hcCgoY2VsbCwgeCkgPT4ge1xuICAgICAgaWYgKHggPCBleGNhdmF0aW9uLnggfHwgeCA+PSBleGNhdmF0aW9uLnggKyBleGNhdmF0aW9uLncpIHtcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0SW1hZ2VTZXR0aW5ncyhjZWxscywgc2l6ZSwgaW5jbHVkZU1hcmdpbiwgaW1hZ2VTZXR0aW5ncykge1xuICBpZiAoaW1hZ2VTZXR0aW5ncyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbWFyZ2luID0gaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9TSVpFIDogMDtcbiAgY29uc3QgbnVtQ2VsbHMgPSBjZWxscy5sZW5ndGggKyBtYXJnaW4gKiAyO1xuICBjb25zdCBkZWZhdWx0U2l6ZSA9IE1hdGguZmxvb3Ioc2l6ZSAqIERFRkFVTFRfSU1HX1NDQUxFKTtcbiAgY29uc3Qgc2NhbGUgPSBudW1DZWxscyAvIHNpemU7XG4gIGNvbnN0IHcgPSAoaW1hZ2VTZXR0aW5ncy53aWR0aCB8fCBkZWZhdWx0U2l6ZSkgKiBzY2FsZTtcbiAgY29uc3QgaCA9IChpbWFnZVNldHRpbmdzLmhlaWdodCB8fCBkZWZhdWx0U2l6ZSkgKiBzY2FsZTtcbiAgY29uc3QgeCA9IGltYWdlU2V0dGluZ3MueCA9PSBudWxsID8gY2VsbHMubGVuZ3RoIC8gMiAtIHcgLyAyIDogaW1hZ2VTZXR0aW5ncy54ICogc2NhbGU7XG4gIGNvbnN0IHkgPSBpbWFnZVNldHRpbmdzLnkgPT0gbnVsbCA/IGNlbGxzLmxlbmd0aCAvIDIgLSBoIC8gMiA6IGltYWdlU2V0dGluZ3MueSAqIHNjYWxlO1xuICBsZXQgZXhjYXZhdGlvbiA9IG51bGw7XG4gIGlmIChpbWFnZVNldHRpbmdzLmV4Y2F2YXRlKSB7XG4gICAgbGV0IGZsb29yWCA9IE1hdGguZmxvb3IoeCk7XG4gICAgbGV0IGZsb29yWSA9IE1hdGguZmxvb3IoeSk7XG4gICAgbGV0IGNlaWxXID0gTWF0aC5jZWlsKHcgKyB4IC0gZmxvb3JYKTtcbiAgICBsZXQgY2VpbEggPSBNYXRoLmNlaWwoaCArIHkgLSBmbG9vclkpO1xuICAgIGV4Y2F2YXRpb24gPSB7IHg6IGZsb29yWCwgeTogZmxvb3JZLCB3OiBjZWlsVywgaDogY2VpbEggfTtcbiAgfVxuICByZXR1cm4geyB4LCB5LCBoLCB3LCBleGNhdmF0aW9uIH07XG59XG52YXIgU1VQUE9SVFNfUEFUSDJEID0gZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgbmV3IFBhdGgyRCgpLmFkZFBhdGgobmV3IFBhdGgyRCgpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0oKTtcbmZ1bmN0aW9uIFFSQ29kZUNhbnZhcyhwcm9wcykge1xuICBjb25zdCBfYSA9IHByb3BzLCB7XG4gICAgdmFsdWUsXG4gICAgc2l6ZSA9IERFRkFVTFRfU0laRSxcbiAgICBsZXZlbCA9IERFRkFVTFRfTEVWRUwsXG4gICAgYmdDb2xvciA9IERFRkFVTFRfQkdDT0xPUixcbiAgICBmZ0NvbG9yID0gREVGQVVMVF9GR0NPTE9SLFxuICAgIGluY2x1ZGVNYXJnaW4gPSBERUZBVUxUX0lOQ0xVREVNQVJHSU4sXG4gICAgc3R5bGUsXG4gICAgaW1hZ2VTZXR0aW5nc1xuICB9ID0gX2EsIG90aGVyUHJvcHMgPSBfX29ialJlc3QoX2EsIFtcbiAgICBcInZhbHVlXCIsXG4gICAgXCJzaXplXCIsXG4gICAgXCJsZXZlbFwiLFxuICAgIFwiYmdDb2xvclwiLFxuICAgIFwiZmdDb2xvclwiLFxuICAgIFwiaW5jbHVkZU1hcmdpblwiLFxuICAgIFwic3R5bGVcIixcbiAgICBcImltYWdlU2V0dGluZ3NcIlxuICBdKTtcbiAgY29uc3QgaW1nU3JjID0gaW1hZ2VTZXR0aW5ncyA9PSBudWxsID8gdm9pZCAwIDogaW1hZ2VTZXR0aW5ncy5zcmM7XG4gIGNvbnN0IF9jYW52YXMgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IF9pbWFnZSA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2lzSW1nTG9hZGVkLCBzZXRJc0ltYWdlTG9hZGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoX2NhbnZhcy5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IF9jYW52YXMuY3VycmVudDtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBpZiAoIWN0eCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgY2VsbHMgPSBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuZW5jb2RlVGV4dCh2YWx1ZSwgRVJST1JfTEVWRUxfTUFQW2xldmVsXSkuZ2V0TW9kdWxlcygpO1xuICAgICAgY29uc3QgbWFyZ2luID0gaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9TSVpFIDogMDtcbiAgICAgIGNvbnN0IG51bUNlbGxzID0gY2VsbHMubGVuZ3RoICsgbWFyZ2luICogMjtcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzID0gZ2V0SW1hZ2VTZXR0aW5ncyhjZWxscywgc2l6ZSwgaW5jbHVkZU1hcmdpbiwgaW1hZ2VTZXR0aW5ncyk7XG4gICAgICBjb25zdCBpbWFnZSA9IF9pbWFnZS5jdXJyZW50O1xuICAgICAgY29uc3QgaGF2ZUltYWdlVG9SZW5kZXIgPSBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyAhPSBudWxsICYmIGltYWdlICE9PSBudWxsICYmIGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxIZWlnaHQgIT09IDAgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwO1xuICAgICAgaWYgKGhhdmVJbWFnZVRvUmVuZGVyKSB7XG4gICAgICAgIGlmIChjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBjZWxscyA9IGV4Y2F2YXRlTW9kdWxlcyhjZWxscywgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCA9IHNpemUgKiBwaXhlbFJhdGlvO1xuICAgICAgY29uc3Qgc2NhbGUgPSBzaXplIC8gbnVtQ2VsbHMgKiBwaXhlbFJhdGlvO1xuICAgICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBudW1DZWxscywgbnVtQ2VsbHMpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZnQ29sb3I7XG4gICAgICBpZiAoU1VQUE9SVFNfUEFUSDJEKSB7XG4gICAgICAgIGN0eC5maWxsKG5ldyBQYXRoMkQoZ2VuZXJhdGVQYXRoKGNlbGxzLCBtYXJnaW4pKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxscy5mb3JFYWNoKGZ1bmN0aW9uKHJvdywgcmR4KSB7XG4gICAgICAgICAgcm93LmZvckVhY2goZnVuY3Rpb24oY2VsbCwgY2R4KSB7XG4gICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoY2R4ICsgbWFyZ2luLCByZHggKyBtYXJnaW4sIDEsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXZlSW1hZ2VUb1JlbmRlcikge1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy54ICsgbWFyZ2luLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy55ICsgbWFyZ2luLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy53LCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElzSW1hZ2VMb2FkZWQoZmFsc2UpO1xuICB9LCBbaW1nU3JjXSk7XG4gIGNvbnN0IGNhbnZhc1N0eWxlID0gX19zcHJlYWRWYWx1ZXMoeyBoZWlnaHQ6IHNpemUsIHdpZHRoOiBzaXplIH0sIHN0eWxlKTtcbiAgbGV0IGltZyA9IG51bGw7XG4gIGlmIChpbWdTcmMgIT0gbnVsbCkge1xuICAgIGltZyA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICAgIHNyYzogaW1nU3JjLFxuICAgICAga2V5OiBpbWdTcmMsXG4gICAgICBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9LFxuICAgICAgb25Mb2FkOiAoKSA9PiB7XG4gICAgICAgIHNldElzSW1hZ2VMb2FkZWQodHJ1ZSk7XG4gICAgICB9LFxuICAgICAgcmVmOiBfaW1hZ2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIF9fc3ByZWFkVmFsdWVzKHtcbiAgICBzdHlsZTogY2FudmFzU3R5bGUsXG4gICAgaGVpZ2h0OiBzaXplLFxuICAgIHdpZHRoOiBzaXplLFxuICAgIHJlZjogX2NhbnZhc1xuICB9LCBvdGhlclByb3BzKSksIGltZyk7XG59XG5mdW5jdGlvbiBRUkNvZGVTVkcocHJvcHMpIHtcbiAgY29uc3QgX2EgPSBwcm9wcywge1xuICAgIHZhbHVlLFxuICAgIHNpemUgPSBERUZBVUxUX1NJWkUsXG4gICAgbGV2ZWwgPSBERUZBVUxUX0xFVkVMLFxuICAgIGJnQ29sb3IgPSBERUZBVUxUX0JHQ09MT1IsXG4gICAgZmdDb2xvciA9IERFRkFVTFRfRkdDT0xPUixcbiAgICBpbmNsdWRlTWFyZ2luID0gREVGQVVMVF9JTkNMVURFTUFSR0lOLFxuICAgIGltYWdlU2V0dGluZ3NcbiAgfSA9IF9hLCBvdGhlclByb3BzID0gX19vYmpSZXN0KF9hLCBbXG4gICAgXCJ2YWx1ZVwiLFxuICAgIFwic2l6ZVwiLFxuICAgIFwibGV2ZWxcIixcbiAgICBcImJnQ29sb3JcIixcbiAgICBcImZnQ29sb3JcIixcbiAgICBcImluY2x1ZGVNYXJnaW5cIixcbiAgICBcImltYWdlU2V0dGluZ3NcIlxuICBdKTtcbiAgbGV0IGNlbGxzID0gcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLmVuY29kZVRleHQodmFsdWUsIEVSUk9SX0xFVkVMX01BUFtsZXZlbF0pLmdldE1vZHVsZXMoKTtcbiAgY29uc3QgbWFyZ2luID0gaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9TSVpFIDogMDtcbiAgY29uc3QgbnVtQ2VsbHMgPSBjZWxscy5sZW5ndGggKyBtYXJnaW4gKiAyO1xuICBjb25zdCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyA9IGdldEltYWdlU2V0dGluZ3MoY2VsbHMsIHNpemUsIGluY2x1ZGVNYXJnaW4sIGltYWdlU2V0dGluZ3MpO1xuICBsZXQgaW1hZ2UgPSBudWxsO1xuICBpZiAoaW1hZ2VTZXR0aW5ncyAhPSBudWxsICYmIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzICE9IG51bGwpIHtcbiAgICBpZiAoY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICBjZWxscyA9IGV4Y2F2YXRlTW9kdWxlcyhjZWxscywgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbik7XG4gICAgfVxuICAgIGltYWdlID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWFnZVwiLCB7XG4gICAgICB4bGlua0hyZWY6IGltYWdlU2V0dGluZ3Muc3JjLFxuICAgICAgaGVpZ2h0OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5oLFxuICAgICAgd2lkdGg6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLncsXG4gICAgICB4OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy54ICsgbWFyZ2luLFxuICAgICAgeTogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MueSArIG1hcmdpbixcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgZmdQYXRoID0gZ2VuZXJhdGVQYXRoKGNlbGxzLCBtYXJnaW4pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX19zcHJlYWRWYWx1ZXMoe1xuICAgIGhlaWdodDogc2l6ZSxcbiAgICB3aWR0aDogc2l6ZSxcbiAgICB2aWV3Qm94OiBgMCAwICR7bnVtQ2VsbHN9ICR7bnVtQ2VsbHN9YFxuICB9LCBvdGhlclByb3BzKSwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBmaWxsOiBiZ0NvbG9yLFxuICAgIGQ6IGBNMCwwIGgke251bUNlbGxzfXYke251bUNlbGxzfUgwemAsXG4gICAgc2hhcGVSZW5kZXJpbmc6IFwiY3Jpc3BFZGdlc1wiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGw6IGZnQ29sb3IsXG4gICAgZDogZmdQYXRoLFxuICAgIHNoYXBlUmVuZGVyaW5nOiBcImNyaXNwRWRnZXNcIlxuICB9KSwgaW1hZ2UpO1xufVxudmFyIFFSQ29kZSA9IChwcm9wcykgPT4ge1xuICBjb25zdCBfYSA9IHByb3BzLCB7IHJlbmRlckFzIH0gPSBfYSwgb3RoZXJQcm9wcyA9IF9fb2JqUmVzdChfYSwgW1wicmVuZGVyQXNcIl0pO1xuICBpZiAocmVuZGVyQXMgPT09IFwic3ZnXCIpIHtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUVJDb2RlU1ZHLCBfX3NwcmVhZFZhbHVlcyh7fSwgb3RoZXJQcm9wcykpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChRUkNvZGVDYW52YXMsIF9fc3ByZWFkVmFsdWVzKHt9LCBvdGhlclByb3BzKSk7XG59O1xuZXhwb3J0IHtcbiAgUVJDb2RlQ2FudmFzLFxuICBRUkNvZGVTVkcsXG4gIFFSQ29kZSBhcyBkZWZhdWx0XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///Wxvo\n')},qHiR:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJpc21qcy90aGVtZXMvcHJpc20uY3NzPzI2NmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoicUhpUi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///qHiR\n")},vRGJ:function(module,exports,__webpack_require__){eval("var isarray = __webpack_require__(\"AqCL\");\n/**\n * Expose `pathToRegexp`.\n */\n\n\nmodule.exports = pathToRegexp;\nmodule.exports.parse = parse;\nmodule.exports.compile = compile;\nmodule.exports.tokensToFunction = tokensToFunction;\nmodule.exports.tokensToRegExp = tokensToRegExp;\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\n\nvar PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.\n// This allows the user to escape special characters that won't transform.\n'(\\\\\\\\.)', // Match Express-style parameters and un-named parameters with a prefix\n// and optional suffixes. Matches appear as:\n//\n// \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n// \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n// \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n'([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\n\nfunction parse(str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length; // Ignore already escaped sequences.\n\n    if (escaped) {\n      path += escaped[1];\n      continue;\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7]; // Push the current path onto the tokens.\n\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n    });\n  } // Match any characters still remaining.\n\n\n  if (index < str.length) {\n    path += str.substr(index);\n  } // If the path exists, push it onto the end.\n\n\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens;\n}\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\n\n\nfunction compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\n\n\nfunction encodeURIComponentPretty(str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\n\n\nfunction encodeAsterisk(str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n  });\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\n\nfunction tokensToFunction(tokens, options) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length); // Compile all the patterns before compilation.\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options));\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n        continue;\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue;\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined');\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue;\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path;\n  };\n}\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\n\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n}\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\n\n\nfunction escapeGroup(group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n}\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\n\n\nfunction attachKeys(re, keys) {\n  re.keys = keys;\n  return re;\n}\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\n\n\nfunction flags(options) {\n  return options && options.sensitive ? '' : 'i';\n}\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys);\n}\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\n\n\nfunction arrayToRegexp(path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n  return attachKeys(regexp, keys);\n}\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\n\n\nfunction tokensToRegExp(tokens, keys, options) {\n  if (!isarray(keys)) {\n    options =\n    /** @type {!Object} */\n    keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = ''; // Iterate over the tokens and create our regexp string.\n\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter; // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys);\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\n\n\nfunction pathToRegexp(path, keys, options) {\n  if (!isarray(keys)) {\n    options =\n    /** @type {!Object} */\n    keys || options;\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path,\n    /** @type {!Array} */\n    keys);\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(\n    /** @type {!Array} */\n    path,\n    /** @type {!Array} */\n    keys, options);\n  }\n\n  return stringToRegexp(\n  /** @type {string} */\n  path,\n  /** @type {!Array} */\n  keys, options);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanM/YmQxMSJdLCJuYW1lcyI6WyJpc2FycmF5IiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJwYXRoVG9SZWdleHAiLCJwYXJzZSIsImNvbXBpbGUiLCJ0b2tlbnNUb0Z1bmN0aW9uIiwidG9rZW5zVG9SZWdFeHAiLCJQQVRIX1JFR0VYUCIsIlJlZ0V4cCIsImpvaW4iLCJzdHIiLCJvcHRpb25zIiwidG9rZW5zIiwia2V5IiwiaW5kZXgiLCJwYXRoIiwiZGVmYXVsdERlbGltaXRlciIsImRlbGltaXRlciIsInJlcyIsImV4ZWMiLCJtIiwiZXNjYXBlZCIsIm9mZnNldCIsInNsaWNlIiwibGVuZ3RoIiwibmV4dCIsInByZWZpeCIsIm5hbWUiLCJjYXB0dXJlIiwiZ3JvdXAiLCJtb2RpZmllciIsImFzdGVyaXNrIiwicHVzaCIsInBhcnRpYWwiLCJyZXBlYXQiLCJvcHRpb25hbCIsInBhdHRlcm4iLCJlc2NhcGVHcm91cCIsImVzY2FwZVN0cmluZyIsInN1YnN0ciIsImVuY29kZVVSSUNvbXBvbmVudFByZXR0eSIsImVuY29kZVVSSSIsInJlcGxhY2UiLCJjIiwiY2hhckNvZGVBdCIsInRvU3RyaW5nIiwidG9VcHBlckNhc2UiLCJlbmNvZGVBc3RlcmlzayIsIm1hdGNoZXMiLCJBcnJheSIsImkiLCJmbGFncyIsIm9iaiIsIm9wdHMiLCJkYXRhIiwiZW5jb2RlIiwicHJldHR5IiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidG9rZW4iLCJ2YWx1ZSIsInNlZ21lbnQiLCJUeXBlRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiaiIsInRlc3QiLCJhdHRhY2hLZXlzIiwicmUiLCJrZXlzIiwic2Vuc2l0aXZlIiwicmVnZXhwVG9SZWdleHAiLCJncm91cHMiLCJzb3VyY2UiLCJtYXRjaCIsImFycmF5VG9SZWdleHAiLCJwYXJ0cyIsInJlZ2V4cCIsInN0cmluZ1RvUmVnZXhwIiwic3RyaWN0IiwiZW5kIiwicm91dGUiLCJlbmRzV2l0aERlbGltaXRlciJdLCJtYXBwaW5ncyI6IkFBQUEsSUFBSUEsT0FBTyxHQUFHQyxtQkFBTyxDQUFDLE1BQUQsQ0FBckI7QUFFQTtBQUNBO0FBQ0E7OztBQUNBQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJDLFlBQWpCO0FBQ0FGLE1BQU0sQ0FBQ0MsT0FBUCxDQUFlRSxLQUFmLEdBQXVCQSxLQUF2QjtBQUNBSCxNQUFNLENBQUNDLE9BQVAsQ0FBZUcsT0FBZixHQUF5QkEsT0FBekI7QUFDQUosTUFBTSxDQUFDQyxPQUFQLENBQWVJLGdCQUFmLEdBQWtDQSxnQkFBbEM7QUFDQUwsTUFBTSxDQUFDQyxPQUFQLENBQWVLLGNBQWYsR0FBZ0NBLGNBQWhDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJQyxXQUFXLEdBQUcsSUFBSUMsTUFBSixDQUFXLENBQzNCO0FBQ0E7QUFDQSxTQUgyQixFQUkzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FWMkIsRUFXM0JDLElBWDJCLENBV3RCLEdBWHNCLENBQVgsRUFXTCxHQVhLLENBQWxCO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU04sS0FBVCxDQUFnQk8sR0FBaEIsRUFBcUJDLE9BQXJCLEVBQThCO0VBQzVCLElBQUlDLE1BQU0sR0FBRyxFQUFiO0VBQ0EsSUFBSUMsR0FBRyxHQUFHLENBQVY7RUFDQSxJQUFJQyxLQUFLLEdBQUcsQ0FBWjtFQUNBLElBQUlDLElBQUksR0FBRyxFQUFYO0VBQ0EsSUFBSUMsZ0JBQWdCLEdBQUdMLE9BQU8sSUFBSUEsT0FBTyxDQUFDTSxTQUFuQixJQUFnQyxHQUF2RDtFQUNBLElBQUlDLEdBQUo7O0VBRUEsT0FBTyxDQUFDQSxHQUFHLEdBQUdYLFdBQVcsQ0FBQ1ksSUFBWixDQUFpQlQsR0FBakIsQ0FBUCxLQUFpQyxJQUF4QyxFQUE4QztJQUM1QyxJQUFJVSxDQUFDLEdBQUdGLEdBQUcsQ0FBQyxDQUFELENBQVg7SUFDQSxJQUFJRyxPQUFPLEdBQUdILEdBQUcsQ0FBQyxDQUFELENBQWpCO0lBQ0EsSUFBSUksTUFBTSxHQUFHSixHQUFHLENBQUNKLEtBQWpCO0lBQ0FDLElBQUksSUFBSUwsR0FBRyxDQUFDYSxLQUFKLENBQVVULEtBQVYsRUFBaUJRLE1BQWpCLENBQVI7SUFDQVIsS0FBSyxHQUFHUSxNQUFNLEdBQUdGLENBQUMsQ0FBQ0ksTUFBbkIsQ0FMNEMsQ0FPNUM7O0lBQ0EsSUFBSUgsT0FBSixFQUFhO01BQ1hOLElBQUksSUFBSU0sT0FBTyxDQUFDLENBQUQsQ0FBZjtNQUNBO0lBQ0Q7O0lBRUQsSUFBSUksSUFBSSxHQUFHZixHQUFHLENBQUNJLEtBQUQsQ0FBZDtJQUNBLElBQUlZLE1BQU0sR0FBR1IsR0FBRyxDQUFDLENBQUQsQ0FBaEI7SUFDQSxJQUFJUyxJQUFJLEdBQUdULEdBQUcsQ0FBQyxDQUFELENBQWQ7SUFDQSxJQUFJVSxPQUFPLEdBQUdWLEdBQUcsQ0FBQyxDQUFELENBQWpCO0lBQ0EsSUFBSVcsS0FBSyxHQUFHWCxHQUFHLENBQUMsQ0FBRCxDQUFmO0lBQ0EsSUFBSVksUUFBUSxHQUFHWixHQUFHLENBQUMsQ0FBRCxDQUFsQjtJQUNBLElBQUlhLFFBQVEsR0FBR2IsR0FBRyxDQUFDLENBQUQsQ0FBbEIsQ0FuQjRDLENBcUI1Qzs7SUFDQSxJQUFJSCxJQUFKLEVBQVU7TUFDUkgsTUFBTSxDQUFDb0IsSUFBUCxDQUFZakIsSUFBWjtNQUNBQSxJQUFJLEdBQUcsRUFBUDtJQUNEOztJQUVELElBQUlrQixPQUFPLEdBQUdQLE1BQU0sSUFBSSxJQUFWLElBQWtCRCxJQUFJLElBQUksSUFBMUIsSUFBa0NBLElBQUksS0FBS0MsTUFBekQ7SUFDQSxJQUFJUSxNQUFNLEdBQUdKLFFBQVEsS0FBSyxHQUFiLElBQW9CQSxRQUFRLEtBQUssR0FBOUM7SUFDQSxJQUFJSyxRQUFRLEdBQUdMLFFBQVEsS0FBSyxHQUFiLElBQW9CQSxRQUFRLEtBQUssR0FBaEQ7SUFDQSxJQUFJYixTQUFTLEdBQUdDLEdBQUcsQ0FBQyxDQUFELENBQUgsSUFBVUYsZ0JBQTFCO0lBQ0EsSUFBSW9CLE9BQU8sR0FBR1IsT0FBTyxJQUFJQyxLQUF6QjtJQUVBakIsTUFBTSxDQUFDb0IsSUFBUCxDQUFZO01BQ1ZMLElBQUksRUFBRUEsSUFBSSxJQUFJZCxHQUFHLEVBRFA7TUFFVmEsTUFBTSxFQUFFQSxNQUFNLElBQUksRUFGUjtNQUdWVCxTQUFTLEVBQUVBLFNBSEQ7TUFJVmtCLFFBQVEsRUFBRUEsUUFKQTtNQUtWRCxNQUFNLEVBQUVBLE1BTEU7TUFNVkQsT0FBTyxFQUFFQSxPQU5DO01BT1ZGLFFBQVEsRUFBRSxDQUFDLENBQUNBLFFBUEY7TUFRVkssT0FBTyxFQUFFQSxPQUFPLEdBQUdDLFdBQVcsQ0FBQ0QsT0FBRCxDQUFkLEdBQTJCTCxRQUFRLEdBQUcsSUFBSCxHQUFVLE9BQU9PLFlBQVksQ0FBQ3JCLFNBQUQsQ0FBbkIsR0FBaUM7SUFScEYsQ0FBWjtFQVVELENBbkQyQixDQXFENUI7OztFQUNBLElBQUlILEtBQUssR0FBR0osR0FBRyxDQUFDYyxNQUFoQixFQUF3QjtJQUN0QlQsSUFBSSxJQUFJTCxHQUFHLENBQUM2QixNQUFKLENBQVd6QixLQUFYLENBQVI7RUFDRCxDQXhEMkIsQ0EwRDVCOzs7RUFDQSxJQUFJQyxJQUFKLEVBQVU7SUFDUkgsTUFBTSxDQUFDb0IsSUFBUCxDQUFZakIsSUFBWjtFQUNEOztFQUVELE9BQU9ILE1BQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTUixPQUFULENBQWtCTSxHQUFsQixFQUF1QkMsT0FBdkIsRUFBZ0M7RUFDOUIsT0FBT04sZ0JBQWdCLENBQUNGLEtBQUssQ0FBQ08sR0FBRCxFQUFNQyxPQUFOLENBQU4sRUFBc0JBLE9BQXRCLENBQXZCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVM2Qix3QkFBVCxDQUFtQzlCLEdBQW5DLEVBQXdDO0VBQ3RDLE9BQU8rQixTQUFTLENBQUMvQixHQUFELENBQVQsQ0FBZWdDLE9BQWYsQ0FBdUIsU0FBdkIsRUFBa0MsVUFBVUMsQ0FBVixFQUFhO0lBQ3BELE9BQU8sTUFBTUEsQ0FBQyxDQUFDQyxVQUFGLENBQWEsQ0FBYixFQUFnQkMsUUFBaEIsQ0FBeUIsRUFBekIsRUFBNkJDLFdBQTdCLEVBQWI7RUFDRCxDQUZNLENBQVA7QUFHRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0MsY0FBVCxDQUF5QnJDLEdBQXpCLEVBQThCO0VBQzVCLE9BQU8rQixTQUFTLENBQUMvQixHQUFELENBQVQsQ0FBZWdDLE9BQWYsQ0FBdUIsT0FBdkIsRUFBZ0MsVUFBVUMsQ0FBVixFQUFhO0lBQ2xELE9BQU8sTUFBTUEsQ0FBQyxDQUFDQyxVQUFGLENBQWEsQ0FBYixFQUFnQkMsUUFBaEIsQ0FBeUIsRUFBekIsRUFBNkJDLFdBQTdCLEVBQWI7RUFDRCxDQUZNLENBQVA7QUFHRDtBQUVEO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3pDLGdCQUFULENBQTJCTyxNQUEzQixFQUFtQ0QsT0FBbkMsRUFBNEM7RUFDMUM7RUFDQSxJQUFJcUMsT0FBTyxHQUFHLElBQUlDLEtBQUosQ0FBVXJDLE1BQU0sQ0FBQ1ksTUFBakIsQ0FBZCxDQUYwQyxDQUkxQzs7RUFDQSxLQUFLLElBQUkwQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdEMsTUFBTSxDQUFDWSxNQUEzQixFQUFtQzBCLENBQUMsRUFBcEMsRUFBd0M7SUFDdEMsSUFBSSxPQUFPdEMsTUFBTSxDQUFDc0MsQ0FBRCxDQUFiLEtBQXFCLFFBQXpCLEVBQW1DO01BQ2pDRixPQUFPLENBQUNFLENBQUQsQ0FBUCxHQUFhLElBQUkxQyxNQUFKLENBQVcsU0FBU0ksTUFBTSxDQUFDc0MsQ0FBRCxDQUFOLENBQVVkLE9BQW5CLEdBQTZCLElBQXhDLEVBQThDZSxLQUFLLENBQUN4QyxPQUFELENBQW5ELENBQWI7SUFDRDtFQUNGOztFQUVELE9BQU8sVUFBVXlDLEdBQVYsRUFBZUMsSUFBZixFQUFxQjtJQUMxQixJQUFJdEMsSUFBSSxHQUFHLEVBQVg7SUFDQSxJQUFJdUMsSUFBSSxHQUFHRixHQUFHLElBQUksRUFBbEI7SUFDQSxJQUFJekMsT0FBTyxHQUFHMEMsSUFBSSxJQUFJLEVBQXRCO0lBQ0EsSUFBSUUsTUFBTSxHQUFHNUMsT0FBTyxDQUFDNkMsTUFBUixHQUFpQmhCLHdCQUFqQixHQUE0Q2lCLGtCQUF6RDs7SUFFQSxLQUFLLElBQUlQLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd0QyxNQUFNLENBQUNZLE1BQTNCLEVBQW1DMEIsQ0FBQyxFQUFwQyxFQUF3QztNQUN0QyxJQUFJUSxLQUFLLEdBQUc5QyxNQUFNLENBQUNzQyxDQUFELENBQWxCOztNQUVBLElBQUksT0FBT1EsS0FBUCxLQUFpQixRQUFyQixFQUErQjtRQUM3QjNDLElBQUksSUFBSTJDLEtBQVI7UUFFQTtNQUNEOztNQUVELElBQUlDLEtBQUssR0FBR0wsSUFBSSxDQUFDSSxLQUFLLENBQUMvQixJQUFQLENBQWhCO01BQ0EsSUFBSWlDLE9BQUo7O01BRUEsSUFBSUQsS0FBSyxJQUFJLElBQWIsRUFBbUI7UUFDakIsSUFBSUQsS0FBSyxDQUFDdkIsUUFBVixFQUFvQjtVQUNsQjtVQUNBLElBQUl1QixLQUFLLENBQUN6QixPQUFWLEVBQW1CO1lBQ2pCbEIsSUFBSSxJQUFJMkMsS0FBSyxDQUFDaEMsTUFBZDtVQUNEOztVQUVEO1FBQ0QsQ0FQRCxNQU9PO1VBQ0wsTUFBTSxJQUFJbUMsU0FBSixDQUFjLGVBQWVILEtBQUssQ0FBQy9CLElBQXJCLEdBQTRCLGlCQUExQyxDQUFOO1FBQ0Q7TUFDRjs7TUFFRCxJQUFJN0IsT0FBTyxDQUFDNkQsS0FBRCxDQUFYLEVBQW9CO1FBQ2xCLElBQUksQ0FBQ0QsS0FBSyxDQUFDeEIsTUFBWCxFQUFtQjtVQUNqQixNQUFNLElBQUkyQixTQUFKLENBQWMsZUFBZUgsS0FBSyxDQUFDL0IsSUFBckIsR0FBNEIsaUNBQTVCLEdBQWdFbUMsSUFBSSxDQUFDQyxTQUFMLENBQWVKLEtBQWYsQ0FBaEUsR0FBd0YsR0FBdEcsQ0FBTjtRQUNEOztRQUVELElBQUlBLEtBQUssQ0FBQ25DLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0I7VUFDdEIsSUFBSWtDLEtBQUssQ0FBQ3ZCLFFBQVYsRUFBb0I7WUFDbEI7VUFDRCxDQUZELE1BRU87WUFDTCxNQUFNLElBQUkwQixTQUFKLENBQWMsZUFBZUgsS0FBSyxDQUFDL0IsSUFBckIsR0FBNEIsbUJBQTFDLENBQU47VUFDRDtRQUNGOztRQUVELEtBQUssSUFBSXFDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdMLEtBQUssQ0FBQ25DLE1BQTFCLEVBQWtDd0MsQ0FBQyxFQUFuQyxFQUF1QztVQUNyQ0osT0FBTyxHQUFHTCxNQUFNLENBQUNJLEtBQUssQ0FBQ0ssQ0FBRCxDQUFOLENBQWhCOztVQUVBLElBQUksQ0FBQ2hCLE9BQU8sQ0FBQ0UsQ0FBRCxDQUFQLENBQVdlLElBQVgsQ0FBZ0JMLE9BQWhCLENBQUwsRUFBK0I7WUFDN0IsTUFBTSxJQUFJQyxTQUFKLENBQWMsbUJBQW1CSCxLQUFLLENBQUMvQixJQUF6QixHQUFnQyxjQUFoQyxHQUFpRCtCLEtBQUssQ0FBQ3RCLE9BQXZELEdBQWlFLG1CQUFqRSxHQUF1RjBCLElBQUksQ0FBQ0MsU0FBTCxDQUFlSCxPQUFmLENBQXZGLEdBQWlILEdBQS9ILENBQU47VUFDRDs7VUFFRDdDLElBQUksSUFBSSxDQUFDaUQsQ0FBQyxLQUFLLENBQU4sR0FBVU4sS0FBSyxDQUFDaEMsTUFBaEIsR0FBeUJnQyxLQUFLLENBQUN6QyxTQUFoQyxJQUE2QzJDLE9BQXJEO1FBQ0Q7O1FBRUQ7TUFDRDs7TUFFREEsT0FBTyxHQUFHRixLQUFLLENBQUMzQixRQUFOLEdBQWlCZ0IsY0FBYyxDQUFDWSxLQUFELENBQS9CLEdBQXlDSixNQUFNLENBQUNJLEtBQUQsQ0FBekQ7O01BRUEsSUFBSSxDQUFDWCxPQUFPLENBQUNFLENBQUQsQ0FBUCxDQUFXZSxJQUFYLENBQWdCTCxPQUFoQixDQUFMLEVBQStCO1FBQzdCLE1BQU0sSUFBSUMsU0FBSixDQUFjLGVBQWVILEtBQUssQ0FBQy9CLElBQXJCLEdBQTRCLGNBQTVCLEdBQTZDK0IsS0FBSyxDQUFDdEIsT0FBbkQsR0FBNkQsbUJBQTdELEdBQW1Gd0IsT0FBbkYsR0FBNkYsR0FBM0csQ0FBTjtNQUNEOztNQUVEN0MsSUFBSSxJQUFJMkMsS0FBSyxDQUFDaEMsTUFBTixHQUFla0MsT0FBdkI7SUFDRDs7SUFFRCxPQUFPN0MsSUFBUDtFQUNELENBbkVEO0FBb0VEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTdUIsWUFBVCxDQUF1QjVCLEdBQXZCLEVBQTRCO0VBQzFCLE9BQU9BLEdBQUcsQ0FBQ2dDLE9BQUosQ0FBWSw0QkFBWixFQUEwQyxNQUExQyxDQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNMLFdBQVQsQ0FBc0JSLEtBQXRCLEVBQTZCO0VBQzNCLE9BQU9BLEtBQUssQ0FBQ2EsT0FBTixDQUFjLGVBQWQsRUFBK0IsTUFBL0IsQ0FBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVN3QixVQUFULENBQXFCQyxFQUFyQixFQUF5QkMsSUFBekIsRUFBK0I7RUFDN0JELEVBQUUsQ0FBQ0MsSUFBSCxHQUFVQSxJQUFWO0VBQ0EsT0FBT0QsRUFBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTaEIsS0FBVCxDQUFnQnhDLE9BQWhCLEVBQXlCO0VBQ3ZCLE9BQU9BLE9BQU8sSUFBSUEsT0FBTyxDQUFDMEQsU0FBbkIsR0FBK0IsRUFBL0IsR0FBb0MsR0FBM0M7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTQyxjQUFULENBQXlCdkQsSUFBekIsRUFBK0JxRCxJQUEvQixFQUFxQztFQUNuQztFQUNBLElBQUlHLE1BQU0sR0FBR3hELElBQUksQ0FBQ3lELE1BQUwsQ0FBWUMsS0FBWixDQUFrQixXQUFsQixDQUFiOztFQUVBLElBQUlGLE1BQUosRUFBWTtJQUNWLEtBQUssSUFBSXJCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxQixNQUFNLENBQUMvQyxNQUEzQixFQUFtQzBCLENBQUMsRUFBcEMsRUFBd0M7TUFDdENrQixJQUFJLENBQUNwQyxJQUFMLENBQVU7UUFDUkwsSUFBSSxFQUFFdUIsQ0FERTtRQUVSeEIsTUFBTSxFQUFFLElBRkE7UUFHUlQsU0FBUyxFQUFFLElBSEg7UUFJUmtCLFFBQVEsRUFBRSxLQUpGO1FBS1JELE1BQU0sRUFBRSxLQUxBO1FBTVJELE9BQU8sRUFBRSxLQU5EO1FBT1JGLFFBQVEsRUFBRSxLQVBGO1FBUVJLLE9BQU8sRUFBRTtNQVJELENBQVY7SUFVRDtFQUNGOztFQUVELE9BQU84QixVQUFVLENBQUNuRCxJQUFELEVBQU9xRCxJQUFQLENBQWpCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTTSxhQUFULENBQXdCM0QsSUFBeEIsRUFBOEJxRCxJQUE5QixFQUFvQ3pELE9BQXBDLEVBQTZDO0VBQzNDLElBQUlnRSxLQUFLLEdBQUcsRUFBWjs7RUFFQSxLQUFLLElBQUl6QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbkMsSUFBSSxDQUFDUyxNQUF6QixFQUFpQzBCLENBQUMsRUFBbEMsRUFBc0M7SUFDcEN5QixLQUFLLENBQUMzQyxJQUFOLENBQVc5QixZQUFZLENBQUNhLElBQUksQ0FBQ21DLENBQUQsQ0FBTCxFQUFVa0IsSUFBVixFQUFnQnpELE9BQWhCLENBQVosQ0FBcUM2RCxNQUFoRDtFQUNEOztFQUVELElBQUlJLE1BQU0sR0FBRyxJQUFJcEUsTUFBSixDQUFXLFFBQVFtRSxLQUFLLENBQUNsRSxJQUFOLENBQVcsR0FBWCxDQUFSLEdBQTBCLEdBQXJDLEVBQTBDMEMsS0FBSyxDQUFDeEMsT0FBRCxDQUEvQyxDQUFiO0VBRUEsT0FBT3VELFVBQVUsQ0FBQ1UsTUFBRCxFQUFTUixJQUFULENBQWpCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTUyxjQUFULENBQXlCOUQsSUFBekIsRUFBK0JxRCxJQUEvQixFQUFxQ3pELE9BQXJDLEVBQThDO0VBQzVDLE9BQU9MLGNBQWMsQ0FBQ0gsS0FBSyxDQUFDWSxJQUFELEVBQU9KLE9BQVAsQ0FBTixFQUF1QnlELElBQXZCLEVBQTZCekQsT0FBN0IsQ0FBckI7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNMLGNBQVQsQ0FBeUJNLE1BQXpCLEVBQWlDd0QsSUFBakMsRUFBdUN6RCxPQUF2QyxFQUFnRDtFQUM5QyxJQUFJLENBQUNiLE9BQU8sQ0FBQ3NFLElBQUQsQ0FBWixFQUFvQjtJQUNsQnpELE9BQU87SUFBRztJQUF3QnlELElBQUksSUFBSXpELE9BQTFDO0lBQ0F5RCxJQUFJLEdBQUcsRUFBUDtFQUNEOztFQUVEekQsT0FBTyxHQUFHQSxPQUFPLElBQUksRUFBckI7RUFFQSxJQUFJbUUsTUFBTSxHQUFHbkUsT0FBTyxDQUFDbUUsTUFBckI7RUFDQSxJQUFJQyxHQUFHLEdBQUdwRSxPQUFPLENBQUNvRSxHQUFSLEtBQWdCLEtBQTFCO0VBQ0EsSUFBSUMsS0FBSyxHQUFHLEVBQVosQ0FWOEMsQ0FZOUM7O0VBQ0EsS0FBSyxJQUFJOUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3RDLE1BQU0sQ0FBQ1ksTUFBM0IsRUFBbUMwQixDQUFDLEVBQXBDLEVBQXdDO0lBQ3RDLElBQUlRLEtBQUssR0FBRzlDLE1BQU0sQ0FBQ3NDLENBQUQsQ0FBbEI7O0lBRUEsSUFBSSxPQUFPUSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO01BQzdCc0IsS0FBSyxJQUFJMUMsWUFBWSxDQUFDb0IsS0FBRCxDQUFyQjtJQUNELENBRkQsTUFFTztNQUNMLElBQUloQyxNQUFNLEdBQUdZLFlBQVksQ0FBQ29CLEtBQUssQ0FBQ2hDLE1BQVAsQ0FBekI7TUFDQSxJQUFJRSxPQUFPLEdBQUcsUUFBUThCLEtBQUssQ0FBQ3RCLE9BQWQsR0FBd0IsR0FBdEM7TUFFQWdDLElBQUksQ0FBQ3BDLElBQUwsQ0FBVTBCLEtBQVY7O01BRUEsSUFBSUEsS0FBSyxDQUFDeEIsTUFBVixFQUFrQjtRQUNoQk4sT0FBTyxJQUFJLFFBQVFGLE1BQVIsR0FBaUJFLE9BQWpCLEdBQTJCLElBQXRDO01BQ0Q7O01BRUQsSUFBSThCLEtBQUssQ0FBQ3ZCLFFBQVYsRUFBb0I7UUFDbEIsSUFBSSxDQUFDdUIsS0FBSyxDQUFDekIsT0FBWCxFQUFvQjtVQUNsQkwsT0FBTyxHQUFHLFFBQVFGLE1BQVIsR0FBaUIsR0FBakIsR0FBdUJFLE9BQXZCLEdBQWlDLEtBQTNDO1FBQ0QsQ0FGRCxNQUVPO1VBQ0xBLE9BQU8sR0FBR0YsTUFBTSxHQUFHLEdBQVQsR0FBZUUsT0FBZixHQUF5QixJQUFuQztRQUNEO01BQ0YsQ0FORCxNQU1PO1FBQ0xBLE9BQU8sR0FBR0YsTUFBTSxHQUFHLEdBQVQsR0FBZUUsT0FBZixHQUF5QixHQUFuQztNQUNEOztNQUVEb0QsS0FBSyxJQUFJcEQsT0FBVDtJQUNEO0VBQ0Y7O0VBRUQsSUFBSVgsU0FBUyxHQUFHcUIsWUFBWSxDQUFDM0IsT0FBTyxDQUFDTSxTQUFSLElBQXFCLEdBQXRCLENBQTVCO0VBQ0EsSUFBSWdFLGlCQUFpQixHQUFHRCxLQUFLLENBQUN6RCxLQUFOLENBQVksQ0FBQ04sU0FBUyxDQUFDTyxNQUF2QixNQUFtQ1AsU0FBM0QsQ0EzQzhDLENBNkM5QztFQUNBO0VBQ0E7RUFDQTs7RUFDQSxJQUFJLENBQUM2RCxNQUFMLEVBQWE7SUFDWEUsS0FBSyxHQUFHLENBQUNDLGlCQUFpQixHQUFHRCxLQUFLLENBQUN6RCxLQUFOLENBQVksQ0FBWixFQUFlLENBQUNOLFNBQVMsQ0FBQ08sTUFBMUIsQ0FBSCxHQUF1Q3dELEtBQXpELElBQWtFLEtBQWxFLEdBQTBFL0QsU0FBMUUsR0FBc0YsU0FBOUY7RUFDRDs7RUFFRCxJQUFJOEQsR0FBSixFQUFTO0lBQ1BDLEtBQUssSUFBSSxHQUFUO0VBQ0QsQ0FGRCxNQUVPO0lBQ0w7SUFDQTtJQUNBQSxLQUFLLElBQUlGLE1BQU0sSUFBSUcsaUJBQVYsR0FBOEIsRUFBOUIsR0FBbUMsUUFBUWhFLFNBQVIsR0FBb0IsS0FBaEU7RUFDRDs7RUFFRCxPQUFPaUQsVUFBVSxDQUFDLElBQUkxRCxNQUFKLENBQVcsTUFBTXdFLEtBQWpCLEVBQXdCN0IsS0FBSyxDQUFDeEMsT0FBRCxDQUE3QixDQUFELEVBQTBDeUQsSUFBMUMsQ0FBakI7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU2xFLFlBQVQsQ0FBdUJhLElBQXZCLEVBQTZCcUQsSUFBN0IsRUFBbUN6RCxPQUFuQyxFQUE0QztFQUMxQyxJQUFJLENBQUNiLE9BQU8sQ0FBQ3NFLElBQUQsQ0FBWixFQUFvQjtJQUNsQnpELE9BQU87SUFBRztJQUF3QnlELElBQUksSUFBSXpELE9BQTFDO0lBQ0F5RCxJQUFJLEdBQUcsRUFBUDtFQUNEOztFQUVEekQsT0FBTyxHQUFHQSxPQUFPLElBQUksRUFBckI7O0VBRUEsSUFBSUksSUFBSSxZQUFZUCxNQUFwQixFQUE0QjtJQUMxQixPQUFPOEQsY0FBYyxDQUFDdkQsSUFBRDtJQUFPO0lBQXVCcUQsSUFBOUIsQ0FBckI7RUFDRDs7RUFFRCxJQUFJdEUsT0FBTyxDQUFDaUIsSUFBRCxDQUFYLEVBQW1CO0lBQ2pCLE9BQU8yRCxhQUFhO0lBQUM7SUFBdUIzRCxJQUF4QjtJQUErQjtJQUF1QnFELElBQXRELEVBQTZEekQsT0FBN0QsQ0FBcEI7RUFDRDs7RUFFRCxPQUFPa0UsY0FBYztFQUFDO0VBQXVCOUQsSUFBeEI7RUFBK0I7RUFBdUJxRCxJQUF0RCxFQUE2RHpELE9BQTdELENBQXJCO0FBQ0QiLCJmaWxlIjoidlJHSi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpc2FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ2V4cFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZVxubW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJylcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdXG4gIHZhciBrZXkgPSAwXG4gIHZhciBpbmRleCA9IDBcbiAgdmFyIHBhdGggPSAnJ1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nXG4gIHZhciByZXNcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdXG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV1cbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoXG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XVxuICAgIHZhciBwcmVmaXggPSByZXNbMl1cbiAgICB2YXIgbmFtZSA9IHJlc1szXVxuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdXG4gICAgdmFyIGdyb3VwID0gcmVzWzVdXG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdXG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddXG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKVxuICAgICAgcGF0aCA9ICcnXG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlclxuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cFxuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KVxuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KVxuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKVxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSwgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpXG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJywgZmxhZ3Mob3B0aW9ucykpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnXG4gICAgdmFyIGRhdGEgPSBvYmogfHwge31cbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge31cbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlblxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV1cbiAgICAgIHZhciBzZWdtZW50XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSlcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSlcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudFxuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzXG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpXG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSlcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSlcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdFxuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlXG4gIHZhciByb3V0ZSA9ICcnXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KVxuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSdcblxuICAgICAga2V5cy5wdXNoKHRva2VuKVxuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJ1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknXG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmVcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJylcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXJcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/J1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJ1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSdcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///vRGJ\n")},"wd/R":function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js\n//! version : 2.29.3\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n;\n\n(function (global, factory) {\n   true ? module.exports = factory() : undefined;\n})(this, function () {\n  'use strict';\n\n  var hookCallback;\n\n  function hooks() {\n    return hookCallback.apply(null, arguments);\n  } // This is done to register the method called with moment()\n  // without creating circular dependencies.\n\n\n  function setHookCallback(callback) {\n    hookCallback = callback;\n  }\n\n  function isArray(input) {\n    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';\n  }\n\n  function isObject(input) {\n    // IE8 will treat undefined and null as object if it wasn't for\n    // input != null\n    return input != null && Object.prototype.toString.call(input) === '[object Object]';\n  }\n\n  function hasOwnProp(a, b) {\n    return Object.prototype.hasOwnProperty.call(a, b);\n  }\n\n  function isObjectEmpty(obj) {\n    if (Object.getOwnPropertyNames) {\n      return Object.getOwnPropertyNames(obj).length === 0;\n    } else {\n      var k;\n\n      for (k in obj) {\n        if (hasOwnProp(obj, k)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }\n\n  function isUndefined(input) {\n    return input === void 0;\n  }\n\n  function isNumber(input) {\n    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';\n  }\n\n  function isDate(input) {\n    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';\n  }\n\n  function map(arr, fn) {\n    var res = [],\n        i,\n        arrLen = arr.length;\n\n    for (i = 0; i < arrLen; ++i) {\n      res.push(fn(arr[i], i));\n    }\n\n    return res;\n  }\n\n  function extend(a, b) {\n    for (var i in b) {\n      if (hasOwnProp(b, i)) {\n        a[i] = b[i];\n      }\n    }\n\n    if (hasOwnProp(b, 'toString')) {\n      a.toString = b.toString;\n    }\n\n    if (hasOwnProp(b, 'valueOf')) {\n      a.valueOf = b.valueOf;\n    }\n\n    return a;\n  }\n\n  function createUTC(input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, true).utc();\n  }\n\n  function defaultParsingFlags() {\n    // We need to deep clone this object.\n    return {\n      empty: false,\n      unusedTokens: [],\n      unusedInput: [],\n      overflow: -2,\n      charsLeftOver: 0,\n      nullInput: false,\n      invalidEra: null,\n      invalidMonth: null,\n      invalidFormat: false,\n      userInvalidated: false,\n      iso: false,\n      parsedDateParts: [],\n      era: null,\n      meridiem: null,\n      rfc2822: false,\n      weekdayMismatch: false\n    };\n  }\n\n  function getParsingFlags(m) {\n    if (m._pf == null) {\n      m._pf = defaultParsingFlags();\n    }\n\n    return m._pf;\n  }\n\n  var some;\n\n  if (Array.prototype.some) {\n    some = Array.prototype.some;\n  } else {\n    some = function some(fun) {\n      var t = Object(this),\n          len = t.length >>> 0,\n          i;\n\n      for (i = 0; i < len; i++) {\n        if (i in t && fun.call(this, t[i], i, t)) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  }\n\n  function isValid(m) {\n    if (m._isValid == null) {\n      var flags = getParsingFlags(m),\n          parsedParts = some.call(flags.parsedDateParts, function (i) {\n        return i != null;\n      }),\n          isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);\n\n      if (m._strict) {\n        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;\n      }\n\n      if (Object.isFrozen == null || !Object.isFrozen(m)) {\n        m._isValid = isNowValid;\n      } else {\n        return isNowValid;\n      }\n    }\n\n    return m._isValid;\n  }\n\n  function createInvalid(flags) {\n    var m = createUTC(NaN);\n\n    if (flags != null) {\n      extend(getParsingFlags(m), flags);\n    } else {\n      getParsingFlags(m).userInvalidated = true;\n    }\n\n    return m;\n  } // Plugins that add properties should also add the key here (null value),\n  // so we can properly clone ourselves.\n\n\n  var momentProperties = hooks.momentProperties = [],\n      updateInProgress = false;\n\n  function copyConfig(to, from) {\n    var i,\n        prop,\n        val,\n        momentPropertiesLen = momentProperties.length;\n\n    if (!isUndefined(from._isAMomentObject)) {\n      to._isAMomentObject = from._isAMomentObject;\n    }\n\n    if (!isUndefined(from._i)) {\n      to._i = from._i;\n    }\n\n    if (!isUndefined(from._f)) {\n      to._f = from._f;\n    }\n\n    if (!isUndefined(from._l)) {\n      to._l = from._l;\n    }\n\n    if (!isUndefined(from._strict)) {\n      to._strict = from._strict;\n    }\n\n    if (!isUndefined(from._tzm)) {\n      to._tzm = from._tzm;\n    }\n\n    if (!isUndefined(from._isUTC)) {\n      to._isUTC = from._isUTC;\n    }\n\n    if (!isUndefined(from._offset)) {\n      to._offset = from._offset;\n    }\n\n    if (!isUndefined(from._pf)) {\n      to._pf = getParsingFlags(from);\n    }\n\n    if (!isUndefined(from._locale)) {\n      to._locale = from._locale;\n    }\n\n    if (momentPropertiesLen > 0) {\n      for (i = 0; i < momentPropertiesLen; i++) {\n        prop = momentProperties[i];\n        val = from[prop];\n\n        if (!isUndefined(val)) {\n          to[prop] = val;\n        }\n      }\n    }\n\n    return to;\n  } // Moment prototype object\n\n\n  function Moment(config) {\n    copyConfig(this, config);\n    this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n\n    if (!this.isValid()) {\n      this._d = new Date(NaN);\n    } // Prevent infinite loop in case updateOffset creates new moment\n    // objects.\n\n\n    if (updateInProgress === false) {\n      updateInProgress = true;\n      hooks.updateOffset(this);\n      updateInProgress = false;\n    }\n  }\n\n  function isMoment(obj) {\n    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;\n  }\n\n  function warn(msg) {\n    if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {\n      console.warn('Deprecation warning: ' + msg);\n    }\n  }\n\n  function deprecate(msg, fn) {\n    var firstTime = true;\n    return extend(function () {\n      if (hooks.deprecationHandler != null) {\n        hooks.deprecationHandler(null, msg);\n      }\n\n      if (firstTime) {\n        var args = [],\n            arg,\n            i,\n            key,\n            argLen = arguments.length;\n\n        for (i = 0; i < argLen; i++) {\n          arg = '';\n\n          if (typeof arguments[i] === 'object') {\n            arg += '\\n[' + i + '] ';\n\n            for (key in arguments[0]) {\n              if (hasOwnProp(arguments[0], key)) {\n                arg += key + ': ' + arguments[0][key] + ', ';\n              }\n            }\n\n            arg = arg.slice(0, -2); // Remove trailing comma and space\n          } else {\n            arg = arguments[i];\n          }\n\n          args.push(arg);\n        }\n\n        warn(msg + '\\nArguments: ' + Array.prototype.slice.call(args).join('') + '\\n' + new Error().stack);\n        firstTime = false;\n      }\n\n      return fn.apply(this, arguments);\n    }, fn);\n  }\n\n  var deprecations = {};\n\n  function deprecateSimple(name, msg) {\n    if (hooks.deprecationHandler != null) {\n      hooks.deprecationHandler(name, msg);\n    }\n\n    if (!deprecations[name]) {\n      warn(msg);\n      deprecations[name] = true;\n    }\n  }\n\n  hooks.suppressDeprecationWarnings = false;\n  hooks.deprecationHandler = null;\n\n  function isFunction(input) {\n    return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';\n  }\n\n  function set(config) {\n    var prop, i;\n\n    for (i in config) {\n      if (hasOwnProp(config, i)) {\n        prop = config[i];\n\n        if (isFunction(prop)) {\n          this[i] = prop;\n        } else {\n          this['_' + i] = prop;\n        }\n      }\n    }\n\n    this._config = config; // Lenient ordinal parsing accepts just a number in addition to\n    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n\n    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\\d{1,2}/.source);\n  }\n\n  function mergeConfigs(parentConfig, childConfig) {\n    var res = extend({}, parentConfig),\n        prop;\n\n    for (prop in childConfig) {\n      if (hasOwnProp(childConfig, prop)) {\n        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n          res[prop] = {};\n          extend(res[prop], parentConfig[prop]);\n          extend(res[prop], childConfig[prop]);\n        } else if (childConfig[prop] != null) {\n          res[prop] = childConfig[prop];\n        } else {\n          delete res[prop];\n        }\n      }\n    }\n\n    for (prop in parentConfig) {\n      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {\n        // make sure changes to properties don't modify parent config\n        res[prop] = extend({}, res[prop]);\n      }\n    }\n\n    return res;\n  }\n\n  function Locale(config) {\n    if (config != null) {\n      this.set(config);\n    }\n  }\n\n  var keys;\n\n  if (Object.keys) {\n    keys = Object.keys;\n  } else {\n    keys = function keys(obj) {\n      var i,\n          res = [];\n\n      for (i in obj) {\n        if (hasOwnProp(obj, i)) {\n          res.push(i);\n        }\n      }\n\n      return res;\n    };\n  }\n\n  var defaultCalendar = {\n    sameDay: '[Today at] LT',\n    nextDay: '[Tomorrow at] LT',\n    nextWeek: 'dddd [at] LT',\n    lastDay: '[Yesterday at] LT',\n    lastWeek: '[Last] dddd [at] LT',\n    sameElse: 'L'\n  };\n\n  function calendar(key, mom, now) {\n    var output = this._calendar[key] || this._calendar['sameElse'];\n    return isFunction(output) ? output.call(mom, now) : output;\n  }\n\n  function zeroFill(number, targetLength, forceSign) {\n    var absNumber = '' + Math.abs(number),\n        zerosToFill = targetLength - absNumber.length,\n        sign = number >= 0;\n    return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n  }\n\n  var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,\n      localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g,\n      formatFunctions = {},\n      formatTokenFunctions = {}; // token:    'M'\n  // padded:   ['MM', 2]\n  // ordinal:  'Mo'\n  // callback: function () { this.month() + 1 }\n\n  function addFormatToken(token, padded, ordinal, callback) {\n    var func = callback;\n\n    if (typeof callback === 'string') {\n      func = function func() {\n        return this[callback]();\n      };\n    }\n\n    if (token) {\n      formatTokenFunctions[token] = func;\n    }\n\n    if (padded) {\n      formatTokenFunctions[padded[0]] = function () {\n        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n      };\n    }\n\n    if (ordinal) {\n      formatTokenFunctions[ordinal] = function () {\n        return this.localeData().ordinal(func.apply(this, arguments), token);\n      };\n    }\n  }\n\n  function removeFormattingTokens(input) {\n    if (input.match(/\\[[\\s\\S]/)) {\n      return input.replace(/^\\[|\\]$/g, '');\n    }\n\n    return input.replace(/\\\\/g, '');\n  }\n\n  function makeFormatFunction(format) {\n    var array = format.match(formattingTokens),\n        i,\n        length;\n\n    for (i = 0, length = array.length; i < length; i++) {\n      if (formatTokenFunctions[array[i]]) {\n        array[i] = formatTokenFunctions[array[i]];\n      } else {\n        array[i] = removeFormattingTokens(array[i]);\n      }\n    }\n\n    return function (mom) {\n      var output = '',\n          i;\n\n      for (i = 0; i < length; i++) {\n        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n      }\n\n      return output;\n    };\n  } // format date using native date object\n\n\n  function formatMoment(m, format) {\n    if (!m.isValid()) {\n      return m.localeData().invalidDate();\n    }\n\n    format = expandFormat(format, m.localeData());\n    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n    return formatFunctions[format](m);\n  }\n\n  function expandFormat(format, locale) {\n    var i = 5;\n\n    function replaceLongDateFormatTokens(input) {\n      return locale.longDateFormat(input) || input;\n    }\n\n    localFormattingTokens.lastIndex = 0;\n\n    while (i >= 0 && localFormattingTokens.test(format)) {\n      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n      localFormattingTokens.lastIndex = 0;\n      i -= 1;\n    }\n\n    return format;\n  }\n\n  var defaultLongDateFormat = {\n    LTS: 'h:mm:ss A',\n    LT: 'h:mm A',\n    L: 'MM/DD/YYYY',\n    LL: 'MMMM D, YYYY',\n    LLL: 'MMMM D, YYYY h:mm A',\n    LLLL: 'dddd, MMMM D, YYYY h:mm A'\n  };\n\n  function longDateFormat(key) {\n    var format = this._longDateFormat[key],\n        formatUpper = this._longDateFormat[key.toUpperCase()];\n\n    if (format || !formatUpper) {\n      return format;\n    }\n\n    this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {\n      if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {\n        return tok.slice(1);\n      }\n\n      return tok;\n    }).join('');\n    return this._longDateFormat[key];\n  }\n\n  var defaultInvalidDate = 'Invalid date';\n\n  function invalidDate() {\n    return this._invalidDate;\n  }\n\n  var defaultOrdinal = '%d',\n      defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n\n  function ordinal(number) {\n    return this._ordinal.replace('%d', number);\n  }\n\n  var defaultRelativeTime = {\n    future: 'in %s',\n    past: '%s ago',\n    s: 'a few seconds',\n    ss: '%d seconds',\n    m: 'a minute',\n    mm: '%d minutes',\n    h: 'an hour',\n    hh: '%d hours',\n    d: 'a day',\n    dd: '%d days',\n    w: 'a week',\n    ww: '%d weeks',\n    M: 'a month',\n    MM: '%d months',\n    y: 'a year',\n    yy: '%d years'\n  };\n\n  function relativeTime(number, withoutSuffix, string, isFuture) {\n    var output = this._relativeTime[string];\n    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);\n  }\n\n  function pastFuture(diff, output) {\n    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];\n    return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n  }\n\n  var aliases = {};\n\n  function addUnitAlias(unit, shorthand) {\n    var lowerCase = unit.toLowerCase();\n    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;\n  }\n\n  function normalizeUnits(units) {\n    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n  }\n\n  function normalizeObjectUnits(inputObject) {\n    var normalizedInput = {},\n        normalizedProp,\n        prop;\n\n    for (prop in inputObject) {\n      if (hasOwnProp(inputObject, prop)) {\n        normalizedProp = normalizeUnits(prop);\n\n        if (normalizedProp) {\n          normalizedInput[normalizedProp] = inputObject[prop];\n        }\n      }\n    }\n\n    return normalizedInput;\n  }\n\n  var priorities = {};\n\n  function addUnitPriority(unit, priority) {\n    priorities[unit] = priority;\n  }\n\n  function getPrioritizedUnits(unitsObj) {\n    var units = [],\n        u;\n\n    for (u in unitsObj) {\n      if (hasOwnProp(unitsObj, u)) {\n        units.push({\n          unit: u,\n          priority: priorities[u]\n        });\n      }\n    }\n\n    units.sort(function (a, b) {\n      return a.priority - b.priority;\n    });\n    return units;\n  }\n\n  function isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n  }\n\n  function absFloor(number) {\n    if (number < 0) {\n      // -0 -> 0\n      return Math.ceil(number) || 0;\n    } else {\n      return Math.floor(number);\n    }\n  }\n\n  function toInt(argumentForCoercion) {\n    var coercedNumber = +argumentForCoercion,\n        value = 0;\n\n    if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n      value = absFloor(coercedNumber);\n    }\n\n    return value;\n  }\n\n  function makeGetSet(unit, keepTime) {\n    return function (value) {\n      if (value != null) {\n        set$1(this, unit, value);\n        hooks.updateOffset(this, keepTime);\n        return this;\n      } else {\n        return get(this, unit);\n      }\n    };\n  }\n\n  function get(mom, unit) {\n    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;\n  }\n\n  function set$1(mom, unit, value) {\n    if (mom.isValid() && !isNaN(value)) {\n      if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n        value = toInt(value);\n\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));\n      } else {\n        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);\n      }\n    }\n  } // MOMENTS\n\n\n  function stringGet(units) {\n    units = normalizeUnits(units);\n\n    if (isFunction(this[units])) {\n      return this[units]();\n    }\n\n    return this;\n  }\n\n  function stringSet(units, value) {\n    if (typeof units === 'object') {\n      units = normalizeObjectUnits(units);\n      var prioritized = getPrioritizedUnits(units),\n          i,\n          prioritizedLen = prioritized.length;\n\n      for (i = 0; i < prioritizedLen; i++) {\n        this[prioritized[i].unit](units[prioritized[i].unit]);\n      }\n    } else {\n      units = normalizeUnits(units);\n\n      if (isFunction(this[units])) {\n        return this[units](value);\n      }\n    }\n\n    return this;\n  }\n\n  var match1 = /\\d/,\n      //       0 - 9\n  match2 = /\\d\\d/,\n      //      00 - 99\n  match3 = /\\d{3}/,\n      //     000 - 999\n  match4 = /\\d{4}/,\n      //    0000 - 9999\n  match6 = /[+-]?\\d{6}/,\n      // -999999 - 999999\n  match1to2 = /\\d\\d?/,\n      //       0 - 99\n  match3to4 = /\\d\\d\\d\\d?/,\n      //     999 - 9999\n  match5to6 = /\\d\\d\\d\\d\\d\\d?/,\n      //   99999 - 999999\n  match1to3 = /\\d{1,3}/,\n      //       0 - 999\n  match1to4 = /\\d{1,4}/,\n      //       0 - 9999\n  match1to6 = /[+-]?\\d{1,6}/,\n      // -999999 - 999999\n  matchUnsigned = /\\d+/,\n      //       0 - inf\n  matchSigned = /[+-]?\\d+/,\n      //    -inf - inf\n  matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi,\n      // +00:00 -00:00 +0000 -0000 or Z\n  matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi,\n      // +00 -00 +00:00 -00:00 +0000 -0000 or Z\n  matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/,\n      // 123456789 123456789.123\n  // any word (or two) characters or numbers including two/three word month in arabic.\n  // includes scottish gaelic two word and hyphenated months\n  matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i,\n      regexes;\n  regexes = {};\n\n  function addRegexToken(token, regex, strictRegex) {\n    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {\n      return isStrict && strictRegex ? strictRegex : regex;\n    };\n  }\n\n  function getParseRegexForToken(token, config) {\n    if (!hasOwnProp(regexes, token)) {\n      return new RegExp(unescapeFormat(token));\n    }\n\n    return regexes[token](config._strict, config._locale);\n  } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n\n\n  function unescapeFormat(s) {\n    return regexEscape(s.replace('\\\\', '').replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function (matched, p1, p2, p3, p4) {\n      return p1 || p2 || p3 || p4;\n    }));\n  }\n\n  function regexEscape(s) {\n    return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  }\n\n  var tokens = {};\n\n  function addParseToken(token, callback) {\n    var i,\n        func = callback,\n        tokenLen;\n\n    if (typeof token === 'string') {\n      token = [token];\n    }\n\n    if (isNumber(callback)) {\n      func = function func(input, array) {\n        array[callback] = toInt(input);\n      };\n    }\n\n    tokenLen = token.length;\n\n    for (i = 0; i < tokenLen; i++) {\n      tokens[token[i]] = func;\n    }\n  }\n\n  function addWeekParseToken(token, callback) {\n    addParseToken(token, function (input, array, config, token) {\n      config._w = config._w || {};\n      callback(input, config._w, config, token);\n    });\n  }\n\n  function addTimeToArrayFromToken(token, input, config) {\n    if (input != null && hasOwnProp(tokens, token)) {\n      tokens[token](input, config._a, config, token);\n    }\n  }\n\n  var YEAR = 0,\n      MONTH = 1,\n      DATE = 2,\n      HOUR = 3,\n      MINUTE = 4,\n      SECOND = 5,\n      MILLISECOND = 6,\n      WEEK = 7,\n      WEEKDAY = 8;\n\n  function mod(n, x) {\n    return (n % x + x) % x;\n  }\n\n  var indexOf;\n\n  if (Array.prototype.indexOf) {\n    indexOf = Array.prototype.indexOf;\n  } else {\n    indexOf = function indexOf(o) {\n      // I know\n      var i;\n\n      for (i = 0; i < this.length; ++i) {\n        if (this[i] === o) {\n          return i;\n        }\n      }\n\n      return -1;\n    };\n  }\n\n  function daysInMonth(year, month) {\n    if (isNaN(year) || isNaN(month)) {\n      return NaN;\n    }\n\n    var modMonth = mod(month, 12);\n    year += (month - modMonth) / 12;\n    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;\n  } // FORMATTING\n\n\n  addFormatToken('M', ['MM', 2], 'Mo', function () {\n    return this.month() + 1;\n  });\n  addFormatToken('MMM', 0, 0, function (format) {\n    return this.localeData().monthsShort(this, format);\n  });\n  addFormatToken('MMMM', 0, 0, function (format) {\n    return this.localeData().months(this, format);\n  }); // ALIASES\n\n  addUnitAlias('month', 'M'); // PRIORITY\n\n  addUnitPriority('month', 8); // PARSING\n\n  addRegexToken('M', match1to2);\n  addRegexToken('MM', match1to2, match2);\n  addRegexToken('MMM', function (isStrict, locale) {\n    return locale.monthsShortRegex(isStrict);\n  });\n  addRegexToken('MMMM', function (isStrict, locale) {\n    return locale.monthsRegex(isStrict);\n  });\n  addParseToken(['M', 'MM'], function (input, array) {\n    array[MONTH] = toInt(input) - 1;\n  });\n  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {\n    var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.\n\n\n    if (month != null) {\n      array[MONTH] = month;\n    } else {\n      getParsingFlags(config).invalidMonth = input;\n    }\n  }); // LOCALES\n\n  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),\n      defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),\n      MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/,\n      defaultMonthsShortRegex = matchWord,\n      defaultMonthsRegex = matchWord;\n\n  function localeMonths(m, format) {\n    if (!m) {\n      return isArray(this._months) ? this._months : this._months['standalone'];\n    }\n\n    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];\n  }\n\n  function localeMonthsShort(m, format) {\n    if (!m) {\n      return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];\n    }\n\n    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];\n  }\n\n  function handleStrictParse(monthName, format, strict) {\n    var i,\n        ii,\n        mom,\n        llc = monthName.toLocaleLowerCase();\n\n    if (!this._monthsParse) {\n      // this is not used\n      this._monthsParse = [];\n      this._longMonthsParse = [];\n      this._shortMonthsParse = [];\n\n      for (i = 0; i < 12; ++i) {\n        mom = createUTC([2000, i]);\n        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();\n        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();\n      }\n    }\n\n    if (strict) {\n      if (format === 'MMM') {\n        ii = indexOf.call(this._shortMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._longMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    } else {\n      if (format === 'MMM') {\n        ii = indexOf.call(this._shortMonthsParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._longMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._longMonthsParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._shortMonthsParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    }\n  }\n\n  function localeMonthsParse(monthName, format, strict) {\n    var i, mom, regex;\n\n    if (this._monthsParseExact) {\n      return handleStrictParse.call(this, monthName, format, strict);\n    }\n\n    if (!this._monthsParse) {\n      this._monthsParse = [];\n      this._longMonthsParse = [];\n      this._shortMonthsParse = [];\n    } // TODO: add sorting\n    // Sorting makes sure if one month (or abbr) is a prefix of another\n    // see sorting in computeMonthsParse\n\n\n    for (i = 0; i < 12; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, i]);\n\n      if (strict && !this._longMonthsParse[i]) {\n        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');\n        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');\n      }\n\n      if (!strict && !this._monthsParse[i]) {\n        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');\n        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');\n      } // test the regex\n\n\n      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {\n        return i;\n      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {\n        return i;\n      } else if (!strict && this._monthsParse[i].test(monthName)) {\n        return i;\n      }\n    }\n  } // MOMENTS\n\n\n  function setMonth(mom, value) {\n    var dayOfMonth;\n\n    if (!mom.isValid()) {\n      // No op\n      return mom;\n    }\n\n    if (typeof value === 'string') {\n      if (/^\\d+$/.test(value)) {\n        value = toInt(value);\n      } else {\n        value = mom.localeData().monthsParse(value); // TODO: Another silent failure?\n\n        if (!isNumber(value)) {\n          return mom;\n        }\n      }\n    }\n\n    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n\n    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);\n\n    return mom;\n  }\n\n  function getSetMonth(value) {\n    if (value != null) {\n      setMonth(this, value);\n      hooks.updateOffset(this, true);\n      return this;\n    } else {\n      return get(this, 'Month');\n    }\n  }\n\n  function getDaysInMonth() {\n    return daysInMonth(this.year(), this.month());\n  }\n\n  function monthsShortRegex(isStrict) {\n    if (this._monthsParseExact) {\n      if (!hasOwnProp(this, '_monthsRegex')) {\n        computeMonthsParse.call(this);\n      }\n\n      if (isStrict) {\n        return this._monthsShortStrictRegex;\n      } else {\n        return this._monthsShortRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_monthsShortRegex')) {\n        this._monthsShortRegex = defaultMonthsShortRegex;\n      }\n\n      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;\n    }\n  }\n\n  function monthsRegex(isStrict) {\n    if (this._monthsParseExact) {\n      if (!hasOwnProp(this, '_monthsRegex')) {\n        computeMonthsParse.call(this);\n      }\n\n      if (isStrict) {\n        return this._monthsStrictRegex;\n      } else {\n        return this._monthsRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_monthsRegex')) {\n        this._monthsRegex = defaultMonthsRegex;\n      }\n\n      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;\n    }\n  }\n\n  function computeMonthsParse() {\n    function cmpLenRev(a, b) {\n      return b.length - a.length;\n    }\n\n    var shortPieces = [],\n        longPieces = [],\n        mixedPieces = [],\n        i,\n        mom;\n\n    for (i = 0; i < 12; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, i]);\n      shortPieces.push(this.monthsShort(mom, ''));\n      longPieces.push(this.months(mom, ''));\n      mixedPieces.push(this.months(mom, ''));\n      mixedPieces.push(this.monthsShort(mom, ''));\n    } // Sorting makes sure if one month (or abbr) is a prefix of another it\n    // will match the longer piece.\n\n\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n\n    for (i = 0; i < 12; i++) {\n      shortPieces[i] = regexEscape(shortPieces[i]);\n      longPieces[i] = regexEscape(longPieces[i]);\n    }\n\n    for (i = 0; i < 24; i++) {\n      mixedPieces[i] = regexEscape(mixedPieces[i]);\n    }\n\n    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._monthsShortRegex = this._monthsRegex;\n    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n  } // FORMATTING\n\n\n  addFormatToken('Y', 0, 0, function () {\n    var y = this.year();\n    return y <= 9999 ? zeroFill(y, 4) : '+' + y;\n  });\n  addFormatToken(0, ['YY', 2], 0, function () {\n    return this.year() % 100;\n  });\n  addFormatToken(0, ['YYYY', 4], 0, 'year');\n  addFormatToken(0, ['YYYYY', 5], 0, 'year');\n  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES\n\n  addUnitAlias('year', 'y'); // PRIORITIES\n\n  addUnitPriority('year', 1); // PARSING\n\n  addRegexToken('Y', matchSigned);\n  addRegexToken('YY', match1to2, match2);\n  addRegexToken('YYYY', match1to4, match4);\n  addRegexToken('YYYYY', match1to6, match6);\n  addRegexToken('YYYYYY', match1to6, match6);\n  addParseToken(['YYYYY', 'YYYYYY'], YEAR);\n  addParseToken('YYYY', function (input, array) {\n    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n  });\n  addParseToken('YY', function (input, array) {\n    array[YEAR] = hooks.parseTwoDigitYear(input);\n  });\n  addParseToken('Y', function (input, array) {\n    array[YEAR] = parseInt(input, 10);\n  }); // HELPERS\n\n  function daysInYear(year) {\n    return isLeapYear(year) ? 366 : 365;\n  } // HOOKS\n\n\n  hooks.parseTwoDigitYear = function (input) {\n    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n  }; // MOMENTS\n\n\n  var getSetYear = makeGetSet('FullYear', true);\n\n  function getIsLeapYear() {\n    return isLeapYear(this.year());\n  }\n\n  function createDate(y, m, d, h, M, s, ms) {\n    // can't just apply() to create a date:\n    // https://stackoverflow.com/q/181348\n    var date; // the date constructor remaps years 0-99 to 1900-1999\n\n    if (y < 100 && y >= 0) {\n      // preserve leap years using a full 400 year cycle, then reset\n      date = new Date(y + 400, m, d, h, M, s, ms);\n\n      if (isFinite(date.getFullYear())) {\n        date.setFullYear(y);\n      }\n    } else {\n      date = new Date(y, m, d, h, M, s, ms);\n    }\n\n    return date;\n  }\n\n  function createUTCDate(y) {\n    var date, args; // the Date.UTC function remaps years 0-99 to 1900-1999\n\n    if (y < 100 && y >= 0) {\n      args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset\n\n      args[0] = y + 400;\n      date = new Date(Date.UTC.apply(null, args));\n\n      if (isFinite(date.getUTCFullYear())) {\n        date.setUTCFullYear(y);\n      }\n    } else {\n      date = new Date(Date.UTC.apply(null, arguments));\n    }\n\n    return date;\n  } // start-of-first-week - start-of-year\n\n\n  function firstWeekOffset(year, dow, doy) {\n    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n    fwd = 7 + dow - doy,\n        // first-week day local weekday -- which local weekday is fwd\n    fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n    return -fwdlw + fwd - 1;\n  } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n\n\n  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n    var localWeekday = (7 + weekday - dow) % 7,\n        weekOffset = firstWeekOffset(year, dow, doy),\n        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,\n        resYear,\n        resDayOfYear;\n\n    if (dayOfYear <= 0) {\n      resYear = year - 1;\n      resDayOfYear = daysInYear(resYear) + dayOfYear;\n    } else if (dayOfYear > daysInYear(year)) {\n      resYear = year + 1;\n      resDayOfYear = dayOfYear - daysInYear(year);\n    } else {\n      resYear = year;\n      resDayOfYear = dayOfYear;\n    }\n\n    return {\n      year: resYear,\n      dayOfYear: resDayOfYear\n    };\n  }\n\n  function weekOfYear(mom, dow, doy) {\n    var weekOffset = firstWeekOffset(mom.year(), dow, doy),\n        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,\n        resWeek,\n        resYear;\n\n    if (week < 1) {\n      resYear = mom.year() - 1;\n      resWeek = week + weeksInYear(resYear, dow, doy);\n    } else if (week > weeksInYear(mom.year(), dow, doy)) {\n      resWeek = week - weeksInYear(mom.year(), dow, doy);\n      resYear = mom.year() + 1;\n    } else {\n      resYear = mom.year();\n      resWeek = week;\n    }\n\n    return {\n      week: resWeek,\n      year: resYear\n    };\n  }\n\n  function weeksInYear(year, dow, doy) {\n    var weekOffset = firstWeekOffset(year, dow, doy),\n        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n  } // FORMATTING\n\n\n  addFormatToken('w', ['ww', 2], 'wo', 'week');\n  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES\n\n  addUnitAlias('week', 'w');\n  addUnitAlias('isoWeek', 'W'); // PRIORITIES\n\n  addUnitPriority('week', 5);\n  addUnitPriority('isoWeek', 5); // PARSING\n\n  addRegexToken('w', match1to2);\n  addRegexToken('ww', match1to2, match2);\n  addRegexToken('W', match1to2);\n  addRegexToken('WW', match1to2, match2);\n  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {\n    week[token.substr(0, 1)] = toInt(input);\n  }); // HELPERS\n  // LOCALES\n\n  function localeWeek(mom) {\n    return weekOfYear(mom, this._week.dow, this._week.doy).week;\n  }\n\n  var defaultLocaleWeek = {\n    dow: 0,\n    // Sunday is the first day of the week.\n    doy: 6 // The week that contains Jan 6th is the first week of the year.\n\n  };\n\n  function localeFirstDayOfWeek() {\n    return this._week.dow;\n  }\n\n  function localeFirstDayOfYear() {\n    return this._week.doy;\n  } // MOMENTS\n\n\n  function getSetWeek(input) {\n    var week = this.localeData().week(this);\n    return input == null ? week : this.add((input - week) * 7, 'd');\n  }\n\n  function getSetISOWeek(input) {\n    var week = weekOfYear(this, 1, 4).week;\n    return input == null ? week : this.add((input - week) * 7, 'd');\n  } // FORMATTING\n\n\n  addFormatToken('d', 0, 'do', 'day');\n  addFormatToken('dd', 0, 0, function (format) {\n    return this.localeData().weekdaysMin(this, format);\n  });\n  addFormatToken('ddd', 0, 0, function (format) {\n    return this.localeData().weekdaysShort(this, format);\n  });\n  addFormatToken('dddd', 0, 0, function (format) {\n    return this.localeData().weekdays(this, format);\n  });\n  addFormatToken('e', 0, 0, 'weekday');\n  addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES\n\n  addUnitAlias('day', 'd');\n  addUnitAlias('weekday', 'e');\n  addUnitAlias('isoWeekday', 'E'); // PRIORITY\n\n  addUnitPriority('day', 11);\n  addUnitPriority('weekday', 11);\n  addUnitPriority('isoWeekday', 11); // PARSING\n\n  addRegexToken('d', match1to2);\n  addRegexToken('e', match1to2);\n  addRegexToken('E', match1to2);\n  addRegexToken('dd', function (isStrict, locale) {\n    return locale.weekdaysMinRegex(isStrict);\n  });\n  addRegexToken('ddd', function (isStrict, locale) {\n    return locale.weekdaysShortRegex(isStrict);\n  });\n  addRegexToken('dddd', function (isStrict, locale) {\n    return locale.weekdaysRegex(isStrict);\n  });\n  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {\n    var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid\n\n\n    if (weekday != null) {\n      week.d = weekday;\n    } else {\n      getParsingFlags(config).invalidWeekday = input;\n    }\n  });\n  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {\n    week[token] = toInt(input);\n  }); // HELPERS\n\n  function parseWeekday(input, locale) {\n    if (typeof input !== 'string') {\n      return input;\n    }\n\n    if (!isNaN(input)) {\n      return parseInt(input, 10);\n    }\n\n    input = locale.weekdaysParse(input);\n\n    if (typeof input === 'number') {\n      return input;\n    }\n\n    return null;\n  }\n\n  function parseIsoWeekday(input, locale) {\n    if (typeof input === 'string') {\n      return locale.weekdaysParse(input) % 7 || 7;\n    }\n\n    return isNaN(input) ? null : input;\n  } // LOCALES\n\n\n  function shiftWeekdays(ws, n) {\n    return ws.slice(n, 7).concat(ws.slice(0, n));\n  }\n\n  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),\n      defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),\n      defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),\n      defaultWeekdaysRegex = matchWord,\n      defaultWeekdaysShortRegex = matchWord,\n      defaultWeekdaysMinRegex = matchWord;\n\n  function localeWeekdays(m, format) {\n    var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];\n    return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;\n  }\n\n  function localeWeekdaysShort(m) {\n    return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n  }\n\n  function localeWeekdaysMin(m) {\n    return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n  }\n\n  function handleStrictParse$1(weekdayName, format, strict) {\n    var i,\n        ii,\n        mom,\n        llc = weekdayName.toLocaleLowerCase();\n\n    if (!this._weekdaysParse) {\n      this._weekdaysParse = [];\n      this._shortWeekdaysParse = [];\n      this._minWeekdaysParse = [];\n\n      for (i = 0; i < 7; ++i) {\n        mom = createUTC([2000, 1]).day(i);\n        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();\n        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();\n        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();\n      }\n    }\n\n    if (strict) {\n      if (format === 'dddd') {\n        ii = indexOf.call(this._weekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else if (format === 'ddd') {\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    } else {\n      if (format === 'dddd') {\n        ii = indexOf.call(this._weekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else if (format === 'ddd') {\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._weekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      } else {\n        ii = indexOf.call(this._minWeekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._weekdaysParse, llc);\n\n        if (ii !== -1) {\n          return ii;\n        }\n\n        ii = indexOf.call(this._shortWeekdaysParse, llc);\n        return ii !== -1 ? ii : null;\n      }\n    }\n  }\n\n  function localeWeekdaysParse(weekdayName, format, strict) {\n    var i, mom, regex;\n\n    if (this._weekdaysParseExact) {\n      return handleStrictParse$1.call(this, weekdayName, format, strict);\n    }\n\n    if (!this._weekdaysParse) {\n      this._weekdaysParse = [];\n      this._minWeekdaysParse = [];\n      this._shortWeekdaysParse = [];\n      this._fullWeekdaysParse = [];\n    }\n\n    for (i = 0; i < 7; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, 1]).day(i);\n\n      if (strict && !this._fullWeekdaysParse[i]) {\n        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\\\.?') + '$', 'i');\n        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\\\.?') + '$', 'i');\n        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\\\.?') + '$', 'i');\n      }\n\n      if (!this._weekdaysParse[i]) {\n        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');\n        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');\n      } // test the regex\n\n\n      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {\n        return i;\n      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {\n        return i;\n      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {\n        return i;\n      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n        return i;\n      }\n    }\n  } // MOMENTS\n\n\n  function getSetDayOfWeek(input) {\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    }\n\n    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n\n    if (input != null) {\n      input = parseWeekday(input, this.localeData());\n      return this.add(input - day, 'd');\n    } else {\n      return day;\n    }\n  }\n\n  function getSetLocaleDayOfWeek(input) {\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    }\n\n    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n    return input == null ? weekday : this.add(input - weekday, 'd');\n  }\n\n  function getSetISODayOfWeek(input) {\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    } // behaves the same as moment#day except\n    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n    // as a setter, sunday should belong to the previous week.\n\n\n    if (input != null) {\n      var weekday = parseIsoWeekday(input, this.localeData());\n      return this.day(this.day() % 7 ? weekday : weekday - 7);\n    } else {\n      return this.day() || 7;\n    }\n  }\n\n  function weekdaysRegex(isStrict) {\n    if (this._weekdaysParseExact) {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        computeWeekdaysParse.call(this);\n      }\n\n      if (isStrict) {\n        return this._weekdaysStrictRegex;\n      } else {\n        return this._weekdaysRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        this._weekdaysRegex = defaultWeekdaysRegex;\n      }\n\n      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;\n    }\n  }\n\n  function weekdaysShortRegex(isStrict) {\n    if (this._weekdaysParseExact) {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        computeWeekdaysParse.call(this);\n      }\n\n      if (isStrict) {\n        return this._weekdaysShortStrictRegex;\n      } else {\n        return this._weekdaysShortRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_weekdaysShortRegex')) {\n        this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n      }\n\n      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n    }\n  }\n\n  function weekdaysMinRegex(isStrict) {\n    if (this._weekdaysParseExact) {\n      if (!hasOwnProp(this, '_weekdaysRegex')) {\n        computeWeekdaysParse.call(this);\n      }\n\n      if (isStrict) {\n        return this._weekdaysMinStrictRegex;\n      } else {\n        return this._weekdaysMinRegex;\n      }\n    } else {\n      if (!hasOwnProp(this, '_weekdaysMinRegex')) {\n        this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n      }\n\n      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n    }\n  }\n\n  function computeWeekdaysParse() {\n    function cmpLenRev(a, b) {\n      return b.length - a.length;\n    }\n\n    var minPieces = [],\n        shortPieces = [],\n        longPieces = [],\n        mixedPieces = [],\n        i,\n        mom,\n        minp,\n        shortp,\n        longp;\n\n    for (i = 0; i < 7; i++) {\n      // make the regex if we don't have it already\n      mom = createUTC([2000, 1]).day(i);\n      minp = regexEscape(this.weekdaysMin(mom, ''));\n      shortp = regexEscape(this.weekdaysShort(mom, ''));\n      longp = regexEscape(this.weekdays(mom, ''));\n      minPieces.push(minp);\n      shortPieces.push(shortp);\n      longPieces.push(longp);\n      mixedPieces.push(minp);\n      mixedPieces.push(shortp);\n      mixedPieces.push(longp);\n    } // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n    // will match the longer piece.\n\n\n    minPieces.sort(cmpLenRev);\n    shortPieces.sort(cmpLenRev);\n    longPieces.sort(cmpLenRev);\n    mixedPieces.sort(cmpLenRev);\n    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._weekdaysShortRegex = this._weekdaysRegex;\n    this._weekdaysMinRegex = this._weekdaysRegex;\n    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');\n    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');\n    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');\n  } // FORMATTING\n\n\n  function hFormat() {\n    return this.hours() % 12 || 12;\n  }\n\n  function kFormat() {\n    return this.hours() || 24;\n  }\n\n  addFormatToken('H', ['HH', 2], 0, 'hour');\n  addFormatToken('h', ['hh', 2], 0, hFormat);\n  addFormatToken('k', ['kk', 2], 0, kFormat);\n  addFormatToken('hmm', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n  });\n  addFormatToken('hmmss', 0, 0, function () {\n    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n  });\n  addFormatToken('Hmm', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2);\n  });\n  addFormatToken('Hmmss', 0, 0, function () {\n    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n  });\n\n  function meridiem(token, lowercase) {\n    addFormatToken(token, 0, 0, function () {\n      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n    });\n  }\n\n  meridiem('a', true);\n  meridiem('A', false); // ALIASES\n\n  addUnitAlias('hour', 'h'); // PRIORITY\n\n  addUnitPriority('hour', 13); // PARSING\n\n  function matchMeridiem(isStrict, locale) {\n    return locale._meridiemParse;\n  }\n\n  addRegexToken('a', matchMeridiem);\n  addRegexToken('A', matchMeridiem);\n  addRegexToken('H', match1to2);\n  addRegexToken('h', match1to2);\n  addRegexToken('k', match1to2);\n  addRegexToken('HH', match1to2, match2);\n  addRegexToken('hh', match1to2, match2);\n  addRegexToken('kk', match1to2, match2);\n  addRegexToken('hmm', match3to4);\n  addRegexToken('hmmss', match5to6);\n  addRegexToken('Hmm', match3to4);\n  addRegexToken('Hmmss', match5to6);\n  addParseToken(['H', 'HH'], HOUR);\n  addParseToken(['k', 'kk'], function (input, array, config) {\n    var kInput = toInt(input);\n    array[HOUR] = kInput === 24 ? 0 : kInput;\n  });\n  addParseToken(['a', 'A'], function (input, array, config) {\n    config._isPm = config._locale.isPM(input);\n    config._meridiem = input;\n  });\n  addParseToken(['h', 'hh'], function (input, array, config) {\n    array[HOUR] = toInt(input);\n    getParsingFlags(config).bigHour = true;\n  });\n  addParseToken('hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n    getParsingFlags(config).bigHour = true;\n  });\n  addParseToken('hmmss', function (input, array, config) {\n    var pos1 = input.length - 4,\n        pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n    getParsingFlags(config).bigHour = true;\n  });\n  addParseToken('Hmm', function (input, array, config) {\n    var pos = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos));\n    array[MINUTE] = toInt(input.substr(pos));\n  });\n  addParseToken('Hmmss', function (input, array, config) {\n    var pos1 = input.length - 4,\n        pos2 = input.length - 2;\n    array[HOUR] = toInt(input.substr(0, pos1));\n    array[MINUTE] = toInt(input.substr(pos1, 2));\n    array[SECOND] = toInt(input.substr(pos2));\n  }); // LOCALES\n\n  function localeIsPM(input) {\n    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n    // Using charAt should be more compatible.\n    return (input + '').toLowerCase().charAt(0) === 'p';\n  }\n\n  var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i,\n      // Setting the hour should keep the time, because the user explicitly\n  // specified which hour they want. So trying to maintain the same hour (in\n  // a new timezone) makes sense. Adding/subtracting hours does not follow\n  // this rule.\n  getSetHour = makeGetSet('Hours', true);\n\n  function localeMeridiem(hours, minutes, isLower) {\n    if (hours > 11) {\n      return isLower ? 'pm' : 'PM';\n    } else {\n      return isLower ? 'am' : 'AM';\n    }\n  }\n\n  var baseConfig = {\n    calendar: defaultCalendar,\n    longDateFormat: defaultLongDateFormat,\n    invalidDate: defaultInvalidDate,\n    ordinal: defaultOrdinal,\n    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n    relativeTime: defaultRelativeTime,\n    months: defaultLocaleMonths,\n    monthsShort: defaultLocaleMonthsShort,\n    week: defaultLocaleWeek,\n    weekdays: defaultLocaleWeekdays,\n    weekdaysMin: defaultLocaleWeekdaysMin,\n    weekdaysShort: defaultLocaleWeekdaysShort,\n    meridiemParse: defaultLocaleMeridiemParse\n  }; // internal storage for locale config files\n\n  var locales = {},\n      localeFamilies = {},\n      globalLocale;\n\n  function commonPrefix(arr1, arr2) {\n    var i,\n        minl = Math.min(arr1.length, arr2.length);\n\n    for (i = 0; i < minl; i += 1) {\n      if (arr1[i] !== arr2[i]) {\n        return i;\n      }\n    }\n\n    return minl;\n  }\n\n  function normalizeLocale(key) {\n    return key ? key.toLowerCase().replace('_', '-') : key;\n  } // pick the locale from the array\n  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n\n\n  function chooseLocale(names) {\n    var i = 0,\n        j,\n        next,\n        locale,\n        split;\n\n    while (i < names.length) {\n      split = normalizeLocale(names[i]).split('-');\n      j = split.length;\n      next = normalizeLocale(names[i + 1]);\n      next = next ? next.split('-') : null;\n\n      while (j > 0) {\n        locale = loadLocale(split.slice(0, j).join('-'));\n\n        if (locale) {\n          return locale;\n        }\n\n        if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {\n          //the next array item is better than a shallower substring of this one\n          break;\n        }\n\n        j--;\n      }\n\n      i++;\n    }\n\n    return globalLocale;\n  }\n\n  function isLocaleNameSane(name) {\n    // Prevent names that look like filesystem paths, i.e contain '/' or '\\'\n    return name.match('^[^/\\\\\\\\]*$') != null;\n  }\n\n  function loadLocale(name) {\n    var oldLocale = null,\n        aliasedRequire; // TODO: Find a better way to register and load all the locales in Node\n\n    if (locales[name] === undefined && typeof module !== 'undefined' && module && module.exports && isLocaleNameSane(name)) {\n      try {\n        oldLocale = globalLocale._abbr;\n        aliasedRequire = require;\n        __webpack_require__(\"RnhZ\")(\"./\" + name);\n        getSetGlobalLocale(oldLocale);\n      } catch (e) {\n        // mark as not found to avoid repeating expensive file require call causing high CPU\n        // when trying to find en-US, en_US, en-us for every format call\n        locales[name] = null; // null means not found\n      }\n    }\n\n    return locales[name];\n  } // This function will load locale and then set the global locale.  If\n  // no arguments are passed in, it will simply return the current global\n  // locale key.\n\n\n  function getSetGlobalLocale(key, values) {\n    var data;\n\n    if (key) {\n      if (isUndefined(values)) {\n        data = getLocale(key);\n      } else {\n        data = defineLocale(key, values);\n      }\n\n      if (data) {\n        // moment.duration._locale = moment._locale = data;\n        globalLocale = data;\n      } else {\n        if (typeof console !== 'undefined' && console.warn) {\n          //warn user if arguments are passed but the locale could not be set\n          console.warn('Locale ' + key + ' not found. Did you forget to load it?');\n        }\n      }\n    }\n\n    return globalLocale._abbr;\n  }\n\n  function defineLocale(name, config) {\n    if (config !== null) {\n      var locale,\n          parentConfig = baseConfig;\n      config.abbr = name;\n\n      if (locales[name] != null) {\n        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');\n        parentConfig = locales[name]._config;\n      } else if (config.parentLocale != null) {\n        if (locales[config.parentLocale] != null) {\n          parentConfig = locales[config.parentLocale]._config;\n        } else {\n          locale = loadLocale(config.parentLocale);\n\n          if (locale != null) {\n            parentConfig = locale._config;\n          } else {\n            if (!localeFamilies[config.parentLocale]) {\n              localeFamilies[config.parentLocale] = [];\n            }\n\n            localeFamilies[config.parentLocale].push({\n              name: name,\n              config: config\n            });\n            return null;\n          }\n        }\n      }\n\n      locales[name] = new Locale(mergeConfigs(parentConfig, config));\n\n      if (localeFamilies[name]) {\n        localeFamilies[name].forEach(function (x) {\n          defineLocale(x.name, x.config);\n        });\n      } // backwards compat for now: also set the locale\n      // make sure we set the locale AFTER all child locales have been\n      // created, so we won't end up with the child locale set.\n\n\n      getSetGlobalLocale(name);\n      return locales[name];\n    } else {\n      // useful for testing\n      delete locales[name];\n      return null;\n    }\n  }\n\n  function updateLocale(name, config) {\n    if (config != null) {\n      var locale,\n          tmpLocale,\n          parentConfig = baseConfig;\n\n      if (locales[name] != null && locales[name].parentLocale != null) {\n        // Update existing child locale in-place to avoid memory-leaks\n        locales[name].set(mergeConfigs(locales[name]._config, config));\n      } else {\n        // MERGE\n        tmpLocale = loadLocale(name);\n\n        if (tmpLocale != null) {\n          parentConfig = tmpLocale._config;\n        }\n\n        config = mergeConfigs(parentConfig, config);\n\n        if (tmpLocale == null) {\n          // updateLocale is called for creating a new locale\n          // Set abbr so it will have a name (getters return\n          // undefined otherwise).\n          config.abbr = name;\n        }\n\n        locale = new Locale(config);\n        locale.parentLocale = locales[name];\n        locales[name] = locale;\n      } // backwards compat for now: also set the locale\n\n\n      getSetGlobalLocale(name);\n    } else {\n      // pass null for config to unupdate, useful for tests\n      if (locales[name] != null) {\n        if (locales[name].parentLocale != null) {\n          locales[name] = locales[name].parentLocale;\n\n          if (name === getSetGlobalLocale()) {\n            getSetGlobalLocale(name);\n          }\n        } else if (locales[name] != null) {\n          delete locales[name];\n        }\n      }\n    }\n\n    return locales[name];\n  } // returns locale data\n\n\n  function getLocale(key) {\n    var locale;\n\n    if (key && key._locale && key._locale._abbr) {\n      key = key._locale._abbr;\n    }\n\n    if (!key) {\n      return globalLocale;\n    }\n\n    if (!isArray(key)) {\n      //short-circuit everything else\n      locale = loadLocale(key);\n\n      if (locale) {\n        return locale;\n      }\n\n      key = [key];\n    }\n\n    return chooseLocale(key);\n  }\n\n  function listLocales() {\n    return keys(locales);\n  }\n\n  function checkOverflow(m) {\n    var overflow,\n        a = m._a;\n\n    if (a && getParsingFlags(m).overflow === -2) {\n      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;\n\n      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n        overflow = DATE;\n      }\n\n      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n        overflow = WEEK;\n      }\n\n      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n        overflow = WEEKDAY;\n      }\n\n      getParsingFlags(m).overflow = overflow;\n    }\n\n    return m;\n  } // iso 8601 regex\n  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n\n\n  var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n      basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/,\n      tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/,\n      isoDates = [['YYYYYY-MM-DD', /[+-]\\d{6}-\\d\\d-\\d\\d/], ['YYYY-MM-DD', /\\d{4}-\\d\\d-\\d\\d/], ['GGGG-[W]WW-E', /\\d{4}-W\\d\\d-\\d/], ['GGGG-[W]WW', /\\d{4}-W\\d\\d/, false], ['YYYY-DDD', /\\d{4}-\\d{3}/], ['YYYY-MM', /\\d{4}-\\d\\d/, false], ['YYYYYYMMDD', /[+-]\\d{10}/], ['YYYYMMDD', /\\d{8}/], ['GGGG[W]WWE', /\\d{4}W\\d{3}/], ['GGGG[W]WW', /\\d{4}W\\d{2}/, false], ['YYYYDDD', /\\d{7}/], ['YYYYMM', /\\d{6}/, false], ['YYYY', /\\d{4}/, false]],\n      // iso time formats and regexes\n  isoTimes = [['HH:mm:ss.SSSS', /\\d\\d:\\d\\d:\\d\\d\\.\\d+/], ['HH:mm:ss,SSSS', /\\d\\d:\\d\\d:\\d\\d,\\d+/], ['HH:mm:ss', /\\d\\d:\\d\\d:\\d\\d/], ['HH:mm', /\\d\\d:\\d\\d/], ['HHmmss.SSSS', /\\d\\d\\d\\d\\d\\d\\.\\d+/], ['HHmmss,SSSS', /\\d\\d\\d\\d\\d\\d,\\d+/], ['HHmmss', /\\d\\d\\d\\d\\d\\d/], ['HHmm', /\\d\\d\\d\\d/], ['HH', /\\d\\d/]],\n      aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i,\n      // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n  rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/,\n      obsOffsets = {\n    UT: 0,\n    GMT: 0,\n    EDT: -4 * 60,\n    EST: -5 * 60,\n    CDT: -5 * 60,\n    CST: -6 * 60,\n    MDT: -6 * 60,\n    MST: -7 * 60,\n    PDT: -7 * 60,\n    PST: -8 * 60\n  }; // date from iso format\n\n  function configFromISO(config) {\n    var i,\n        l,\n        string = config._i,\n        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),\n        allowTime,\n        dateFormat,\n        timeFormat,\n        tzFormat,\n        isoDatesLen = isoDates.length,\n        isoTimesLen = isoTimes.length;\n\n    if (match) {\n      getParsingFlags(config).iso = true;\n\n      for (i = 0, l = isoDatesLen; i < l; i++) {\n        if (isoDates[i][1].exec(match[1])) {\n          dateFormat = isoDates[i][0];\n          allowTime = isoDates[i][2] !== false;\n          break;\n        }\n      }\n\n      if (dateFormat == null) {\n        config._isValid = false;\n        return;\n      }\n\n      if (match[3]) {\n        for (i = 0, l = isoTimesLen; i < l; i++) {\n          if (isoTimes[i][1].exec(match[3])) {\n            // match[2] should be 'T' or space\n            timeFormat = (match[2] || ' ') + isoTimes[i][0];\n            break;\n          }\n        }\n\n        if (timeFormat == null) {\n          config._isValid = false;\n          return;\n        }\n      }\n\n      if (!allowTime && timeFormat != null) {\n        config._isValid = false;\n        return;\n      }\n\n      if (match[4]) {\n        if (tzRegex.exec(match[4])) {\n          tzFormat = 'Z';\n        } else {\n          config._isValid = false;\n          return;\n        }\n      }\n\n      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');\n      configFromStringAndFormat(config);\n    } else {\n      config._isValid = false;\n    }\n  }\n\n  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n    var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];\n\n    if (secondStr) {\n      result.push(parseInt(secondStr, 10));\n    }\n\n    return result;\n  }\n\n  function untruncateYear(yearStr) {\n    var year = parseInt(yearStr, 10);\n\n    if (year <= 49) {\n      return 2000 + year;\n    } else if (year <= 999) {\n      return 1900 + year;\n    }\n\n    return year;\n  }\n\n  function preprocessRFC2822(s) {\n    // Remove comments and folding whitespace and replace multiple-spaces with a single space\n    return s.replace(/\\([^)]*\\)|[\\n\\t]/g, ' ').replace(/(\\s\\s+)/g, ' ').replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n  }\n\n  function checkWeekday(weekdayStr, parsedInput, config) {\n    if (weekdayStr) {\n      // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\n      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),\n          weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n\n      if (weekdayProvided !== weekdayActual) {\n        getParsingFlags(config).weekdayMismatch = true;\n        config._isValid = false;\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function calculateOffset(obsOffset, militaryOffset, numOffset) {\n    if (obsOffset) {\n      return obsOffsets[obsOffset];\n    } else if (militaryOffset) {\n      // the only allowed military tz is Z\n      return 0;\n    } else {\n      var hm = parseInt(numOffset, 10),\n          m = hm % 100,\n          h = (hm - m) / 100;\n      return h * 60 + m;\n    }\n  } // date and time from ref 2822 format\n\n\n  function configFromRFC2822(config) {\n    var match = rfc2822.exec(preprocessRFC2822(config._i)),\n        parsedArray;\n\n    if (match) {\n      parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n\n      if (!checkWeekday(match[1], parsedArray, config)) {\n        return;\n      }\n\n      config._a = parsedArray;\n      config._tzm = calculateOffset(match[8], match[9], match[10]);\n      config._d = createUTCDate.apply(null, config._a);\n\n      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n\n      getParsingFlags(config).rfc2822 = true;\n    } else {\n      config._isValid = false;\n    }\n  } // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\n\n\n  function configFromString(config) {\n    var matched = aspNetJsonRegex.exec(config._i);\n\n    if (matched !== null) {\n      config._d = new Date(+matched[1]);\n      return;\n    }\n\n    configFromISO(config);\n\n    if (config._isValid === false) {\n      delete config._isValid;\n    } else {\n      return;\n    }\n\n    configFromRFC2822(config);\n\n    if (config._isValid === false) {\n      delete config._isValid;\n    } else {\n      return;\n    }\n\n    if (config._strict) {\n      config._isValid = false;\n    } else {\n      // Final attempt, use Input Fallback\n      hooks.createFromInputFallback(config);\n    }\n  }\n\n  hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {\n    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));\n  }); // Pick the first defined of two or three arguments.\n\n  function defaults(a, b, c) {\n    if (a != null) {\n      return a;\n    }\n\n    if (b != null) {\n      return b;\n    }\n\n    return c;\n  }\n\n  function currentDateArray(config) {\n    // hooks is actually the exported moment object\n    var nowValue = new Date(hooks.now());\n\n    if (config._useUTC) {\n      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];\n    }\n\n    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];\n  } // convert an array to a date.\n  // the array should mirror the parameters below\n  // note: all values past the year are optional and will default to the lowest possible value.\n  // [year, month, day , hour, minute, second, millisecond]\n\n\n  function configFromArray(config) {\n    var i,\n        date,\n        input = [],\n        currentDate,\n        expectedWeekday,\n        yearToUse;\n\n    if (config._d) {\n      return;\n    }\n\n    currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays\n\n    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n      dayOfYearFromWeekInfo(config);\n    } //if the day of the year is set, figure out what it is\n\n\n    if (config._dayOfYear != null) {\n      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n\n      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n        getParsingFlags(config)._overflowDayOfYear = true;\n      }\n\n      date = createUTCDate(yearToUse, 0, config._dayOfYear);\n      config._a[MONTH] = date.getUTCMonth();\n      config._a[DATE] = date.getUTCDate();\n    } // Default to current date.\n    // * if no year, month, day of month are given, default to today\n    // * if day of month is given, default month and year\n    // * if month is given, default only year\n    // * if year is given, don't default anything\n\n\n    for (i = 0; i < 3 && config._a[i] == null; ++i) {\n      config._a[i] = input[i] = currentDate[i];\n    } // Zero out whatever was not defaulted, including time\n\n\n    for (; i < 7; i++) {\n      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];\n    } // Check for 24:00:00.000\n\n\n    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {\n      config._nextDay = true;\n      config._a[HOUR] = 0;\n    }\n\n    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed\n    // with parseZone.\n\n    if (config._tzm != null) {\n      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n    }\n\n    if (config._nextDay) {\n      config._a[HOUR] = 24;\n    } // check for mismatching day of week\n\n\n    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {\n      getParsingFlags(config).weekdayMismatch = true;\n    }\n  }\n\n  function dayOfYearFromWeekInfo(config) {\n    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;\n    w = config._w;\n\n    if (w.GG != null || w.W != null || w.E != null) {\n      dow = 1;\n      doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on\n      // how we interpret now (local, utc, fixed offset). So create\n      // a now version of current config (take local/utc/offset flags, and\n      // create now).\n\n      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n      week = defaults(w.W, 1);\n      weekday = defaults(w.E, 1);\n\n      if (weekday < 1 || weekday > 7) {\n        weekdayOverflow = true;\n      }\n    } else {\n      dow = config._locale._week.dow;\n      doy = config._locale._week.doy;\n      curWeek = weekOfYear(createLocal(), dow, doy);\n      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.\n\n      week = defaults(w.w, curWeek.week);\n\n      if (w.d != null) {\n        // weekday -- low day numbers are considered next week\n        weekday = w.d;\n\n        if (weekday < 0 || weekday > 6) {\n          weekdayOverflow = true;\n        }\n      } else if (w.e != null) {\n        // local weekday -- counting starts from beginning of week\n        weekday = w.e + dow;\n\n        if (w.e < 0 || w.e > 6) {\n          weekdayOverflow = true;\n        }\n      } else {\n        // default to beginning of week\n        weekday = dow;\n      }\n    }\n\n    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n      getParsingFlags(config)._overflowWeeks = true;\n    } else if (weekdayOverflow != null) {\n      getParsingFlags(config)._overflowWeekday = true;\n    } else {\n      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n      config._a[YEAR] = temp.year;\n      config._dayOfYear = temp.dayOfYear;\n    }\n  } // constant that refers to the ISO standard\n\n\n  hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form\n\n\n  hooks.RFC_2822 = function () {}; // date from string and format string\n\n\n  function configFromStringAndFormat(config) {\n    // TODO: Move this to another part of the creation flow to prevent circular deps\n    if (config._f === hooks.ISO_8601) {\n      configFromISO(config);\n      return;\n    }\n\n    if (config._f === hooks.RFC_2822) {\n      configFromRFC2822(config);\n      return;\n    }\n\n    config._a = [];\n    getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`\n\n    var string = '' + config._i,\n        i,\n        parsedInput,\n        tokens,\n        token,\n        skipped,\n        stringLength = string.length,\n        totalParsedInputLength = 0,\n        era,\n        tokenLen;\n    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n    tokenLen = tokens.length;\n\n    for (i = 0; i < tokenLen; i++) {\n      token = tokens[i];\n      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n\n      if (parsedInput) {\n        skipped = string.substr(0, string.indexOf(parsedInput));\n\n        if (skipped.length > 0) {\n          getParsingFlags(config).unusedInput.push(skipped);\n        }\n\n        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n        totalParsedInputLength += parsedInput.length;\n      } // don't parse if it's not a known token\n\n\n      if (formatTokenFunctions[token]) {\n        if (parsedInput) {\n          getParsingFlags(config).empty = false;\n        } else {\n          getParsingFlags(config).unusedTokens.push(token);\n        }\n\n        addTimeToArrayFromToken(token, parsedInput, config);\n      } else if (config._strict && !parsedInput) {\n        getParsingFlags(config).unusedTokens.push(token);\n      }\n    } // add remaining unparsed input length to the string\n\n\n    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n\n    if (string.length > 0) {\n      getParsingFlags(config).unusedInput.push(string);\n    } // clear _12h flag if hour is <= 12\n\n\n    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {\n      getParsingFlags(config).bigHour = undefined;\n    }\n\n    getParsingFlags(config).parsedDateParts = config._a.slice(0);\n    getParsingFlags(config).meridiem = config._meridiem; // handle meridiem\n\n    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem); // handle era\n\n    era = getParsingFlags(config).era;\n\n    if (era !== null) {\n      config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n    }\n\n    configFromArray(config);\n    checkOverflow(config);\n  }\n\n  function meridiemFixWrap(locale, hour, meridiem) {\n    var isPm;\n\n    if (meridiem == null) {\n      // nothing to do\n      return hour;\n    }\n\n    if (locale.meridiemHour != null) {\n      return locale.meridiemHour(hour, meridiem);\n    } else if (locale.isPM != null) {\n      // Fallback\n      isPm = locale.isPM(meridiem);\n\n      if (isPm && hour < 12) {\n        hour += 12;\n      }\n\n      if (!isPm && hour === 12) {\n        hour = 0;\n      }\n\n      return hour;\n    } else {\n      // this is not supposed to happen\n      return hour;\n    }\n  } // date from string and array of format strings\n\n\n  function configFromStringAndArray(config) {\n    var tempConfig,\n        bestMoment,\n        scoreToBeat,\n        i,\n        currentScore,\n        validFormatFound,\n        bestFormatIsValid = false,\n        configfLen = config._f.length;\n\n    if (configfLen === 0) {\n      getParsingFlags(config).invalidFormat = true;\n      config._d = new Date(NaN);\n      return;\n    }\n\n    for (i = 0; i < configfLen; i++) {\n      currentScore = 0;\n      validFormatFound = false;\n      tempConfig = copyConfig({}, config);\n\n      if (config._useUTC != null) {\n        tempConfig._useUTC = config._useUTC;\n      }\n\n      tempConfig._f = config._f[i];\n      configFromStringAndFormat(tempConfig);\n\n      if (isValid(tempConfig)) {\n        validFormatFound = true;\n      } // if there is any input that was not parsed add a penalty for that format\n\n\n      currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens\n\n      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n      getParsingFlags(tempConfig).score = currentScore;\n\n      if (!bestFormatIsValid) {\n        if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {\n          scoreToBeat = currentScore;\n          bestMoment = tempConfig;\n\n          if (validFormatFound) {\n            bestFormatIsValid = true;\n          }\n        }\n      } else {\n        if (currentScore < scoreToBeat) {\n          scoreToBeat = currentScore;\n          bestMoment = tempConfig;\n        }\n      }\n    }\n\n    extend(config, bestMoment || tempConfig);\n  }\n\n  function configFromObject(config) {\n    if (config._d) {\n      return;\n    }\n\n    var i = normalizeObjectUnits(config._i),\n        dayOrDate = i.day === undefined ? i.date : i.day;\n    config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {\n      return obj && parseInt(obj, 10);\n    });\n    configFromArray(config);\n  }\n\n  function createFromConfig(config) {\n    var res = new Moment(checkOverflow(prepareConfig(config)));\n\n    if (res._nextDay) {\n      // Adding is smart enough around DST\n      res.add(1, 'd');\n      res._nextDay = undefined;\n    }\n\n    return res;\n  }\n\n  function prepareConfig(config) {\n    var input = config._i,\n        format = config._f;\n    config._locale = config._locale || getLocale(config._l);\n\n    if (input === null || format === undefined && input === '') {\n      return createInvalid({\n        nullInput: true\n      });\n    }\n\n    if (typeof input === 'string') {\n      config._i = input = config._locale.preparse(input);\n    }\n\n    if (isMoment(input)) {\n      return new Moment(checkOverflow(input));\n    } else if (isDate(input)) {\n      config._d = input;\n    } else if (isArray(format)) {\n      configFromStringAndArray(config);\n    } else if (format) {\n      configFromStringAndFormat(config);\n    } else {\n      configFromInput(config);\n    }\n\n    if (!isValid(config)) {\n      config._d = null;\n    }\n\n    return config;\n  }\n\n  function configFromInput(config) {\n    var input = config._i;\n\n    if (isUndefined(input)) {\n      config._d = new Date(hooks.now());\n    } else if (isDate(input)) {\n      config._d = new Date(input.valueOf());\n    } else if (typeof input === 'string') {\n      configFromString(config);\n    } else if (isArray(input)) {\n      config._a = map(input.slice(0), function (obj) {\n        return parseInt(obj, 10);\n      });\n      configFromArray(config);\n    } else if (isObject(input)) {\n      configFromObject(config);\n    } else if (isNumber(input)) {\n      // from milliseconds\n      config._d = new Date(input);\n    } else {\n      hooks.createFromInputFallback(config);\n    }\n  }\n\n  function createLocalOrUTC(input, format, locale, strict, isUTC) {\n    var c = {};\n\n    if (format === true || format === false) {\n      strict = format;\n      format = undefined;\n    }\n\n    if (locale === true || locale === false) {\n      strict = locale;\n      locale = undefined;\n    }\n\n    if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {\n      input = undefined;\n    } // object construction must be done this way.\n    // https://github.com/moment/moment/issues/1423\n\n\n    c._isAMomentObject = true;\n    c._useUTC = c._isUTC = isUTC;\n    c._l = locale;\n    c._i = input;\n    c._f = format;\n    c._strict = strict;\n    return createFromConfig(c);\n  }\n\n  function createLocal(input, format, locale, strict) {\n    return createLocalOrUTC(input, format, locale, strict, false);\n  }\n\n  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {\n    var other = createLocal.apply(null, arguments);\n\n    if (this.isValid() && other.isValid()) {\n      return other < this ? this : other;\n    } else {\n      return createInvalid();\n    }\n  }),\n      prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {\n    var other = createLocal.apply(null, arguments);\n\n    if (this.isValid() && other.isValid()) {\n      return other > this ? this : other;\n    } else {\n      return createInvalid();\n    }\n  }); // Pick a moment m from moments so that m[fn](other) is true for all\n  // other. This relies on the function fn to be transitive.\n  //\n  // moments should either be an array of moment objects or an array, whose\n  // first element is an array of moment objects.\n\n  function pickBy(fn, moments) {\n    var res, i;\n\n    if (moments.length === 1 && isArray(moments[0])) {\n      moments = moments[0];\n    }\n\n    if (!moments.length) {\n      return createLocal();\n    }\n\n    res = moments[0];\n\n    for (i = 1; i < moments.length; ++i) {\n      if (!moments[i].isValid() || moments[i][fn](res)) {\n        res = moments[i];\n      }\n    }\n\n    return res;\n  } // TODO: Use [].sort instead?\n\n\n  function min() {\n    var args = [].slice.call(arguments, 0);\n    return pickBy('isBefore', args);\n  }\n\n  function max() {\n    var args = [].slice.call(arguments, 0);\n    return pickBy('isAfter', args);\n  }\n\n  var now = function now() {\n    return Date.now ? Date.now() : +new Date();\n  };\n\n  var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];\n\n  function isDurationValid(m) {\n    var key,\n        unitHasDecimal = false,\n        i,\n        orderLen = ordering.length;\n\n    for (key in m) {\n      if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n        return false;\n      }\n    }\n\n    for (i = 0; i < orderLen; ++i) {\n      if (m[ordering[i]]) {\n        if (unitHasDecimal) {\n          return false; // only allow non-integers for smallest unit\n        }\n\n        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n          unitHasDecimal = true;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function isValid$1() {\n    return this._isValid;\n  }\n\n  function createInvalid$1() {\n    return createDuration(NaN);\n  }\n\n  function Duration(duration) {\n    var normalizedInput = normalizeObjectUnits(duration),\n        years = normalizedInput.year || 0,\n        quarters = normalizedInput.quarter || 0,\n        months = normalizedInput.month || 0,\n        weeks = normalizedInput.week || normalizedInput.isoWeek || 0,\n        days = normalizedInput.day || 0,\n        hours = normalizedInput.hour || 0,\n        minutes = normalizedInput.minute || 0,\n        seconds = normalizedInput.second || 0,\n        milliseconds = normalizedInput.millisecond || 0;\n    this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove\n\n    this._milliseconds = +milliseconds + seconds * 1e3 + // 1000\n    minutes * 6e4 + // 1000 * 60\n    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n    // Because of dateAddRemove treats 24 hours as different from a\n    // day when working around DST, we need to store them separately\n\n    this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing\n    // which months you are are talking about, so we have to store\n    // it separately.\n\n    this._months = +months + quarters * 3 + years * 12;\n    this._data = {};\n    this._locale = getLocale();\n\n    this._bubble();\n  }\n\n  function isDuration(obj) {\n    return obj instanceof Duration;\n  }\n\n  function absRound(number) {\n    if (number < 0) {\n      return Math.round(-1 * number) * -1;\n    } else {\n      return Math.round(number);\n    }\n  } // compare two arrays, return the number of differences\n\n\n  function compareArrays(array1, array2, dontConvert) {\n    var len = Math.min(array1.length, array2.length),\n        lengthDiff = Math.abs(array1.length - array2.length),\n        diffs = 0,\n        i;\n\n    for (i = 0; i < len; i++) {\n      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {\n        diffs++;\n      }\n    }\n\n    return diffs + lengthDiff;\n  } // FORMATTING\n\n\n  function offset(token, separator) {\n    addFormatToken(token, 0, 0, function () {\n      var offset = this.utcOffset(),\n          sign = '+';\n\n      if (offset < 0) {\n        offset = -offset;\n        sign = '-';\n      }\n\n      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);\n    });\n  }\n\n  offset('Z', ':');\n  offset('ZZ', ''); // PARSING\n\n  addRegexToken('Z', matchShortOffset);\n  addRegexToken('ZZ', matchShortOffset);\n  addParseToken(['Z', 'ZZ'], function (input, array, config) {\n    config._useUTC = true;\n    config._tzm = offsetFromString(matchShortOffset, input);\n  }); // HELPERS\n  // timezone chunker\n  // '+10:00' > ['10',  '00']\n  // '-1530'  > ['-15', '30']\n\n  var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n\n  function offsetFromString(matcher, string) {\n    var matches = (string || '').match(matcher),\n        chunk,\n        parts,\n        minutes;\n\n    if (matches === null) {\n      return null;\n    }\n\n    chunk = matches[matches.length - 1] || [];\n    parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];\n    minutes = +(parts[1] * 60) + toInt(parts[2]);\n    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;\n  } // Return a moment from input, that is local/utc/zone equivalent to model.\n\n\n  function cloneWithOffset(input, model) {\n    var res, diff;\n\n    if (model._isUTC) {\n      res = model.clone();\n      diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.\n\n      res._d.setTime(res._d.valueOf() + diff);\n\n      hooks.updateOffset(res, false);\n      return res;\n    } else {\n      return createLocal(input).local();\n    }\n  }\n\n  function getDateOffset(m) {\n    // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n    // https://github.com/moment/moment/pull/1871\n    return -Math.round(m._d.getTimezoneOffset());\n  } // HOOKS\n  // This function will be called whenever a moment is mutated.\n  // It is intended to keep the offset in sync with the timezone.\n\n\n  hooks.updateOffset = function () {}; // MOMENTS\n  // keepLocalTime = true means only change the timezone, without\n  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]--\x3e\n  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n  // +0200, so we adjust the time as needed, to be valid.\n  //\n  // Keeping the time actually adds/subtracts (one hour)\n  // from the actual represented time. That is why we call updateOffset\n  // a second time. In case it wants us to change the offset again\n  // _changeInProgress == true case, then we have to adjust, because\n  // there is no such time in the given timezone.\n\n\n  function getSetOffset(input, keepLocalTime, keepMinutes) {\n    var offset = this._offset || 0,\n        localAdjust;\n\n    if (!this.isValid()) {\n      return input != null ? this : NaN;\n    }\n\n    if (input != null) {\n      if (typeof input === 'string') {\n        input = offsetFromString(matchShortOffset, input);\n\n        if (input === null) {\n          return this;\n        }\n      } else if (Math.abs(input) < 16 && !keepMinutes) {\n        input = input * 60;\n      }\n\n      if (!this._isUTC && keepLocalTime) {\n        localAdjust = getDateOffset(this);\n      }\n\n      this._offset = input;\n      this._isUTC = true;\n\n      if (localAdjust != null) {\n        this.add(localAdjust, 'm');\n      }\n\n      if (offset !== input) {\n        if (!keepLocalTime || this._changeInProgress) {\n          addSubtract(this, createDuration(input - offset, 'm'), 1, false);\n        } else if (!this._changeInProgress) {\n          this._changeInProgress = true;\n          hooks.updateOffset(this, true);\n          this._changeInProgress = null;\n        }\n      }\n\n      return this;\n    } else {\n      return this._isUTC ? offset : getDateOffset(this);\n    }\n  }\n\n  function getSetZone(input, keepLocalTime) {\n    if (input != null) {\n      if (typeof input !== 'string') {\n        input = -input;\n      }\n\n      this.utcOffset(input, keepLocalTime);\n      return this;\n    } else {\n      return -this.utcOffset();\n    }\n  }\n\n  function setOffsetToUTC(keepLocalTime) {\n    return this.utcOffset(0, keepLocalTime);\n  }\n\n  function setOffsetToLocal(keepLocalTime) {\n    if (this._isUTC) {\n      this.utcOffset(0, keepLocalTime);\n      this._isUTC = false;\n\n      if (keepLocalTime) {\n        this.subtract(getDateOffset(this), 'm');\n      }\n    }\n\n    return this;\n  }\n\n  function setOffsetToParsedOffset() {\n    if (this._tzm != null) {\n      this.utcOffset(this._tzm, false, true);\n    } else if (typeof this._i === 'string') {\n      var tZone = offsetFromString(matchOffset, this._i);\n\n      if (tZone != null) {\n        this.utcOffset(tZone);\n      } else {\n        this.utcOffset(0, true);\n      }\n    }\n\n    return this;\n  }\n\n  function hasAlignedHourOffset(input) {\n    if (!this.isValid()) {\n      return false;\n    }\n\n    input = input ? createLocal(input).utcOffset() : 0;\n    return (this.utcOffset() - input) % 60 === 0;\n  }\n\n  function isDaylightSavingTime() {\n    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();\n  }\n\n  function isDaylightSavingTimeShifted() {\n    if (!isUndefined(this._isDSTShifted)) {\n      return this._isDSTShifted;\n    }\n\n    var c = {},\n        other;\n    copyConfig(c, this);\n    c = prepareConfig(c);\n\n    if (c._a) {\n      other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n    } else {\n      this._isDSTShifted = false;\n    }\n\n    return this._isDSTShifted;\n  }\n\n  function isLocal() {\n    return this.isValid() ? !this._isUTC : false;\n  }\n\n  function isUtcOffset() {\n    return this.isValid() ? this._isUTC : false;\n  }\n\n  function isUtc() {\n    return this.isValid() ? this._isUTC && this._offset === 0 : false;\n  } // ASP.NET json date format regex\n\n\n  var aspNetRegex = /^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/,\n      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n  // and further modified to allow for strings containing both week and day\n  isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n\n  function createDuration(input, key) {\n    var duration = input,\n        // matching against regexp is expensive, do it on demand\n    match = null,\n        sign,\n        ret,\n        diffRes;\n\n    if (isDuration(input)) {\n      duration = {\n        ms: input._milliseconds,\n        d: input._days,\n        M: input._months\n      };\n    } else if (isNumber(input) || !isNaN(+input)) {\n      duration = {};\n\n      if (key) {\n        duration[key] = +input;\n      } else {\n        duration.milliseconds = +input;\n      }\n    } else if (match = aspNetRegex.exec(input)) {\n      sign = match[1] === '-' ? -1 : 1;\n      duration = {\n        y: 0,\n        d: toInt(match[DATE]) * sign,\n        h: toInt(match[HOUR]) * sign,\n        m: toInt(match[MINUTE]) * sign,\n        s: toInt(match[SECOND]) * sign,\n        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match\n\n      };\n    } else if (match = isoRegex.exec(input)) {\n      sign = match[1] === '-' ? -1 : 1;\n      duration = {\n        y: parseIso(match[2], sign),\n        M: parseIso(match[3], sign),\n        w: parseIso(match[4], sign),\n        d: parseIso(match[5], sign),\n        h: parseIso(match[6], sign),\n        m: parseIso(match[7], sign),\n        s: parseIso(match[8], sign)\n      };\n    } else if (duration == null) {\n      // checks for null or undefined\n      duration = {};\n    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {\n      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n      duration = {};\n      duration.ms = diffRes.milliseconds;\n      duration.M = diffRes.months;\n    }\n\n    ret = new Duration(duration);\n\n    if (isDuration(input) && hasOwnProp(input, '_locale')) {\n      ret._locale = input._locale;\n    }\n\n    if (isDuration(input) && hasOwnProp(input, '_isValid')) {\n      ret._isValid = input._isValid;\n    }\n\n    return ret;\n  }\n\n  createDuration.fn = Duration.prototype;\n  createDuration.invalid = createInvalid$1;\n\n  function parseIso(inp, sign) {\n    // We'd normally use ~~inp for this, but unfortunately it also\n    // converts floats to ints.\n    // inp may be undefined, so careful calling replace on it.\n    var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it\n\n    return (isNaN(res) ? 0 : res) * sign;\n  }\n\n  function positiveMomentsDifference(base, other) {\n    var res = {};\n    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;\n\n    if (base.clone().add(res.months, 'M').isAfter(other)) {\n      --res.months;\n    }\n\n    res.milliseconds = +other - +base.clone().add(res.months, 'M');\n    return res;\n  }\n\n  function momentsDifference(base, other) {\n    var res;\n\n    if (!(base.isValid() && other.isValid())) {\n      return {\n        milliseconds: 0,\n        months: 0\n      };\n    }\n\n    other = cloneWithOffset(other, base);\n\n    if (base.isBefore(other)) {\n      res = positiveMomentsDifference(base, other);\n    } else {\n      res = positiveMomentsDifference(other, base);\n      res.milliseconds = -res.milliseconds;\n      res.months = -res.months;\n    }\n\n    return res;\n  } // TODO: remove 'name' arg after deprecation is removed\n\n\n  function createAdder(direction, name) {\n    return function (val, period) {\n      var dur, tmp; //invert the arguments, but complain about it\n\n      if (period !== null && !isNaN(+period)) {\n        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');\n        tmp = val;\n        val = period;\n        period = tmp;\n      }\n\n      dur = createDuration(val, period);\n      addSubtract(this, dur, direction);\n      return this;\n    };\n  }\n\n  function addSubtract(mom, duration, isAdding, updateOffset) {\n    var milliseconds = duration._milliseconds,\n        days = absRound(duration._days),\n        months = absRound(duration._months);\n\n    if (!mom.isValid()) {\n      // No op\n      return;\n    }\n\n    updateOffset = updateOffset == null ? true : updateOffset;\n\n    if (months) {\n      setMonth(mom, get(mom, 'Month') + months * isAdding);\n    }\n\n    if (days) {\n      set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);\n    }\n\n    if (milliseconds) {\n      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n    }\n\n    if (updateOffset) {\n      hooks.updateOffset(mom, days || months);\n    }\n  }\n\n  var add = createAdder(1, 'add'),\n      subtract = createAdder(-1, 'subtract');\n\n  function isString(input) {\n    return typeof input === 'string' || input instanceof String;\n  } // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined\n\n\n  function isMomentInput(input) {\n    return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;\n  }\n\n  function isMomentInputObject(input) {\n    var objectTest = isObject(input) && !isObjectEmpty(input),\n        propertyTest = false,\n        properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],\n        i,\n        property,\n        propertyLen = properties.length;\n\n    for (i = 0; i < propertyLen; i += 1) {\n      property = properties[i];\n      propertyTest = propertyTest || hasOwnProp(input, property);\n    }\n\n    return objectTest && propertyTest;\n  }\n\n  function isNumberOrStringArray(input) {\n    var arrayTest = isArray(input),\n        dataTypeTest = false;\n\n    if (arrayTest) {\n      dataTypeTest = input.filter(function (item) {\n        return !isNumber(item) && isString(input);\n      }).length === 0;\n    }\n\n    return arrayTest && dataTypeTest;\n  }\n\n  function isCalendarSpec(input) {\n    var objectTest = isObject(input) && !isObjectEmpty(input),\n        propertyTest = false,\n        properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],\n        i,\n        property;\n\n    for (i = 0; i < properties.length; i += 1) {\n      property = properties[i];\n      propertyTest = propertyTest || hasOwnProp(input, property);\n    }\n\n    return objectTest && propertyTest;\n  }\n\n  function getCalendarFormat(myMoment, now) {\n    var diff = myMoment.diff(now, 'days', true);\n    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';\n  }\n\n  function calendar$1(time, formats) {\n    // Support for single parameter, formats only overload to the calendar function\n    if (arguments.length === 1) {\n      if (!arguments[0]) {\n        time = undefined;\n        formats = undefined;\n      } else if (isMomentInput(arguments[0])) {\n        time = arguments[0];\n        formats = undefined;\n      } else if (isCalendarSpec(arguments[0])) {\n        formats = arguments[0];\n        time = undefined;\n      }\n    } // We want to compare the start of today, vs this.\n    // Getting start-of-today depends on whether we're local/utc/offset or not.\n\n\n    var now = time || createLocal(),\n        sod = cloneWithOffset(now, this).startOf('day'),\n        format = hooks.calendarFormat(this, sod) || 'sameElse',\n        output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n  }\n\n  function clone() {\n    return new Moment(this);\n  }\n\n  function isAfter(input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n\n    if (!(this.isValid() && localInput.isValid())) {\n      return false;\n    }\n\n    units = normalizeUnits(units) || 'millisecond';\n\n    if (units === 'millisecond') {\n      return this.valueOf() > localInput.valueOf();\n    } else {\n      return localInput.valueOf() < this.clone().startOf(units).valueOf();\n    }\n  }\n\n  function isBefore(input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input);\n\n    if (!(this.isValid() && localInput.isValid())) {\n      return false;\n    }\n\n    units = normalizeUnits(units) || 'millisecond';\n\n    if (units === 'millisecond') {\n      return this.valueOf() < localInput.valueOf();\n    } else {\n      return this.clone().endOf(units).valueOf() < localInput.valueOf();\n    }\n  }\n\n  function isBetween(from, to, units, inclusivity) {\n    var localFrom = isMoment(from) ? from : createLocal(from),\n        localTo = isMoment(to) ? to : createLocal(to);\n\n    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n      return false;\n    }\n\n    inclusivity = inclusivity || '()';\n    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));\n  }\n\n  function isSame(input, units) {\n    var localInput = isMoment(input) ? input : createLocal(input),\n        inputMs;\n\n    if (!(this.isValid() && localInput.isValid())) {\n      return false;\n    }\n\n    units = normalizeUnits(units) || 'millisecond';\n\n    if (units === 'millisecond') {\n      return this.valueOf() === localInput.valueOf();\n    } else {\n      inputMs = localInput.valueOf();\n      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n    }\n  }\n\n  function isSameOrAfter(input, units) {\n    return this.isSame(input, units) || this.isAfter(input, units);\n  }\n\n  function isSameOrBefore(input, units) {\n    return this.isSame(input, units) || this.isBefore(input, units);\n  }\n\n  function diff(input, units, asFloat) {\n    var that, zoneDelta, output;\n\n    if (!this.isValid()) {\n      return NaN;\n    }\n\n    that = cloneWithOffset(input, this);\n\n    if (!that.isValid()) {\n      return NaN;\n    }\n\n    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n    units = normalizeUnits(units);\n\n    switch (units) {\n      case 'year':\n        output = monthDiff(this, that) / 12;\n        break;\n\n      case 'month':\n        output = monthDiff(this, that);\n        break;\n\n      case 'quarter':\n        output = monthDiff(this, that) / 3;\n        break;\n\n      case 'second':\n        output = (this - that) / 1e3;\n        break;\n      // 1000\n\n      case 'minute':\n        output = (this - that) / 6e4;\n        break;\n      // 1000 * 60\n\n      case 'hour':\n        output = (this - that) / 36e5;\n        break;\n      // 1000 * 60 * 60\n\n      case 'day':\n        output = (this - that - zoneDelta) / 864e5;\n        break;\n      // 1000 * 60 * 60 * 24, negate dst\n\n      case 'week':\n        output = (this - that - zoneDelta) / 6048e5;\n        break;\n      // 1000 * 60 * 60 * 24 * 7, negate dst\n\n      default:\n        output = this - that;\n    }\n\n    return asFloat ? output : absFloor(output);\n  }\n\n  function monthDiff(a, b) {\n    if (a.date() < b.date()) {\n      // end-of-month calculations work correct when the start month has more\n      // days than the end month.\n      return -monthDiff(b, a);\n    } // difference in months\n\n\n    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),\n        // b is in (anchor - 1 month, anchor + 1 month)\n    anchor = a.clone().add(wholeMonthDiff, 'months'),\n        anchor2,\n        adjust;\n\n    if (b - anchor < 0) {\n      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month\n\n      adjust = (b - anchor) / (anchor - anchor2);\n    } else {\n      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month\n\n      adjust = (b - anchor) / (anchor2 - anchor);\n    } //check for negative zero, return zero if negative zero\n\n\n    return -(wholeMonthDiff + adjust) || 0;\n  }\n\n  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';\n  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';\n\n  function toString() {\n    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');\n  }\n\n  function toISOString(keepOffset) {\n    if (!this.isValid()) {\n      return null;\n    }\n\n    var utc = keepOffset !== true,\n        m = utc ? this.clone().utc() : this;\n\n    if (m.year() < 0 || m.year() > 9999) {\n      return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');\n    }\n\n    if (isFunction(Date.prototype.toISOString)) {\n      // native implementation is ~50x faster, use it when we can\n      if (utc) {\n        return this.toDate().toISOString();\n      } else {\n        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));\n      }\n    }\n\n    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');\n  }\n  /**\n   * Return a human readable representation of a moment that can\n   * also be evaluated to get a new moment which is the same\n   *\n   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n   */\n\n\n  function inspect() {\n    if (!this.isValid()) {\n      return 'moment.invalid(/* ' + this._i + ' */)';\n    }\n\n    var func = 'moment',\n        zone = '',\n        prefix,\n        year,\n        datetime,\n        suffix;\n\n    if (!this.isLocal()) {\n      func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';\n      zone = 'Z';\n    }\n\n    prefix = '[' + func + '(\"]';\n    year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';\n    datetime = '-MM-DD[T]HH:mm:ss.SSS';\n    suffix = zone + '[\")]';\n    return this.format(prefix + year + datetime + suffix);\n  }\n\n  function format(inputString) {\n    if (!inputString) {\n      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n    }\n\n    var output = formatMoment(this, inputString);\n    return this.localeData().postformat(output);\n  }\n\n  function from(time, withoutSuffix) {\n    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n      return createDuration({\n        to: this,\n        from: time\n      }).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n      return this.localeData().invalidDate();\n    }\n  }\n\n  function fromNow(withoutSuffix) {\n    return this.from(createLocal(), withoutSuffix);\n  }\n\n  function to(time, withoutSuffix) {\n    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n      return createDuration({\n        from: this,\n        to: time\n      }).locale(this.locale()).humanize(!withoutSuffix);\n    } else {\n      return this.localeData().invalidDate();\n    }\n  }\n\n  function toNow(withoutSuffix) {\n    return this.to(createLocal(), withoutSuffix);\n  } // If passed a locale key, it will set the locale for this\n  // instance.  Otherwise, it will return the locale configuration\n  // variables for this instance.\n\n\n  function locale(key) {\n    var newLocaleData;\n\n    if (key === undefined) {\n      return this._locale._abbr;\n    } else {\n      newLocaleData = getLocale(key);\n\n      if (newLocaleData != null) {\n        this._locale = newLocaleData;\n      }\n\n      return this;\n    }\n  }\n\n  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {\n    if (key === undefined) {\n      return this.localeData();\n    } else {\n      return this.locale(key);\n    }\n  });\n\n  function localeData() {\n    return this._locale;\n  }\n\n  var MS_PER_SECOND = 1000,\n      MS_PER_MINUTE = 60 * MS_PER_SECOND,\n      MS_PER_HOUR = 60 * MS_PER_MINUTE,\n      MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):\n\n  function mod$1(dividend, divisor) {\n    return (dividend % divisor + divisor) % divisor;\n  }\n\n  function localStartOfDate(y, m, d) {\n    // the date constructor remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0) {\n      // preserve leap years using a full 400 year cycle, then reset\n      return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n    } else {\n      return new Date(y, m, d).valueOf();\n    }\n  }\n\n  function utcStartOfDate(y, m, d) {\n    // Date.UTC remaps years 0-99 to 1900-1999\n    if (y < 100 && y >= 0) {\n      // preserve leap years using a full 400 year cycle, then reset\n      return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n    } else {\n      return Date.UTC(y, m, d);\n    }\n  }\n\n  function startOf(units) {\n    var time, startOfDate;\n    units = normalizeUnits(units);\n\n    if (units === undefined || units === 'millisecond' || !this.isValid()) {\n      return this;\n    }\n\n    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n    switch (units) {\n      case 'year':\n        time = startOfDate(this.year(), 0, 1);\n        break;\n\n      case 'quarter':\n        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);\n        break;\n\n      case 'month':\n        time = startOfDate(this.year(), this.month(), 1);\n        break;\n\n      case 'week':\n        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());\n        break;\n\n      case 'isoWeek':\n        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));\n        break;\n\n      case 'day':\n      case 'date':\n        time = startOfDate(this.year(), this.month(), this.date());\n        break;\n\n      case 'hour':\n        time = this._d.valueOf();\n        time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);\n        break;\n\n      case 'minute':\n        time = this._d.valueOf();\n        time -= mod$1(time, MS_PER_MINUTE);\n        break;\n\n      case 'second':\n        time = this._d.valueOf();\n        time -= mod$1(time, MS_PER_SECOND);\n        break;\n    }\n\n    this._d.setTime(time);\n\n    hooks.updateOffset(this, true);\n    return this;\n  }\n\n  function endOf(units) {\n    var time, startOfDate;\n    units = normalizeUnits(units);\n\n    if (units === undefined || units === 'millisecond' || !this.isValid()) {\n      return this;\n    }\n\n    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n\n    switch (units) {\n      case 'year':\n        time = startOfDate(this.year() + 1, 0, 1) - 1;\n        break;\n\n      case 'quarter':\n        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;\n        break;\n\n      case 'month':\n        time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n        break;\n\n      case 'week':\n        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;\n        break;\n\n      case 'isoWeek':\n        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;\n        break;\n\n      case 'day':\n      case 'date':\n        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n        break;\n\n      case 'hour':\n        time = this._d.valueOf();\n        time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;\n        break;\n\n      case 'minute':\n        time = this._d.valueOf();\n        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n        break;\n\n      case 'second':\n        time = this._d.valueOf();\n        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n        break;\n    }\n\n    this._d.setTime(time);\n\n    hooks.updateOffset(this, true);\n    return this;\n  }\n\n  function valueOf() {\n    return this._d.valueOf() - (this._offset || 0) * 60000;\n  }\n\n  function unix() {\n    return Math.floor(this.valueOf() / 1000);\n  }\n\n  function toDate() {\n    return new Date(this.valueOf());\n  }\n\n  function toArray() {\n    var m = this;\n    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];\n  }\n\n  function toObject() {\n    var m = this;\n    return {\n      years: m.year(),\n      months: m.month(),\n      date: m.date(),\n      hours: m.hours(),\n      minutes: m.minutes(),\n      seconds: m.seconds(),\n      milliseconds: m.milliseconds()\n    };\n  }\n\n  function toJSON() {\n    // new Date(NaN).toJSON() === null\n    return this.isValid() ? this.toISOString() : null;\n  }\n\n  function isValid$2() {\n    return isValid(this);\n  }\n\n  function parsingFlags() {\n    return extend({}, getParsingFlags(this));\n  }\n\n  function invalidAt() {\n    return getParsingFlags(this).overflow;\n  }\n\n  function creationData() {\n    return {\n      input: this._i,\n      format: this._f,\n      locale: this._locale,\n      isUTC: this._isUTC,\n      strict: this._strict\n    };\n  }\n\n  addFormatToken('N', 0, 0, 'eraAbbr');\n  addFormatToken('NN', 0, 0, 'eraAbbr');\n  addFormatToken('NNN', 0, 0, 'eraAbbr');\n  addFormatToken('NNNN', 0, 0, 'eraName');\n  addFormatToken('NNNNN', 0, 0, 'eraNarrow');\n  addFormatToken('y', ['y', 1], 'yo', 'eraYear');\n  addFormatToken('y', ['yy', 2], 0, 'eraYear');\n  addFormatToken('y', ['yyy', 3], 0, 'eraYear');\n  addFormatToken('y', ['yyyy', 4], 0, 'eraYear');\n  addRegexToken('N', matchEraAbbr);\n  addRegexToken('NN', matchEraAbbr);\n  addRegexToken('NNN', matchEraAbbr);\n  addRegexToken('NNNN', matchEraName);\n  addRegexToken('NNNNN', matchEraNarrow);\n  addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {\n    var era = config._locale.erasParse(input, token, config._strict);\n\n    if (era) {\n      getParsingFlags(config).era = era;\n    } else {\n      getParsingFlags(config).invalidEra = input;\n    }\n  });\n  addRegexToken('y', matchUnsigned);\n  addRegexToken('yy', matchUnsigned);\n  addRegexToken('yyy', matchUnsigned);\n  addRegexToken('yyyy', matchUnsigned);\n  addRegexToken('yo', matchEraYearOrdinal);\n  addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);\n  addParseToken(['yo'], function (input, array, config, token) {\n    var match;\n\n    if (config._locale._eraYearOrdinalRegex) {\n      match = input.match(config._locale._eraYearOrdinalRegex);\n    }\n\n    if (config._locale.eraYearOrdinalParse) {\n      array[YEAR] = config._locale.eraYearOrdinalParse(input, match);\n    } else {\n      array[YEAR] = parseInt(input, 10);\n    }\n  });\n\n  function localeEras(m, format) {\n    var i,\n        l,\n        date,\n        eras = this._eras || getLocale('en')._eras;\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      switch (typeof eras[i].since) {\n        case 'string':\n          // truncate time\n          date = hooks(eras[i].since).startOf('day');\n          eras[i].since = date.valueOf();\n          break;\n      }\n\n      switch (typeof eras[i].until) {\n        case 'undefined':\n          eras[i].until = +Infinity;\n          break;\n\n        case 'string':\n          // truncate time\n          date = hooks(eras[i].until).startOf('day').valueOf();\n          eras[i].until = date.valueOf();\n          break;\n      }\n    }\n\n    return eras;\n  }\n\n  function localeErasParse(eraName, format, strict) {\n    var i,\n        l,\n        eras = this.eras(),\n        name,\n        abbr,\n        narrow;\n    eraName = eraName.toUpperCase();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      name = eras[i].name.toUpperCase();\n      abbr = eras[i].abbr.toUpperCase();\n      narrow = eras[i].narrow.toUpperCase();\n\n      if (strict) {\n        switch (format) {\n          case 'N':\n          case 'NN':\n          case 'NNN':\n            if (abbr === eraName) {\n              return eras[i];\n            }\n\n            break;\n\n          case 'NNNN':\n            if (name === eraName) {\n              return eras[i];\n            }\n\n            break;\n\n          case 'NNNNN':\n            if (narrow === eraName) {\n              return eras[i];\n            }\n\n            break;\n        }\n      } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {\n        return eras[i];\n      }\n    }\n  }\n\n  function localeErasConvertYear(era, year) {\n    var dir = era.since <= era.until ? +1 : -1;\n\n    if (year === undefined) {\n      return hooks(era.since).year();\n    } else {\n      return hooks(era.since).year() + (year - era.offset) * dir;\n    }\n  }\n\n  function getEraName() {\n    var i,\n        l,\n        val,\n        eras = this.localeData().eras();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      // truncate time\n      val = this.clone().startOf('day').valueOf();\n\n      if (eras[i].since <= val && val <= eras[i].until) {\n        return eras[i].name;\n      }\n\n      if (eras[i].until <= val && val <= eras[i].since) {\n        return eras[i].name;\n      }\n    }\n\n    return '';\n  }\n\n  function getEraNarrow() {\n    var i,\n        l,\n        val,\n        eras = this.localeData().eras();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      // truncate time\n      val = this.clone().startOf('day').valueOf();\n\n      if (eras[i].since <= val && val <= eras[i].until) {\n        return eras[i].narrow;\n      }\n\n      if (eras[i].until <= val && val <= eras[i].since) {\n        return eras[i].narrow;\n      }\n    }\n\n    return '';\n  }\n\n  function getEraAbbr() {\n    var i,\n        l,\n        val,\n        eras = this.localeData().eras();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      // truncate time\n      val = this.clone().startOf('day').valueOf();\n\n      if (eras[i].since <= val && val <= eras[i].until) {\n        return eras[i].abbr;\n      }\n\n      if (eras[i].until <= val && val <= eras[i].since) {\n        return eras[i].abbr;\n      }\n    }\n\n    return '';\n  }\n\n  function getEraYear() {\n    var i,\n        l,\n        dir,\n        val,\n        eras = this.localeData().eras();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      dir = eras[i].since <= eras[i].until ? +1 : -1; // truncate time\n\n      val = this.clone().startOf('day').valueOf();\n\n      if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {\n        return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;\n      }\n    }\n\n    return this.year();\n  }\n\n  function erasNameRegex(isStrict) {\n    if (!hasOwnProp(this, '_erasNameRegex')) {\n      computeErasParse.call(this);\n    }\n\n    return isStrict ? this._erasNameRegex : this._erasRegex;\n  }\n\n  function erasAbbrRegex(isStrict) {\n    if (!hasOwnProp(this, '_erasAbbrRegex')) {\n      computeErasParse.call(this);\n    }\n\n    return isStrict ? this._erasAbbrRegex : this._erasRegex;\n  }\n\n  function erasNarrowRegex(isStrict) {\n    if (!hasOwnProp(this, '_erasNarrowRegex')) {\n      computeErasParse.call(this);\n    }\n\n    return isStrict ? this._erasNarrowRegex : this._erasRegex;\n  }\n\n  function matchEraAbbr(isStrict, locale) {\n    return locale.erasAbbrRegex(isStrict);\n  }\n\n  function matchEraName(isStrict, locale) {\n    return locale.erasNameRegex(isStrict);\n  }\n\n  function matchEraNarrow(isStrict, locale) {\n    return locale.erasNarrowRegex(isStrict);\n  }\n\n  function matchEraYearOrdinal(isStrict, locale) {\n    return locale._eraYearOrdinalRegex || matchUnsigned;\n  }\n\n  function computeErasParse() {\n    var abbrPieces = [],\n        namePieces = [],\n        narrowPieces = [],\n        mixedPieces = [],\n        i,\n        l,\n        eras = this.eras();\n\n    for (i = 0, l = eras.length; i < l; ++i) {\n      namePieces.push(regexEscape(eras[i].name));\n      abbrPieces.push(regexEscape(eras[i].abbr));\n      narrowPieces.push(regexEscape(eras[i].narrow));\n      mixedPieces.push(regexEscape(eras[i].name));\n      mixedPieces.push(regexEscape(eras[i].abbr));\n      mixedPieces.push(regexEscape(eras[i].narrow));\n    }\n\n    this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');\n    this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');\n    this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');\n    this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');\n  } // FORMATTING\n\n\n  addFormatToken(0, ['gg', 2], 0, function () {\n    return this.weekYear() % 100;\n  });\n  addFormatToken(0, ['GG', 2], 0, function () {\n    return this.isoWeekYear() % 100;\n  });\n\n  function addWeekYearFormatToken(token, getter) {\n    addFormatToken(0, [token, token.length], 0, getter);\n  }\n\n  addWeekYearFormatToken('gggg', 'weekYear');\n  addWeekYearFormatToken('ggggg', 'weekYear');\n  addWeekYearFormatToken('GGGG', 'isoWeekYear');\n  addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES\n\n  addUnitAlias('weekYear', 'gg');\n  addUnitAlias('isoWeekYear', 'GG'); // PRIORITY\n\n  addUnitPriority('weekYear', 1);\n  addUnitPriority('isoWeekYear', 1); // PARSING\n\n  addRegexToken('G', matchSigned);\n  addRegexToken('g', matchSigned);\n  addRegexToken('GG', match1to2, match2);\n  addRegexToken('gg', match1to2, match2);\n  addRegexToken('GGGG', match1to4, match4);\n  addRegexToken('gggg', match1to4, match4);\n  addRegexToken('GGGGG', match1to6, match6);\n  addRegexToken('ggggg', match1to6, match6);\n  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {\n    week[token.substr(0, 2)] = toInt(input);\n  });\n  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {\n    week[token] = hooks.parseTwoDigitYear(input);\n  }); // MOMENTS\n\n  function getSetWeekYear(input) {\n    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);\n  }\n\n  function getSetISOWeekYear(input) {\n    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);\n  }\n\n  function getISOWeeksInYear() {\n    return weeksInYear(this.year(), 1, 4);\n  }\n\n  function getISOWeeksInISOWeekYear() {\n    return weeksInYear(this.isoWeekYear(), 1, 4);\n  }\n\n  function getWeeksInYear() {\n    var weekInfo = this.localeData()._week;\n\n    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n  }\n\n  function getWeeksInWeekYear() {\n    var weekInfo = this.localeData()._week;\n\n    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\n  }\n\n  function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n    var weeksTarget;\n\n    if (input == null) {\n      return weekOfYear(this, dow, doy).year;\n    } else {\n      weeksTarget = weeksInYear(input, dow, doy);\n\n      if (week > weeksTarget) {\n        week = weeksTarget;\n      }\n\n      return setWeekAll.call(this, input, week, weekday, dow, doy);\n    }\n  }\n\n  function setWeekAll(weekYear, week, weekday, dow, doy) {\n    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),\n        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n    this.year(date.getUTCFullYear());\n    this.month(date.getUTCMonth());\n    this.date(date.getUTCDate());\n    return this;\n  } // FORMATTING\n\n\n  addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES\n\n  addUnitAlias('quarter', 'Q'); // PRIORITY\n\n  addUnitPriority('quarter', 7); // PARSING\n\n  addRegexToken('Q', match1);\n  addParseToken('Q', function (input, array) {\n    array[MONTH] = (toInt(input) - 1) * 3;\n  }); // MOMENTS\n\n  function getSetQuarter(input) {\n    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n  } // FORMATTING\n\n\n  addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES\n\n  addUnitAlias('date', 'D'); // PRIORITY\n\n  addUnitPriority('date', 9); // PARSING\n\n  addRegexToken('D', match1to2);\n  addRegexToken('DD', match1to2, match2);\n  addRegexToken('Do', function (isStrict, locale) {\n    // TODO: Remove \"ordinalParse\" fallback in next major release.\n    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;\n  });\n  addParseToken(['D', 'DD'], DATE);\n  addParseToken('Do', function (input, array) {\n    array[DATE] = toInt(input.match(match1to2)[0]);\n  }); // MOMENTS\n\n  var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING\n\n  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES\n\n  addUnitAlias('dayOfYear', 'DDD'); // PRIORITY\n\n  addUnitPriority('dayOfYear', 4); // PARSING\n\n  addRegexToken('DDD', match1to3);\n  addRegexToken('DDDD', match3);\n  addParseToken(['DDD', 'DDDD'], function (input, array, config) {\n    config._dayOfYear = toInt(input);\n  }); // HELPERS\n  // MOMENTS\n\n  function getSetDayOfYear(input) {\n    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;\n    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');\n  } // FORMATTING\n\n\n  addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES\n\n  addUnitAlias('minute', 'm'); // PRIORITY\n\n  addUnitPriority('minute', 14); // PARSING\n\n  addRegexToken('m', match1to2);\n  addRegexToken('mm', match1to2, match2);\n  addParseToken(['m', 'mm'], MINUTE); // MOMENTS\n\n  var getSetMinute = makeGetSet('Minutes', false); // FORMATTING\n\n  addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES\n\n  addUnitAlias('second', 's'); // PRIORITY\n\n  addUnitPriority('second', 15); // PARSING\n\n  addRegexToken('s', match1to2);\n  addRegexToken('ss', match1to2, match2);\n  addParseToken(['s', 'ss'], SECOND); // MOMENTS\n\n  var getSetSecond = makeGetSet('Seconds', false); // FORMATTING\n\n  addFormatToken('S', 0, 0, function () {\n    return ~~(this.millisecond() / 100);\n  });\n  addFormatToken(0, ['SS', 2], 0, function () {\n    return ~~(this.millisecond() / 10);\n  });\n  addFormatToken(0, ['SSS', 3], 0, 'millisecond');\n  addFormatToken(0, ['SSSS', 4], 0, function () {\n    return this.millisecond() * 10;\n  });\n  addFormatToken(0, ['SSSSS', 5], 0, function () {\n    return this.millisecond() * 100;\n  });\n  addFormatToken(0, ['SSSSSS', 6], 0, function () {\n    return this.millisecond() * 1000;\n  });\n  addFormatToken(0, ['SSSSSSS', 7], 0, function () {\n    return this.millisecond() * 10000;\n  });\n  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {\n    return this.millisecond() * 100000;\n  });\n  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {\n    return this.millisecond() * 1000000;\n  }); // ALIASES\n\n  addUnitAlias('millisecond', 'ms'); // PRIORITY\n\n  addUnitPriority('millisecond', 16); // PARSING\n\n  addRegexToken('S', match1to3, match1);\n  addRegexToken('SS', match1to3, match2);\n  addRegexToken('SSS', match1to3, match3);\n  var token, getSetMillisecond;\n\n  for (token = 'SSSS'; token.length <= 9; token += 'S') {\n    addRegexToken(token, matchUnsigned);\n  }\n\n  function parseMs(input, array) {\n    array[MILLISECOND] = toInt(('0.' + input) * 1000);\n  }\n\n  for (token = 'S'; token.length <= 9; token += 'S') {\n    addParseToken(token, parseMs);\n  }\n\n  getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING\n\n  addFormatToken('z', 0, 0, 'zoneAbbr');\n  addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS\n\n  function getZoneAbbr() {\n    return this._isUTC ? 'UTC' : '';\n  }\n\n  function getZoneName() {\n    return this._isUTC ? 'Coordinated Universal Time' : '';\n  }\n\n  var proto = Moment.prototype;\n  proto.add = add;\n  proto.calendar = calendar$1;\n  proto.clone = clone;\n  proto.diff = diff;\n  proto.endOf = endOf;\n  proto.format = format;\n  proto.from = from;\n  proto.fromNow = fromNow;\n  proto.to = to;\n  proto.toNow = toNow;\n  proto.get = stringGet;\n  proto.invalidAt = invalidAt;\n  proto.isAfter = isAfter;\n  proto.isBefore = isBefore;\n  proto.isBetween = isBetween;\n  proto.isSame = isSame;\n  proto.isSameOrAfter = isSameOrAfter;\n  proto.isSameOrBefore = isSameOrBefore;\n  proto.isValid = isValid$2;\n  proto.lang = lang;\n  proto.locale = locale;\n  proto.localeData = localeData;\n  proto.max = prototypeMax;\n  proto.min = prototypeMin;\n  proto.parsingFlags = parsingFlags;\n  proto.set = stringSet;\n  proto.startOf = startOf;\n  proto.subtract = subtract;\n  proto.toArray = toArray;\n  proto.toObject = toObject;\n  proto.toDate = toDate;\n  proto.toISOString = toISOString;\n  proto.inspect = inspect;\n\n  if (typeof Symbol !== 'undefined' && Symbol[\"for\"] != null) {\n    proto[Symbol[\"for\"]('nodejs.util.inspect.custom')] = function () {\n      return 'Moment<' + this.format() + '>';\n    };\n  }\n\n  proto.toJSON = toJSON;\n  proto.toString = toString;\n  proto.unix = unix;\n  proto.valueOf = valueOf;\n  proto.creationData = creationData;\n  proto.eraName = getEraName;\n  proto.eraNarrow = getEraNarrow;\n  proto.eraAbbr = getEraAbbr;\n  proto.eraYear = getEraYear;\n  proto.year = getSetYear;\n  proto.isLeapYear = getIsLeapYear;\n  proto.weekYear = getSetWeekYear;\n  proto.isoWeekYear = getSetISOWeekYear;\n  proto.quarter = proto.quarters = getSetQuarter;\n  proto.month = getSetMonth;\n  proto.daysInMonth = getDaysInMonth;\n  proto.week = proto.weeks = getSetWeek;\n  proto.isoWeek = proto.isoWeeks = getSetISOWeek;\n  proto.weeksInYear = getWeeksInYear;\n  proto.weeksInWeekYear = getWeeksInWeekYear;\n  proto.isoWeeksInYear = getISOWeeksInYear;\n  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;\n  proto.date = getSetDayOfMonth;\n  proto.day = proto.days = getSetDayOfWeek;\n  proto.weekday = getSetLocaleDayOfWeek;\n  proto.isoWeekday = getSetISODayOfWeek;\n  proto.dayOfYear = getSetDayOfYear;\n  proto.hour = proto.hours = getSetHour;\n  proto.minute = proto.minutes = getSetMinute;\n  proto.second = proto.seconds = getSetSecond;\n  proto.millisecond = proto.milliseconds = getSetMillisecond;\n  proto.utcOffset = getSetOffset;\n  proto.utc = setOffsetToUTC;\n  proto.local = setOffsetToLocal;\n  proto.parseZone = setOffsetToParsedOffset;\n  proto.hasAlignedHourOffset = hasAlignedHourOffset;\n  proto.isDST = isDaylightSavingTime;\n  proto.isLocal = isLocal;\n  proto.isUtcOffset = isUtcOffset;\n  proto.isUtc = isUtc;\n  proto.isUTC = isUtc;\n  proto.zoneAbbr = getZoneAbbr;\n  proto.zoneName = getZoneName;\n  proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);\n  proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);\n  proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);\n  proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);\n  proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);\n\n  function createUnix(input) {\n    return createLocal(input * 1000);\n  }\n\n  function createInZone() {\n    return createLocal.apply(null, arguments).parseZone();\n  }\n\n  function preParsePostFormat(string) {\n    return string;\n  }\n\n  var proto$1 = Locale.prototype;\n  proto$1.calendar = calendar;\n  proto$1.longDateFormat = longDateFormat;\n  proto$1.invalidDate = invalidDate;\n  proto$1.ordinal = ordinal;\n  proto$1.preparse = preParsePostFormat;\n  proto$1.postformat = preParsePostFormat;\n  proto$1.relativeTime = relativeTime;\n  proto$1.pastFuture = pastFuture;\n  proto$1.set = set;\n  proto$1.eras = localeEras;\n  proto$1.erasParse = localeErasParse;\n  proto$1.erasConvertYear = localeErasConvertYear;\n  proto$1.erasAbbrRegex = erasAbbrRegex;\n  proto$1.erasNameRegex = erasNameRegex;\n  proto$1.erasNarrowRegex = erasNarrowRegex;\n  proto$1.months = localeMonths;\n  proto$1.monthsShort = localeMonthsShort;\n  proto$1.monthsParse = localeMonthsParse;\n  proto$1.monthsRegex = monthsRegex;\n  proto$1.monthsShortRegex = monthsShortRegex;\n  proto$1.week = localeWeek;\n  proto$1.firstDayOfYear = localeFirstDayOfYear;\n  proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n  proto$1.weekdays = localeWeekdays;\n  proto$1.weekdaysMin = localeWeekdaysMin;\n  proto$1.weekdaysShort = localeWeekdaysShort;\n  proto$1.weekdaysParse = localeWeekdaysParse;\n  proto$1.weekdaysRegex = weekdaysRegex;\n  proto$1.weekdaysShortRegex = weekdaysShortRegex;\n  proto$1.weekdaysMinRegex = weekdaysMinRegex;\n  proto$1.isPM = localeIsPM;\n  proto$1.meridiem = localeMeridiem;\n\n  function get$1(format, index, field, setter) {\n    var locale = getLocale(),\n        utc = createUTC().set(setter, index);\n    return locale[field](utc, format);\n  }\n\n  function listMonthsImpl(format, index, field) {\n    if (isNumber(format)) {\n      index = format;\n      format = undefined;\n    }\n\n    format = format || '';\n\n    if (index != null) {\n      return get$1(format, index, field, 'month');\n    }\n\n    var i,\n        out = [];\n\n    for (i = 0; i < 12; i++) {\n      out[i] = get$1(format, i, field, 'month');\n    }\n\n    return out;\n  } // ()\n  // (5)\n  // (fmt, 5)\n  // (fmt)\n  // (true)\n  // (true, 5)\n  // (true, fmt, 5)\n  // (true, fmt)\n\n\n  function listWeekdaysImpl(localeSorted, format, index, field) {\n    if (typeof localeSorted === 'boolean') {\n      if (isNumber(format)) {\n        index = format;\n        format = undefined;\n      }\n\n      format = format || '';\n    } else {\n      format = localeSorted;\n      index = format;\n      localeSorted = false;\n\n      if (isNumber(format)) {\n        index = format;\n        format = undefined;\n      }\n\n      format = format || '';\n    }\n\n    var locale = getLocale(),\n        shift = localeSorted ? locale._week.dow : 0,\n        i,\n        out = [];\n\n    if (index != null) {\n      return get$1(format, (index + shift) % 7, field, 'day');\n    }\n\n    for (i = 0; i < 7; i++) {\n      out[i] = get$1(format, (i + shift) % 7, field, 'day');\n    }\n\n    return out;\n  }\n\n  function listMonths(format, index) {\n    return listMonthsImpl(format, index, 'months');\n  }\n\n  function listMonthsShort(format, index) {\n    return listMonthsImpl(format, index, 'monthsShort');\n  }\n\n  function listWeekdays(localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');\n  }\n\n  function listWeekdaysShort(localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');\n  }\n\n  function listWeekdaysMin(localeSorted, format, index) {\n    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');\n  }\n\n  getSetGlobalLocale('en', {\n    eras: [{\n      since: '0001-01-01',\n      until: +Infinity,\n      offset: 1,\n      name: 'Anno Domini',\n      narrow: 'AD',\n      abbr: 'AD'\n    }, {\n      since: '0000-12-31',\n      until: -Infinity,\n      offset: 1,\n      name: 'Before Christ',\n      narrow: 'BC',\n      abbr: 'BC'\n    }],\n    dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n    ordinal: function ordinal(number) {\n      var b = number % 10,\n          output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';\n      return number + output;\n    }\n  }); // Side effect imports\n\n  hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);\n  hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);\n  var mathAbs = Math.abs;\n\n  function abs() {\n    var data = this._data;\n    this._milliseconds = mathAbs(this._milliseconds);\n    this._days = mathAbs(this._days);\n    this._months = mathAbs(this._months);\n    data.milliseconds = mathAbs(data.milliseconds);\n    data.seconds = mathAbs(data.seconds);\n    data.minutes = mathAbs(data.minutes);\n    data.hours = mathAbs(data.hours);\n    data.months = mathAbs(data.months);\n    data.years = mathAbs(data.years);\n    return this;\n  }\n\n  function addSubtract$1(duration, input, value, direction) {\n    var other = createDuration(input, value);\n    duration._milliseconds += direction * other._milliseconds;\n    duration._days += direction * other._days;\n    duration._months += direction * other._months;\n    return duration._bubble();\n  } // supports only 2.0-style add(1, 's') or add(duration)\n\n\n  function add$1(input, value) {\n    return addSubtract$1(this, input, value, 1);\n  } // supports only 2.0-style subtract(1, 's') or subtract(duration)\n\n\n  function subtract$1(input, value) {\n    return addSubtract$1(this, input, value, -1);\n  }\n\n  function absCeil(number) {\n    if (number < 0) {\n      return Math.floor(number);\n    } else {\n      return Math.ceil(number);\n    }\n  }\n\n  function bubble() {\n    var milliseconds = this._milliseconds,\n        days = this._days,\n        months = this._months,\n        data = this._data,\n        seconds,\n        minutes,\n        hours,\n        years,\n        monthsFromDays; // if we have a mix of positive and negative values, bubble down first\n    // check: https://github.com/moment/moment/issues/2166\n\n    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {\n      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n      days = 0;\n      months = 0;\n    } // The following code bubbles up values, see the tests for\n    // examples of what that means.\n\n\n    data.milliseconds = milliseconds % 1000;\n    seconds = absFloor(milliseconds / 1000);\n    data.seconds = seconds % 60;\n    minutes = absFloor(seconds / 60);\n    data.minutes = minutes % 60;\n    hours = absFloor(minutes / 60);\n    data.hours = hours % 24;\n    days += absFloor(hours / 24); // convert days to months\n\n    monthsFromDays = absFloor(daysToMonths(days));\n    months += monthsFromDays;\n    days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year\n\n    years = absFloor(months / 12);\n    months %= 12;\n    data.days = days;\n    data.months = months;\n    data.years = years;\n    return this;\n  }\n\n  function daysToMonths(days) {\n    // 400 years have 146097 days (taking into account leap year rules)\n    // 400 years have 12 months === 4800\n    return days * 4800 / 146097;\n  }\n\n  function monthsToDays(months) {\n    // the reverse of daysToMonths\n    return months * 146097 / 4800;\n  }\n\n  function as(units) {\n    if (!this.isValid()) {\n      return NaN;\n    }\n\n    var days,\n        months,\n        milliseconds = this._milliseconds;\n    units = normalizeUnits(units);\n\n    if (units === 'month' || units === 'quarter' || units === 'year') {\n      days = this._days + milliseconds / 864e5;\n      months = this._months + daysToMonths(days);\n\n      switch (units) {\n        case 'month':\n          return months;\n\n        case 'quarter':\n          return months / 3;\n\n        case 'year':\n          return months / 12;\n      }\n    } else {\n      // handle milliseconds separately because of floating point math errors (issue #1867)\n      days = this._days + Math.round(monthsToDays(this._months));\n\n      switch (units) {\n        case 'week':\n          return days / 7 + milliseconds / 6048e5;\n\n        case 'day':\n          return days + milliseconds / 864e5;\n\n        case 'hour':\n          return days * 24 + milliseconds / 36e5;\n\n        case 'minute':\n          return days * 1440 + milliseconds / 6e4;\n\n        case 'second':\n          return days * 86400 + milliseconds / 1000;\n        // Math.floor prevents floating point math errors here\n\n        case 'millisecond':\n          return Math.floor(days * 864e5) + milliseconds;\n\n        default:\n          throw new Error('Unknown unit ' + units);\n      }\n    }\n  } // TODO: Use this.as('ms')?\n\n\n  function valueOf$1() {\n    if (!this.isValid()) {\n      return NaN;\n    }\n\n    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;\n  }\n\n  function makeAs(alias) {\n    return function () {\n      return this.as(alias);\n    };\n  }\n\n  var asMilliseconds = makeAs('ms'),\n      asSeconds = makeAs('s'),\n      asMinutes = makeAs('m'),\n      asHours = makeAs('h'),\n      asDays = makeAs('d'),\n      asWeeks = makeAs('w'),\n      asMonths = makeAs('M'),\n      asQuarters = makeAs('Q'),\n      asYears = makeAs('y');\n\n  function clone$1() {\n    return createDuration(this);\n  }\n\n  function get$2(units) {\n    units = normalizeUnits(units);\n    return this.isValid() ? this[units + 's']() : NaN;\n  }\n\n  function makeGetter(name) {\n    return function () {\n      return this.isValid() ? this._data[name] : NaN;\n    };\n  }\n\n  var milliseconds = makeGetter('milliseconds'),\n      seconds = makeGetter('seconds'),\n      minutes = makeGetter('minutes'),\n      hours = makeGetter('hours'),\n      days = makeGetter('days'),\n      months = makeGetter('months'),\n      years = makeGetter('years');\n\n  function weeks() {\n    return absFloor(this.days() / 7);\n  }\n\n  var round = Math.round,\n      thresholds = {\n    ss: 44,\n    // a few seconds to seconds\n    s: 45,\n    // seconds to minute\n    m: 45,\n    // minutes to hour\n    h: 22,\n    // hours to day\n    d: 26,\n    // days to month/week\n    w: null,\n    // weeks to month\n    M: 11 // months to year\n\n  }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n\n  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n  }\n\n  function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {\n    var duration = createDuration(posNegDuration).abs(),\n        seconds = round(duration.as('s')),\n        minutes = round(duration.as('m')),\n        hours = round(duration.as('h')),\n        days = round(duration.as('d')),\n        months = round(duration.as('M')),\n        weeks = round(duration.as('w')),\n        years = round(duration.as('y')),\n        a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];\n\n    if (thresholds.w != null) {\n      a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];\n    }\n\n    a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];\n    a[2] = withoutSuffix;\n    a[3] = +posNegDuration > 0;\n    a[4] = locale;\n    return substituteTimeAgo.apply(null, a);\n  } // This function allows you to set the rounding function for relative time strings\n\n\n  function getSetRelativeTimeRounding(roundingFunction) {\n    if (roundingFunction === undefined) {\n      return round;\n    }\n\n    if (typeof roundingFunction === 'function') {\n      round = roundingFunction;\n      return true;\n    }\n\n    return false;\n  } // This function allows you to set a threshold for relative time strings\n\n\n  function getSetRelativeTimeThreshold(threshold, limit) {\n    if (thresholds[threshold] === undefined) {\n      return false;\n    }\n\n    if (limit === undefined) {\n      return thresholds[threshold];\n    }\n\n    thresholds[threshold] = limit;\n\n    if (threshold === 's') {\n      thresholds.ss = limit - 1;\n    }\n\n    return true;\n  }\n\n  function humanize(argWithSuffix, argThresholds) {\n    if (!this.isValid()) {\n      return this.localeData().invalidDate();\n    }\n\n    var withSuffix = false,\n        th = thresholds,\n        locale,\n        output;\n\n    if (typeof argWithSuffix === 'object') {\n      argThresholds = argWithSuffix;\n      argWithSuffix = false;\n    }\n\n    if (typeof argWithSuffix === 'boolean') {\n      withSuffix = argWithSuffix;\n    }\n\n    if (typeof argThresholds === 'object') {\n      th = Object.assign({}, thresholds, argThresholds);\n\n      if (argThresholds.s != null && argThresholds.ss == null) {\n        th.ss = argThresholds.s - 1;\n      }\n    }\n\n    locale = this.localeData();\n    output = relativeTime$1(this, !withSuffix, th, locale);\n\n    if (withSuffix) {\n      output = locale.pastFuture(+this, output);\n    }\n\n    return locale.postformat(output);\n  }\n\n  var abs$1 = Math.abs;\n\n  function sign(x) {\n    return (x > 0) - (x < 0) || +x;\n  }\n\n  function toISOString$1() {\n    // for ISO strings we do not use the normal bubbling rules:\n    //  * milliseconds bubble up until they become hours\n    //  * days do not bubble at all\n    //  * months bubble up until they become years\n    // This is because there is no context-free conversion between hours and days\n    // (think of clock changes)\n    // and also not between days and months (28-31 days per month)\n    if (!this.isValid()) {\n      return this.localeData().invalidDate();\n    }\n\n    var seconds = abs$1(this._milliseconds) / 1000,\n        days = abs$1(this._days),\n        months = abs$1(this._months),\n        minutes,\n        hours,\n        years,\n        s,\n        total = this.asSeconds(),\n        totalSign,\n        ymSign,\n        daysSign,\n        hmsSign;\n\n    if (!total) {\n      // this is the same as C#'s (Noda) and python (isodate)...\n      // but not other JS (goog.date)\n      return 'P0D';\n    } // 3600 seconds -> 60 minutes -> 1 hour\n\n\n    minutes = absFloor(seconds / 60);\n    hours = absFloor(minutes / 60);\n    seconds %= 60;\n    minutes %= 60; // 12 months -> 1 year\n\n    years = absFloor(months / 12);\n    months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n\n    s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, '') : '';\n    totalSign = total < 0 ? '-' : '';\n    ymSign = sign(this._months) !== sign(total) ? '-' : '';\n    daysSign = sign(this._days) !== sign(total) ? '-' : '';\n    hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';\n    return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');\n  }\n\n  var proto$2 = Duration.prototype;\n  proto$2.isValid = isValid$1;\n  proto$2.abs = abs;\n  proto$2.add = add$1;\n  proto$2.subtract = subtract$1;\n  proto$2.as = as;\n  proto$2.asMilliseconds = asMilliseconds;\n  proto$2.asSeconds = asSeconds;\n  proto$2.asMinutes = asMinutes;\n  proto$2.asHours = asHours;\n  proto$2.asDays = asDays;\n  proto$2.asWeeks = asWeeks;\n  proto$2.asMonths = asMonths;\n  proto$2.asQuarters = asQuarters;\n  proto$2.asYears = asYears;\n  proto$2.valueOf = valueOf$1;\n  proto$2._bubble = bubble;\n  proto$2.clone = clone$1;\n  proto$2.get = get$2;\n  proto$2.milliseconds = milliseconds;\n  proto$2.seconds = seconds;\n  proto$2.minutes = minutes;\n  proto$2.hours = hours;\n  proto$2.days = days;\n  proto$2.weeks = weeks;\n  proto$2.months = months;\n  proto$2.years = years;\n  proto$2.humanize = humanize;\n  proto$2.toISOString = toISOString$1;\n  proto$2.toString = toISOString$1;\n  proto$2.toJSON = toISOString$1;\n  proto$2.locale = locale;\n  proto$2.localeData = localeData;\n  proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);\n  proto$2.lang = lang; // FORMATTING\n\n  addFormatToken('X', 0, 0, 'unix');\n  addFormatToken('x', 0, 0, 'valueOf'); // PARSING\n\n  addRegexToken('x', matchSigned);\n  addRegexToken('X', matchTimestamp);\n  addParseToken('X', function (input, array, config) {\n    config._d = new Date(parseFloat(input) * 1000);\n  });\n  addParseToken('x', function (input, array, config) {\n    config._d = new Date(toInt(input));\n  }); //! moment.js\n\n  hooks.version = '2.29.3';\n  setHookCallback(createLocal);\n  hooks.fn = proto;\n  hooks.min = min;\n  hooks.max = max;\n  hooks.now = now;\n  hooks.utc = createUTC;\n  hooks.unix = createUnix;\n  hooks.months = listMonths;\n  hooks.isDate = isDate;\n  hooks.locale = getSetGlobalLocale;\n  hooks.invalid = createInvalid;\n  hooks.duration = createDuration;\n  hooks.isMoment = isMoment;\n  hooks.weekdays = listWeekdays;\n  hooks.parseZone = createInZone;\n  hooks.localeData = getLocale;\n  hooks.isDuration = isDuration;\n  hooks.monthsShort = listMonthsShort;\n  hooks.weekdaysMin = listWeekdaysMin;\n  hooks.defineLocale = defineLocale;\n  hooks.updateLocale = updateLocale;\n  hooks.locales = listLocales;\n  hooks.weekdaysShort = listWeekdaysShort;\n  hooks.normalizeUnits = normalizeUnits;\n  hooks.relativeTimeRounding = getSetRelativeTimeRounding;\n  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n  hooks.calendarFormat = getCalendarFormat;\n  hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats\n\n  hooks.HTML5_FMT = {\n    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',\n    // <input type=\"datetime-local\" />\n    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',\n    // <input type=\"datetime-local\" step=\"1\" />\n    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',\n    // <input type=\"datetime-local\" step=\"0.001\" />\n    DATE: 'YYYY-MM-DD',\n    // <input type=\"date\" />\n    TIME: 'HH:mm',\n    // <input type=\"time\" />\n    TIME_SECONDS: 'HH:mm:ss',\n    // <input type=\"time\" step=\"1\" />\n    TIME_MS: 'HH:mm:ss.SSS',\n    // <input type=\"time\" step=\"0.001\" />\n    WEEK: 'GGGG-[W]WW',\n    // <input type=\"week\" />\n    MONTH: 'YYYY-MM' // <input type=\"month\" />\n\n  };\n  return hooks;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(\"hOG+\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcz9jMWRmIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiaG9va0NhbGxiYWNrIiwiaG9va3MiLCJhcHBseSIsImFyZ3VtZW50cyIsInNldEhvb2tDYWxsYmFjayIsImNhbGxiYWNrIiwiaXNBcnJheSIsImlucHV0IiwiQXJyYXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc09iamVjdCIsImhhc093blByb3AiLCJhIiwiYiIsImhhc093blByb3BlcnR5IiwiaXNPYmplY3RFbXB0eSIsIm9iaiIsImdldE93blByb3BlcnR5TmFtZXMiLCJsZW5ndGgiLCJrIiwiaXNVbmRlZmluZWQiLCJpc051bWJlciIsImlzRGF0ZSIsIkRhdGUiLCJtYXAiLCJhcnIiLCJmbiIsInJlcyIsImkiLCJhcnJMZW4iLCJwdXNoIiwiZXh0ZW5kIiwidmFsdWVPZiIsImNyZWF0ZVVUQyIsImZvcm1hdCIsImxvY2FsZSIsInN0cmljdCIsImNyZWF0ZUxvY2FsT3JVVEMiLCJ1dGMiLCJkZWZhdWx0UGFyc2luZ0ZsYWdzIiwiZW1wdHkiLCJ1bnVzZWRUb2tlbnMiLCJ1bnVzZWRJbnB1dCIsIm92ZXJmbG93IiwiY2hhcnNMZWZ0T3ZlciIsIm51bGxJbnB1dCIsImludmFsaWRFcmEiLCJpbnZhbGlkTW9udGgiLCJpbnZhbGlkRm9ybWF0IiwidXNlckludmFsaWRhdGVkIiwiaXNvIiwicGFyc2VkRGF0ZVBhcnRzIiwiZXJhIiwibWVyaWRpZW0iLCJyZmMyODIyIiwid2Vla2RheU1pc21hdGNoIiwiZ2V0UGFyc2luZ0ZsYWdzIiwibSIsIl9wZiIsInNvbWUiLCJmdW4iLCJ0IiwibGVuIiwiaXNWYWxpZCIsIl9pc1ZhbGlkIiwiZmxhZ3MiLCJwYXJzZWRQYXJ0cyIsImlzTm93VmFsaWQiLCJpc05hTiIsIl9kIiwiZ2V0VGltZSIsImludmFsaWRXZWVrZGF5IiwiX3N0cmljdCIsImJpZ0hvdXIiLCJ1bmRlZmluZWQiLCJpc0Zyb3plbiIsImNyZWF0ZUludmFsaWQiLCJOYU4iLCJtb21lbnRQcm9wZXJ0aWVzIiwidXBkYXRlSW5Qcm9ncmVzcyIsImNvcHlDb25maWciLCJ0byIsImZyb20iLCJwcm9wIiwidmFsIiwibW9tZW50UHJvcGVydGllc0xlbiIsIl9pc0FNb21lbnRPYmplY3QiLCJfaSIsIl9mIiwiX2wiLCJfdHptIiwiX2lzVVRDIiwiX29mZnNldCIsIl9sb2NhbGUiLCJNb21lbnQiLCJjb25maWciLCJ1cGRhdGVPZmZzZXQiLCJpc01vbWVudCIsIndhcm4iLCJtc2ciLCJzdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MiLCJjb25zb2xlIiwiZGVwcmVjYXRlIiwiZmlyc3RUaW1lIiwiZGVwcmVjYXRpb25IYW5kbGVyIiwiYXJncyIsImFyZyIsImtleSIsImFyZ0xlbiIsInNsaWNlIiwiam9pbiIsIkVycm9yIiwic3RhY2siLCJkZXByZWNhdGlvbnMiLCJkZXByZWNhdGVTaW1wbGUiLCJuYW1lIiwiaXNGdW5jdGlvbiIsIkZ1bmN0aW9uIiwic2V0IiwiX2NvbmZpZyIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCIsIlJlZ0V4cCIsIl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwic291cmNlIiwiX29yZGluYWxQYXJzZSIsIm1lcmdlQ29uZmlncyIsInBhcmVudENvbmZpZyIsImNoaWxkQ29uZmlnIiwiTG9jYWxlIiwia2V5cyIsImRlZmF1bHRDYWxlbmRhciIsInNhbWVEYXkiLCJuZXh0RGF5IiwibmV4dFdlZWsiLCJsYXN0RGF5IiwibGFzdFdlZWsiLCJzYW1lRWxzZSIsImNhbGVuZGFyIiwibW9tIiwibm93Iiwib3V0cHV0IiwiX2NhbGVuZGFyIiwiemVyb0ZpbGwiLCJudW1iZXIiLCJ0YXJnZXRMZW5ndGgiLCJmb3JjZVNpZ24iLCJhYnNOdW1iZXIiLCJNYXRoIiwiYWJzIiwiemVyb3NUb0ZpbGwiLCJzaWduIiwicG93IiwibWF4Iiwic3Vic3RyIiwiZm9ybWF0dGluZ1Rva2VucyIsImxvY2FsRm9ybWF0dGluZ1Rva2VucyIsImZvcm1hdEZ1bmN0aW9ucyIsImZvcm1hdFRva2VuRnVuY3Rpb25zIiwiYWRkRm9ybWF0VG9rZW4iLCJ0b2tlbiIsInBhZGRlZCIsIm9yZGluYWwiLCJmdW5jIiwibG9jYWxlRGF0YSIsInJlbW92ZUZvcm1hdHRpbmdUb2tlbnMiLCJtYXRjaCIsInJlcGxhY2UiLCJtYWtlRm9ybWF0RnVuY3Rpb24iLCJhcnJheSIsImZvcm1hdE1vbWVudCIsImludmFsaWREYXRlIiwiZXhwYW5kRm9ybWF0IiwicmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zIiwibG9uZ0RhdGVGb3JtYXQiLCJsYXN0SW5kZXgiLCJ0ZXN0IiwiZGVmYXVsdExvbmdEYXRlRm9ybWF0IiwiTFRTIiwiTFQiLCJMIiwiTEwiLCJMTEwiLCJMTExMIiwiX2xvbmdEYXRlRm9ybWF0IiwiZm9ybWF0VXBwZXIiLCJ0b1VwcGVyQ2FzZSIsInRvayIsImRlZmF1bHRJbnZhbGlkRGF0ZSIsIl9pbnZhbGlkRGF0ZSIsImRlZmF1bHRPcmRpbmFsIiwiZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UiLCJfb3JkaW5hbCIsImRlZmF1bHRSZWxhdGl2ZVRpbWUiLCJmdXR1cmUiLCJwYXN0IiwicyIsInNzIiwibW0iLCJoIiwiaGgiLCJkIiwiZGQiLCJ3Iiwid3ciLCJNIiwiTU0iLCJ5IiwieXkiLCJyZWxhdGl2ZVRpbWUiLCJ3aXRob3V0U3VmZml4Iiwic3RyaW5nIiwiaXNGdXR1cmUiLCJfcmVsYXRpdmVUaW1lIiwicGFzdEZ1dHVyZSIsImRpZmYiLCJhbGlhc2VzIiwiYWRkVW5pdEFsaWFzIiwidW5pdCIsInNob3J0aGFuZCIsImxvd2VyQ2FzZSIsInRvTG93ZXJDYXNlIiwibm9ybWFsaXplVW5pdHMiLCJ1bml0cyIsIm5vcm1hbGl6ZU9iamVjdFVuaXRzIiwiaW5wdXRPYmplY3QiLCJub3JtYWxpemVkSW5wdXQiLCJub3JtYWxpemVkUHJvcCIsInByaW9yaXRpZXMiLCJhZGRVbml0UHJpb3JpdHkiLCJwcmlvcml0eSIsImdldFByaW9yaXRpemVkVW5pdHMiLCJ1bml0c09iaiIsInUiLCJzb3J0IiwiaXNMZWFwWWVhciIsInllYXIiLCJhYnNGbG9vciIsImNlaWwiLCJmbG9vciIsInRvSW50IiwiYXJndW1lbnRGb3JDb2VyY2lvbiIsImNvZXJjZWROdW1iZXIiLCJ2YWx1ZSIsImlzRmluaXRlIiwibWFrZUdldFNldCIsImtlZXBUaW1lIiwic2V0JDEiLCJnZXQiLCJtb250aCIsImRhdGUiLCJkYXlzSW5Nb250aCIsInN0cmluZ0dldCIsInN0cmluZ1NldCIsInByaW9yaXRpemVkIiwicHJpb3JpdGl6ZWRMZW4iLCJtYXRjaDEiLCJtYXRjaDIiLCJtYXRjaDMiLCJtYXRjaDQiLCJtYXRjaDYiLCJtYXRjaDF0bzIiLCJtYXRjaDN0bzQiLCJtYXRjaDV0bzYiLCJtYXRjaDF0bzMiLCJtYXRjaDF0bzQiLCJtYXRjaDF0bzYiLCJtYXRjaFVuc2lnbmVkIiwibWF0Y2hTaWduZWQiLCJtYXRjaE9mZnNldCIsIm1hdGNoU2hvcnRPZmZzZXQiLCJtYXRjaFRpbWVzdGFtcCIsIm1hdGNoV29yZCIsInJlZ2V4ZXMiLCJhZGRSZWdleFRva2VuIiwicmVnZXgiLCJzdHJpY3RSZWdleCIsImlzU3RyaWN0IiwiZ2V0UGFyc2VSZWdleEZvclRva2VuIiwidW5lc2NhcGVGb3JtYXQiLCJyZWdleEVzY2FwZSIsIm1hdGNoZWQiLCJwMSIsInAyIiwicDMiLCJwNCIsInRva2VucyIsImFkZFBhcnNlVG9rZW4iLCJ0b2tlbkxlbiIsImFkZFdlZWtQYXJzZVRva2VuIiwiX3ciLCJhZGRUaW1lVG9BcnJheUZyb21Ub2tlbiIsIl9hIiwiWUVBUiIsIk1PTlRIIiwiREFURSIsIkhPVVIiLCJNSU5VVEUiLCJTRUNPTkQiLCJNSUxMSVNFQ09ORCIsIldFRUsiLCJXRUVLREFZIiwibW9kIiwibiIsIngiLCJpbmRleE9mIiwibyIsIm1vZE1vbnRoIiwibW9udGhzU2hvcnQiLCJtb250aHMiLCJtb250aHNTaG9ydFJlZ2V4IiwibW9udGhzUmVnZXgiLCJtb250aHNQYXJzZSIsImRlZmF1bHRMb2NhbGVNb250aHMiLCJzcGxpdCIsImRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCIsIk1PTlRIU19JTl9GT1JNQVQiLCJkZWZhdWx0TW9udGhzU2hvcnRSZWdleCIsImRlZmF1bHRNb250aHNSZWdleCIsImxvY2FsZU1vbnRocyIsIl9tb250aHMiLCJpc0Zvcm1hdCIsImxvY2FsZU1vbnRoc1Nob3J0IiwiX21vbnRoc1Nob3J0IiwiaGFuZGxlU3RyaWN0UGFyc2UiLCJtb250aE5hbWUiLCJpaSIsImxsYyIsInRvTG9jYWxlTG93ZXJDYXNlIiwiX21vbnRoc1BhcnNlIiwiX2xvbmdNb250aHNQYXJzZSIsIl9zaG9ydE1vbnRoc1BhcnNlIiwibG9jYWxlTW9udGhzUGFyc2UiLCJfbW9udGhzUGFyc2VFeGFjdCIsInNldE1vbnRoIiwiZGF5T2ZNb250aCIsIm1pbiIsImdldFNldE1vbnRoIiwiZ2V0RGF5c0luTW9udGgiLCJjb21wdXRlTW9udGhzUGFyc2UiLCJfbW9udGhzU2hvcnRTdHJpY3RSZWdleCIsIl9tb250aHNTaG9ydFJlZ2V4IiwiX21vbnRoc1N0cmljdFJlZ2V4IiwiX21vbnRoc1JlZ2V4IiwiY21wTGVuUmV2Iiwic2hvcnRQaWVjZXMiLCJsb25nUGllY2VzIiwibWl4ZWRQaWVjZXMiLCJwYXJzZVR3b0RpZ2l0WWVhciIsInBhcnNlSW50IiwiZGF5c0luWWVhciIsImdldFNldFllYXIiLCJnZXRJc0xlYXBZZWFyIiwiY3JlYXRlRGF0ZSIsIm1zIiwiZ2V0RnVsbFllYXIiLCJzZXRGdWxsWWVhciIsImNyZWF0ZVVUQ0RhdGUiLCJVVEMiLCJnZXRVVENGdWxsWWVhciIsInNldFVUQ0Z1bGxZZWFyIiwiZmlyc3RXZWVrT2Zmc2V0IiwiZG93IiwiZG95IiwiZndkIiwiZndkbHciLCJnZXRVVENEYXkiLCJkYXlPZlllYXJGcm9tV2Vla3MiLCJ3ZWVrIiwid2Vla2RheSIsImxvY2FsV2Vla2RheSIsIndlZWtPZmZzZXQiLCJkYXlPZlllYXIiLCJyZXNZZWFyIiwicmVzRGF5T2ZZZWFyIiwid2Vla09mWWVhciIsInJlc1dlZWsiLCJ3ZWVrc0luWWVhciIsIndlZWtPZmZzZXROZXh0IiwibG9jYWxlV2VlayIsIl93ZWVrIiwiZGVmYXVsdExvY2FsZVdlZWsiLCJsb2NhbGVGaXJzdERheU9mV2VlayIsImxvY2FsZUZpcnN0RGF5T2ZZZWFyIiwiZ2V0U2V0V2VlayIsImFkZCIsImdldFNldElTT1dlZWsiLCJ3ZWVrZGF5c01pbiIsIndlZWtkYXlzU2hvcnQiLCJ3ZWVrZGF5cyIsIndlZWtkYXlzTWluUmVnZXgiLCJ3ZWVrZGF5c1Nob3J0UmVnZXgiLCJ3ZWVrZGF5c1JlZ2V4Iiwid2Vla2RheXNQYXJzZSIsInBhcnNlV2Vla2RheSIsInBhcnNlSXNvV2Vla2RheSIsInNoaWZ0V2Vla2RheXMiLCJ3cyIsImNvbmNhdCIsImRlZmF1bHRMb2NhbGVXZWVrZGF5cyIsImRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0IiwiZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluIiwiZGVmYXVsdFdlZWtkYXlzUmVnZXgiLCJkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4IiwiZGVmYXVsdFdlZWtkYXlzTWluUmVnZXgiLCJsb2NhbGVXZWVrZGF5cyIsIl93ZWVrZGF5cyIsImRheSIsImxvY2FsZVdlZWtkYXlzU2hvcnQiLCJfd2Vla2RheXNTaG9ydCIsImxvY2FsZVdlZWtkYXlzTWluIiwiX3dlZWtkYXlzTWluIiwiaGFuZGxlU3RyaWN0UGFyc2UkMSIsIndlZWtkYXlOYW1lIiwiX3dlZWtkYXlzUGFyc2UiLCJfc2hvcnRXZWVrZGF5c1BhcnNlIiwiX21pbldlZWtkYXlzUGFyc2UiLCJsb2NhbGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzUGFyc2VFeGFjdCIsIl9mdWxsV2Vla2RheXNQYXJzZSIsImdldFNldERheU9mV2VlayIsImdldERheSIsImdldFNldExvY2FsZURheU9mV2VlayIsImdldFNldElTT0RheU9mV2VlayIsImNvbXB1dGVXZWVrZGF5c1BhcnNlIiwiX3dlZWtkYXlzU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNSZWdleCIsIl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXgiLCJfd2Vla2RheXNTaG9ydFJlZ2V4IiwiX3dlZWtkYXlzTWluU3RyaWN0UmVnZXgiLCJfd2Vla2RheXNNaW5SZWdleCIsIm1pblBpZWNlcyIsIm1pbnAiLCJzaG9ydHAiLCJsb25ncCIsImhGb3JtYXQiLCJob3VycyIsImtGb3JtYXQiLCJtaW51dGVzIiwic2Vjb25kcyIsImxvd2VyY2FzZSIsIm1hdGNoTWVyaWRpZW0iLCJfbWVyaWRpZW1QYXJzZSIsImtJbnB1dCIsIl9pc1BtIiwiaXNQTSIsIl9tZXJpZGllbSIsInBvcyIsInBvczEiLCJwb3MyIiwibG9jYWxlSXNQTSIsImNoYXJBdCIsImRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlIiwiZ2V0U2V0SG91ciIsImxvY2FsZU1lcmlkaWVtIiwiaXNMb3dlciIsImJhc2VDb25maWciLCJkYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwibWVyaWRpZW1QYXJzZSIsImxvY2FsZXMiLCJsb2NhbGVGYW1pbGllcyIsImdsb2JhbExvY2FsZSIsImNvbW1vblByZWZpeCIsImFycjEiLCJhcnIyIiwibWlubCIsIm5vcm1hbGl6ZUxvY2FsZSIsImNob29zZUxvY2FsZSIsIm5hbWVzIiwiaiIsIm5leHQiLCJsb2FkTG9jYWxlIiwiaXNMb2NhbGVOYW1lU2FuZSIsIm9sZExvY2FsZSIsImFsaWFzZWRSZXF1aXJlIiwiX2FiYnIiLCJyZXF1aXJlIiwiZ2V0U2V0R2xvYmFsTG9jYWxlIiwiZSIsInZhbHVlcyIsImRhdGEiLCJnZXRMb2NhbGUiLCJkZWZpbmVMb2NhbGUiLCJhYmJyIiwicGFyZW50TG9jYWxlIiwiZm9yRWFjaCIsInVwZGF0ZUxvY2FsZSIsInRtcExvY2FsZSIsImxpc3RMb2NhbGVzIiwiY2hlY2tPdmVyZmxvdyIsIl9vdmVyZmxvd0RheU9mWWVhciIsIl9vdmVyZmxvd1dlZWtzIiwiX292ZXJmbG93V2Vla2RheSIsImV4dGVuZGVkSXNvUmVnZXgiLCJiYXNpY0lzb1JlZ2V4IiwidHpSZWdleCIsImlzb0RhdGVzIiwiaXNvVGltZXMiLCJhc3BOZXRKc29uUmVnZXgiLCJvYnNPZmZzZXRzIiwiVVQiLCJHTVQiLCJFRFQiLCJFU1QiLCJDRFQiLCJDU1QiLCJNRFQiLCJNU1QiLCJQRFQiLCJQU1QiLCJjb25maWdGcm9tSVNPIiwibCIsImV4ZWMiLCJhbGxvd1RpbWUiLCJkYXRlRm9ybWF0IiwidGltZUZvcm1hdCIsInR6Rm9ybWF0IiwiaXNvRGF0ZXNMZW4iLCJpc29UaW1lc0xlbiIsImNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQiLCJleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzIiwieWVhclN0ciIsIm1vbnRoU3RyIiwiZGF5U3RyIiwiaG91clN0ciIsIm1pbnV0ZVN0ciIsInNlY29uZFN0ciIsInJlc3VsdCIsInVudHJ1bmNhdGVZZWFyIiwicHJlcHJvY2Vzc1JGQzI4MjIiLCJjaGVja1dlZWtkYXkiLCJ3ZWVrZGF5U3RyIiwicGFyc2VkSW5wdXQiLCJ3ZWVrZGF5UHJvdmlkZWQiLCJ3ZWVrZGF5QWN0dWFsIiwiY2FsY3VsYXRlT2Zmc2V0Iiwib2JzT2Zmc2V0IiwibWlsaXRhcnlPZmZzZXQiLCJudW1PZmZzZXQiLCJobSIsImNvbmZpZ0Zyb21SRkMyODIyIiwicGFyc2VkQXJyYXkiLCJzZXRVVENNaW51dGVzIiwiZ2V0VVRDTWludXRlcyIsImNvbmZpZ0Zyb21TdHJpbmciLCJjcmVhdGVGcm9tSW5wdXRGYWxsYmFjayIsIl91c2VVVEMiLCJkZWZhdWx0cyIsImMiLCJjdXJyZW50RGF0ZUFycmF5Iiwibm93VmFsdWUiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJnZXRNb250aCIsImdldERhdGUiLCJjb25maWdGcm9tQXJyYXkiLCJjdXJyZW50RGF0ZSIsImV4cGVjdGVkV2Vla2RheSIsInllYXJUb1VzZSIsImRheU9mWWVhckZyb21XZWVrSW5mbyIsIl9kYXlPZlllYXIiLCJfbmV4dERheSIsIndlZWtZZWFyIiwidGVtcCIsIndlZWtkYXlPdmVyZmxvdyIsImN1cldlZWsiLCJHRyIsIlciLCJFIiwiY3JlYXRlTG9jYWwiLCJnZyIsIklTT184NjAxIiwiUkZDXzI4MjIiLCJza2lwcGVkIiwic3RyaW5nTGVuZ3RoIiwidG90YWxQYXJzZWRJbnB1dExlbmd0aCIsIm1lcmlkaWVtRml4V3JhcCIsImVyYXNDb252ZXJ0WWVhciIsImhvdXIiLCJpc1BtIiwibWVyaWRpZW1Ib3VyIiwiY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5IiwidGVtcENvbmZpZyIsImJlc3RNb21lbnQiLCJzY29yZVRvQmVhdCIsImN1cnJlbnRTY29yZSIsInZhbGlkRm9ybWF0Rm91bmQiLCJiZXN0Rm9ybWF0SXNWYWxpZCIsImNvbmZpZ2ZMZW4iLCJzY29yZSIsImNvbmZpZ0Zyb21PYmplY3QiLCJkYXlPckRhdGUiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsImNyZWF0ZUZyb21Db25maWciLCJwcmVwYXJlQ29uZmlnIiwicHJlcGFyc2UiLCJjb25maWdGcm9tSW5wdXQiLCJpc1VUQyIsInByb3RvdHlwZU1pbiIsIm90aGVyIiwicHJvdG90eXBlTWF4IiwicGlja0J5IiwibW9tZW50cyIsIm9yZGVyaW5nIiwiaXNEdXJhdGlvblZhbGlkIiwidW5pdEhhc0RlY2ltYWwiLCJvcmRlckxlbiIsInBhcnNlRmxvYXQiLCJpc1ZhbGlkJDEiLCJjcmVhdGVJbnZhbGlkJDEiLCJjcmVhdGVEdXJhdGlvbiIsIkR1cmF0aW9uIiwiZHVyYXRpb24iLCJ5ZWFycyIsInF1YXJ0ZXJzIiwicXVhcnRlciIsIndlZWtzIiwiaXNvV2VlayIsImRheXMiLCJtaWxsaXNlY29uZHMiLCJfbWlsbGlzZWNvbmRzIiwiX2RheXMiLCJfZGF0YSIsIl9idWJibGUiLCJpc0R1cmF0aW9uIiwiYWJzUm91bmQiLCJyb3VuZCIsImNvbXBhcmVBcnJheXMiLCJhcnJheTEiLCJhcnJheTIiLCJkb250Q29udmVydCIsImxlbmd0aERpZmYiLCJkaWZmcyIsIm9mZnNldCIsInNlcGFyYXRvciIsInV0Y09mZnNldCIsIm9mZnNldEZyb21TdHJpbmciLCJjaHVua09mZnNldCIsIm1hdGNoZXIiLCJtYXRjaGVzIiwiY2h1bmsiLCJwYXJ0cyIsImNsb25lV2l0aE9mZnNldCIsIm1vZGVsIiwiY2xvbmUiLCJzZXRUaW1lIiwibG9jYWwiLCJnZXREYXRlT2Zmc2V0IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJnZXRTZXRPZmZzZXQiLCJrZWVwTG9jYWxUaW1lIiwia2VlcE1pbnV0ZXMiLCJsb2NhbEFkanVzdCIsIl9jaGFuZ2VJblByb2dyZXNzIiwiYWRkU3VidHJhY3QiLCJnZXRTZXRab25lIiwic2V0T2Zmc2V0VG9VVEMiLCJzZXRPZmZzZXRUb0xvY2FsIiwic3VidHJhY3QiLCJzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCIsInRab25lIiwiaGFzQWxpZ25lZEhvdXJPZmZzZXQiLCJpc0RheWxpZ2h0U2F2aW5nVGltZSIsImlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCIsIl9pc0RTVFNoaWZ0ZWQiLCJ0b0FycmF5IiwiaXNMb2NhbCIsImlzVXRjT2Zmc2V0IiwiaXNVdGMiLCJhc3BOZXRSZWdleCIsImlzb1JlZ2V4IiwicmV0IiwiZGlmZlJlcyIsInBhcnNlSXNvIiwibW9tZW50c0RpZmZlcmVuY2UiLCJpbnZhbGlkIiwiaW5wIiwicG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZSIsImJhc2UiLCJpc0FmdGVyIiwiaXNCZWZvcmUiLCJjcmVhdGVBZGRlciIsImRpcmVjdGlvbiIsInBlcmlvZCIsImR1ciIsInRtcCIsImlzQWRkaW5nIiwiaXNTdHJpbmciLCJTdHJpbmciLCJpc01vbWVudElucHV0IiwiaXNOdW1iZXJPclN0cmluZ0FycmF5IiwiaXNNb21lbnRJbnB1dE9iamVjdCIsIm9iamVjdFRlc3QiLCJwcm9wZXJ0eVRlc3QiLCJwcm9wZXJ0aWVzIiwicHJvcGVydHkiLCJwcm9wZXJ0eUxlbiIsImFycmF5VGVzdCIsImRhdGFUeXBlVGVzdCIsImZpbHRlciIsIml0ZW0iLCJpc0NhbGVuZGFyU3BlYyIsImdldENhbGVuZGFyRm9ybWF0IiwibXlNb21lbnQiLCJjYWxlbmRhciQxIiwidGltZSIsImZvcm1hdHMiLCJzb2QiLCJzdGFydE9mIiwiY2FsZW5kYXJGb3JtYXQiLCJsb2NhbElucHV0IiwiZW5kT2YiLCJpc0JldHdlZW4iLCJpbmNsdXNpdml0eSIsImxvY2FsRnJvbSIsImxvY2FsVG8iLCJpc1NhbWUiLCJpbnB1dE1zIiwiaXNTYW1lT3JBZnRlciIsImlzU2FtZU9yQmVmb3JlIiwiYXNGbG9hdCIsInRoYXQiLCJ6b25lRGVsdGEiLCJtb250aERpZmYiLCJ3aG9sZU1vbnRoRGlmZiIsImFuY2hvciIsImFuY2hvcjIiLCJhZGp1c3QiLCJkZWZhdWx0Rm9ybWF0IiwiZGVmYXVsdEZvcm1hdFV0YyIsInRvSVNPU3RyaW5nIiwia2VlcE9mZnNldCIsInRvRGF0ZSIsImluc3BlY3QiLCJ6b25lIiwicHJlZml4IiwiZGF0ZXRpbWUiLCJzdWZmaXgiLCJpbnB1dFN0cmluZyIsInBvc3Rmb3JtYXQiLCJodW1hbml6ZSIsImZyb21Ob3ciLCJ0b05vdyIsIm5ld0xvY2FsZURhdGEiLCJsYW5nIiwiTVNfUEVSX1NFQ09ORCIsIk1TX1BFUl9NSU5VVEUiLCJNU19QRVJfSE9VUiIsIk1TX1BFUl80MDBfWUVBUlMiLCJtb2QkMSIsImRpdmlkZW5kIiwiZGl2aXNvciIsImxvY2FsU3RhcnRPZkRhdGUiLCJ1dGNTdGFydE9mRGF0ZSIsInN0YXJ0T2ZEYXRlIiwiaXNvV2Vla2RheSIsInVuaXgiLCJ0b09iamVjdCIsInRvSlNPTiIsImlzVmFsaWQkMiIsInBhcnNpbmdGbGFncyIsImludmFsaWRBdCIsImNyZWF0aW9uRGF0YSIsIm1hdGNoRXJhQWJiciIsIm1hdGNoRXJhTmFtZSIsIm1hdGNoRXJhTmFycm93IiwiZXJhc1BhcnNlIiwibWF0Y2hFcmFZZWFyT3JkaW5hbCIsIl9lcmFZZWFyT3JkaW5hbFJlZ2V4IiwiZXJhWWVhck9yZGluYWxQYXJzZSIsImxvY2FsZUVyYXMiLCJlcmFzIiwiX2VyYXMiLCJzaW5jZSIsInVudGlsIiwiSW5maW5pdHkiLCJsb2NhbGVFcmFzUGFyc2UiLCJlcmFOYW1lIiwibmFycm93IiwibG9jYWxlRXJhc0NvbnZlcnRZZWFyIiwiZGlyIiwiZ2V0RXJhTmFtZSIsImdldEVyYU5hcnJvdyIsImdldEVyYUFiYnIiLCJnZXRFcmFZZWFyIiwiZXJhc05hbWVSZWdleCIsImNvbXB1dGVFcmFzUGFyc2UiLCJfZXJhc05hbWVSZWdleCIsIl9lcmFzUmVnZXgiLCJlcmFzQWJiclJlZ2V4IiwiX2VyYXNBYmJyUmVnZXgiLCJlcmFzTmFycm93UmVnZXgiLCJfZXJhc05hcnJvd1JlZ2V4IiwiYWJiclBpZWNlcyIsIm5hbWVQaWVjZXMiLCJuYXJyb3dQaWVjZXMiLCJpc29XZWVrWWVhciIsImFkZFdlZWtZZWFyRm9ybWF0VG9rZW4iLCJnZXR0ZXIiLCJnZXRTZXRXZWVrWWVhciIsImdldFNldFdlZWtZZWFySGVscGVyIiwiZ2V0U2V0SVNPV2Vla1llYXIiLCJnZXRJU09XZWVrc0luWWVhciIsImdldElTT1dlZWtzSW5JU09XZWVrWWVhciIsImdldFdlZWtzSW5ZZWFyIiwid2Vla0luZm8iLCJnZXRXZWVrc0luV2Vla1llYXIiLCJ3ZWVrc1RhcmdldCIsInNldFdlZWtBbGwiLCJkYXlPZlllYXJEYXRhIiwiZ2V0U2V0UXVhcnRlciIsImdldFNldERheU9mTW9udGgiLCJnZXRTZXREYXlPZlllYXIiLCJnZXRTZXRNaW51dGUiLCJnZXRTZXRTZWNvbmQiLCJnZXRTZXRNaWxsaXNlY29uZCIsInBhcnNlTXMiLCJnZXRab25lQWJiciIsImdldFpvbmVOYW1lIiwicHJvdG8iLCJTeW1ib2wiLCJlcmFOYXJyb3ciLCJlcmFBYmJyIiwiZXJhWWVhciIsImlzb1dlZWtzIiwid2Vla3NJbldlZWtZZWFyIiwiaXNvV2Vla3NJblllYXIiLCJpc29XZWVrc0luSVNPV2Vla1llYXIiLCJwYXJzZVpvbmUiLCJpc0RTVCIsInpvbmVBYmJyIiwiem9uZU5hbWUiLCJkYXRlcyIsImlzRFNUU2hpZnRlZCIsImNyZWF0ZVVuaXgiLCJjcmVhdGVJblpvbmUiLCJwcmVQYXJzZVBvc3RGb3JtYXQiLCJwcm90byQxIiwiZmlyc3REYXlPZlllYXIiLCJmaXJzdERheU9mV2VlayIsImdldCQxIiwiaW5kZXgiLCJmaWVsZCIsInNldHRlciIsImxpc3RNb250aHNJbXBsIiwib3V0IiwibGlzdFdlZWtkYXlzSW1wbCIsImxvY2FsZVNvcnRlZCIsInNoaWZ0IiwibGlzdE1vbnRocyIsImxpc3RNb250aHNTaG9ydCIsImxpc3RXZWVrZGF5cyIsImxpc3RXZWVrZGF5c1Nob3J0IiwibGlzdFdlZWtkYXlzTWluIiwibGFuZ0RhdGEiLCJtYXRoQWJzIiwiYWRkU3VidHJhY3QkMSIsImFkZCQxIiwic3VidHJhY3QkMSIsImFic0NlaWwiLCJidWJibGUiLCJtb250aHNGcm9tRGF5cyIsIm1vbnRoc1RvRGF5cyIsImRheXNUb01vbnRocyIsImFzIiwidmFsdWVPZiQxIiwibWFrZUFzIiwiYWxpYXMiLCJhc01pbGxpc2Vjb25kcyIsImFzU2Vjb25kcyIsImFzTWludXRlcyIsImFzSG91cnMiLCJhc0RheXMiLCJhc1dlZWtzIiwiYXNNb250aHMiLCJhc1F1YXJ0ZXJzIiwiYXNZZWFycyIsImNsb25lJDEiLCJnZXQkMiIsIm1ha2VHZXR0ZXIiLCJ0aHJlc2hvbGRzIiwic3Vic3RpdHV0ZVRpbWVBZ28iLCJyZWxhdGl2ZVRpbWUkMSIsInBvc05lZ0R1cmF0aW9uIiwiZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmciLCJyb3VuZGluZ0Z1bmN0aW9uIiwiZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkIiwidGhyZXNob2xkIiwibGltaXQiLCJhcmdXaXRoU3VmZml4IiwiYXJnVGhyZXNob2xkcyIsIndpdGhTdWZmaXgiLCJ0aCIsImFzc2lnbiIsImFicyQxIiwidG9JU09TdHJpbmckMSIsInRvdGFsIiwidG90YWxTaWduIiwieW1TaWduIiwiZGF5c1NpZ24iLCJobXNTaWduIiwidG9GaXhlZCIsInByb3RvJDIiLCJ0b0lzb1N0cmluZyIsInZlcnNpb24iLCJyZWxhdGl2ZVRpbWVSb3VuZGluZyIsInJlbGF0aXZlVGltZVRocmVzaG9sZCIsIkhUTUw1X0ZNVCIsIkRBVEVUSU1FX0xPQ0FMIiwiREFURVRJTUVfTE9DQUxfU0VDT05EUyIsIkRBVEVUSU1FX0xPQ0FMX01TIiwiVElNRSIsIlRJTUVfU0VDT05EUyIsIlRJTUVfTVMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFBRSxXQUFVQSxNQUFWLEVBQWtCQyxPQUFsQixFQUEyQjtFQUN6QixRQUErREMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCRixPQUFPLEVBQXZGLEdBQ0EsU0FEQTtBQUdILENBSkMsRUFJQSxJQUpBLEVBSU8sWUFBWTtFQUFFOztFQUVuQixJQUFJRyxZQUFKOztFQUVBLFNBQVNDLEtBQVQsR0FBaUI7SUFDYixPQUFPRCxZQUFZLENBQUNFLEtBQWIsQ0FBbUIsSUFBbkIsRUFBeUJDLFNBQXpCLENBQVA7RUFDSCxDQU5nQixDQVFqQjtFQUNBOzs7RUFDQSxTQUFTQyxlQUFULENBQXlCQyxRQUF6QixFQUFtQztJQUMvQkwsWUFBWSxHQUFHSyxRQUFmO0VBQ0g7O0VBRUQsU0FBU0MsT0FBVCxDQUFpQkMsS0FBakIsRUFBd0I7SUFDcEIsT0FDSUEsS0FBSyxZQUFZQyxLQUFqQixJQUNBQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLFFBQWpCLENBQTBCQyxJQUExQixDQUErQkwsS0FBL0IsTUFBMEMsZ0JBRjlDO0VBSUg7O0VBRUQsU0FBU00sUUFBVCxDQUFrQk4sS0FBbEIsRUFBeUI7SUFDckI7SUFDQTtJQUNBLE9BQ0lBLEtBQUssSUFBSSxJQUFULElBQ0FFLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCTCxLQUEvQixNQUEwQyxpQkFGOUM7RUFJSDs7RUFFRCxTQUFTTyxVQUFULENBQW9CQyxDQUFwQixFQUF1QkMsQ0FBdkIsRUFBMEI7SUFDdEIsT0FBT1AsTUFBTSxDQUFDQyxT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Q0FBQ3dzQixjQUFOLEdBQXVCUCxpQkFBdkI7RUFDQWpzQixLQUFLLENBQUNTLFNBQU4sR0FBa0I2eUIsS0FBbEIsQ0F6aExpQixDQTJoTGpCOztFQUNBdHpCLEtBQUssQ0FBQzg0QixTQUFOLEdBQWtCO0lBQ2RDLGNBQWMsRUFBRSxrQkFERjtJQUNzQjtJQUNwQ0Msc0JBQXNCLEVBQUUscUJBRlY7SUFFaUM7SUFDL0NDLGlCQUFpQixFQUFFLHlCQUhMO0lBR2dDO0lBQzlDem1CLElBQUksRUFBRSxZQUpRO0lBSU07SUFDcEIwbUIsSUFBSSxFQUFFLE9BTFE7SUFLQztJQUNmQyxZQUFZLEVBQUUsVUFOQTtJQU1ZO0lBQzFCQyxPQUFPLEVBQUUsY0FQSztJQU9XO0lBQ3pCdm1CLElBQUksRUFBRSxZQVJRO0lBUU07SUFDcEJOLEtBQUssRUFBRSxTQVRPLENBU0k7O0VBVEosQ0FBbEI7RUFZQSxPQUFPdlMsS0FBUDtBQUVILENBOWlMQyxDQUFELEMiLCJmaWxlIjoid2QvUi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4yOS4zXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0ICE9IG51bGwgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgYXJyTGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyckxlbjsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0OiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93OiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXI6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQ6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZEVyYTogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRNb250aDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQ6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbzogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHM6IFtdLFxuICAgICAgICAgICAgZXJhOiBudWxsLFxuICAgICAgICAgICAgbWVyaWRpZW06IG51bGwsXG4gICAgICAgICAgICByZmMyODIyOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSksXG4gICAgICAgICAgICAgICAgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRFcmEgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSAoaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdKSxcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBtb21lbnRQcm9wZXJ0aWVzTGVuID0gbW9tZW50UHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzTGVuID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXNMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQob2JqKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXJnTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoYXJndW1lbnRzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgbXNnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG5Bcmd1bWVudHM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHR5cGVvZiBGdW5jdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjb25maWcsIGkpKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArXG4gICAgICAgICAgICAgICAgL1xcZHsxLDJ9Ly5zb3VyY2VcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLFxuICAgICAgICAgICAgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXk6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheTogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXk6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArXG4gICAgICAgICAgICBhYnNOdW1iZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9XG4gICAgICAgICAgICAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fE57MSw1fXxZWVlZWVl8WVlZWVl8WVlZWXxZWXx5ezIsNH18eW8/fGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nLFxuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbih0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSlcbiAgICAgICAgICAgICAgICAgICAgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vuc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFM6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVDogJ2g6bW0gQScsXG4gICAgICAgIEw6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEw6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEw6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlclxuICAgICAgICAgICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2spIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdERCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnZGRkZCdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnLFxuICAgICAgICBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZTogJ2luICVzJyxcbiAgICAgICAgcGFzdDogJyVzIGFnbycsXG4gICAgICAgIHM6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgc3M6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbTogJ2EgbWludXRlJyxcbiAgICAgICAgbW06ICclZCBtaW51dGVzJyxcbiAgICAgICAgaDogJ2FuIGhvdXInLFxuICAgICAgICBoaDogJyVkIGhvdXJzJyxcbiAgICAgICAgZDogJ2EgZGF5JyxcbiAgICAgICAgZGQ6ICclZCBkYXlzJyxcbiAgICAgICAgdzogJ2Egd2VlaycsXG4gICAgICAgIHd3OiAnJWQgd2Vla3MnLFxuICAgICAgICBNOiAnYSBtb250aCcsXG4gICAgICAgIE1NOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeTogJ2EgeWVhcicsXG4gICAgICAgIHl5OiAnJWQgeWVhcnMnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KVxuICAgICAgICAgICAgPyBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKVxuICAgICAgICAgICAgOiBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW10sXG4gICAgICAgICAgICB1O1xuICAgICAgICBmb3IgKHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHVuaXRzT2JqLCB1KSkge1xuICAgICAgICAgICAgICAgIHVuaXRzLnB1c2goeyB1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0KHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0KG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKVxuICAgICAgICAgICAgPyBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKVxuICAgICAgICAgICAgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJlxuICAgICAgICAgICAgICAgIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiZcbiAgICAgICAgICAgICAgICBtb20ubW9udGgoKSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIG1vbS5kYXRlKCkgPT09IDI5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBtb20ubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0KHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHByaW9yaXRpemVkTGVuID0gcHJpb3JpdGl6ZWQubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByaW9yaXRpemVkTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxID0gL1xcZC8sIC8vICAgICAgIDAgLSA5XG4gICAgICAgIG1hdGNoMiA9IC9cXGRcXGQvLCAvLyAgICAgIDAwIC0gOTlcbiAgICAgICAgbWF0Y2gzID0gL1xcZHszfS8sIC8vICAgICAwMDAgLSA5OTlcbiAgICAgICAgbWF0Y2g0ID0gL1xcZHs0fS8sIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgICAgIG1hdGNoNiA9IC9bKy1dP1xcZHs2fS8sIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2gxdG8yID0gL1xcZFxcZD8vLCAvLyAgICAgICAwIC0gOTlcbiAgICAgICAgbWF0Y2gzdG80ID0gL1xcZFxcZFxcZFxcZD8vLCAvLyAgICAgOTk5IC0gOTk5OVxuICAgICAgICBtYXRjaDV0bzYgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy8sIC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2gxdG8zID0gL1xcZHsxLDN9LywgLy8gICAgICAgMCAtIDk5OVxuICAgICAgICBtYXRjaDF0bzQgPSAvXFxkezEsNH0vLCAvLyAgICAgICAwIC0gOTk5OVxuICAgICAgICBtYXRjaDF0bzYgPSAvWystXT9cXGR7MSw2fS8sIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2hVbnNpZ25lZCA9IC9cXGQrLywgLy8gICAgICAgMCAtIGluZlxuICAgICAgICBtYXRjaFNpZ25lZCA9IC9bKy1dP1xcZCsvLCAvLyAgICAtaW5mIC0gaW5mXG4gICAgICAgIG1hdGNoT2Zmc2V0ID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpLCAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpLCAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgICBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy8sIC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG4gICAgICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgICAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgICAgIG1hdGNoV29yZCA9XG4gICAgICAgICAgICAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaSxcbiAgICAgICAgcmVnZXhlcztcblxuICAgIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4odG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpXG4gICAgICAgICAgICA/IHJlZ2V4XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4ID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKFxuICAgICAgICAgICAgc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdcXFxcJywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBmdW5jID0gY2FsbGJhY2ssXG4gICAgICAgICAgICB0b2tlbkxlbjtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5MZW4gPSB0b2tlbi5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbkxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMCxcbiAgICAgICAgTU9OVEggPSAxLFxuICAgICAgICBEQVRFID0gMixcbiAgICAgICAgSE9VUiA9IDMsXG4gICAgICAgIE1JTlVURSA9IDQsXG4gICAgICAgIFNFQ09ORCA9IDUsXG4gICAgICAgIE1JTExJU0VDT05EID0gNixcbiAgICAgICAgV0VFSyA9IDcsXG4gICAgICAgIFdFRUtEQVkgPSA4O1xuXG4gICAgZnVuY3Rpb24gbW9kKG4sIHgpIHtcbiAgICAgICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xuICAgIH1cblxuICAgIHZhciBpbmRleE9mO1xuXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIC8vIEkga25vd1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgICAgICB5ZWFyICs9IChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuICAgICAgICByZXR1cm4gbW9kTW9udGggPT09IDFcbiAgICAgICAgICAgID8gaXNMZWFwWWVhcih5ZWFyKVxuICAgICAgICAgICAgICAgID8gMjlcbiAgICAgICAgICAgICAgICA6IDI4XG4gICAgICAgICAgICA6IDMxIC0gKChtb2RNb250aCAlIDcpICUgMik7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzID1cbiAgICAgICAgICAgICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdChcbiAgICAgICAgICAgICAgICAnXydcbiAgICAgICAgICAgICksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9XG4gICAgICAgICAgICAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy8sXG4gICAgICAgIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpXG4gICAgICAgICAgICA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1tcbiAgICAgICAgICAgICAgICAgICh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgICAgPyAnZm9ybWF0J1xuICAgICAgICAgICAgICAgICAgICAgIDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgICAgIF1bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0W1xuICAgICAgICAgICAgICAgICAgTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQoXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID1cbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnTU1NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnTU1NJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGgodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gemVyb0ZpbGwoeSwgNCkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsIDRdLCAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCA1XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPVxuICAgICAgICAgICAgaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlKHkpIHtcbiAgICAgICAgdmFyIGRhdGUsIGFyZ3M7XG4gICAgICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBhcmdzWzBdID0geSArIDQwMDtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsXG4gICAgICAgICAgICByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLFxuICAgICAgICAgICAgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihcbiAgICAgICAgWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vlayhtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3k6IDYsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayhpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOYU4oaW5wdXQpID8gbnVsbCA6IGlucHV0O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcbiAgICBmdW5jdGlvbiBzaGlmdFdlZWtkYXlzKHdzLCBuKSB7XG4gICAgICAgIHJldHVybiB3cy5zbGljZShuLCA3KS5jb25jYXQod3Muc2xpY2UoMCwgbikpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPVxuICAgICAgICAgICAgJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpXG4gICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzW1xuICAgICAgICAgICAgICAgICAgbSAmJiBtICE9PSB0cnVlICYmIHRoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdO1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHdlZWtkYXlzLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB3ZWVrZGF5c1ttLmRheSgpXVxuICAgICAgICAgICAgOiB3ZWVrZGF5cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0KG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4obSkge1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihcbiAgICAgICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQoXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2Uod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID1cbiAgICAgICAgICAgICAgICAgICAgJ14nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArXG4gICAgICAgICAgICAgICAgICAgICd8XicgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZGRkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIG1pbnAsXG4gICAgICAgICAgICBzaG9ydHAsXG4gICAgICAgICAgICBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c01pbihtb20sICcnKSk7XG4gICAgICAgICAgICBzaG9ydHAgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ3AgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgaEZvcm1hdC5hcHBseSh0aGlzKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpXG4gICAgICAgICk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnJyArXG4gICAgICAgICAgICB0aGlzLmhvdXJzKCkgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0odG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKFxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMoKSxcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgICAgICBsb3dlcmNhc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2trJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaycsICdrayddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0LFxuICAgICAgICAgICAgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUlzUE0oaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuIChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pLFxuICAgICAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAgICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgICAgIC8vIHRoaXMgcnVsZS5cbiAgICAgICAgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbShob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlLFxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fSxcbiAgICAgICAgbG9jYWxlRmFtaWxpZXMgPSB7fSxcbiAgICAgICAgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gY29tbW9uUHJlZml4KGFycjEsIGFycjIpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBtaW5sID0gTWF0aC5taW4oYXJyMS5sZW5ndGgsIGFycjIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1pbmw7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlubDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBuZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHQubGVuZ3RoID49IGogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uUHJlZml4KHNwbGl0LCBuZXh0KSA+PSBqIC0gMVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsZU5hbWVTYW5lKG5hbWUpIHtcbiAgICAgICAgLy8gUHJldmVudCBuYW1lcyB0aGF0IGxvb2sgbGlrZSBmaWxlc3lzdGVtIHBhdGhzLCBpLmUgY29udGFpbiAnLycgb3IgJ1xcJ1xuICAgICAgICByZXR1cm4gbmFtZS5tYXRjaCgnXlteL1xcXFxcXFxcXSokJykgIT0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGwsXG4gICAgICAgICAgICBhbGlhc2VkUmVxdWlyZTtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgbW9kdWxlICYmXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyAmJlxuICAgICAgICAgICAgaXNMb2NhbGVOYW1lU2FuZShuYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlID0gcmVxdWlyZTtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgbm90IGZvdW5kIHRvIGF2b2lkIHJlcGVhdGluZyBleHBlbnNpdmUgZmlsZSByZXF1aXJlIGNhbGwgY2F1c2luZyBoaWdoIENQVVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGZpbmQgZW4tVVMsIGVuX1VTLCBlbi11cyBmb3IgZXZlcnkgZm9ybWF0IGNhbGxcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbnVsbDsgLy8gbnVsbCBtZWFucyBub3QgZm91bmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gZ2V0U2V0R2xvYmFsTG9jYWxlKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy93YXJuIHVzZXIgaWYgYXJndW1lbnRzIGFyZSBwYXNzZWQgYnV0IHRoZSBsb2NhbGUgY291bGQgbm90IGJlIHNldFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAnTG9jYWxlICcgKyBrZXkgKyAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoXG4gICAgICAgICAgICAgICAgICAgICdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoY29uZmlnLnBhcmVudExvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHRtcExvY2FsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsICYmIGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgY2hpbGQgbG9jYWxlIGluLXBsYWNlIHRvIGF2b2lkIG1lbW9yeS1sZWFrc1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0uc2V0KG1lcmdlQ29uZmlncyhsb2NhbGVzW25hbWVdLl9jb25maWcsIGNvbmZpZykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVMb2NhbGUgaXMgY2FsbGVkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFiYnIgc28gaXQgd2lsbCBoYXZlIGEgbmFtZSAoZ2V0dGVycyByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIG90aGVyd2lzZSkuXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBnZXRTZXRHbG9iYWxMb2NhbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICBmdW5jdGlvbiBnZXRMb2NhbGUoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93KG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93LFxuICAgICAgICAgICAgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdIDwgMCB8fCBhW01PTlRIXSA+IDExXG4gICAgICAgICAgICAgICAgICAgID8gTU9OVEhcbiAgICAgICAgICAgICAgICAgICAgOiBhW0RBVEVdIDwgMSB8fCBhW0RBVEVdID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pXG4gICAgICAgICAgICAgICAgICAgID8gREFURVxuICAgICAgICAgICAgICAgICAgICA6IGFbSE9VUl0gPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgYVtIT1VSXSA+IDI0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgKGFbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChhW01JTlVURV0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbU0VDT05EXSAhPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gIT09IDApKVxuICAgICAgICAgICAgICAgICAgICA/IEhPVVJcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTlVURV0gPCAwIHx8IGFbTUlOVVRFXSA+IDU5XG4gICAgICAgICAgICAgICAgICAgID8gTUlOVVRFXG4gICAgICAgICAgICAgICAgICAgIDogYVtTRUNPTkRdIDwgMCB8fCBhW1NFQ09ORF0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IFNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTExJU0VDT05EXG4gICAgICAgICAgICAgICAgICAgIDogLTE7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmXG4gICAgICAgICAgICAgICAgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9XG4gICAgICAgICAgICAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgYmFzaWNJc29SZWdleCA9XG4gICAgICAgICAgICAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkfCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvLFxuICAgICAgICB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vLFxuICAgICAgICBpc29EYXRlcyA9IFtcbiAgICAgICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXSxcbiAgICAgICAgICAgIFsnWVlZWU1NJywgL1xcZHs2fS8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWScsIC9cXGR7NH0vLCBmYWxzZV0sXG4gICAgICAgIF0sXG4gICAgICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICAgICAgaXNvVGltZXMgPSBbXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgICAgWydISCcsIC9cXGRcXGQvXSxcbiAgICAgICAgXSxcbiAgICAgICAgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKCgtP1xcZCspL2ksXG4gICAgICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICAgICAgcmZjMjgyMiA9XG4gICAgICAgICAgICAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvLFxuICAgICAgICBvYnNPZmZzZXRzID0ge1xuICAgICAgICAgICAgVVQ6IDAsXG4gICAgICAgICAgICBHTVQ6IDAsXG4gICAgICAgICAgICBFRFQ6IC00ICogNjAsXG4gICAgICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgICAgICBDU1Q6IC02ICogNjAsXG4gICAgICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgICAgICBQRFQ6IC03ICogNjAsXG4gICAgICAgICAgICBQU1Q6IC04ICogNjAsXG4gICAgICAgIH07XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsXG4gICAgICAgICAgICBkYXRlRm9ybWF0LFxuICAgICAgICAgICAgdGltZUZvcm1hdCxcbiAgICAgICAgICAgIHR6Rm9ybWF0LFxuICAgICAgICAgICAgaXNvRGF0ZXNMZW4gPSBpc29EYXRlcy5sZW5ndGgsXG4gICAgICAgICAgICBpc29UaW1lc0xlbiA9IGlzb1RpbWVzLmxlbmd0aDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXNMZW47IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXNMZW47IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKFxuICAgICAgICB5ZWFyU3RyLFxuICAgICAgICBtb250aFN0cixcbiAgICAgICAgZGF5U3RyLFxuICAgICAgICBob3VyU3RyLFxuICAgICAgICBtaW51dGVTdHIsXG4gICAgICAgIHNlY29uZFN0clxuICAgICkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChzZWNvbmRTdHIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhclN0cikge1xuICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcbiAgICAgICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgICAgIHJldHVybiAyMDAwICsgeWVhcjtcbiAgICAgICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ZWFyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcc1xccyspL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbmRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzBdLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFsxXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMl1cbiAgICAgICAgICAgICAgICApLmdldERheSgpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApLFxuICAgICAgICAgICAgICAgIG0gPSBobSAlIDEwMCxcbiAgICAgICAgICAgICAgICBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpLFxuICAgICAgICAgICAgcGFyc2VkQXJyYXk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKFxuICAgICAgICAgICAgICAgIG1hdGNoWzRdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzNdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzVdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzZdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzddXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSAxKSBBU1AuTkVULCAyKSBJU08sIDMpIFJGQyAyODIyIGZvcm1hdHMsIG9yIDQpIG9wdGlvbmFsIGZhbGxiYWNrIGlmIHBhcnNpbmcgaXNuJ3Qgc3RyaWN0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fc3RyaWN0KSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICAgICAnZGlzY291cmFnZWQuIFBsZWFzZSByZWZlciB0byBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGlucHV0ID0gW10sXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGV4cGVjdGVkV2Vla2RheSxcbiAgICAgICAgICAgIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSB8fFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9XG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW2ldID09IG51bGwgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0ZWRXZWVrZGF5ID0gY29uZmlnLl91c2VVVENcbiAgICAgICAgICAgID8gY29uZmlnLl9kLmdldFVUQ0RheSgpXG4gICAgICAgICAgICA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29uZmlnLl93ICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5XG4gICAgICAgICkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93LCBjdXJXZWVrO1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMoXG4gICAgICAgICAgICAgICAgdy5HRyxcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbWUVBUl0sXG4gICAgICAgICAgICAgICAgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbiAgICBob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDAsXG4gICAgICAgICAgICBlcmEsXG4gICAgICAgICAgICB0b2tlbkxlbjtcblxuICAgICAgICB0b2tlbnMgPVxuICAgICAgICAgICAgZXhwYW5kRm9ybWF0KGNvbmZpZy5fZiwgY29uZmlnLl9sb2NhbGUpLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpIHx8IFtdO1xuICAgICAgICB0b2tlbkxlbiA9IHRva2Vucy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbkxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8XG4gICAgICAgICAgICAgICAgW10pWzBdO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID1cbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKFxuICAgICAgICAgICAgY29uZmlnLl9sb2NhbGUsXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0sXG4gICAgICAgICAgICBjb25maWcuX21lcmlkaWVtXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGVyYVxuICAgICAgICBlcmEgPSBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmE7XG4gICAgICAgIGlmIChlcmEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IGNvbmZpZy5fbG9jYWxlLmVyYXNDb252ZXJ0WWVhcihlcmEsIGNvbmZpZy5fYVtZRUFSXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlLFxuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCxcbiAgICAgICAgICAgIGJlc3RGb3JtYXRJc1ZhbGlkID0gZmFsc2UsXG4gICAgICAgICAgICBjb25maWdmTGVuID0gY29uZmlnLl9mLmxlbmd0aDtcblxuICAgICAgICBpZiAoY29uZmlnZkxlbiA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZ2ZMZW47IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoaXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS51bnVzZWRUb2tlbnMubGVuZ3RoICogMTA7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKCFiZXN0Rm9ybWF0SXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCB8fFxuICAgICAgICAgICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbGlkRm9ybWF0Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RGb3JtYXRJc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKSxcbiAgICAgICAgICAgIGRheU9yRGF0ZSA9IGkuZGF5ID09PSB1bmRlZmluZWQgPyBpLmRhdGUgOiBpLmRheTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFxuICAgICAgICAgICAgW2kueWVhciwgaS5tb250aCwgZGF5T3JEYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sXG4gICAgICAgICAgICBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgICAgICBpZiAocmVzLl9uZXh0RGF5KSB7XG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgICAgIHJlcy5fbmV4dERheSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgZ2V0TG9jYWxlKGNvbmZpZy5fbCk7XG5cbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCh7IG51bGxJbnB1dDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlucHV0KGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgaXNVVEMpIHtcbiAgICAgICAgdmFyIGMgPSB7fTtcblxuICAgICAgICBpZiAoZm9ybWF0ID09PSB0cnVlIHx8IGZvcm1hdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApXG4gICAgICAgICkge1xuICAgICAgICAgICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDIzXG4gICAgICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgICAgIGMuX2wgPSBsb2NhbGU7XG4gICAgICAgIGMuX2kgPSBpbnB1dDtcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcbiAgICAgICAgYy5fc3RyaWN0ID0gc3RyaWN0O1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAgICAgICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAvLyBQaWNrIGEgbW9tZW50IG0gZnJvbSBtb21lbnRzIHNvIHRoYXQgbVtmbl0ob3RoZXIpIGlzIHRydWUgZm9yIGFsbFxuICAgIC8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbiAgICAvL1xuICAgIC8vIG1vbWVudHMgc2hvdWxkIGVpdGhlciBiZSBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cyBvciBhbiBhcnJheSwgd2hvc2VcbiAgICAvLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgICAgICB2YXIgcmVzLCBpO1xuICAgICAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbW9tZW50c1swXTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xuICAgICAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgW10uc29ydCBpbnN0ZWFkP1xuICAgIGZ1bmN0aW9uIG1pbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXgoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICB2YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogK25ldyBEYXRlKCk7XG4gICAgfTtcblxuICAgIHZhciBvcmRlcmluZyA9IFtcbiAgICAgICAgJ3llYXInLFxuICAgICAgICAncXVhcnRlcicsXG4gICAgICAgICdtb250aCcsXG4gICAgICAgICd3ZWVrJyxcbiAgICAgICAgJ2RheScsXG4gICAgICAgICdob3VyJyxcbiAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICdzZWNvbmQnLFxuICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgIF07XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBvcmRlckxlbiA9IG9yZGVyaW5nLmxlbmd0aDtcbiAgICAgICAgZm9yIChrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AobSwga2V5KSAmJlxuICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmRlckxlbjsgKytpKSB7XG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgbm9ybWFsaXplZElucHV0Lmlzb1dlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBpc0R1cmF0aW9uVmFsaWQobm9ybWFsaXplZElucHV0KTtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPVxuICAgICAgICAgICAgK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0byB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArIHF1YXJ0ZXJzICogMyArIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBvZmZzZXQodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzaWduICtcbiAgICAgICAgICAgICAgICB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IgK1xuICAgICAgICAgICAgICAgIHplcm9GaWxsKH5+b2Zmc2V0ICUgNjAsIDIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlciksXG4gICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgICAgbWludXRlcztcblxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjaHVuayA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgcGFydHMgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/IDAgOiBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9XG4gICAgICAgICAgICAgICAgKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQudmFsdWVPZigpXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICBob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyhrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fSxcbiAgICAgICAgICAgIG90aGVyO1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPVxuICAgICAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKyk6KFxcZCspKD86OihcXGQrKShcXC5cXGQqKT8pPyQvLFxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgICAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICAgICAgaXNvUmVnZXggPVxuICAgICAgICAgICAgL14oLXxcXCspP1AoPzooWy0rXT9bMC05LC5dKilZKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilXKT8oPzooWy0rXT9bMC05LC5dKilEKT8oPzpUKD86KFstK10/WzAtOSwuXSopSCk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtczogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNOiBpbnB1dC5fbW9udGhzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkgfHwgIWlzTmFOKCtpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9ICtpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gK2lucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIGQ6IHRvSW50KG1hdGNoW0RBVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaDogdG9JbnQobWF0Y2hbSE9VUl0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtOiB0b0ludChtYXRjaFtNSU5VVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgczogdG9JbnQobWF0Y2hbU0VDT05EXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduLCAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdzogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQ6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbTogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHM6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2lzVmFsaWQnKSkge1xuICAgICAgICAgICAgcmV0Ll9pc1ZhbGlkID0gaW5wdXQuX2lzVmFsaWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuICAgIGNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyhpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPVxuICAgICAgICAgICAgb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICtiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgJ21vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDtcbiAgICAgICAgICAgICAgICB2YWwgPSBwZXJpb2Q7XG4gICAgICAgICAgICAgICAgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpLFxuICAgICAgICBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nO1xuICAgIH1cblxuICAgIC8vIHR5cGUgTW9tZW50SW5wdXQgPSBNb21lbnQgfCBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyIHwgKG51bWJlciB8IHN0cmluZylbXSB8IE1vbWVudElucHV0T2JqZWN0IHwgdm9pZDsgLy8gbnVsbCB8IHVuZGVmaW5lZFxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzTW9tZW50KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNEYXRlKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNTdHJpbmcoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc051bWJlcihpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyT3JTdHJpbmdBcnJheShpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgaW5wdXQgPT09IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICd5ZWFycycsXG4gICAgICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgICAgICdNJyxcbiAgICAgICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAgICAgJ2RheScsXG4gICAgICAgICAgICAgICAgJ2QnLFxuICAgICAgICAgICAgICAgICdkYXRlcycsXG4gICAgICAgICAgICAgICAgJ2RhdGUnLFxuICAgICAgICAgICAgICAgICdEJyxcbiAgICAgICAgICAgICAgICAnaG91cnMnLFxuICAgICAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICAgICAnaCcsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAgICAgICAgICdtaW51dGUnLFxuICAgICAgICAgICAgICAgICdtJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgICAgICdtaWxsaXNlY29uZHMnLFxuICAgICAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAgICAgJ21zJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICBwcm9wZXJ0eUxlbiA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0eUxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBwcm9wZXJ0eVRlc3QgfHwgaGFzT3duUHJvcChpbnB1dCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdFRlc3QgJiYgcHJvcGVydHlUZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyT3JTdHJpbmdBcnJheShpbnB1dCkge1xuICAgICAgICB2YXIgYXJyYXlUZXN0ID0gaXNBcnJheShpbnB1dCksXG4gICAgICAgICAgICBkYXRhVHlwZVRlc3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFycmF5VGVzdCkge1xuICAgICAgICAgICAgZGF0YVR5cGVUZXN0ID1cbiAgICAgICAgICAgICAgICBpbnB1dC5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFpc051bWJlcihpdGVtKSAmJiBpc1N0cmluZyhpbnB1dCk7XG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheVRlc3QgJiYgZGF0YVR5cGVUZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQ2FsZW5kYXJTcGVjKGlucHV0KSB7XG4gICAgICAgIHZhciBvYmplY3RUZXN0ID0gaXNPYmplY3QoaW5wdXQpICYmICFpc09iamVjdEVtcHR5KGlucHV0KSxcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IGZhbHNlLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICAgICAnc2FtZURheScsXG4gICAgICAgICAgICAgICAgJ25leHREYXknLFxuICAgICAgICAgICAgICAgICdsYXN0RGF5JyxcbiAgICAgICAgICAgICAgICAnbmV4dFdlZWsnLFxuICAgICAgICAgICAgICAgICdsYXN0V2VlaycsXG4gICAgICAgICAgICAgICAgJ3NhbWVFbHNlJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcHJvcGVydHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02XG4gICAgICAgICAgICA/ICdzYW1lRWxzZSdcbiAgICAgICAgICAgIDogZGlmZiA8IC0xXG4gICAgICAgICAgICA/ICdsYXN0V2VlaydcbiAgICAgICAgICAgIDogZGlmZiA8IDBcbiAgICAgICAgICAgID8gJ2xhc3REYXknXG4gICAgICAgICAgICA6IGRpZmYgPCAxXG4gICAgICAgICAgICA/ICdzYW1lRGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgMlxuICAgICAgICAgICAgPyAnbmV4dERheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDdcbiAgICAgICAgICAgID8gJ25leHRXZWVrJ1xuICAgICAgICAgICAgOiAnc2FtZUVsc2UnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyJDEodGltZSwgZm9ybWF0cykge1xuICAgICAgICAvLyBTdXBwb3J0IGZvciBzaW5nbGUgcGFyYW1ldGVyLCBmb3JtYXRzIG9ubHkgb3ZlcmxvYWQgdG8gdGhlIGNhbGVuZGFyIGZ1bmN0aW9uXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb21lbnRJbnB1dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0NhbGVuZGFyU3BlYyhhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0cyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICB0aW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZScsXG4gICAgICAgICAgICBvdXRwdXQgPVxuICAgICAgICAgICAgICAgIGZvcm1hdHMgJiZcbiAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pXG4gICAgICAgICAgICAgICAgICAgID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KVxuICAgICAgICAgICAgICAgICAgICA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KFxuICAgICAgICAgICAgb3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBZnRlcihpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZXR3ZWVuKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICAgICAgdmFyIGxvY2FsRnJvbSA9IGlzTW9tZW50KGZyb20pID8gZnJvbSA6IGNyZWF0ZUxvY2FsKGZyb20pLFxuICAgICAgICAgICAgbG9jYWxUbyA9IGlzTW9tZW50KHRvKSA/IHRvIDogY3JlYXRlTG9jYWwodG8pO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbEZyb20uaXNWYWxpZCgpICYmIGxvY2FsVG8uaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGluY2x1c2l2aXR5ID0gaW5jbHVzaXZpdHkgfHwgJygpJztcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVswXSA9PT0gJygnXG4gICAgICAgICAgICAgICAgPyB0aGlzLmlzQWZ0ZXIobG9jYWxGcm9tLCB1bml0cylcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQmVmb3JlKGxvY2FsRnJvbSwgdW5pdHMpKSAmJlxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKSdcbiAgICAgICAgICAgICAgICA/IHRoaXMuaXNCZWZvcmUobG9jYWxUbywgdW5pdHMpXG4gICAgICAgICAgICAgICAgOiAhdGhpcy5pc0FmdGVyKGxvY2FsVG8sIHVuaXRzKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgICAgICBpbnB1dE1zO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCkgPD0gaW5wdXRNcyAmJlxuICAgICAgICAgICAgICAgIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckFmdGVyKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckJlZm9yZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpZmYoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgICAgIHZhciB0aGF0LCB6b25lRGVsdGEsIG91dHB1dDtcblxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCF0aGF0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvbmVEZWx0YSA9ICh0aGF0LnV0Y09mZnNldCgpIC0gdGhpcy51dGNPZmZzZXQoKSkgKiA2ZTQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDFlMztcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMFxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gNmU0O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMgLSB0aGF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZihhLCBiKSB7XG4gICAgICAgIGlmIChhLmRhdGUoKSA8IGIuZGF0ZSgpKSB7XG4gICAgICAgICAgICAvLyBlbmQtb2YtbW9udGggY2FsY3VsYXRpb25zIHdvcmsgY29ycmVjdCB3aGVuIHRoZSBzdGFydCBtb250aCBoYXMgbW9yZVxuICAgICAgICAgICAgLy8gZGF5cyB0aGFuIHRoZSBlbmQgbW9udGguXG4gICAgICAgICAgICByZXR1cm4gLW1vbnRoRGlmZihiLCBhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMiArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsXG4gICAgICAgICAgICBhZGp1c3Q7XG5cbiAgICAgICAgaWYgKGIgLSBhbmNob3IgPCAwKSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yIC0gYW5jaG9yMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NoZWNrIGZvciBuZWdhdGl2ZSB6ZXJvLCByZXR1cm4gemVybyBpZiBuZWdhdGl2ZSB6ZXJvXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xuICAgIH1cblxuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXQgPSAnWVlZWS1NTS1ERFRISDptbTpzc1onO1xuICAgIGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nKGtlZXBPZmZzZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHV0YyA9IGtlZXBPZmZzZXQgIT09IHRydWUsXG4gICAgICAgICAgICBtID0gdXRjID8gdGhpcy5jbG9uZSgpLnV0YygpIDogdGhpcztcbiAgICAgICAgaWYgKG0ueWVhcigpIDwgMCB8fCBtLnllYXIoKSA+IDk5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQoXG4gICAgICAgICAgICAgICAgbSxcbiAgICAgICAgICAgICAgICB1dGNcbiAgICAgICAgICAgICAgICAgICAgPyAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJ1xuICAgICAgICAgICAgICAgICAgICA6ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgICAgICBpZiAodXRjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpICsgdGhpcy51dGNPZmZzZXQoKSAqIDYwICogMTAwMClcbiAgICAgICAgICAgICAgICAgICAgLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1onLCBmb3JtYXRNb21lbnQobSwgJ1onKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICB1dGMgPyAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScgOiAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgaHVtYW4gcmVhZGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBtb21lbnQgdGhhdCBjYW5cbiAgICAgKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gICAgICpcbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvdXRpbC5odG1sI3V0aWxfY3VzdG9tX2luc3BlY3RfZnVuY3Rpb25fb25fb2JqZWN0c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbW9tZW50LmludmFsaWQoLyogJyArIHRoaXMuX2kgKyAnICovKSc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmMgPSAnbW9tZW50JyxcbiAgICAgICAgICAgIHpvbmUgPSAnJyxcbiAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgIHllYXIsXG4gICAgICAgICAgICBkYXRldGltZSxcbiAgICAgICAgICAgIHN1ZmZpeDtcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgICAgICB6b25lID0gJ1onO1xuICAgICAgICB9XG4gICAgICAgIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgICAgIHllYXIgPSAwIDw9IHRoaXMueWVhcigpICYmIHRoaXMueWVhcigpIDw9IDk5OTkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICAgICAgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICAgICAgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHByZWZpeCArIHllYXIgKyBkYXRldGltZSArIHN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0KGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpXG4gICAgICAgICAgICAgICAgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjXG4gICAgICAgICAgICAgICAgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcpO1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb20odGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHwgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IHRvOiB0aGlzLCBmcm9tOiB0aW1lIH0pXG4gICAgICAgICAgICAgICAgLmxvY2FsZSh0aGlzLmxvY2FsZSgpKVxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Ob3cod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8IGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBmcm9tOiB0aGlzLCB0bzogdGltZSB9KVxuICAgICAgICAgICAgICAgIC5sb2NhbGUodGhpcy5sb2NhbGUoKSlcbiAgICAgICAgICAgICAgICAuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbiAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4gICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxuICAgIGZ1bmN0aW9uIGxvY2FsZShrZXkpIHtcbiAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIE1TX1BFUl9TRUNPTkQgPSAxMDAwLFxuICAgICAgICBNU19QRVJfTUlOVVRFID0gNjAgKiBNU19QRVJfU0VDT05ELFxuICAgICAgICBNU19QRVJfSE9VUiA9IDYwICogTVNfUEVSX01JTlVURSxcbiAgICAgICAgTVNfUEVSXzQwMF9ZRUFSUyA9ICgzNjUgKiA0MDAgKyA5NykgKiAyNCAqIE1TX1BFUl9IT1VSO1xuXG4gICAgLy8gYWN0dWFsIG1vZHVsbyAtIGhhbmRsZXMgbmVnYXRpdmUgbnVtYmVycyAoZm9yIGRhdGVzIGJlZm9yZSAxOTcwKTpcbiAgICBmdW5jdGlvbiBtb2QkMShkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gKChkaXZpZGVuZCAlIGRpdmlzb3IpICsgZGl2aXNvcikgJSBkaXZpc29yO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1dGNTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIERhdGUuVVRDIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHksIG0sIGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRPZih1bml0cykge1xuICAgICAgICB2YXIgdGltZSwgc3RhcnRPZkRhdGU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRPZkRhdGUgPSB0aGlzLl9pc1VUQyA/IHV0Y1N0YXJ0T2ZEYXRlIDogbG9jYWxTdGFydE9mRGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIDAsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpLFxuICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEoXG4gICAgICAgICAgICAgICAgICAgIHRpbWUgKyAodGhpcy5faXNVVEMgPyAwIDogdGhpcy51dGNPZmZzZXQoKSAqIE1TX1BFUl9NSU5VVEUpLFxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZih1bml0cykge1xuICAgICAgICB2YXIgdGltZSwgc3RhcnRPZkRhdGU7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJyB8fCAhdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRPZkRhdGUgPSB0aGlzLl9pc1VUQyA/IHV0Y1N0YXJ0T2ZEYXRlIDogbG9jYWxTdGFydE9mRGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCkgKyAxLCAwLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSAtICh0aGlzLm1vbnRoKCkgJSAzKSArIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpICsgMSwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpICsgN1xuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKSArIDdcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpICsgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz1cbiAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVIgLVxuICAgICAgICAgICAgICAgICAgICBtb2QkMShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUgKyAodGhpcy5faXNVVEMgPyAwIDogdGhpcy51dGNPZmZzZXQoKSAqIE1TX1BFUl9NSU5VVEUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVJcbiAgICAgICAgICAgICAgICAgICAgKSAtXG4gICAgICAgICAgICAgICAgICAgIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9NSU5VVEUgLSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9TRUNPTkQgLSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXgoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9EYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvQXJyYXkoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG0ueWVhcigpLFxuICAgICAgICAgICAgbS5tb250aCgpLFxuICAgICAgICAgICAgbS5kYXRlKCksXG4gICAgICAgICAgICBtLmhvdXIoKSxcbiAgICAgICAgICAgIG0ubWludXRlKCksXG4gICAgICAgICAgICBtLnNlY29uZCgpLFxuICAgICAgICAgICAgbS5taWxsaXNlY29uZCgpLFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvT2JqZWN0KCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQyKCkge1xuICAgICAgICByZXR1cm4gaXNWYWxpZCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzaW5nRmxhZ3MoKSB7XG4gICAgICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZEF0KCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTicsIDAsIDAsICdlcmFOYW1lJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTk5OJywgMCwgMCwgJ2VyYU5hcnJvdycpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3knLCAxXSwgJ3lvJywgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXknLCAyXSwgMCwgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXl5JywgM10sIDAsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eXknLCA0XSwgMCwgJ2VyYVllYXInKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ04nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk4nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTk4nLCBtYXRjaEVyYU5hbWUpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTk5OJywgbWF0Y2hFcmFOYXJyb3cpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihcbiAgICAgICAgWydOJywgJ05OJywgJ05OTicsICdOTk5OJywgJ05OTk5OJ10sXG4gICAgICAgIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBlcmEgPSBjb25maWcuX2xvY2FsZS5lcmFzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgICAgICBpZiAoZXJhKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZXJhID0gZXJhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRXJhID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgYWRkUmVnZXhUb2tlbigneScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXl5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXl5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3lvJywgbWF0Y2hFcmFZZWFyT3JkaW5hbCk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsneScsICd5eScsICd5eXknLCAneXl5eSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsneW8nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIGlmIChjb25maWcuX2xvY2FsZS5fZXJhWWVhck9yZGluYWxSZWdleCkge1xuICAgICAgICAgICAgbWF0Y2ggPSBpbnB1dC5tYXRjaChjb25maWcuX2xvY2FsZS5fZXJhWWVhck9yZGluYWxSZWdleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZSkge1xuICAgICAgICAgICAgYXJyYXlbWUVBUl0gPSBjb25maWcuX2xvY2FsZS5lcmFZZWFyT3JkaW5hbFBhcnNlKGlucHV0LCBtYXRjaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXMobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5fZXJhcyB8fCBnZXRMb2NhbGUoJ2VuJykuX2VyYXM7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0uc2luY2UpLnN0YXJ0T2YoJ2RheScpO1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnNpbmNlID0gZGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS51bnRpbCA9ICtJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS51bnRpbCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnVudGlsID0gZGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcmFzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXNQYXJzZShlcmFOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCksXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYWJicixcbiAgICAgICAgICAgIG5hcnJvdztcbiAgICAgICAgZXJhTmFtZSA9IGVyYU5hbWUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5hbWUgPSBlcmFzW2ldLm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGFiYnIgPSBlcmFzW2ldLmFiYnIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIG5hcnJvdyA9IGVyYXNbaV0ubmFycm93LnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk4nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFiYnIgPT09IGVyYU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGVyYU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYXJyb3cgPT09IGVyYU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoW25hbWUsIGFiYnIsIG5hcnJvd10uaW5kZXhPZihlcmFOYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzQ29udmVydFllYXIoZXJhLCB5ZWFyKSB7XG4gICAgICAgIHZhciBkaXIgPSBlcmEuc2luY2UgPD0gZXJhLnVudGlsID8gKzEgOiAtMTtcbiAgICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2tzKGVyYS5zaW5jZSkueWVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2tzKGVyYS5zaW5jZSkueWVhcigpICsgKHllYXIgLSBlcmEub2Zmc2V0KSAqIGRpcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYU5hbWUoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhTmFycm93KCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hcnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hcnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFBYmJyKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLmFiYnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5hYmJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYVllYXIoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgZGlyID0gZXJhc1tpXS5zaW5jZSA8PSBlcmFzW2ldLnVudGlsID8gKzEgOiAtMTtcblxuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkgfHxcbiAgICAgICAgICAgICAgICAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy55ZWFyKCkgLSBob29rcyhlcmFzW2ldLnNpbmNlKS55ZWFyKCkpICogZGlyICtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5vZmZzZXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNOYW1lUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc05hbWVSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc05hbWVSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzQWJiclJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNBYmJyUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNBYmJyUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc05hcnJvd1JlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYXJyb3dSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc05hcnJvd1JlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhQWJicihpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc0FiYnJSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFOYW1lKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYU5hcnJvdyhpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc05hcnJvd1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYVllYXJPcmRpbmFsKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fZXJhWWVhck9yZGluYWxSZWdleCB8fCBtYXRjaFVuc2lnbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVFcmFzUGFyc2UoKSB7XG4gICAgICAgIHZhciBhYmJyUGllY2VzID0gW10sXG4gICAgICAgICAgICBuYW1lUGllY2VzID0gW10sXG4gICAgICAgICAgICBuYXJyb3dQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmVyYXMoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5hbWVQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hbWUpKTtcbiAgICAgICAgICAgIGFiYnJQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcbiAgICAgICAgICAgIG5hcnJvd1BpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFycm93KSk7XG5cbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYW1lKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0uYWJicikpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZXJhc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbmFtZVBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNBYmJyUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBhYmJyUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc05hcnJvd1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBuYXJyb3dQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4odG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oXG4gICAgICAgIFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sXG4gICAgICAgIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICB0aGlzLmlzb1dlZWsoKSxcbiAgICAgICAgICAgIHRoaXMuaXNvV2Vla2RheSgpLFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIDRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRJU09XZWVrc0luSVNPV2Vla1llYXIoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLmlzb1dlZWtZZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJbldlZWtZZWFyKCkge1xuICAgICAgICB2YXIgd2Vla0luZm8gPSB0aGlzLmxvY2FsZURhdGEoKS5fd2VlaztcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMud2Vla1llYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsXG4gICAgICAgICAgICA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKVxuICAgICAgICAgICAgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArICh0aGlzLm1vbnRoKCkgJSAzKSk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICByZXR1cm4gaXNTdHJpY3RcbiAgICAgICAgICAgID8gbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlXG4gICAgICAgICAgICA6IGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnRCcsICdERCddLCBEQVRFKTtcbiAgICBhZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdKTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0RERCcsIFsnRERERCcsIDNdLCAnREREbycsICdkYXlPZlllYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignREREJywgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPVxuICAgICAgICAgICAgTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNVxuICAgICAgICAgICAgKSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoaW5wdXQgLSBkYXlPZlllYXIsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydtJywgJ21tJ10sIE1JTlVURSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3NlY29uZCcsICdzJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdzJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTJywgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaWxsaXNlY29uZCcsICdtcycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdTJywgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTJywgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsIG1hdGNoMXRvMywgbWF0Y2gzKTtcblxuICAgIHZhciB0b2tlbiwgZ2V0U2V0TWlsbGlzZWNvbmQ7XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdVVEMnIDogJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG4gICAgcHJvdG8uYWRkID0gYWRkO1xuICAgIHByb3RvLmNhbGVuZGFyID0gY2FsZW5kYXIkMTtcbiAgICBwcm90by5jbG9uZSA9IGNsb25lO1xuICAgIHByb3RvLmRpZmYgPSBkaWZmO1xuICAgIHByb3RvLmVuZE9mID0gZW5kT2Y7XG4gICAgcHJvdG8uZm9ybWF0ID0gZm9ybWF0O1xuICAgIHByb3RvLmZyb20gPSBmcm9tO1xuICAgIHByb3RvLmZyb21Ob3cgPSBmcm9tTm93O1xuICAgIHByb3RvLnRvID0gdG87XG4gICAgcHJvdG8udG9Ob3cgPSB0b05vdztcbiAgICBwcm90by5nZXQgPSBzdHJpbmdHZXQ7XG4gICAgcHJvdG8uaW52YWxpZEF0ID0gaW52YWxpZEF0O1xuICAgIHByb3RvLmlzQWZ0ZXIgPSBpc0FmdGVyO1xuICAgIHByb3RvLmlzQmVmb3JlID0gaXNCZWZvcmU7XG4gICAgcHJvdG8uaXNCZXR3ZWVuID0gaXNCZXR3ZWVuO1xuICAgIHByb3RvLmlzU2FtZSA9IGlzU2FtZTtcbiAgICBwcm90by5pc1NhbWVPckFmdGVyID0gaXNTYW1lT3JBZnRlcjtcbiAgICBwcm90by5pc1NhbWVPckJlZm9yZSA9IGlzU2FtZU9yQmVmb3JlO1xuICAgIHByb3RvLmlzVmFsaWQgPSBpc1ZhbGlkJDI7XG4gICAgcHJvdG8ubGFuZyA9IGxhbmc7XG4gICAgcHJvdG8ubG9jYWxlID0gbG9jYWxlO1xuICAgIHByb3RvLmxvY2FsZURhdGEgPSBsb2NhbGVEYXRhO1xuICAgIHByb3RvLm1heCA9IHByb3RvdHlwZU1heDtcbiAgICBwcm90by5taW4gPSBwcm90b3R5cGVNaW47XG4gICAgcHJvdG8ucGFyc2luZ0ZsYWdzID0gcGFyc2luZ0ZsYWdzO1xuICAgIHByb3RvLnNldCA9IHN0cmluZ1NldDtcbiAgICBwcm90by5zdGFydE9mID0gc3RhcnRPZjtcbiAgICBwcm90by5zdWJ0cmFjdCA9IHN1YnRyYWN0O1xuICAgIHByb3RvLnRvQXJyYXkgPSB0b0FycmF5O1xuICAgIHByb3RvLnRvT2JqZWN0ID0gdG9PYmplY3Q7XG4gICAgcHJvdG8udG9EYXRlID0gdG9EYXRlO1xuICAgIHByb3RvLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmc7XG4gICAgcHJvdG8uaW5zcGVjdCA9IGluc3BlY3Q7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5mb3IgIT0gbnVsbCkge1xuICAgICAgICBwcm90b1tTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAnTW9tZW50PCcgKyB0aGlzLmZvcm1hdCgpICsgJz4nO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBwcm90by50b0pTT04gPSB0b0pTT047XG4gICAgcHJvdG8udG9TdHJpbmcgPSB0b1N0cmluZztcbiAgICBwcm90by51bml4ID0gdW5peDtcbiAgICBwcm90by52YWx1ZU9mID0gdmFsdWVPZjtcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgPSBjcmVhdGlvbkRhdGE7XG4gICAgcHJvdG8uZXJhTmFtZSA9IGdldEVyYU5hbWU7XG4gICAgcHJvdG8uZXJhTmFycm93ID0gZ2V0RXJhTmFycm93O1xuICAgIHByb3RvLmVyYUFiYnIgPSBnZXRFcmFBYmJyO1xuICAgIHByb3RvLmVyYVllYXIgPSBnZXRFcmFZZWFyO1xuICAgIHByb3RvLnllYXIgPSBnZXRTZXRZZWFyO1xuICAgIHByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuICAgIHByb3RvLndlZWtZZWFyID0gZ2V0U2V0V2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcbiAgICBwcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuICAgIHByb3RvLm1vbnRoID0gZ2V0U2V0TW9udGg7XG4gICAgcHJvdG8uZGF5c0luTW9udGggPSBnZXREYXlzSW5Nb250aDtcbiAgICBwcm90by53ZWVrID0gcHJvdG8ud2Vla3MgPSBnZXRTZXRXZWVrO1xuICAgIHByb3RvLmlzb1dlZWsgPSBwcm90by5pc29XZWVrcyA9IGdldFNldElTT1dlZWs7XG4gICAgcHJvdG8ud2Vla3NJblllYXIgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBwcm90by53ZWVrc0luV2Vla1llYXIgPSBnZXRXZWVrc0luV2Vla1llYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luSVNPV2Vla1llYXIgPSBnZXRJU09XZWVrc0luSVNPV2Vla1llYXI7XG4gICAgcHJvdG8uZGF0ZSA9IGdldFNldERheU9mTW9udGg7XG4gICAgcHJvdG8uZGF5ID0gcHJvdG8uZGF5cyA9IGdldFNldERheU9mV2VlaztcbiAgICBwcm90by53ZWVrZGF5ID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xuICAgIHByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG4gICAgcHJvdG8uZGF5T2ZZZWFyID0gZ2V0U2V0RGF5T2ZZZWFyO1xuICAgIHByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XG4gICAgcHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcbiAgICBwcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuICAgIHByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG4gICAgcHJvdG8udXRjT2Zmc2V0ID0gZ2V0U2V0T2Zmc2V0O1xuICAgIHByb3RvLnV0YyA9IHNldE9mZnNldFRvVVRDO1xuICAgIHByb3RvLmxvY2FsID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBwcm90by5wYXJzZVpvbmUgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbiAgICBwcm90by5oYXNBbGlnbmVkSG91ck9mZnNldCA9IGhhc0FsaWduZWRIb3VyT2Zmc2V0O1xuICAgIHByb3RvLmlzRFNUID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgcHJvdG8uaXNMb2NhbCA9IGlzTG9jYWw7XG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgPSBpc1V0Y09mZnNldDtcbiAgICBwcm90by5pc1V0YyA9IGlzVXRjO1xuICAgIHByb3RvLmlzVVRDID0gaXNVdGM7XG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBwcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuICAgIHByb3RvLmRhdGVzID0gZGVwcmVjYXRlKFxuICAgICAgICAnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLFxuICAgICAgICBnZXRTZXREYXlPZk1vbnRoXG4gICAgKTtcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLFxuICAgICAgICBnZXRTZXRNb250aFxuICAgICk7XG4gICAgcHJvdG8ueWVhcnMgPSBkZXByZWNhdGUoXG4gICAgICAgICd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkJyxcbiAgICAgICAgZ2V0U2V0WWVhclxuICAgICk7XG4gICAgcHJvdG8uem9uZSA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJyxcbiAgICAgICAgZ2V0U2V0Wm9uZVxuICAgICk7XG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKFxuICAgICAgICAnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsXG4gICAgICAgIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZFxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVbml4KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0KHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIHZhciBwcm90byQxID0gTG9jYWxlLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDEuY2FsZW5kYXIgPSBjYWxlbmRhcjtcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG8kMS5pbnZhbGlkRGF0ZSA9IGludmFsaWREYXRlO1xuICAgIHByb3RvJDEub3JkaW5hbCA9IG9yZGluYWw7XG4gICAgcHJvdG8kMS5wcmVwYXJzZSA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnBvc3Rmb3JtYXQgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5yZWxhdGl2ZVRpbWUgPSByZWxhdGl2ZVRpbWU7XG4gICAgcHJvdG8kMS5wYXN0RnV0dXJlID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90byQxLnNldCA9IHNldDtcbiAgICBwcm90byQxLmVyYXMgPSBsb2NhbGVFcmFzO1xuICAgIHByb3RvJDEuZXJhc1BhcnNlID0gbG9jYWxlRXJhc1BhcnNlO1xuICAgIHByb3RvJDEuZXJhc0NvbnZlcnRZZWFyID0gbG9jYWxlRXJhc0NvbnZlcnRZZWFyO1xuICAgIHByb3RvJDEuZXJhc0FiYnJSZWdleCA9IGVyYXNBYmJyUmVnZXg7XG4gICAgcHJvdG8kMS5lcmFzTmFtZVJlZ2V4ID0gZXJhc05hbWVSZWdleDtcbiAgICBwcm90byQxLmVyYXNOYXJyb3dSZWdleCA9IGVyYXNOYXJyb3dSZWdleDtcblxuICAgIHByb3RvJDEubW9udGhzID0gbG9jYWxlTW9udGhzO1xuICAgIHByb3RvJDEubW9udGhzU2hvcnQgPSBsb2NhbGVNb250aHNTaG9ydDtcbiAgICBwcm90byQxLm1vbnRoc1BhcnNlID0gbG9jYWxlTW9udGhzUGFyc2U7XG4gICAgcHJvdG8kMS5tb250aHNSZWdleCA9IG1vbnRoc1JlZ2V4O1xuICAgIHByb3RvJDEubW9udGhzU2hvcnRSZWdleCA9IG1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5cyA9IGxvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvJDEud2Vla2RheXNNaW4gPSBsb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnQgPSBsb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvJDEud2Vla2RheXNQYXJzZSA9IGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90byQxLndlZWtkYXlzUmVnZXggPSB3ZWVrZGF5c1JlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ID0gd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCA9IHdlZWtkYXlzTWluUmVnZXg7XG5cbiAgICBwcm90byQxLmlzUE0gPSBsb2NhbGVJc1BNO1xuICAgIHByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuICAgIGZ1bmN0aW9uIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgdXRjID0gY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbG9jYWxlU29ydGVkO1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDAsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgb3V0ID0gW107XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIChpbmRleCArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHMoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRocycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzU2hvcnQobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4obG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgZXJhczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNpbmNlOiAnMDAwMS0wMS0wMScsXG4gICAgICAgICAgICAgICAgdW50aWw6ICtJbmZpbml0eSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0Fubm8gRG9taW5pJyxcbiAgICAgICAgICAgICAgICBuYXJyb3c6ICdBRCcsXG4gICAgICAgICAgICAgICAgYWJicjogJ0FEJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2luY2U6ICcwMDAwLTEyLTMxJyxcbiAgICAgICAgICAgICAgICB1bnRpbDogLUluZmluaXR5LFxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQmVmb3JlIENocmlzdCcsXG4gICAgICAgICAgICAgICAgbmFycm93OiAnQkMnLFxuICAgICAgICAgICAgICAgIGFiYnI6ICdCQycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICAgICAgb3JkaW5hbDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgICAgICBvdXRwdXQgPVxuICAgICAgICAgICAgICAgICAgICB0b0ludCgobnVtYmVyICUgMTAwKSAvIDEwKSA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAndGgnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3N0J1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICduZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gM1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAncmQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgaG9va3MubGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlXG4gICAgKTtcbiAgICBob29rcy5sYW5nRGF0YSA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLFxuICAgICAgICBnZXRMb2NhbGVcbiAgICApO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGFicygpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgICAgIHRoaXMuX21vbnRocyA9IG1hdGhBYnModGhpcy5fbW9udGhzKTtcblxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgICAgIGRhdGEubW9udGhzID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgPSBtYXRoQWJzKGRhdGEueWVhcnMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0JDEoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB2YWx1ZSk7XG5cbiAgICAgICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5fZGF5cyArPSBkaXJlY3Rpb24gKiBvdGhlci5fZGF5cztcbiAgICAgICAgZHVyYXRpb24uX21vbnRocyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIGFkZCQxKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gc3VidHJhY3QkMShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWJibGUoKSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyxcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxuICAgICAgICAgICAgc2Vjb25kcyxcbiAgICAgICAgICAgIG1pbnV0ZXMsXG4gICAgICAgICAgICBob3VycyxcbiAgICAgICAgICAgIHllYXJzLFxuICAgICAgICAgICAgbW9udGhzRnJvbURheXM7XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG1peCBvZiBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgdmFsdWVzLCBidWJibGUgZG93biBmaXJzdFxuICAgICAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICAgICAgbW9udGhzICs9IG1vbnRoc0Zyb21EYXlzO1xuICAgICAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvTW9udGhzKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICAgICAgcmV0dXJuIChkYXlzICogNDgwMCkgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzKG1vbnRocykge1xuICAgICAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICAgICAgcmV0dXJuIChtb250aHMgKiAxNDYwOTcpIC8gNDgwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcyh1bml0cykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXlzLFxuICAgICAgICAgICAgbW9udGhzLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMztcbiAgICAgICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocyAvIDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1pbGxpc2Vjb25kcyBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgKGlzc3VlICMxODY3KVxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgLyA3ICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogMjQgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogMTQ0MCArIG1pbGxpc2Vjb25kcyAvIDZlNDtcbiAgICAgICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIHZhbHVlT2YkMSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMoYWxpYXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyksXG4gICAgICAgIGFzU2Vjb25kcyA9IG1ha2VBcygncycpLFxuICAgICAgICBhc01pbnV0ZXMgPSBtYWtlQXMoJ20nKSxcbiAgICAgICAgYXNIb3VycyA9IG1ha2VBcygnaCcpLFxuICAgICAgICBhc0RheXMgPSBtYWtlQXMoJ2QnKSxcbiAgICAgICAgYXNXZWVrcyA9IG1ha2VBcygndycpLFxuICAgICAgICBhc01vbnRocyA9IG1ha2VBcygnTScpLFxuICAgICAgICBhc1F1YXJ0ZXJzID0gbWFrZUFzKCdRJyksXG4gICAgICAgIGFzWWVhcnMgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGNsb25lJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQkMih1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpLFxuICAgICAgICBzZWNvbmRzID0gbWFrZUdldHRlcignc2Vjb25kcycpLFxuICAgICAgICBtaW51dGVzID0gbWFrZUdldHRlcignbWludXRlcycpLFxuICAgICAgICBob3VycyA9IG1ha2VHZXR0ZXIoJ2hvdXJzJyksXG4gICAgICAgIGRheXMgPSBtYWtlR2V0dGVyKCdkYXlzJyksXG4gICAgICAgIG1vbnRocyA9IG1ha2VHZXR0ZXIoJ21vbnRocycpLFxuICAgICAgICB5ZWFycyA9IG1ha2VHZXR0ZXIoJ3llYXJzJyk7XG5cbiAgICBmdW5jdGlvbiB3ZWVrcygpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgICAgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgICAgIHNzOiA0NCwgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgICAgICAgICBzOiA0NSwgLy8gc2Vjb25kcyB0byBtaW51dGVcbiAgICAgICAgICAgIG06IDQ1LCAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICAgICAgICAgIGg6IDIyLCAvLyBob3VycyB0byBkYXlcbiAgICAgICAgICAgIGQ6IDI2LCAvLyBkYXlzIHRvIG1vbnRoL3dlZWtcbiAgICAgICAgICAgIHc6IG51bGwsIC8vIHdlZWtzIHRvIG1vbnRoXG4gICAgICAgICAgICBNOiAxMSwgLy8gbW9udGhzIHRvIHllYXJcbiAgICAgICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lJDEocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIHRocmVzaG9sZHMsIGxvY2FsZSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCksXG4gICAgICAgICAgICBzZWNvbmRzID0gcm91bmQoZHVyYXRpb24uYXMoJ3MnKSksXG4gICAgICAgICAgICBtaW51dGVzID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSksXG4gICAgICAgICAgICBob3VycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpLFxuICAgICAgICAgICAgZGF5cyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpLFxuICAgICAgICAgICAgbW9udGhzID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSksXG4gICAgICAgICAgICB3ZWVrcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd3JykpLFxuICAgICAgICAgICAgeWVhcnMgPSByb3VuZChkdXJhdGlvbi5hcygneScpKSxcbiAgICAgICAgICAgIGEgPVxuICAgICAgICAgICAgICAgIChzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10pIHx8XG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgJiYgWydzcycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgICAgIChtaW51dGVzIDw9IDEgJiYgWydtJ10pIHx8XG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPCB0aHJlc2hvbGRzLm0gJiYgWydtbScsIG1pbnV0ZXNdKSB8fFxuICAgICAgICAgICAgICAgIChob3VycyA8PSAxICYmIFsnaCddKSB8fFxuICAgICAgICAgICAgICAgIChob3VycyA8IHRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdKSB8fFxuICAgICAgICAgICAgICAgIChkYXlzIDw9IDEgJiYgWydkJ10pIHx8XG4gICAgICAgICAgICAgICAgKGRheXMgPCB0aHJlc2hvbGRzLmQgJiYgWydkZCcsIGRheXNdKTtcblxuICAgICAgICBpZiAodGhyZXNob2xkcy53ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGEgPVxuICAgICAgICAgICAgICAgIGEgfHxcbiAgICAgICAgICAgICAgICAod2Vla3MgPD0gMSAmJiBbJ3cnXSkgfHxcbiAgICAgICAgICAgICAgICAod2Vla3MgPCB0aHJlc2hvbGRzLncgJiYgWyd3dycsIHdlZWtzXSk7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEgfHxcbiAgICAgICAgICAgIChtb250aHMgPD0gMSAmJiBbJ00nXSkgfHxcbiAgICAgICAgICAgIChtb250aHMgPCB0aHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10pIHx8XG4gICAgICAgICAgICAoeWVhcnMgPD0gMSAmJiBbJ3knXSkgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcocm91bmRpbmdGdW5jdGlvbikge1xuICAgICAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3VuZGluZ0Z1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCBhIHRocmVzaG9sZCBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZShhcmdXaXRoU3VmZml4LCBhcmdUaHJlc2hvbGRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdpdGhTdWZmaXggPSBmYWxzZSxcbiAgICAgICAgICAgIHRoID0gdGhyZXNob2xkcyxcbiAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgIG91dHB1dDtcblxuICAgICAgICBpZiAodHlwZW9mIGFyZ1dpdGhTdWZmaXggPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhcmdUaHJlc2hvbGRzID0gYXJnV2l0aFN1ZmZpeDtcbiAgICAgICAgICAgIGFyZ1dpdGhTdWZmaXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ1dpdGhTdWZmaXggPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgd2l0aFN1ZmZpeCA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdUaHJlc2hvbGRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGggPSBPYmplY3QuYXNzaWduKHt9LCB0aHJlc2hvbGRzLCBhcmdUaHJlc2hvbGRzKTtcbiAgICAgICAgICAgIGlmIChhcmdUaHJlc2hvbGRzLnMgIT0gbnVsbCAmJiBhcmdUaHJlc2hvbGRzLnNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aC5zcyA9IGFyZ1RocmVzaG9sZHMucyAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIHRoLCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICAgIHJldHVybiAoeCA+IDApIC0gKHggPCAwKSB8fCAreDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyQxKCkge1xuICAgICAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgICAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgICAgIC8vICAqIGRheXMgZG8gbm90IGJ1YmJsZSBhdCBhbGxcbiAgICAgICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgICAgICAvLyAodGhpbmsgb2YgY2xvY2sgY2hhbmdlcylcbiAgICAgICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwLFxuICAgICAgICAgICAgZGF5cyA9IGFicyQxKHRoaXMuX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzJDEodGhpcy5fbW9udGhzKSxcbiAgICAgICAgICAgIG1pbnV0ZXMsXG4gICAgICAgICAgICBob3VycyxcbiAgICAgICAgICAgIHllYXJzLFxuICAgICAgICAgICAgcyxcbiAgICAgICAgICAgIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKSxcbiAgICAgICAgICAgIHRvdGFsU2lnbixcbiAgICAgICAgICAgIHltU2lnbixcbiAgICAgICAgICAgIGRheXNTaWduLFxuICAgICAgICAgICAgaG1zU2lnbjtcblxuICAgICAgICBpZiAoIXRvdGFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgICAgICByZXR1cm4gJ1AwRCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICAgICAgbWludXRlcyA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGhvdXJzID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgc2Vjb25kcyAlPSA2MDtcbiAgICAgICAgbWludXRlcyAlPSA2MDtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICAgICAgcyA9IHNlY29uZHMgPyBzZWNvbmRzLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSA6ICcnO1xuXG4gICAgICAgIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB5bVNpZ24gPSBzaWduKHRoaXMuX21vbnRocykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIGRheXNTaWduID0gc2lnbih0aGlzLl9kYXlzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdG90YWxTaWduICtcbiAgICAgICAgICAgICdQJyArXG4gICAgICAgICAgICAoeWVhcnMgPyB5bVNpZ24gKyB5ZWFycyArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAobW9udGhzID8geW1TaWduICsgbW9udGhzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChkYXlzID8gZGF5c1NpZ24gKyBkYXlzICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgIChob3VycyB8fCBtaW51dGVzIHx8IHNlY29uZHMgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGhvdXJzID8gaG1zU2lnbiArIGhvdXJzICsgJ0gnIDogJycpICtcbiAgICAgICAgICAgIChtaW51dGVzID8gaG1zU2lnbiArIG1pbnV0ZXMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHNlY29uZHMgPyBobXNTaWduICsgcyArICdTJyA6ICcnKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMi5pc1ZhbGlkID0gaXNWYWxpZCQxO1xuICAgIHByb3RvJDIuYWJzID0gYWJzO1xuICAgIHByb3RvJDIuYWRkID0gYWRkJDE7XG4gICAgcHJvdG8kMi5zdWJ0cmFjdCA9IHN1YnRyYWN0JDE7XG4gICAgcHJvdG8kMi5hcyA9IGFzO1xuICAgIHByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLmFzU2Vjb25kcyA9IGFzU2Vjb25kcztcbiAgICBwcm90byQyLmFzTWludXRlcyA9IGFzTWludXRlcztcbiAgICBwcm90byQyLmFzSG91cnMgPSBhc0hvdXJzO1xuICAgIHByb3RvJDIuYXNEYXlzID0gYXNEYXlzO1xuICAgIHByb3RvJDIuYXNXZWVrcyA9IGFzV2Vla3M7XG4gICAgcHJvdG8kMi5hc01vbnRocyA9IGFzTW9udGhzO1xuICAgIHByb3RvJDIuYXNRdWFydGVycyA9IGFzUXVhcnRlcnM7XG4gICAgcHJvdG8kMi5hc1llYXJzID0gYXNZZWFycztcbiAgICBwcm90byQyLnZhbHVlT2YgPSB2YWx1ZU9mJDE7XG4gICAgcHJvdG8kMi5fYnViYmxlID0gYnViYmxlO1xuICAgIHByb3RvJDIuY2xvbmUgPSBjbG9uZSQxO1xuICAgIHByb3RvJDIuZ2V0ID0gZ2V0JDI7XG4gICAgcHJvdG8kMi5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5zZWNvbmRzID0gc2Vjb25kcztcbiAgICBwcm90byQyLm1pbnV0ZXMgPSBtaW51dGVzO1xuICAgIHByb3RvJDIuaG91cnMgPSBob3VycztcbiAgICBwcm90byQyLmRheXMgPSBkYXlzO1xuICAgIHByb3RvJDIud2Vla3MgPSB3ZWVrcztcbiAgICBwcm90byQyLm1vbnRocyA9IG1vbnRocztcbiAgICBwcm90byQyLnllYXJzID0geWVhcnM7XG4gICAgcHJvdG8kMi5odW1hbml6ZSA9IGh1bWFuaXplO1xuICAgIHByb3RvJDIudG9JU09TdHJpbmcgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9TdHJpbmcgPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIudG9KU09OID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLmxvY2FsZSA9IGxvY2FsZTtcbiAgICBwcm90byQyLmxvY2FsZURhdGEgPSBsb2NhbGVEYXRhO1xuXG4gICAgcHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3RvSXNvU3RyaW5nKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0b0lTT1N0cmluZygpIGluc3RlYWQgKG5vdGljZSB0aGUgY2FwaXRhbHMpJyxcbiAgICAgICAgdG9JU09TdHJpbmckMVxuICAgICk7XG4gICAgcHJvdG8kMi5sYW5nID0gbGFuZztcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG4gICAgYWRkUGFyc2VUb2tlbignWCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0KSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vISBtb21lbnQuanNcblxuICAgIGhvb2tzLnZlcnNpb24gPSAnMi4yOS4zJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbiAgICBob29rcy5mbiA9IHByb3RvO1xuICAgIGhvb2tzLm1pbiA9IG1pbjtcbiAgICBob29rcy5tYXggPSBtYXg7XG4gICAgaG9va3Mubm93ID0gbm93O1xuICAgIGhvb2tzLnV0YyA9IGNyZWF0ZVVUQztcbiAgICBob29rcy51bml4ID0gY3JlYXRlVW5peDtcbiAgICBob29rcy5tb250aHMgPSBsaXN0TW9udGhzO1xuICAgIGhvb2tzLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICBob29rcy5sb2NhbGUgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG4gICAgaG9va3MuaW52YWxpZCA9IGNyZWF0ZUludmFsaWQ7XG4gICAgaG9va3MuZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbjtcbiAgICBob29rcy5pc01vbWVudCA9IGlzTW9tZW50O1xuICAgIGhvb2tzLndlZWtkYXlzID0gbGlzdFdlZWtkYXlzO1xuICAgIGhvb2tzLnBhcnNlWm9uZSA9IGNyZWF0ZUluWm9uZTtcbiAgICBob29rcy5sb2NhbGVEYXRhID0gZ2V0TG9jYWxlO1xuICAgIGhvb2tzLmlzRHVyYXRpb24gPSBpc0R1cmF0aW9uO1xuICAgIGhvb2tzLm1vbnRoc1Nob3J0ID0gbGlzdE1vbnRoc1Nob3J0O1xuICAgIGhvb2tzLndlZWtkYXlzTWluID0gbGlzdFdlZWtkYXlzTWluO1xuICAgIGhvb2tzLmRlZmluZUxvY2FsZSA9IGRlZmluZUxvY2FsZTtcbiAgICBob29rcy51cGRhdGVMb2NhbGUgPSB1cGRhdGVMb2NhbGU7XG4gICAgaG9va3MubG9jYWxlcyA9IGxpc3RMb2NhbGVzO1xuICAgIGhvb2tzLndlZWtkYXlzU2hvcnQgPSBsaXN0V2Vla2RheXNTaG9ydDtcbiAgICBob29rcy5ub3JtYWxpemVVbml0cyA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuICAgIGhvb2tzLmNhbGVuZGFyRm9ybWF0ID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG4gICAgaG9va3MucHJvdG90eXBlID0gcHJvdG87XG5cbiAgICAvLyBjdXJyZW50bHkgSFRNTDUgaW5wdXQgdHlwZSBvbmx5IHN1cHBvcnRzIDI0LWhvdXIgZm9ybWF0c1xuICAgIGhvb2tzLkhUTUw1X0ZNVCA9IHtcbiAgICAgICAgREFURVRJTUVfTE9DQUw6ICdZWVlZLU1NLUREVEhIOm1tJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX1NFQ09ORFM6ICdZWVlZLU1NLUREVEhIOm1tOnNzJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfTVM6ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBEQVRFOiAnWVlZWS1NTS1ERCcsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIC8+XG4gICAgICAgIFRJTUU6ICdISDptbScsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgICAgIFRJTUVfU0VDT05EUzogJ0hIOm1tOnNzJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBUSU1FX01TOiAnSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgV0VFSzogJ0dHR0ctW1ddV1cnLCAvLyA8aW5wdXQgdHlwZT1cIndlZWtcIiAvPlxuICAgICAgICBNT05USDogJ1lZWVktTU0nLCAvLyA8aW5wdXQgdHlwZT1cIm1vbnRoXCIgLz5cbiAgICB9O1xuXG4gICAgcmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///wd/R\n")}}]);